{"meta":{"title":"ReBE","subtitle":"Febers的博客","description":null,"author":"Febers","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:31:24.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-01-11T16:43:43.000Z","updated":"2019-06-02T06:19:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"category","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:19:34.000Z","comments":false,"path":"category/index.html","permalink":"http://yoursite.com/category/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"search","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:25:56.000Z","comments":false,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tag","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:23:00.000Z","comments":false,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-03-15T15:33:56.000Z","updated":"2019-03-15T15:46:34.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Spring 学习笔记（三）：面向切面","slug":"Spring-学习笔记（三）：面向切面","date":"2019-06-02T04:52:24.000Z","updated":"2019-06-03T04:18:04.000Z","comments":true,"path":"Spring-学习笔记（三）：面向切面/","link":"","permalink":"http://yoursite.com/Spring-学习笔记（三）：面向切面/","excerpt":"第一篇笔记 曾简单提及了 AOP 的知识，本文将重点展开 Spring 对切面的支持，包括如何使用和 AspectJ 的具体应用","text":"第一篇笔记 曾简单提及了 AOP 的知识，本文将重点展开 Spring 对切面的支持，包括如何使用和 AspectJ 的具体应用 面向切面编程Aspect-Oriented Programming，AOP。每个应用除了其核心业务之外，还会需要一些模块化的通用功能——比如日志、安全、通知等。重用通用功能的方式一般有继承（inheritance）、 委托（delegation），缺点在于前者会导致对象体系复杂、难以维护，后者则可能需要对委托对象进行复杂的调用。切面提供了不一样的思路，并且在很多场景下更加清晰简洁。 AOP 术语 Advice通知，如果翻译为“增强”就能更直观地理解它所扮演的角色。Spring 切面可以应用 5 种类型的通知 前置通知（ Before ）：在目标方法被调用之前调用通知功能 后置通知（ After ）：在目标方法完成之后调用通知，不关心方法的返回值 返回通知（ After-returning ）：在目标方法成功执行之后调用通知 异常通知（ After-throwing ）：在目标方法抛出异常之后调用通知 环绕通知（ Around ）：通知包裹了被通知的方法，在被通知的方法调用之前喝调用之后执行自定义的行为 Joint point连接点，应用可能有数以千计的时机应用通知，这些时机被称为连接点。根据上面的图理解，连接点是在应用执行过程中能够插入切面的一个点，改点可以是调用方法时、抛出异常时、甚至修改一个字段时。 Pointcut切点，通知定义了切面的“什么”和“何时”，连接点定义了“时间点”，切点则定义了“何处”。切点会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称、或者使用正则表达式定义所匹配的类和方法来指定切点，有些 AOP 框架也会允许动态创建切点。 Aspect切面，通知+切点，这两者共同定义了切面的全部内容 Introduction引入，允许开发者向现有的类添加方法或属性 Weaving织入，把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入。需要特殊的编译器，如 AspectJ 的织入编译器 类加载期：切面在目标类加载到 JVM 时被织入。这种方式需要特殊的类加载器，从而在目标类被引用之前增强其字节码。比如 AspectJ 5 的加载时织入（load-time weaving，LTW） 运行期：切面在应用运行的某个时刻被织入。一般情况下，织入时 AOP 容器会为目标对象动态地创建一个代理对象。比如 Spring AOP Spring AOPSpring 提供了 4 中类型的 AOP 支持： 基于代理的经典 Spring AOP 纯 POJO 切面 @AspectJ注解驱动的切面 注入式 AspectJ 切面 相比起其他方式，第一种显得笨重而古典，不再介绍。纯 POJO 切面需要借助 Spring 的 aop命名空间，虽然足够简便，但也不再赘述。Spring 借鉴了 AspectJ 的切面以提供注解驱动的 AOP，其本质仍然是代理，但是编程模型几乎与成熟的 AspectJ 注解完全一致。如果开发者对 AOP 的需求超过了简单的方法调用（如构造器或属性拦截），那么可以考虑第四种方式——使用 AspectJ。 通过再代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。代理类封装了目标类并拦截被通知方法的调用，再把调用转发给真正的目标 bean 由于 Spring AOP 基于动态代理，所以只支持方法连接点，不支持字段连接点——无法创建细粒度的通知、不支持构造器连接点——无法在 bean 创建时应用通知。 通过切点选择连接点使用 AspectJ 的切点表达式语言来定义切点。Spring 仅支持 AspectJ 切点指示器的一个子集，因为 Spring 基于代理，而某些切点表达式与代理无关。下表是 Spring AOP 所支持的指示器 AspectJ 指示器 描述 arg() 限制连接点匹配参数为指定类型的执行方法 @args() 限制连接点匹配参数由指定注解标注的执行方法 execution() 用于匹配是连接点的执行方法 this() 限制连接点匹配 AOP 代理的 bean 引用为指定类型的类 target() 限制连接点匹配目标对象为指定类型的类 @target() 限制连接点匹配特定的具有指定类型注解的执行对象 within() 限制连接点匹配指定的类型 @within() 限制连接点匹配指定注解所标注的类型（方法定义在该类型中） @annotation 限定匹配带有指定注解的连接点 尝试使用其他指示器时，将抛出IllegalArgumentException异常 以上的指示器只有execution()指示器是实际执行匹配的，其他指示器都是用来限制匹配的。 编写切点准备一个主题 Performance，可代表任何类型的现场表演，假设要编写其中perform方法触发的通知 package concertinterface Performance { fun perform()} 使用 AspectJ 表达式编写切点 execution(* concert.Performance.perform(..)) && within(concert.*) 使用execution()指示器选择perform方法，方法表达式以*开始表示不关心返回值类型，然后使用全限定类名和方法名；使用两个点号..表示不关心方法参数列表，切点会选择为所有的perform方法。&&操作符把execution()和within指示器连接在一起形成与（and）关系，限制需要配置的切点仅匹配concert包，类似也可以使用||和!来标识或（or）和非（not）操作 当然也可以通过 Spring 引入的指示器bean()指示特定的 bean，参数为 bean 的 id execution(* concert.Performance.perform(..)) && bean('woodstock')execution(* concert.Performance.perform(..)) && !bean('woodstock') 使用注解创建切面简单通知对于一场演出，我们将“观众”定义为切面 @Aspectclass Audience { @Before(\"execution(** concert.Performance.perform(..)\") fun silenceCellPhones() { println(\"Silencing cell phones\") } @Before(\"execution(** concert.Performance.perform(..)\") fun takeSeats() { println(\"Taking seats\") } @AfterReturning(\"execution(** concert.Performance.perform(..)\") fun applause() { println(\"CLAP CLAP CLAP!!\") } @AfterThrowing(\"execution(** concert.Performance.perform(..)\") fun demandRefund() { println(\"Demanding a refund\") }} AspectJ 库需要通过依赖引入 Audience 定义了四个方法，通过 AOP 注解，形成以下期望的行为——演出之前观众就坐、将手机静音，演出很精彩则鼓掌欢呼，演出没有达到预期则要求退款。以上的方式有一点不足，每个方法的切点表达式都是一样的，重复了四次。为此可以使用@Pointcut注解定义可重用的切点 @Aspectclass Audience { @Pointcut(\"execution(** concert.Performance.perform(..))\") fun performance(){ } @Before(\"performance()\") fun silenceCellPhones() { println(\"Silencing cell phones\") } @Before(\"performance()\") fun takeSeats() { println(\"Taking seats\") } @AfterReturning(\"performance()\") fun applause() { println(\"CLAP CLAP CLAP!!\") } @AfterThrowing(\"performance()\") fun demandRefund() { println(\"Demanding a refund\") }} 除了注解和作为标识的空performance方法，Audience 仍然是一个 POJO，可以添加@Component注解将其注入容器中。但此时 Audience 不会视为切面，需要在配置类的的类级别通过使用@EnableAspectJAutoProxy注解启动自动代理功能 @Configuration@EnableAspectJAutoProxy@ComponentScanopen class ConcertConfig 同时为 Performance 提供一个实现类 @Componentopen class MyPerformance: Performance { override fun perform() { println(\"Start perform\") }} 测试类如下 @RunWith(SpringJUnit4ClassRunner::class)@ContextConfiguration(classes = [ConcertConfig::class])class PerformTest { @Autowired lateinit var performance: Performance @Test fun perform() { performance.perform() }} 输出结果为 Silencing cell phonesTaking seatsStart performCLAP CLAP CLAP!! 环绕通知环绕通知时最强大的通知类型，能够使编写的逻辑将被通知的目标方法完全包装，就像 在一个通知方法中同时编写前置通知和后置通知，重写上面的 Audience 切面 @Aspect@Componentclass Audience { @Pointcut(\"execution(** concert.Performance.perform(..))\") fun performance(){ } @Around(\"performance()\") fun watchPerformance(jointPoint: ProceedingJoinPoint) { try { println(\"Silencing cell phones\") println(\"Taking seats\") jointPoint.proceed() println(\"CLAP CLAP CLAP!!\") } catch (e: Exception) { println(\"Demanding a refund\") } }} 上面的代码将实现同样的功能。环绕通知注解的方法watchPerformance中类型为ProceedingJoinPoint的参数是必须的，由此拿到切点的引用 带参数的通知通过一个例子来展现带参数的通知如何实现，首先修改 MyPerformance 类 @Componentopen class MyPerformance: Performance { private var performList: List = arrayListOf(\"Song\", \"Dance\", \"Magic\") override fun perform() { perform(Math.round(10f) % 2) } override fun perform(type: Int) { println(\"Start perform: ${performList[type]}\") }} 假设现在有一个计数类 PerformanceCounter，其将跟踪每一次表演节目，记录下该节目的类型以及次数并打印 @Aspect@Componentclass PerformanceCounter { private var playCounter: MutableMap = HashMap() @Pointcut(\"execution(** concert.Performance.perform(..)) && args(whichType)\") fun performanceTypePlay(whichType: Int) { } @After(\"performanceTypePlay(typeIntValue)\") fun countPerformance(typeIntValue: Int) { val currentCount = getPlayCount(typeIntValue) playCounter[typeIntValue] = currentCount+1 println(\"=== type: ${getDesByInt(typeIntValue)}, played ${currentCount+1} times ===\") } private fun getPlayCount(type: Int): Int = playCounter[type] ?: 0 private fun getDesByInt(type: Int): String = when(type) { 0 -> \"Song\" 1 -> \"Dance\" 2 -> \"Magic\" else -> \"null\" }} 着重注意不同方法中的type参数，参数名称各有不同，但本质都代表“表演类型”。而相同的参数名称则表示一一对应的关系：定义切点时，AspectJ 表达式内使用的参数名称为whichType，与标识该切点的空函数的参数是一致的；通知方法上的参数名称typeIntValue则与通知时机中引用切点时 AspectJ 表达式内的参数名称一致 测试类如下 @RunWith(SpringJUnit4ClassRunner::class)@ContextConfiguration(classes = [ConcertConfig::class])class PerformTest { @Autowired lateinit var performance: Performance @Test fun perform() { for (i in 0..4) { performance.perform(i % 3) } }} 控制台输出为 Start perform: Song=== type: Song, played 1 times ===Start perform: Dance=== type: Dance, played 1 times ===Start perform: Magic=== type: Magic, played 1 times ===Start perform: Song=== type: Song, played 2 times ===Start perform: Dance=== type: Dance, played 2 times === 注入 AspectJ 切面AspectJ 和 Spring 实际上是独立的，只不过 Spring AOP 借助了前者的指示器。通过一个例子展示如何注入原始的 AspectJ 切面。 首先准备一个评论员，在表演之后发表一段言论，其类型为aspect，在 IDEA 中可通过右键 New -> Aspect 新建一个该类型的文件 public aspect CriticAspect { public CriticAspect() { } pointcut performance(): execution(* concert.MyPerformance.perform(..)); after(): performance() { System.out.println(\"something\"); }} 在 Spring 框架中，CriticAspect 将不会由容器创建，因为它属于 AspectJ 切面，由 AspectJ 在运行时创建。所以需要通过 AspectJ 切面提供的静态aspectOf方法给 Spring 返回切面的单例，Spring XML 配置写成以下形式 如果是 JavaConfig，则需要以下形式 @Configuration@EnableAspectJAutoProxy@ComponentScanopen class ConcertConfig { @Bean open fun criticAspect(): concert.CriticAspect = org.aspectj.lang.Aspects.aspectOf(CriticAspect::class.java)} 但是运行时 JRE 将不会识别类 CriticAspect，无法运行。目前未找到解决办法，故使用 XML 配置的方法 之后最重要的一步是使用ajc编译器，以编译.aj文件。通过一个插件 Mojo’s AspectJ Maven Plugin 引入ajc，注意此时 IDEA Compiler 的选项截图为 测试类如下 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {\"classpath:concert.xml\"})public class PerformTest { @Autowired Performance performance; @Test public void test() { performance.perform(); }} 按理说应该运行成功，然而此时还是报错 Error:ajc: can't find critical required type java.io.SerializableError:ajc: can't determine whether missing type java.io.Serializable is an instance of concert.CriticAspect......Error:ajc: can't find critical required type java.lang.CloneableError:ajc: can't determine whether missing type java.lang.Cloneable is an instance of concert.CriticAspect...... 目前并无解决办法， V2EX 上的求助帖为 诚心求助 Spring 注入式 AspectJ 切面时 ClassNotFoundException 的问题 Spring AOP 的内容到此为止，日后大概率会对本篇文章进行增删查改，继续进行下一步的学习吧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"Spring 学习笔记（二）：高级装配","slug":"Spring-学习笔记（二）：高级装配","date":"2019-06-01T08:17:51.000Z","updated":"2019-06-02T05:03:48.000Z","comments":true,"path":"Spring-学习笔记（二）：高级装配/","link":"","permalink":"http://yoursite.com/Spring-学习笔记（二）：高级装配/","excerpt":"开发软件的过程中要涉及到不同的环境，需要配置不同的数据库配置、加密算法和外部环境的集成等组件，为此必须要考虑不同的环境下对应不同的配置。本文将从 Spring profile 出发，进而介绍条件化的 Bean 声明、自动装配的歧义性和 Bean 的作用域，以及 Spring 表达式语言。","text":"开发软件的过程中要涉及到不同的环境，需要配置不同的数据库配置、加密算法和外部环境的集成等组件，为此必须要考虑不同的环境下对应不同的配置。本文将从 Spring profile 出发，进而介绍条件化的 Bean 声明、自动装配的歧义性和 Bean 的作用域，以及 Spring 表达式语言。 Spring profile配置 profile使用注解@Profile指定某个 Bean 属于哪一个 profile，以不同环境下的数据库 Bean 为例 @Configurationopen class DataSourceConfig { @Bean @Profile(\"dev\") open fun embeddedDataSource(): DataSource = EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript(\"classpath:schema.sql\") .build() @Bean @Profile(\"prod\") open fun jndiDataSource(): DataSource { val jndiObjectFactoryBean = JndiObjectFactoryBean() jndiObjectFactoryBean.jndiName = \"jndi/myDS\" jndiObjectFactoryBean.isResourceRef = true jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource::class.java) return jndiObjectFactoryBean.`object` as DataSource }} 同样支持使用 XML 文件配置 profile < /jdbc:embedded-database> 可以将 profile 设置为prod，创建适用于生产环境的 JNDI 获取的 DataSource Bean，所有的配置文件都会被放进部署单元之中（如 WAR 文件），但是只有 profile 属性与当前激活 profile 相匹配的配置文件才会被使用。 不过更方便的方法是把所有的 Bean 放进同一个配置文件中 激活 profileSpring 借助两个独立的属性spring.profiles.active、spring.profiles.default来确定哪个 profile 处于激活状态，优先级从高到低。如果两个值都没有设置，那就没有激活的 profile，此时只会创建那些没有定义在 profile 中的 Bean。以下是设置这两个属性的方式 作为 DispatcherServlet 的初始化参数 作为 Web 应用的上下文参数 作为 JNDI 条目 作为环境变量 作为 JVM 的系统属性 在集成测试类上，使用@ActiveProfiles注解设置 例如在 Web 应用中，设置spring.profiles.default的 web.xml 文件如下 spring.profiles.default dev appServlet org.springframework.web.servlet.DispatcherServlet spring.profiles.default dev 该文件分别为上下文和 Servlet 设置了默认的 profile。当应用程序部署到 QA、生产或者其他环境中时，负责部署的人根据情况使用系统属性、环境变量或 JNDI 设置spring.profiles.active即可——其优先级比spring.profiles.default高 条件化的 Bean使用 Spring 提供的注解@Conditional，可以实现 Bean 在符合条件的情况下才会配置的效果，不符合条件则该 Bean 会被忽略。下面的例子假设只有设置了magic环境属性时 Spring 才会实例化 MagicBean（事先准备），否则它将被忽略。 @Configurationopen class MagicConfig { @Bean @Conditional(MagicExistsCondition::class) open fun magicBean(): MagicBean = MagicBean()} @Conditional需要一个class参数，并且该类要实现Condition接口，重写方法match，如果该方法返回 true 则创建带有@Conditional的 Bean。 class MagicExistsCondition: Condition { override fun matches(p0: ConditionContext?, p1: AnnotatedTypeMetadata?): Boolean { val env = p0?.environment return env?.containsProperty(\"magic\") ?: false } } 该方法传入两个参数，第一个为ConditionContext public interface ConditionContext { BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); ClassLoader getClassLoader();} 可以看到该参数为我们提供了很多接口。第二个参数为AnnotatedTypeMetadata public interface AnnotatedTypeMetadata { boolean isAnnotated(String var1); Map getAnnotationAttributes(String var1); Map getAnnotationAttributes(String var1, boolean var2); MultiValueMap getAllAnnotationAttributes(String var1); MultiValueMap getAllAnnotationAttributes(String var1, boolean var2);} 该参数为我们提供了一系列检查@Bean方法上的其他注解的接口 观察第一节提到的Profile注解 @Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional({ProfileCondition.class})public @interface Profile { String[] value();} 可以看到其本身也使用了@Conditional，引用ProfileCondition.class作为 Condition 实现 class ProfileCondition implements Condition { ProfileCondition() { } public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { if (context.getEnvironment() != null) { MultiValueMap attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) { Iterator var4 = ((List)attrs.get(\"value\")).iterator(); Object value; do { if (!var4.hasNext()) { return false; } value = var4.next(); } while(!context.getEnvironment().acceptsProfiles((String[])((String[])value))); return true; } } return true; }} 该类通过 AnnotatedTypeMetadata 获得用于@Profile注解的所有属性，然后检查value属性，得到profile名称。然后通过 ConditionContext 检查该profile是否激活 自动装配的歧义性在自动装配中，只有当仅有一个 Bean 匹配所需的结果时，自动装配才是有效的，出现歧义则将阻碍 Spring 自动装配属性、构造器参数或方法参数。 比如下面的例子，提供两个 CompactDisc 的实现类 interface CompactDisc { fun play()}@Componentclass SgtPeppers: CompactDisc { ......}@Componentclass BlankDisc: CompactDisc { ......} 测试代码为 @RunWith(SpringJUnit4ClassRunner::class)@ContextConfiguration(classes = [CDPlayerConfig::class])class CDPlayerTest { private lateinit var cd: CompactDisc @Test fun play() { cd.play() } @Autowired fun setCompactDisc(cd: CompactDisc) { this.cd = cd }} 测试将会报错 org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'soundsystem.CompactDisc' available: expected single matching bean but found 2: blankDisc,sgtPeppers 针对这种情况，可以使用@Primary和@Qualifier解决 @Primary在其中一个实现上添加注解 @Component@Primaryclass SgtPeppers: CompactDisc { ......} 该注解也可以应用在 JavaConfig 代码中，在 XML 文件的配置方式为 @Qualifier该注解比@Primary更加灵活，使用简单 @Autowired@Qualifier(\"sgtPeppers\")fun setCompactDisc(cd: CompactDisc) { this.cd = cd} 为@Qualifier注解设置的参数就是想要注入的 Bean 的 id，一般为 Bean 的类名首字母变为小写之后的字符。当然开发者也可以自定义 Bean 的限定符防止重命名之后原来的注解失效 @Component@Qualifier(\"byBeatles\")class SgtPeppers: CompactDisc { private val title = \"Sgt. Pepper's Lonely Hearts Club Band\" private val artist = \"The Beatles\" override fun play() { println(\"Playing $title by $artist\") }} 相应的代码也更改为 @Autowired@Qualifier(\"byBeatles\")fun setCompactDisc(cd: CompactDisc) { this.cd = cd} 更进一步，开发者可以自定义一个使用@Qualifier注解的注解类，防止以后再出现一个byBeatles的 Bean import org.springframework.beans.factory.annotation.Qualifier@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FIELD, AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)@Retention(AnnotationRetention.RUNTIME)@Qualifierannotation class FavoriteCD 使用方法和@Qualifier(\"id\")类似，在需要注解的类上添加@FavoriteCD，然后在自动装配的地方同样使用该注解即可。 Bean 的作用域 在上一篇文章中我们提到 Spring 中的 Bean 默认是单例的，但是显然这样的实例将会保持一定的“状态”，因此重用将是不安全的。Spring 定义了多种 Bean 作用域 单例（Singleton）：整个应用中只创建 Bean 的一个实例 原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候都会创建一个新的实例 会话（Session）：在 Web 应用中，为每个会话创建一个实例 请求（Request）：在 Web 应用中，为每个请求创建一个实例 要使用作用域，可以通过@Scope注解实现 @Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)class SgtPeppers 当然在自动装配的地方使用该注解也可以，XML 文件的配置方式同理，不再赘述 会话和请求作用域在典型的电子商务应用中，可能有一个 Bean 代表用户的购物车，当其为单例时意味着所有的用户共用一个购物车。这种情况下使用会话作用域显然更加合适 @Component@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode..TARGET_CLASS)open class ShoppingCart 注解的第一个参数value将告诉 Spring 为 Web 应用的每个会话创建一个 ShoppingCart，在会话相关的操作中其相当于一个单例。第二个参数proxyMode被设为ScopedProxyMode.INTERFACES，解决将会话或者请求作用域的 Bean 注入到单例 Bean 中所遇到的问题 假设 ShoppingCart 注入到一个单例 StoreService 中，由于单例 Bean 会在 Spring 应用上下文加载的时候创建，然而此时属于会话作用域的 ShoppingCart 并不存在；此外，系统中将会有多个 ShoppingCart 实例，我们并不想让某一个固定的 ShoppingCart 实例到 StoreService 中，而是希望当 StoreService 处理购物车功能时，其所使用的 ShoppingCart 实例刚好是当前会话所对应的那个 proxyMode的作用就在于，Spring 不会将实际的 ShoppingCart 注入到 StoreService 中，而是将它的代理注入。这一代理会暴露与 ShoppingCart 相同的方法，所以 StoreService 会认为它就是一个购物车。当 StoreService 调用方法时，代理会进行懒解析并将调用委托到会话作用域内真正的 ShoppingCart 实例 XML 方式配置不再赘述 Spring 表达式语言Spring Expression Language，简称 SpEL，能够以一种强大和简洁的方式将值装配到 Bean 属性和构造器参数中。其有很多特性 使用 ID 来引用 Bean 调用方法和访问对象的属性 对值进行算数、关系和逻辑运算 正则表达式匹配 集合操作 SpEL 要放到#{ ... }中，与属性占位符放到${ ... }中类似。对于下面的表达式 #{T(System).currentTimeMillis()} 将得到表达式计算的那一刻时间的毫秒数。T()表达式将其中参数视为 Java 中的类型，从而可以调用该类型的静态方法。 #{ ... }中既可以放字面值如整数、浮点数、字符串、布尔值，也可以引用对象属性和方法 #{sgtPeppers.artist}#{systemProperties['sgtPeppers.title']}#{sgtPeppers.toString()?.toUpperCase} 上面的第二个表达式将调用properties文件中sgtPeppers的title属性值。第三个参数表示我们可以对方法返回值使用安全调用 SpEL 支持各种常用的运算，包括算术运算、比较运算、逻辑运算、条件运算（? :和?:）、正则表达式（matches），下面是一个正则表达式的例子，用以验证邮箱 #{admin.email matches '[a-zA-Z0-9._&+-]+@[a-zA-Z0-9._&+-]'+\\\\.com} 下面是一个操作集合的例子 #{cd.tracks[1].title}#{'the string'[1]} //得到 h#{cd.tracks.?[title eq 'Title'} //得到 title 为 Title 的新集合#{cd.tracks.^[title eq 'Title'} //得到第一个 title 值为 Title 的元素 #{cd.tracks.$[title eq 'Title'} //得到最后一个 title 值为 Title 的元素 #{cd.tracks.![title]} //得到 title 的集合 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring-学习笔记（一）：基本理念和-Bean-装配","slug":"Spring-学习笔记（一）：基本理念和-Bean-装配","date":"2019-05-28T14:13:09.000Z","updated":"2019-06-01T12:16:24.000Z","comments":true,"path":"Spring-学习笔记（一）：基本理念和-Bean-装配/","link":"","permalink":"http://yoursite.com/Spring-学习笔记（一）：基本理念和-Bean-装配/","excerpt":"很早就接触 Java 后端开发，不过大都浅尝辄止，并没有深刻地理解和实践，时间一长倒也跟没学过差不了多少。由于职业规划是要从 Android 开发慢慢转到后端开发，拖到现在终于是要系统学习了。学习的路线初步定为，从 Spring 出发，不断回顾 Java Web 的知识，重点在 Spring Boot 项目，通过具体的项目实践掌握相关知识。这篇文章属于第一篇学习笔记，参考手上的《Spring 实战》和网络上的技术文章，主要记录 Spring 的基本知识和理念、Bean 的装配。","text":"很早就接触 Java 后端开发，不过大都浅尝辄止，并没有深刻地理解和实践，时间一长倒也跟没学过差不了多少。由于职业规划是要从 Android 开发慢慢转到后端开发，拖到现在终于是要系统学习了。学习的路线初步定为，从 Spring 出发，不断回顾 Java Web 的知识，重点在 Spring Boot 项目，通过具体的项目实践掌握相关知识。这篇文章属于第一篇学习笔记，参考手上的《Spring 实战》和网络上的技术文章，主要记录 Spring 的基本知识和理念、Bean 的装配。 关于Spring一个 Java EE 框架，同来替代更加重量级的企业级 Java 技术。其起源可以追溯到作者 Rod Johnson 2002年编写的《Expert One-to-One J2EE Design and Development》一书，书中他提出了一种基于普通 Java 类和依赖注入的解决方案。Rod Johnson 编写了超过30,000行基础结构代码，这便是最初的 Spring 框架。 Spring 的基本理念在于：简化 Java 开发，为此采用了4种关键措施： 基于 POJO 的轻量级和最小侵入性编程 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板式代码 依赖注入依赖注入（Dependency Injection，简称 DI）是最常见的控制反转（Inversion of Control，简称 IoC）方式，是面向对象编程中的一种设计原则，用于减少代码之间的耦合度。系统通过引入实现 IoC 模式的容器，管理对象的声明周期、依赖关系，常用的 IoC 容器有 Spring 、JBoss、EJB 等。可以把 IoC 模式看作工厂模式的升华，区别在于该工厂要生成的对象是通过 XML 文件、配置类或者注解来配置。 Java 项目大都是由众多类组成，这些类相互协作来完成特定的业务逻辑。传统的做法是每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，导致代码高度耦合。耦合具有两面性，一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且修复 Bug 的过程中容易引发更多的 Bug；另一方面，一定的耦合又是必须的——完全无耦合的代码什么也做不了。通过 DI，对象的依赖关系交由系统中负责协调各对象的第三者在创建对象时设定，依赖关系被注入到需要它们的对象中。 通过一个简单的 Spring Demo 引入依赖注入的思想。 项目结构如下 ├─src│ ├─main│ │ ├─java│ │ │ └─knigt│ │ │ BraveKnight.kt│ │ │ SlayDragonQuest.kt│ │ │ KnightConfig.kt│ │ │ KnightMain.kt│ │ ││ │ └─resources│ │ knights.xml 在 IDEA 内通过以下命令生成项目文档树 tree >> D:/tree.txt 输出文件夹tree /f >> D:/tree.txt 输出文件夹和文件 //BraveKnight.ktinterface Knight { fun embarkOnQuest()}class BraveKnight(private val quest: Quest): Knight { override fun embarkOnQuest() { quest.embark() }}//SlayDragonQuest.ktinterface Quest { fun embark()}class SlayDragonQuest(private val stream: PrintStream): Quest { override fun embark() { stream.println(\"Embarking on quest to slay the dragon!\") }}//KnightConfig.kt@Configurationopen class KnightConfig { @Bean open fun knight(): Knight = BraveKnight(quest()) @Bean open fun quest(): Quest = SlayDragonQuest(System.out)}//KnightMain.ktclass KnightMain { companion object { @JvmStatic fun main(args: Array) { val context: AnnotationConfigApplicationContext = AnnotationConfigApplicationContext(KnightConfig::class.java) //val context: ClassPathXmlApplicationContext = ClassPathXmlApplicationContext(\"knights.xml\") XML 方式配置 val knight: Knight = context.getBean(Knight::class.java) knight.embarkOnQuest() context.close() } }} XML 的配置文件为 //knight.xml 输出结果为 Embarking on quest to slay the dragon! 面向切面编程Aspect-Oriented Programming，AOP。DI 能够让相互协作的组件保持松耦合，而 AOP 则允许开发者把组件除自身核心功能之外，可重用的功能分离出来，比如日志、事务管理和安全等服务。AOP 思想中的相关术语包括 Joinpoint：连接点，目标对象中所有可增强的方法 Pointcut：切入点，目标对象中所有已增强的方法 Advice：增强/通知，增强的代码 Weaving：织入，将“通知”应用到切入点的过程 Proxy：将“通知”织入到目标对象后，形成代理对象 Aspect：切面，切入点+“通知” 使用一个传唱骑士事迹的吟游诗人服务类作为一个 AOP 的应用 //Minstrel.ktopen class Minstrel(private val stream: PrintStream) { open fun singBeforeQuest() { stream.println(\"Fa la la, the knight is so brave!\") } open fun singAfterQuest() { stream.println(\"Tee hee hee, the brave knight did embark on a quest!\") }} //knights.xml 加入以下代码 默认缺少 org.aspectj.aspectjweaver，可以引入 maven，添加对应的依赖 运行之后，控制台输出结果为 Fa la la, the knight is so brave!Embarking on quest to slay the dragon!Tee hee hee, the brave knight did embark on a quest! 不使用 BraveKnight 和 Minstrel 组合的方式而是使用 AOP，通过少量的 XML 配置，就可以把 Minstrel 声明为一个 Spring 切面，进而实现相应的功能。Minstrel 仍然只是一个 POJO，但可以被应用到任何需要它的地方，只需要修改配置文件中的 AspectJ 切点表达式语言即可。 装配 Bean容器Spring 容器（Container）负责创建、装配和配置对象，并且管理它们的生命周期。Spring 的核心便是容器，它自带多个容器实现，可以归为两种不同的类型：Bean 工厂（由org.springframework.beans.factory.BeanFactory接口定义）是最简单的容器，提供基本的 DI 支持；应用上下文（由org.springframework.context.ApplicationContext接口定义），基于 BeanFactory 构建，并提供应用框架级别的服务，例如从属性文本解析文本信息以及发送应用事件给感兴趣的事件监听者。重点在于应用上下文上。 Spring 自带多种应用上下文 AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文 AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文 ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源 FileSystemXmlApplicationContext：从文件系统的一个或多个 XML 配置文件中加载上下文定义 XmlWebApplicationContext：从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义 Bean 生命周期 Spring 对 bean 进行实例化 Spring 将值和 bean 的引用注入到 bean 对应的属性中 如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给setBeanName方法 如果 bean 实现了 BeanFactoryAware 接口，Spring 将调用setBeanFactory方法，将 BeanFactory 容器实例传入 如果 bean 实现了 ApplicationContextAware 接口， Spring 将调用setApplicationContext方法，将 bean 所在的应用上下文的引用传入 如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的postProcessBeforeInitialization方法 如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet方法。类似的，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用 如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的postProcessAfterInitialzation方法 此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁 如果 bean 实现了 DisposablBean 接口，Spring 将调用它的destroy接口方法。同样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用 可选装配方案有三种方式向 Spring 容器描述 Bean 如何装配 在 XML 文件中进行显示配置 在 Java 代码中进行显示配置 隐式的 bean 发现机制和自动装配 自动化装配 beanSpring 从两个角度实现自动化装配 组件扫描（Component Scanning）：Spring 会自动发现应用上下文中所创建的 bean 自动装配（Autowiring）：Spring 自动满足 bean 之间的依赖 通过一个 CD 播放的 Demo 说明，XML config 文件位于/resources目录下，Kotlin 文件位于java/soundsystem目录下 //conpactDisc.kt@Componentclass CompactDisc { private val title = \"Sgt. Pepper's Lonely Hearts Club Band\" private val artist = \"The Beatles\" fun play() { println(\"Playing $title by $artist\") }}//CDPlayer.kt@Componentclass CDPlayer @Autowiredconstructor(private val cd: CompactDisc) { fun play() { cd.play() }}//CDPlayerTest.kt@RunWith(SpringJUnit4ClassRunner::class)@ContextConfiguration(classes = [CDPlayerConfig::class])class CDPlayerTest { @Autowired lateinit var player: CDPlayer @Test fun play() { player.play() }} 以上便是准备好的工程文件，使用@Autowired注解在需要自动装配的任何属性、构造器、方法上，然后在 Java 代码或者 XML 配置文件启动自动装配。不同的自动装配方式需要修改 JUnit 测试框架的@ContextConfiguration注解参数 XML 方式：locations = [\"classpath:spring-config.xml\"] Java 方式：classes = [CDPlayerConfig::class] JUnit 测试框架需要导入依赖 接下来的一步便是启用 Spring 的组件扫描，也就是配置以上的两种注解参数之一，搭配 Bean 类注解@Component便可以实现组件扫描。以下两种做法都可以，第一种是使用一个Config类并添加注解@Configuration和@ConponentScan，第二种则是在 XML 文件中配置context:component-scan //Java 代码@Configuration@ComponentScanopen class CDPlayerConfig //XML 文件 运行测试，控制台成功输出 Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles Java 代码装配大多数情况下都可以通过自动化装配的方式完成配置，但是当我们使用第三方的类库组件时，无法在组件类上直接添加注解，只能使用显示装配。这种情况下，使用 JavaConfig 是最好的方式。通常将 JavaConfig 放到同一个包中，并且它应该不包含任何的业务逻辑。 @Configurationopen class CDPlayerConfig { @Bean open fun sgtPeppers(): SgtPeppers = SgtPeppers() @Bean open fun cdPlayer(): CDPlayer = CDPlayer(sgtPeppers()) @Bean open fun anotherCDPlayer(): CDPlayer = CDPlayer(sgtPeppers()) @Bean open fun cdPlayerUseParam(compactDisc: CompactDisc): CDPlayer { val cdPlayer = CDPlayer(compactDisc) cdPlayer.setCompactDisc(compactDisc) return cdPlayer }} 在上面的代码中，配置类CDPlayerConfig中提供了几种装配 Bean 的方式。sgtPeppers方法注入了一个 SgtPeppers 实例，cdPlayer和anotherCDPlayer需要调用该方法来注入 CDPlayer 实例。Spring 会拦截所有对该方法的调用，并直接返回该方法创建的 Bean，并且默认情况下 Bean 是单例的。 最后一个方法则展现了一个更具可读性、更多样化的注入方式。 XML 代码装配最简单的 Spring XML 配置如下 需要在配置文件顶部声明多个 XML 模式（XSD）文件，这些文件定义了配置 Spring 的 XML 元素。配置文件的根元素。 声明一个简单的 Bean 可以通过下面的方式实现 如果没有指定 id，该 Bean 将会根据全限定类名命名：sound_system.CDPlayer#0，#0为计数形式，用以区分相同类型的其他 Bean。 &lt;constructor-arg&gt;元素告知 Spring 要将一个 id 为sgtPeppers的 bean 引用传递到 CDPlayer 的构造器中。作为替代，也可以使用 Spring 的 c-命名空间，不再赘述。关于&lt;constructor-arg&gt;元素的更多知识：IOC 之解析 bean 标签：constructor-arg、property 子元素 在该元素中，可以使用value属性将字面量传递给构造器，使用子元素&lt;null/&gt;空值，使用子元素&lt;list&gt;传递集合。 XML 配置也提供了设置属性的接口，通过元素property可以将对象引用、字面量、集合等注入 Bean 中。比如为 SgtPeppers 添加新的属性并对外提供修改接口 class SgtPeppers: CompactDisc { var title = \"Sgt. Pepper's Lonely Hearts Club Band\" var artist = \"The Beatles\" var tracks: MutableList = ArrayList() override fun play() { println(\"Playing $title by $artist\") }} 然后在 XML 文件中注入属性设置 track 1 track 2 track 3 track 4 导入和混合配置当开发者使用自动装配的时候，Spring 会考虑容器中的所有 Bean，因此不用考虑混合配置的问题。混合配置应用在显式装配时，比如 XML 和 Java 互相引用配置的 Bean。 在 JavaConfig 中使用注解@Import导入其他 JavaConfig，使用注解@ImportResource混合 XML 配置，比如 @Configuration@Import(CDPlayerConfig::class)@ImportResource(\"classpath:sound_system.xml\")open class SoundSystemConfig 在 XML 中使用元素import导入其他 XML 文件，而如果要导入 JavaConfig，做法很简单 ：将其声明为一个 bean 即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"},{"name":"DI","slug":"DI","permalink":"http://yoursite.com/tags/DI/"},{"name":"Java EE","slug":"Java-EE","permalink":"http://yoursite.com/tags/Java-EE/"}]},{"title":"Gradle 构建工具详解","slug":"Gradle-构建工具详解","date":"2019-05-25T14:37:41.000Z","updated":"2019-06-02T05:00:46.000Z","comments":true,"path":"Gradle-构建工具详解/","link":"","permalink":"http://yoursite.com/Gradle-构建工具详解/","excerpt":"Gradle 是一个基于 JVM 的自动化构建工具，使用 Groovy DSL 声明配置。现代软件开发包含众多步骤，包括编译、测试、打包等，如果需要手动重复每一过程，将会耗费大量时间、增加出错概率，项目自动化应运而生。在此之前，常见的 Java 构建工具包括 Ant、Gant 和 Maven 等，Gradle 结合了以上工具的优点，基于约定大于配置，通用灵活，是 Android 的官方构建工具。本文将介绍 Gradle 的基本知识、Groovy 基本语法以及 Android 开发中的 Gradle 知识。","text":"Gradle 是一个基于 JVM 的自动化构建工具，使用 Groovy DSL 声明配置。现代软件开发包含众多步骤，包括编译、测试、打包等，如果需要手动重复每一过程，将会耗费大量时间、增加出错概率，项目自动化应运而生。在此之前，常见的 Java 构建工具包括 Ant、Gant 和 Maven 等，Gradle 结合了以上工具的优点，基于约定大于配置，通用灵活，是 Android 的官方构建工具。本文将介绍 Gradle 的基本知识、Groovy 基本语法以及 Android 开发中的 Gradle 知识。 入门搭建环境确保系统已安装 JDK 1.7及以上，此处将介绍 Gradle 在 Windows 平台下的手动安装。在 https://gradle.org/releases/ 下载最新的 release 包并解压至相应文件夹，然后在系统环境变量添加GRADLE_HOME，作者的变量值为D:\\gradle-5.4.1，最后再将%GRADLE_HOME%\\bin添加进Path变量中即可。在命令行中键入gradle -v验证环境搭建结果。 PS C:\\Users\\Febers> gradle -vWelcome to Gradle 5.4.1!Here are the highlights of this release: - Run builds with JDK12 - New API for Incremental Tasks - Updates to native projects, including Swift 5 supportFor more details see https://docs.gradle.org/5.4.1/release-notes.html Hello World新建一个工程项目，比如gradle_demo，然后新建一个build.gradle文件，在其中输入 task hello { doLast { println 'Hello World!' }} 在当前文件夹命令行中键入gradle -q hello即可输出Hello World!。这里使用的是基于 Groovy 的 DSL（Domain Specific Language，领域特定语言）。 task 和 action 是 Gradle 的重要元素，前者代表一个独立的原子操作，比如复制一个文件、编译一次 Java 代码，这里简单定义一个名为hello的 task；后者则是前者的组成部分，doLast代表 task 执行的最后一个 action，task 执行完毕之后会回调该 action。 日志级别和 Android 类似，Gradle 也定义了日志级别 级别 用于 ERROR 错误信息 QUIET 重要信息 WARNING 警告信息 LIFECYCLE 进度信息 INFO 信息消息 DEBUG 调试消息 上文运行任务所使用到的命令gradle -q hello中的-q即为日志的级别开关选项 开关选项 输出级别 无 LIFECYCLE及以上 -q 或 –quiet QUIET及以上 -i 或 –info INFO及以上 -d 或 –debug DEBUG及以上 Project每个 Gradle 项目都由一个或多个 Project 构成，每个 Project 又都由 Task 构成。一个 build.gradle文件便是对一个 Project 对象的配置。在 Android 项目中，根目录会存在一个build.gradle文件，每个模块下也会有一个该文件。 在构建脚本中调用的没有在构建脚本中定义的方法和属性都委派给 Project 对象，比如project.copy()等价于copy()、project.buildDir等价于buildDir Task创建任务task hello { doLast { println 'Hello World!' }}//直接用任务名称def Task helloo = task(helloo)helloo.doLast { println 'Helloo World!'}//声明任务配置def Task hellooo = task(hellooo, group: BasePlugin.BUILD_GROUP)hellooo.doLast { println 'Hellooo World!'}//使用 TaskContainer 的 create 方法创建，以上三种方式最终都会调用该方法tasks.create(name: 'helloooo') { doLast { println 'helloooo World!' }} 输入gradle -q hello*之后的结果为，说明成功创建任务 Hello World!Helloo World!Hellooo World!helloooo World! 任务顺序通过dependsOn指定任务的依赖，通过一个例子理解 task hello { println 'hello' doFirst { println 'hello first' } doLast { println 'Hello last' }}task go(dependsOn: hello) { println 'go' doLast { println 'go last 0' } doFirst { println 'go first' } doLast { println 'go last 1' }} 输入gradle -q go之后的输出结果为 hellogohello firstHello lastgo firstgo last 0go last 1 排除任务在命令行后添加-x go来排除任务 go，输入gradle hello -x go之后 > Task :hellohellohello firsthello lastBUILD SUCCESSFUL in 1s1 actionable task: 1 executed 动态任务可以通过拓展方法times动态创建任务 3.times { count -> task \"task$count\" { doLast { println \"task $count\" } }} 输入gradle -q task0之后将输出task 0，已创建的三个任务中的一个 任务属性标准属性有group、description等，除此之外的自定义属性需添加ext前缀 task hello { group = 'group0' description = 'description' ext.myTitle = 'title' ext.myId = 9527 doLast { println \"任务分组属性: $group\" println \"任务描述:属性 $description\" println \"自定义Title属性: $myTitle\" println \"自定义Id属性: $myId\" }} 输出正常 Groovy Gadle 使用 Groovy 的 DSL 编写，Groovy 是 Apache 推出的 JVM 语言。Groovy 的学习可以参考其官方文档，写得相当友好。Groovy 可以与 Java 无缝连接，甚至可以在其中直接使用 Java 语法，Java 中调用 Groovy 也相当方便。此处只介绍一些与 Java 不同的地方。 Groovy 会默认导入以下包，不需要显示导入 java.io.*java.lang.*java.math.BigDecimaljava.math.BigIntegerjava.net.*java.util.*groovy.lang.*groovy.util.* 可以导入 SDK 之后在 IDE 中编写 Groovy 程序，也可以在 build.gradle 中编写代码，在 task 中调用，使用 gradle 命令运行。以下的例子采用后一种方法。 变量与方法使用 def 关键字来定义变量和方法，可以不指定变量的类型，默认访问修饰符为 public。Groovy 中使用双引号定义字符串的时候类型为GString而非java.lang.String，因此可以使用$输出表达式结果 task t { //定义变量，可以使用 def，也可以使用具体类型，或者两者结合 def a = 0 def int b = 1 //定义字符串，同 dart String s = \"s\" String ss = 'ss' String sss = \"\"\"first row second row\"\"\" println \"95-27=${minus(95,27)}\" println \"95+27=${add 95,27}\"}//指定返回类型则 def 可省略，且参数类型可省略//不使用 return 则返回最后一行int minus(a, b) { println \"before return\" a - b}//定义方法def add(int a, int b) { return a + b} 控制台输出 before return95-27=6895+27=122 对象Groovy 中的类与 Java 类似，不过由于没有访问修饰符，默认为public，要想实现 Java 默认的包访问权限（default），可以使用注解@PackageScope。对于没有可见性修饰的变量，Groovy 会隐式提供setter/getter方法。以下的两个类是等价的 task t { def object = new ClassInGroovy() object.name = \"Jack\" println \"${object.name}\"}public class ClassInJava { public String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}class ClassInGroovy { String name} 此外 Groovy 使用asType函数进行类型转换，支持object.with{ }进行级联操作，支持使用?.进行非空操作，都是些很眼熟的语法特性 闭包闭包在 Groovy 中是groovy.lang.Closure的实例，类似于 Dart 中的函数是 Function 的实例，因此可以像变量一样传递，其语法定义为 //闭包的参数为可选项def closure = { [closureParameters -> ] statements } 闭包跟函数不同的地方在于其可以访问外部变量 task t { def str = \"hello\" def closure0 = { println str } def closure1 = { String name, int t -> println \"before print\" println \"$name call $t times\" } //调用，call 可省略 closure0.call() closure1(\"Jack\", 10)} 与 Java 中的 Lambda 表达式类似，闭包可以当做参数传递，当闭包为最后一个参数时可写在调用的括号后 文件读取相较于 Java，Groovy 的文件读写非常简洁友好。在当前文件夹新建一个文件静夜思.txt task t { def path = \"静夜思.txt\" def file = new File(path).eachLine { line -> println line } //更简洁 println file.text //写入，该方法会打印并覆盖原来的内容 file.withPrintWriter { it.println \"表达了诗人对家乡的思念\" }} 其他Groovy 中的流程控制语句（比如if/else、for/in、switch/case）、数据结构（比如List、Map）与 Java/Dart 类似，在此便不过多费笔墨，参考官方文档即可。 Gradle WrapperGradle 包装器。为了应对团队开发中 Gradle 环境和版本的差异会对编译结果带来的不确定性，使用 Gradle Wrapper，它是一个脚本，可以指定构建版本、快速运行项目，从而达到标准化、提到开发效率。Android Studio 新建项目时自带 Gradle Wrapper，因此 Android 开发者很少单独下载安装 Gradle Gradle Wrapper 的工作流程如下图 使用 Gradle Wrapper 启动 Gradle 之后，如果指定版本的 Gradle 没有被下载关联，会先从官方仓库下载到用户本地，进行解包并执行批处理文件。后续的构建运行都会重用这个解包的运行时安装程序 构建 Gradle WrapperGradle 内置 Wrapper Task，执行 Wrapper Task 就可以在项目目录中生成对应的目录文件。在项目根目录执行gradle wrapper 命令即可。之后根目录的文件结构如下 ├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat 文件含义为 gradle-wrapper.jar ：包含 Gradle 运行时的逻辑代码。 gradle-wrapper.properties ：负责配置包装器运行时行为的属性文件 gradlew：Linux 平台下，用于执行 Gralde 命令的包装器脚本。 gradlew.bat：Windows 平台下，用于执行 Gradle 命令的包装器脚本。 查看.properties文件 distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-5.4.1-bin.zipzipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/dists 属性含义为 distributionBase：Gradle 解包后存储的主目录。 distributionPath：distributionBase 指定目录的子目录。distributionBase+distributionPath 为 Gradle 解包后的存放位置。 distributionUrl：Gradle 发行版压缩包的下载地址。 zipStoreBase：Gradle 压缩包存储主目录。 zipStorePath：zipStoreBase 指定目录的子目录。zipStoreBase+zipStorePath 为 Gradle 压缩包的存放位置。 如果官方包发行版下载缓慢，可以手动更改distributionUrl为可用地址 使用 Gradle Wrapper使用gradlew.bar代替gradle运行 Gradle Project，首次使用会下载 Gradle 到配置文件指定的位置，作者的路径为C:\\Users\\23033\\.gradle\\wrapper\\dists\\gradle-5.4.1-bin\\e75iq110yv9r9wt1a6619x2xm\\gradle-5.4.1 PS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat tDownloading https://services.gradle.org/distributions/gradle-5.4.1-bin.zip...................................................................................Hello World! 再次使用该命令便不会重复下载。升级 Gradle 版本可以通过gradlew wrapper –gradle-version 5.*.*命令实现 Gradle 插件Gradle 中的插件可分为两类 脚本插件：额外的构建脚本，类似于一个 build.gradle 对象插件：又叫二进制插件，是实现了 Plugin 接口的类 应用插件又分为两个步骤，一是解析插件，二是通过apply()把插件应用到项目中。 脚本插件在根目录新建一个other.gradle文件，内容如下 ext { otherVersion = '1.0' otherUrl = 'https://febers.github.io'} 将build.gradle内容修改为 apply from: 'other.gradle'task t { println \"版本为: ${otherVersion},地址为: ${otherUrl}\"} 输出结果 PS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat t> Configure project :版本为: 1.0,地址为: https://febers.github.io 对象插件对象插件是实现了org.gradle.api.plugin接口的插件，又可分为内部插件和第三方插件 内部插件使用以下方法应用 Java 插件（因为默认导入org.gradle.api.plugin包，所以可以去掉包名） apply plugin: org.gradle.api.plugins.JavaPluginapply plugin: JavaPlugin //去掉包名apply plugin: 'java' //使用 pluginid（实现 plugin 接口的插件的属性）apply plugin: 'cpp' //Gradle 中含有大量插件 第三方插件一般为 jar 文件，通过buildscript配置，此处引入 Android Gradle 插件 buildscript { repositories { google() } dependencies { classpath 'com.android.tools.build:gradle:3.4.1' }}apply plugin: 'com.android.application' 如果第三方插件被托管到 Gradle - Plugins，也可以不使用buildscript plugins { id \"com.quittle.setup-android-sdk\" version \"1.2.0\"} 自定义对象插件Plugin 接口中定义了一个apply方法，重写该方法，在其中通过传进来的参数Object o（实际为 Project 类型）调用 task 新建一个任务 class MyPlugin implements Plugin { @Override void apply(Object o) { o.task(\"myTask\") { println \"This is a custom task in custom plugin\" } }}apply plugin: MyPlugin 输入命令gradle myTask即可验证 Android 中的 Gradle为了支持 Android 项目的构建，Google 为 Gradle 编写了 Android 插件，组成 Android 构建系统。Android Studio+Gradle 是目前最流行的 Android 开发构建环境。关于 Android 构建配置可查阅官方文档 配置构建 模块类型Android Studio 中的每个项目包含一个或多个含有源代码文件和资源文件的模块，这些模块可以独立构建测试，模块类型包含以下几种 Android 应用程序模块：可能依赖于库模块，构建系统会将其生成一个 apk 文件 Android 库模块：包含可重用的特定于 Android 的代码和资源，构建系统将其生成一个 aar 文件 App 引擎模块：包含应用程序引擎继承的代码和资源 Java 库模块：包含可重用的代码，构建系统将其生成一个 jar 文件 项目结构在 Android Studio 中，Android 项目视图如下，以开发者个人项目 UESTC_BBS 为例 所有构建稳健位于 Gradle Scripts 层级下，文件作用如下 项目 build.gradle：配置项目整体属性，比如指定的代码仓库、依赖的 Gradle 版本等 模块 build.gradle：配置当前模块的编译参数 gradle-wrapper-properties：配置 Gradle Wrapper gradle-properties：配置 Gradle setting.gradle：配置 Gradle 的多项目管理 local.properties：存放 Android 项目的私有属性配置，如 SDK 路径 multiDexKeep.pro、proguard-rules.pro：可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类 项目 build.gradle典型的项目build.gradle文件如下 buildscript { ext.kotlin_version = '1.3.10' repositories { mavenCentral() google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.4.0' classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" classpath \"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\" }}allprojects { repositories { google() jcenter() mavenCentral() maven { url 'https://jitpack.io' } maven { url \"https://maven.google.com\" } }}task clean(type: Delete) { delete rootProject.buildDir} 其中google()是配置 Google 的 Maven 仓库，maven { url \"https://maven.google.com\" }同理 模块 build.gradle典型的模块build.gradle文件如下 apply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'apply plugin: 'kotlin-kapt'ext.anko_version = '0.10.5'dependencies { implementation fileTree(include: ['*.jar'], dir: 'libs') implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\" implementation 'com.android.support:multidex:1.0.3' implementation 'androidx.appcompat:appcompat:1.0.2' testImplementation 'junit:junit:4.12'}android { compileSdkVersion 28 defaultConfig { applicationId \"com.febers.uestc_bbs\" minSdkVersion 17 targetSdkVersion 28 versionCode 12 versionName \"1.1.4\" testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" multiDexEnabled true multiDexKeepProguard file('multiDexKeep.pro') // keep specific classes using proguard syntax } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } }} 第一行 apply 的是一个application，说明当前模块为一个应用程序模块，Gradle 的 Android 插件分为以下几种 应用程序插件：插件 id 为com.android.application，构建生成 apk 库插件：插件 id 为com.android.library，构建生成 aar 测试插件：插件 id 为com.android.test，用于测试其他模块 feature 插件：插件 id 为com.android.feature，用于创建 Android Instant App instant App 插件：插件 id 为com.android.instantapp，是 Android Instant App 的入口 很多属性都可以望文生义，此处不再赘述。 参考 Gradle的Android插件入门 Gradle核心思想 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://yoursite.com/categories/Gradle/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"http://yoursite.com/tags/Gradle/"},{"name":"构建工具","slug":"构建工具","permalink":"http://yoursite.com/tags/构建工具/"},{"name":"Groovy","slug":"Groovy","permalink":"http://yoursite.com/tags/Groovy/"}]},{"title":"Kotlin 委托属性详解","slug":"Kotlin-委托属性详解","date":"2019-05-21T08:52:14.000Z","updated":"2019-06-02T05:02:28.000Z","comments":true,"path":"Kotlin-委托属性详解/","link":"","permalink":"http://yoursite.com/Kotlin-委托属性详解/","excerpt":"委托属性算是 Kotlin 语言中的高级特性，初次接触可能毫无头绪，再次接触还是一脸懵逼。只有在深入理解其语言特性和实现原理之后，才能对这一甜之又甜的“语法糖”有所认识，从而极大提高代码效率。在笔者的项目 UESTC_BBS 中，对自带 SharedPreferences 的封装 PreferenceUtils 就使用了委托属性，故一直想找机会写一篇笔记类型的文章将其记录下来。委托属性的基础是委托，一种设计模式，操作的对象不用自己执行，而是委托给另一个辅助对象。","text":"委托属性算是 Kotlin 语言中的高级特性，初次接触可能毫无头绪，再次接触还是一脸懵逼。只有在深入理解其语言特性和实现原理之后，才能对这一甜之又甜的“语法糖”有所认识，从而极大提高代码效率。在笔者的项目 UESTC_BBS 中，对自带 SharedPreferences 的封装 PreferenceUtils 就使用了委托属性，故一直想找机会写一篇笔记类型的文章将其记录下来。委托属性的基础是委托，一种设计模式，操作的对象不用自己执行，而是委托给另一个辅助对象。 委托基本使用定义一个委托属性的基本语法为 val/var : by ，在 by 后面的表达式即为委托， 属性对应的 get()与set()会被委托给它的 getValue() 与 setValue() 方法。 class Example { var p: String by Delegate() companion object { @JvmStatic fun main(args: Array) { var e = Example() println(e.p) e.p = \"newValue\" } }}class Delegate { operator fun getValue(thisRef: Any?, property: Any): String { return \"$thisRef, thank you for delegating '$property' to me!\" } operator fun setValue(thisRef: Any?, property: Any, value: String) { println(\"$value has been assigned to '$property' in $thisRef.\") }} 上述代码中，Delegate 内方法的参数 property 原本为 KProperty 接口类型，为了手动调用其方法，改成 Any 以实现传参。 控制台输出结果为 Example@1175e2db, thank you for delegating 'p' to me!newValue has been assigned to 'p' in Example@1175e2db. 可以看到属性 p 委托给了 Delegate() 对象实例，按照约定，该对象必须声明具有getValue、setValue方法，且方法参数个数必须大于2、3。 为了更清楚的了解这一过程，可以将代码改写成另一种形式 class Example { var delegate: Delegate = Delegate() var p: String set(value) { delegate.setValue(thisRef = this, property = delegate, value = value) } get() = delegate.getValue(thisRef = this, property = delegate)} 当我们使用 p 时调用其get方法，给 p 赋值时调用其set方法，并且都是通过委托对象 delegate 实现。 标准委托lazy函数lazy接收一个 lambda 表达式并返回一个 Lazy 实例，默认情况下其线程安全 //方法签名public actual fun lazy(initializer: () -> T): Lazy = SynchronizedLazyImpl(initializer)val s: String by lazy { println(\"get\") \"hello\"}println(s)println(s) 只有在第一次调用 s 时才会执行传递给 lazy() 的 lambda 表达式并返回一个记录下来的结果， 后续调用 get() 只会返回记录的结果。底层原理在于函数签名中的SynchronizedLazyImpl方法，其中会检查变量的值，判断其是否为默认值，如果是则执行初始化函数，否则直接返回结果，具体代码可以查阅LazyJVM.kt文件。 控制台输出为 gethellohello observable字面意思，用委托的方式来定义一个可观察属性。该函数的方法签名为 public inline fun observable(initialValue: T, crossinline onChange: (property: KProperty, oldValue: T, newValue: T) -> Unit): ReadWriteProperty 其接收两个参数，第一个为默认值，第二个为 lambda 表达式，位于Delegates.kt，具体使用 var name: String by Delegates.observable(\"initialValue\") { property, oldValue, newValue -> println(\"$oldValue -> $newValue\")}name = \"newValue0\"name = \"newValue1\" 控制台输出 initialValue -> newValue0newValue0 -> newValue1 Storing将对象的属性委托值 map 中，用于解析 JSON 或者其他动态工作，不过应用较少 val user = User(mapOf(\"name\" to \"Jack\", \"age\" to 20))println(user.name)println(user.age)class User(private val map: Map) { val name: String by map val age: Int by map} 典型应用封装一个 SharedPreferences（简称 SP） 是 Android 开发中经常要做的事，因为直接调用 SP 足够繁琐。如果是 Java 代码，则代码基本如下 public final class PreferencesUtil { private static PreferencesUtil sInstance; public static void init(Context context) { if (sInstance == null) { sInstance = new PreferencesUtil(context); } } public static PreferencesUtil getInstance() { if (sInstance == null) throw new RuntimeException(\"Uninitialized.\"); return sInstance; } private final SharedPreferences mSp; private PreferencesUtil(Context context) { mSp = PreferenceManager.getDefaultSharedPreferences(context); } public String getString(String key, String defValue) { return mSp.getString(key, defValue); } public void putString(String key, String value) { mSp.edit().putString(key, value).apply(); } public int getInt(String key, int defValue) { return mSp.getInt(key, defValue); } public void putInt(String key, int value) { mSp.edit().putInt(key, value).apply(); } public long getLong(String key, long defValue) { return mSp.getLong(key, defValue); } public void putLong(String key, long value) { mSp.edit().putLong(key, value).apply(); } public float getFloat(String key, float defValue) { return mSp.getFloat(key, defValue); } public void putFloat(String key, float value) { mSp.edit().putFloat(key, value).apply(); } public boolean getBoolean(String key, boolean defValue) { return mSp.getBoolean(key, defValue); } public void putBoolean(String key, boolean value) { mSp.edit().putBoolean(key, value).apply(); }} 外部调用 if (PreferencesUtil.getInstance().getBoolean(Constant.IS_FIRST_LAUNCH, Constant.DEF_IS_FIRST_LAUNCH)) { // Do something first launch, like showing Welcome. ... PreferencesUtil.getInstance().putBoolean(Constant.IS_FIRST_LAUNCH, false);} 使用 Kotlin 的委托属性之后实现就简洁很多 class PreferenceUtils(val context: Context, val name: String, val default: T): ReadWriteProperty { val prefs: SharedPreferences by lazy { context.defaultSharedPreferences } override fun getValue(thisRef: Any?, property: KProperty): T { return findPreference(name, default) } override fun setValue(thisRef: Any?, property: KProperty, value: T) { putPreference(name, value) } private fun findPreference(name: String, default: T): T = with(prefs) { val res: Any = when (default) { is Long -> getLong(name, default) is Int -> getInt(name, default) is String -> getString(name, default) is Boolean -> getBoolean(name, default) is Float -> getFloat(name, default) else -> throw IllegalArgumentException(\"This type can't be saved into Preferences\") } return@with res as T } private fun putPreference(name: String, value: T) = with(prefs.edit()) { when (value) { is Long -> putLong(name, value) is Int -> putInt(name, value) is String -> putString(name, value) is Boolean -> putBoolean(name, value) is Float -> putFloat(name, value) else -> throw IllegalArgumentException(\"This type can't be saved into Preferences\") }.apply() }} 其中接口ReadWriteProperty为系统提供的规范接口，其中定义了getValue/setValue方法。外部调用如下 var themeCode by PreferenceUtils(context, Constant.theme_code, default = 1)themeCode = 9527 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"},{"name":"委托属性","slug":"委托属性","permalink":"http://yoursite.com/tags/委托属性/"}]},{"title":"Dart 反射初识","slug":"Dart-反射初识","date":"2019-05-20T02:16:44.000Z","updated":"2019-06-02T04:55:16.000Z","comments":true,"path":"Dart-反射初识/","link":"","permalink":"http://yoursite.com/Dart-反射初识/","excerpt":"在 Java 反射详解 一文中，我们知道反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。换一个角度说，反射可以细分为自省——程序在运行时决定自身结构的能力，以及自我修正——程序在运行时改变自身的能力。Dart 的反射基于 mirror 概念，它指的是反映其他对象的对象，并且目前只支持自省，不支持自我修改。","text":"在 Java 反射详解 一文中，我们知道反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。换一个角度说，反射可以细分为自省——程序在运行时决定自身结构的能力，以及自我修正——程序在运行时改变自身的能力。Dart 的反射基于 mirror 概念，它指的是反映其他对象的对象，并且目前只支持自省，不支持自我修改。 MirrorExamplemain() { ClassMirror cm = reflectClass(ChildClass); cm.instanceMembers.forEach((key, value) => print('$key >>> $value')); ClassMirror simpleCM = reflectClass(Simple); Simple simple = simpleCM.newInstance(Symbol.empty, ['hey']) as Simple;} class Simple { Simple(a) { print('A new Simple: $a'); }} class SuperClass { int superField = 0; final int superFinalField = 1; int get superGetter => 2; set superSetter(x){ superField = x; } int superMethod(x) => 4; static int superStaticField = 5; static final int superStaticFinalField = 6; static const superStaticConstField = 7; static int get superStaticGetter => 8; static set superStaticSetter(x) { } static int superStaticMethod(x) => 10;}class ChildClass extends SuperClass { int aField = 11; final int aFinalField = 12; get aGetter => 13; set aSetter(x) { aField = x; } int aMethod(x) => 15; static int staticField = 16; static final staticFinalField = 17; static const staticConstField = 18; static int get staticGetter => 19; static set staticSetter(x) { staticField = x; } static int staticMethod(x) => 21;} 控制台输出为 Symbol(\"==\") >>> MethodMirror on '=='Symbol(\"hashCode\") >>> MethodMirror on 'hashCode'Symbol(\"toString\") >>> MethodMirror on 'toString'Symbol(\"noSuchMethod\") >>> MethodMirror on 'noSuchMethod'Symbol(\"runtimeType\") >>> MethodMirror on 'runtimeType'Symbol(\"superField\") >>> Instance of '_SyntheticAccessor'Symbol(\"superField=\") >>> Instance of '_SyntheticAccessor'Symbol(\"superFinalField\") >>> Instance of '_SyntheticAccessor'Symbol(\"superGetter\") >>> MethodMirror on 'superGetter'Symbol(\"superSetter=\") >>> MethodMirror on 'superSetter='Symbol(\"superMethod\") >>> MethodMirror on 'superMethod'Symbol(\"aField\") >>> Instance of '_SyntheticAccessor'Symbol(\"aField=\") >>> Instance of '_SyntheticAccessor'Symbol(\"aFinalField\") >>> Instance of '_SyntheticAccessor'Symbol(\"aGetter\") >>> MethodMirror on 'aGetter'Symbol(\"aSetter=\") >>> MethodMirror on 'aSetter='Symbol(\"aMethod\") >>> MethodMirror on 'aMethod'A new Simple: hey 分类在官方 API 页面可以看到所有的 Mirror 类型：dart:mirrors library。Mirror 的主要类型如下 ClassMirror：Dart 类的反射类型 InstanceMirror：Dart 实例的反射类型 ClosureMirror： 闭包的反射类型 DeclarationMirror：类属性的反射类型 IsolateMirror：Isolate 的反射类型 MethodMirror：Dart 方法（包括函数、构造函数、getter/setter 函数）的反射类型 通过dart:mirrors包内顶层函数reflecClass 获得类的“镜像”的实例，该实例的instanceMembers属性如下 Map get instanceMembers; 由控制台输出结果可以看到，对于普通字段（属性），除自身外还列出了以“=”结尾的 setter 字段，对于不提供 setter 的final字段则只出现一次。 使用staticMembers将列出所有的静态字段 cm.staticMembers.forEach((key, value) => print('$key >>> $value')); 输出如下 Symbol(\"staticField\") >>> Instance of '_SyntheticAccessor'Symbol(\"staticField=\") >>> Instance of '_SyntheticAccessor'Symbol(\"staticFinalField\") >>> Instance of '_SyntheticAccessor'Symbol(\"staticConstField\") >>> Instance of '_SyntheticAccessor'Symbol(\"staticGetter\") >>> MethodMirror on 'staticGetter'Symbol(\"staticSetter=\") >>> MethodMirror on 'staticSetter='Symbol(\"staticMethod\") >>> MethodMirror on 'staticMethod' 可以发现父类静态成员没有出现在列表中，这是因为静态属性不会被继承、不能被ChildClass调用。 SymbolSymbol表示使用 Dart 的 mirror API 反射得到的实例类型，位于dart:core包 part of dart.core;/// Opaque name used by mirrors, invocations and [Function.apply].abstract class Symbol { static const Symbol unaryMinus = const Symbol(\"unary-\"); static const Symbol empty = const Symbol(\"\"); //工厂构造方法 //也可以直接通过 Symbol s = #name; 创建 const factory Symbol(String name) = internal.Symbol; int get hashCode; bool operator ==(other);} 源码通过 ClassMirror 的源码，可以大概看出 Dart 语言关于反射的设计思想以及对外提供的 API abstract class ClassMirror implements TypeMirror, ObjectMirror { ClassMirror get superclass; //父类 ， Object的父类为null List get superinterfaces; //接口列表 bool get isAbstract; bool get isEnum; Map get declarations; //不包含父类属性和方法 Map get instanceMembers; //实例属性 Map get staticMembers; //静态属性 //如果S = A with B ,那么ClassMirror（S）.mixin 为 ClassMirror（B），否则返回本身 ClassMirror get mixin; /** * 调用构造方法 * @param constructorName 构造方法名称（默认构造方法为空字符串，命名构造方法为其命名） * @param positionalArguments 参数列表 */ InstanceMirror newInstance(Symbol constructorName, List positionalArguments, [Map namedArguments]); bool operator ==(other); bool isSubclassOf(ClassMirror other);} 影响在 Java 中，当开发者多次（10w 次以上）访问、修改某一属性时，使用反射的成本会比正常访问高很多，同时会让private修饰符失去作用。在 Dart 中，反射的影响主要在于，编译器使用tree shaking的过程确定应用真正运行时使用的代码，以减少程序的大小。但是使用反射将使tree shaking失效，因为任何代码都有可能被使用，由此严重影响应用的启动时间和内存占用。 解决👆一问题的有效方法是，通过代码生成执行反射。为了“告知”编译器使用反射的代码和方式，开发者可以使用dart:reflectable库，通过特定元数据注解反射代码。reflectable 另一个影响在于最小化，其表示对下载到 Web 浏览器的源程序进行压缩的过程。在最小化过程中，源代码使用的名称在编译代码中被压缩成了短名称。这一过程会对反射带来不良影响，因为最小化之后，原来表示声明的名称的字符串，不再对应程序中的实际名称。 为了解决这一问题， Dart 反射使用 symbol 而非字符串作为 key，symbol 会被执行最小化的程序minifier识别并使用与标识符同样的压缩方式。这也是上面的输出中出现Symbol(...)的原因。开发者也可以通过 MirrorSystem 提供的static String getName(Symbol symbol)方法获得非最小化名称字符串。 小结目前来看 Dart 还不算一门“足够完善”的语言，比如反射机制的不完全、文档教程匮乏等等，相信随着 Flutter 的发展，这门语言的发展会更加地好。关于 Dart 反射的知识全部来自 Gilad Bracha 所著《Dart 编程语言》，不知道是不是翻译的问题，写得不够明晰，看得也是一头雾水。希望有朝一日，更加掌握 Dart 的反射机制，再写一篇《Dart 反射机制详解》的文章 😄。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/tags/Dart/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/反射/"}]},{"title":"Markdown 语法详解","slug":"Markdown-语法详解","date":"2019-05-19T07:36:02.000Z","updated":"2019-06-02T07:10:48.000Z","comments":true,"path":"Markdown-语法详解/","link":"","permalink":"http://yoursite.com/Markdown-语法详解/","excerpt":"这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown 的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。","text":"这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown 的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。 关于Markdown 是一门轻量级的标记语言，由美国工程师 John Gruber 于2004年创造。这门语言的目的是让人们使用易于阅读、易于撰写的纯文字格式，并选择性地转换成有效的 XHTML（或是 HTML）。 Markdown 所谓的易读并不是指排版之后呈现的结果易读，而是指原始格式下的文件依然拥有优秀的可读性，不会像阅读原始 HTML 代码一样，满眼都是尖括号（可以通过 右键浏览器页面 -> 查看源代码 体验）。Markdown 的易写则体现在其语法足够简单，学习曲线平缓，并且在写作中基本可以脱离鼠标操作。 Markdown 的轻量级是相对于 LaTeX 来说的，这种基于 Tex 的排版系统广泛运用在高质量书籍印刷和复杂公式论文中。不过使用 Markdown 仍然可以使用一些基本的数学公式，比如$ E = mc^2 $、$ \\int_0^xf(x)dx $，单个$用于行内公式，$$用于单行公式 比如 $ E = mc^2 $、$ \\int_0^xf(x)dx $ 这需要不同平台上的 Markdown 数学公式插件的支持，本博客使用Hexo + Github Pages搭建，可以通过安装 MathJax 实现。 分类跟早期的 HTML 类似，Markdown 在发展的过程中衍生出了不同的版本，它们的基本语法上相通，但是在诸如表格、锚点、时序图等实现上出现了不一致。在关于语法规范化的讨论中，作者 John Gruber 认为，不同的网站（和人们）有不同的需求，没有一种语法可以让所有人满意。 现今 Markdown 的主要分类如下 CommonMark：由 Stack Exchange、Github、Reddit 等组织发起的标准化项目。一开始名称为Standard Markdown，由于遭到作者的反对，更名CommonMark GFM：Github Flavored Markdown，由 Github 于2017年发布，基于 CommonMark。相信很多开发者都是通过一份README.md文件认识 Markdown，这也是本博客采用的版本。 Markdown Extra：基于 PHP、Python 和 Rudy 中实现的 Markdown。 编辑器市面上优秀的 Markdown 编辑器层出不穷，这也有力推动了 Markdown 的发展。可以使用Sublime Text配合插件编辑写作，可以使用Typora等优秀的跨平台工具实现所见即所得，也可以通过 Cmd Markdown 在线书写并导出、发布。 博主使用的是Typora。 相关链接：码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点、 用 Markdown 写作用什么文本编辑器？ - 知乎 初级语法标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 三级标题四级标题五级标题六级标题 另外在 GFM 中，任意 1-6 个 # 标注的标题都会被添加上同名的锚点链接，比如# First Title会被标注成[First Title](#first-title)（注意小写转换），因此我们可以在文章的其他地方，使用标注之后的格式跳转到任何标题，比如[跳转至引言](#引言) 文字 格式 效果 *斜体1* 斜体1 _斜体2_ 斜体2 **粗体1** 粗体1 __粗体2__ 粗体2 ~~删除线~~ 删除线 ***斜粗体1*** 斜粗体1 ___斜粗体2___ 斜粗体2 ***~~斜粗体删除线1~~***、~~***斜粗体删除线2***~~ 斜粗体删除线 表情GFM 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。比如:stuck_out_tongue_winking_eye:：😜 👻 🐶 💩 🔥 🙇 😄 🚣 🍉 🏊 🍂 可以在此找到不同表情对应的符号码：Emoji cheat sheet for GitHub, Basecamp, Slack & more Hexo 默认不支持 emoji 表情，可以通过安装 hexo-filter-github-emojis 实现 分割线使用三个（或多个连续）的-、*、-实现分割线效果 ---___****** 链接链接分为文字链接和图片链接 文字链接[ReBe](https://febers.github.io \"鼠标悬停显示\")：ReBe 支持使用标识符标志地址，将真正的URL地址放在文末，比如 [Github][Github URL][Github URL]:https://github.com/Febers 效果如下: Github 图片链接基本格式为![title](url)，其中title可省略，![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067) 列表有序列表看起来并不明显 1. PHP是最好的语言？2. PHP是最好的语言！ PHP是最好的语言？ PHP是最好的语言！ 无序列表可以使用-、*、+开头接空格，但在多级列表中最好使用- - PHP是最好的语言？* PHP是最好的语言。+ PHP是最好的语言！ - 毫无疑问 - 众所周知 PHP是最好的语言？ PHP是最好的语言。 PHP是最好的语言！ 毫无疑问 众所周知 复选框列表- [x] 大一- [x] 大二- [ ] 大三- [ ] 大四 [x] 大一 [x] 大二 [ ] 大三 [ ] 大四 Hexo 默认的渲染引擎 Marked 不支持 TODO list，可以更换为 markdown-it，之后实现的效果如 Typora 预览 引用与高亮引用使用>实现引用，多个>实现引用层级 > PHP>> 是>>> 最好的>>>> 语言 PHP 是 最好的 语言 一般用在引用原文内容中 一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！”黛玉纳罕道：“这些人个个皆敛声屏气，恭肃严整如此，这来者系谁，这样放诞无礼？”心下想时，只见一群媳妇丫鬟围拥着一个人从后房门进来。这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子：头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗；项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩；身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂；下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未起笑先闻。黛玉连忙起身接见。 居中Markdown 中标准引用是 > 符号后面加上引用内容，可以嵌套，或者搭配其他 Markdown 语法结合一起使用。但样式未免单一，不够美观，可以直接使用 HTML 语言插入，如下，使用 class=\"blockquote-center\" 勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。 鲁迅 勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。 鲁迅 也可以使用标签的方式centerquote（或者其别名cq） {% centerquote %}盛年不重来，一日难再晨。及时当勉励，岁月不待人。陶渊明 {% endcenterquote %} 该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用 Note使用前端框架 Bootstrap Callout 的语法，Hexo 提供了对其的支持，Content 可以搭配 Markdown 语法 {% note class_name %} Content (md partial supported) {% endnote %}{% note default %} This is a default note {% endnote %}{% note primary %} This is a primary note {% endnote %}{% note success %} This is a success note {% endnote %}{% note info %} This is a info note {% endnote %}{% note warning %} This is a warning note {% endnote %}{% note danger %} This is a danger note {% endnote %} 实现类似笔记的引用效果，其中class_name可以为 default primary success info warning danger 该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用 高亮使用单个反引号实现单行文本高亮，三个反引号实现代码块高亮。可以在第一个三反引号后添加语言名称实现不同的语法高亮 PHP是`最好的`语言 PHP是最好的语言 fun main(args: Array) { print(\"hello\")} 高级进阶在不同的 Markdown 版本中实现可能不同 表格| 序号 | 列名1 | 列名2 || - | - | - || 0 | 一一 | 一二 || 1 | 二一 | 二二 | 序号 列名1 列名2 0 一一 一二 1 二一 二二 在分隔行（第二行）中的-右边添加:，表格内容实现右对齐效果，两边都加则为居中对齐，默认为左对齐 | 序号 | 列名1 | 列名2 || :-: | :-: | :-: || 0 | 一一 | 一二 | 序号 列名1 列名2 0 一一 一二 流程图分为两部分，第一部分定义元素，第二部分定义元素走向。定义元素语法为tag=>type: content:>url，其中tag为元素名称，type为元素类型，有以下6种 type 含义 start 开始 end 结束 operation 操作 subroutine 子程序 condition 条件 inputoutput 输入或输出 content为在流程图方框中显示的内容 st=>start: 开始:>https://www.markdown-syntax.comio=>inputoutput: 输入或输出op=>operation: 操作cond=>condition: Yes or No?sub=>subroutine: 子程序e=>end: 结束st->io->op->condcond(yes)->econd(no)->sub->io Hexo 原生并不支持流程图，需要安装hexo-filter-flowchart 时序图title为时序图标题，participant定义时序图对象，note定义时序图中的说明，有三种方位控制 left of, 表示说明位于当前对象的左侧 right of, 表示说明位于当前对象的右侧 over, 表示说明覆盖在当前对象（们）上 不同对象之间使用箭头控制指向 ->：实线实箭头 –>：虚线实箭头 ->>：实线虚箭头 –>>：虚线虚箭头 title: 时序图标题participant 大一participant 大二participant 大三note left of 大一: 大一好好学习note over 大二: 大二课程很多note right of 大三: 大三面临毕业大一->大一:大一留级大一->大二:大一迟早要到大二大二-->大三:大二不一定能升大三大二->>大三:大二不一定能升大三大三-->>大一:大三也可能回炉重造 Hexo 默认同样不支持时序图，使用 hexo-filter-sequence。具体的做法参考 为 Hexo 增加时序图解析功能 字符转义由于 Markdown 最终会渲染成 HTML 页面，所以一些特殊字符需要遵循 HTML 的转义规则，转义成实体字符才能显示，传送门：HTML 转义字符。以下图表中为了显示空格的实体多添加了一个空格 显示结果 描述 实体名称 实体编号 空格 &n bsp; &# 160; 大于号 &g t; &# 62; & 和号 &a mp; &# 38; “ 引号 &q uot; &# 34; ‘ 撇号 &a pos; (IE不支持) &# 39; st=>start: 开始:>https://www.markdown-syntax.com io=>inputoutput: 输入或输出 op=>operation: 操作 cond=>condition: Yes or No? sub=>subroutine: 子程序 e=>end: 结束 st->io->op->cond cond(yes)->e cond(no)->sub->io{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);title: 大学生活 participant 大一 participant 大二 participant 大三 note left of 大一: 大一好好学习 note over 大二: 大二课程很多 note right of 大三: 大三面临毕业 大一->大一:大一惨遭留级 大一->大二:大一迟早要到大二 大二-->大三:大二不一定能升大三 大二->>大三:大二不一定能升大三 大三-->>大一:大三也可能回炉重造{\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"利用反射实现 DrawerLayout 全屏滑动","slug":"利用反射实现-DrawerLayout-全屏滑动","date":"2019-05-06T04:58:30.000Z","updated":"2019-06-02T05:04:54.000Z","comments":true,"path":"利用反射实现-DrawerLayout-全屏滑动/","link":"","permalink":"http://yoursite.com/利用反射实现-DrawerLayout-全屏滑动/","excerpt":"在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。","text":"在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。 DrawerLayout 侧滑在 DrawerLayout 中定义了两个变量，分别对应 Gravity 为 Left 和 Right 的滑动情景，两者并无实质分别，本文只分析 Left 的情况。此外，DrawerLayout 包含三种状态，STATE_IDLE（已打开或已关闭），STATE_DRAGGING（正在拖动），STATE_SETTLING（执行打开或关闭的动画过程中）。 private final ViewDragHelper mLeftDragger;private final ViewDragHelper mRightDragger; 构造函数对一些变量做了初始化 mLeftCallback = new ViewDragCallback(Gravity.LEFT);mLeftDragger = ViewDragHelper.create(this, TOUCH_SLOP_SENSITIVITY, mLeftCallback);mLeftDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);mLeftDragger.setMinVelocity(minVel);mLeftCallback.setDragger(mLeftDragger); ViewDraghelper 是官方提供的专门为自定义 ViewGroup 处理拖拽的手势类。此处用到的构造方法为 public static ViewDragHelper create(@NonNull ViewGroup forParent, float sensitivity, @NonNull Callback cb) DrawerLayout 中侧滑打开界面正是通过 ViewDragHelper 实现的，查看 DrawerLayout 的onTouchEvent方法 @Overridepublic boolean onTouchEvent(MotionEvent ev) { mLeftDragger.processTouchEvent(ev); mRightDragger.processTouchEvent(ev); final int action = ev.getAction(); boolean wantTouchEvents = true; switch (action & MotionEvent.ACTION_MASK) { ...... } return wantTouchEvents;} 其明显调用了 ViewDragHelper 的processTouchEvent方法处理 Touch 事件 public void processTouchEvent(MotionEvent ev) { ...... switch (action) { case MotionEvent.ACTION_DOWN: { final float x = ev.getX(); final float y = ev.getY(); final int pointerId = ev.getPointerId(0); //找到当前触摸点的最顶层的子View,作为需要操作的View final View toCapture = findTopChildUnder((int) x, (int) y); //保存当前Touch点发生的初始状态 saveInitialMotion(x, y, pointerId); //这里是点在一个正在滑动的侧滑栏上，使侧滑栏的状态由正在滑动状态变为正在拖动状态 tryCaptureViewForDrag(toCapture, pointerId); //处理侧滑栏的触摸触发区域是否触摸，如果触摸则通知回调，在DrawerLayout中处理，执行一个侧滑微弹的操作，也就是稍微弹出一点，表示触发了侧滑操作 final int edgesTouched = mInitialEdgesTouched[pointerId]; if ((edgesTouched & mTrackingEdges) != 0) { mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId); } break; } ......} 重点在mInitialEdgesTouched[pointerId]，其为一个保存边缘滑动值的 int 数组。在saveInitialMotion方法中发现其赋值过程 private void saveInitialMotion(float x, float y, int pointerId) { ensureMotionHistorySizeForId(pointerId); mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x; mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y; mInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y); mPointersDown |= 1 mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT; if (y > mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM; return result;} 可以看到，该方法将判断x < mParentView.get*() + mEdgeSize，然后将对应的 result 返回。mEdgeSize即为边缘滑动的临界值，其初始化值为 final float density = context.getResources().getDisplayMetrics().density;mEdgeSize = (int) (EDGE_SIZE * density + 0.5f); 因此，要让 DrawerLayout 支持全屏滑动打开侧滑菜单而不是边缘滑动，重点便是要修改该值，将其设为屏幕宽度。 具体的反射代码（kotlin） //获取 ViewDragHelper，更改 edgeSizeFieldval leftDraggerField = drawerLayout.javaClass.getDeclaredField(\"mLeftDragger\")leftDraggerField.isAccessible = trueval leftDragger = leftDraggerField.get(drawerLayout) as ViewDragHelperval edgeSizeField = leftDragger.javaClass.getDeclaredField(\"mEdgeSize\")edgeSizeField.isAccessible = trueval edgeSize = edgeSizeField.getInt(leftDragger)val displaySize = Point()activity.windowManager.defaultDisplay.getSize(displaySize)edgeSizeField.setInt(leftDragger, displaySize.x) DrawerLayout 长按弹出引言 在 DrawerLayout 中，用户在非侧滑界面的 mEdgeSize 范围内长按，侧滑界面将弹出。当我们修改 mEdgeSize 为屏幕宽度之后，用户所有的长按动作都将触发原来的弹出逻辑，而且触发范围为屏幕宽度，侧滑菜单将过度右移，造成左侧边缘有空白。 原来是 DrawerLayout 的私有内部类 ViewDragCallback 重写了onEdgeTouched方法 private class ViewDragCallback extends ViewDragHelper.Callback @Overridepublic void onEdgeTouched(int edgeFlags, int pointerId) { postDelayed(mPeekRunnable, PEEK_DELAY);} 该方法会执行一个 mPeekRunnable，其为内部类的私有 Runnable 类型的属性，其run方法执行了peekDrawer方法 void peekDrawer() { final View toCapture; final int childLeft; final int peekDistance = mDragger.getEdgeSize(); final boolean leftEdge = mAbsGravity == Gravity.LEFT; if (leftEdge) { toCapture = findDrawerWithGravity(Gravity.LEFT); childLeft = (toCapture != null ? -toCapture.getWidth() : 0) + peekDistance; } else { toCapture = findDrawerWithGravity(Gravity.RIGHT); childLeft = getWidth() - peekDistance; } // Only peek if it would mean making the drawer more visible and the drawer isn't locked if (toCapture != null && ((leftEdge && toCapture.getLeft() < childLeft) || (!leftEdge && toCapture.getLeft() > childLeft)) && getDrawerLockMode(toCapture) == LOCK_MODE_UNLOCKED) { final LayoutParams lp = (LayoutParams) toCapture.getLayoutParams(); mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop()); lp.isPeeking = true; invalidate(); closeOtherDrawer(); cancelChildViewTouch(); }} 注意mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop())就是长按屏幕时，侧滑菜单会自动滑出来的原因。 解决这个问题着实费了一番脑筋，因为 ViewDragCallback 为私有内部类，外部无法直接得到其引用。幸好观察之后发现其实现了 ViewDragHelper.Callback 接口，从而让我们可以利用多态的方式，获取其反射实例 //获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”//更改其属性 mPeekRunnableval leftCallbackField = drawerLayout.javaClass.getDeclaredField(\"mLeftCallback\")leftCallbackField.isAccessible = true//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例val leftCallback = leftCallbackField.get(drawerLayout) as ViewDragHelper.Callbackval peekRunnableField = leftCallback.javaClass.getDeclaredField(\"mPeekRunnable\")peekRunnableField.isAccessible = trueval nullRunnable = Runnable { }peekRunnableField.set(leftCallback, nullRunnable) 完美解决问题！ 最后便是构建一个工具类 object DrawerLayoutHelper { /** * 通过反射的方式将 DrawerLayout 的侧滑范围设为全屏 * 该方法存在一个问题，在侧滑范围内长按，也会划出菜单 * 通过查看 DrawerLayout 的源码分析，其内部类 ViewDragCallback * 重写了 onEdgeTouched 方法，然后调用一个 Runnable 属性的变量 “mPeekRunnable” * 该变量调用了 peekDraw 方法，实现了长按划出侧滑菜单的功能 * 同样使用反射将该 Runnable 更改为空实现 * * @param activity * @param drawerLayout * @param displayWidthPercentage */ fun setDrawerLeftEdgeSize(activity: Activity?, drawerLayout: DrawerLayout?, displayWidthPercentage: Float) { if (activity == null || drawerLayout == null) return try { //获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小 val leftDraggerField = drawerLayout.javaClass.getDeclaredField(\"mLeftDragger\") leftDraggerField.isAccessible = true val leftDragger = leftDraggerField.get(drawerLayout) as ViewDragHelper val edgeSizeField = leftDragger.javaClass.getDeclaredField(\"mEdgeSize\") edgeSizeField.isAccessible = true val edgeSize = edgeSizeField.getInt(leftDragger) val displaySize = Point() activity.windowManager.defaultDisplay.getSize(displaySize) edgeSizeField.setInt(leftDragger, Math.max(edgeSize, (displaySize.x * displayWidthPercentage).toInt())) //获取 Layout 的 ViewDragCallBack 实例“mLeftCallback” //更改其属性 mPeekRunnable val leftCallbackField = drawerLayout.javaClass.getDeclaredField(\"mLeftCallback\") leftCallbackField.isAccessible = true //因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例 val leftCallback = leftCallbackField.get(drawerLayout) as ViewDragHelper.Callback val peekRunnableField = leftCallback.javaClass.getDeclaredField(\"mPeekRunnable\") peekRunnableField.isAccessible = true val nullRunnable = Runnable { } peekRunnableField.set(leftCallback, nullRunnable) } catch (e: Exception) { e.printStackTrace() } } fun setDrawerLeftEdgeFullScreen(activity: Activity?, drawerLayout: DrawerLayout?) { setDrawerLeftEdgeSize(activity, drawerLayout, 1.0f) }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/反射/"}]},{"title":"Android 自定义 View 详解","slug":"Android-自定义-View-详解","date":"2019-05-03T10:34:00.000Z","updated":"2019-06-02T04:54:56.000Z","comments":true,"path":"Android-自定义-View-详解/","link":"","permalink":"http://yoursite.com/Android-自定义-View-详解/","excerpt":"开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。","text":"开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。 CanvasPaint自定义 View自定义 ViewGroup document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"Dart 异步编程","slug":"Dart-异步编程","date":"2019-04-30T00:21:26.000Z","updated":"2019-06-02T04:55:30.000Z","comments":true,"path":"Dart-异步编程/","link":"","permalink":"http://yoursite.com/Dart-异步编程/","excerpt":"Dart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。","text":"Dart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。 事件循环作为一个事件驱动语言，Dart 同样拥有事件循环（Event Loop，类似于 Android 中的Looper/Handler）。Dart 有两个队列，一个是微任务队列（MicroTask Queue），一个是事件队列（Event Queue） 微任务队列包含 Dart 内部的微任务，主要通过scheduleMicrotask调度 事件队列包含外部事件，如 I/O、Timer、绘制事件等 从上图可以看出，Dart 处理事件循环的逻辑 首先处理所有微任务队列里的微任务 处理完所有微任务之后，处理事件队列里的一个事件 回到微任务队列继续循环 对于微任务队列，一次性全部处理，对于事件队列，一次只处理一个。 微任务和事件微任务dart:async定义了一个顶级函数scheduleMicrotask，使用其让代码以微任务的方式异步执行 import 'dart:async'; //下文不再显式导入void main() { print('开始'); scheduleMicrotask(() { print('这是一个微任务'); }); print(\"结束\");} 控制台输出 开始结束这是一个微任务 事件使用Timer.run(callback)让代码以事件的方式异步执行 void main() { print('开始'); Timer.run(() { print('这是一个事件'); }); scheduleMicrotask((){ print('这是微任务0'); }); scheduleMicrotask((){ print('这是微任务1'); }); scheduleMicrotask((){ print('这是微任务2'); }); print(\"结束\");} 控制台输出 开始结束这是微任务0这是微任务1这是微任务2这是一个事件 同时可以看出和 Java 使用new Thread（Runnable r）不同，在 Dart 中，微任务的执行顺序是有序的。 考虑下面的代码，会输出这是一个事件吗？ Timer.run(() { print('这是一个事件');});foo() { scheduleMicrotask(foo);}foo(); 根据上面 Dart 处理事件循环的逻辑图，Timer.run永远不会被执行，因为scheduleMicrotask永远在执行。 仅仅使用回调函数实现异步很容易陷入“回调地狱（Callback hell）”，为此 Dart 引入了Future FutureFuture 封装了一系列静态函数完成异步操作，其内部通过scheduleMicrotask和Timer实现。此外还有一个then方法，接收一个名为onValue的闭包作为参数，该闭包在 Future 成功完成时被调用 函数 用途 Future(FutureOr computation()) 创建事件任务 microtask(FutureOr computation()) 创建microtask任务 sync(FutureOr computation()) 创建同步任务 delayed(Duration duration, [FutureOr computation()]) 创建延迟任务 通过代码理解 void main() { print('开始'); Timer.run(() => print('这是一个事件')); scheduleMicrotask((){print('这是微任务0');}); scheduleMicrotask((){print('这是微任务1');}); scheduleMicrotask((){print('这是微任务2');}); print(\"结束\"); Future(() => print('普通Future，通过Timer实现')); Future.delayed(const Duration(seconds: 2), () => print('延迟Future，通过Timer实现')); Future.microtask(() => print('Future创建微任务，通过scheduleMicrotask实现')); Future.sync(() => print('同步Future，执行同步代码')) .then((a) => print('then中的代码0')) .then((b) => print('then中的代码1')) .then((c) { throw '抛出then中的错误'; }) .catchError((error) => print('捕获Error $error')) .whenComplete(() {print('then任务完成');});} 输出结果 开始结束同步Future，执行同步代码这是微任务0这是微任务1这是微任务2Future创建微任务，通过scheduleMicrotask实现then中的代码0then中的代码1捕获Error 抛出then中的错误then任务完成这是一个事件普通Future，通过Timer实现 //延迟2s 延迟Future，通过Timer实现 在dart:async中，除了 Future，还有 Completer，用来将具体的 Future 流程控制权交给开发者 var completer = Completer();var future = completer.future;future.then((d) => '返回的字符串') .then((e) => print('获得Completer中的future $e'));completer.complete((e) => print('设为完成状态')); 控制台输出 获得Completer中的future 返回的字符串 虽然 Future 缓解了回调地狱的问题，但如果串太多的then代码，可读性仍然会非常差，特别是各种 Future 嵌套的时候。与 JavaScript 类似，Dart 引入了async/await。 async 和 awaitasync 关键字修饰的函数与传统函数并无区别，只是将返回值类型使用 Future 进行了封装。 通过代码具体理解 void main() async { getInt().then((i) => print('getInt: $i')); getString().then((s) => print('getString: $s')); print('main');}getInt() async => 2333;getString() async => 'hello'; 控制台输出 maingetInt: 2333getString: hello 可以看到，调用async方法的代码转换成了异步任务。要想使之变成同步顺序，使用await关键字。不过需要注意的是，该关键字必须要在async函数中使用 void main() async { var i = await getInt(); print('getInt: $i'); var s = await getString(); print('getString: $s'); print('main');} 控制台输出 getInt: 2333getString: hellomain 继续下面的例子 void main() { print('main 0'); foo(); print('main 1');}foo() async { print('Foo'); var s = await bar(); print('from bar: $s');}bar() { print('Bar'); return 'hello';} 控制台输出为 main 0FooBarmain 1from bar: hello 也就是说，在foo中，除了第一行代码以及bar()这一函数调用之外的其他代码均为异步执行。当使用await的时候，其右边会马上返回一个 Future 对象，下面的代码则会以then的形式运行。 上面的代码转换成 Future 风格 foo() { print('Foo'); return Future.sync(bar).then((s) => print('from bar: $s'));} Generatorstreamstream 是 Dart 中一个长度不确定的值列表，可以是有限的或者无限的，重要的是我们不知道 stream 何时结束或已经结束。随时间改变的鼠标位置、所有素数的列表或者网络上的视频流，都可以看做一个 stream。 可以通过为 stream 注册一个或多个回调函数的方式，对其进行订阅监听。 yieldyield 语句被用于生成器函数内，目的是给生成的集合添加新的结果。yield 语句总是使它的表达式被求值，通常情况下，求值结果会被追加到外层生成器所关联的集合中。如果生成器是同步的，则关联的集合是一个 iterable；如果是异步的，则关联的集合是一个 stream。 此外，yield 也会因外层的生成器是否同步产生不同的行为：同步时 yield 会暂停外层生成器，直至调用moveNext且返回值为 true，异步时生成器的执行会继续。 异步一个函数体标记有async*修饰符的函数，将作为 stream 的生成函数。下面的函数生成一个包含自然数序列的 stream get naturals async* { int k = 0; while (k < 3) { yield await k++; }}void main() async { await for (var i in naturals) { print('get a natural $i'); }} 运行main函数，控制台将输出 get a natural 0get a natural 1get a natural 2 当 naturals 被调用时，立即返回一个新的 stream，一旦 stream 被监听，函数体将运行，以便生成值来填充 stream。每一次迭代执行一次 yield 语句，k 将自增（由于 await 的存在，函数会有短暂停止），然后函数将继续执行并使用新的 k 值，该值将被 yield 追加到 stream 中。 同步上述函数的同步形式 Iterable naturalsTo(n) sync* { int k = 0; while(k < n) { yield k++; }} 通过一个混合编程的例子来体会两者的区别 Iterable nSync(n) sync* { int k = 0; while (k < n) { print('sync before k++ and k is $k'); yield k++; print('sync after k++ and k is $k'); }}Stream nAsync(n) async* { int k = 0; while (k < n) { print('async before k++ and k is $k'); yield await k++; print('async after k++ and k is $k'); }}void main() { nAsync(2).last; nSync(2).last; print('main');} 控制台输出为 sync before k++ and k is 0sync after k++ and k is 1sync before k++ and k is 1sync after k++ and k is 2mainasync before k++ and k is 0async after k++ and k is 1async before k++ and k is 1async after k++ and k is 2 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/tags/Dart/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"}]},{"title":"《红楼梦》读书笔记","slug":"《红楼梦》读书笔记","date":"2019-04-24T03:35:40.000Z","updated":"2019-06-02T13:45:52.000Z","comments":true,"path":"《红楼梦》读书笔记/","link":"","permalink":"http://yoursite.com/《红楼梦》读书笔记/","excerpt":"完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促，不过更新周期可能会异常的漫长。","text":"完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促，不过更新周期可能会异常的漫长。 第一回 甄士隐梦幻识通灵 贾雨村风尘怀闺秀缘起 曾历过一番梦幻之后，故将真事隐去，而借通灵说此《石头记》一书也，故曰“甄士隐”云云。 “….我虽不学无文，又何妨用假语村言敷演出来？亦可使闺阁昭传。复可破一时之闷，醒同人之目，不亦宜乎？”故曰“贾雨村”云云。 女娲补天所用三万六千五百零一块石头剩一块通灵，被一道人镌刻文字于其上，名《石头记》 上面述着堕落之乡、投胎之处，以及家庭琐事、闺阁闲情、诗词谜语，倒还全备 后所记录被空空道人所抄写，改《情僧录》，东鲁孔梅溪题《风月宝鉴》，曹雪芹于悼红轩批阅增删、分目录章节，题曰《金陵十二衩》，此为《石头记》缘起。曹雪芹题诗 满纸荒唐言，一把辛酸泪。 都云作者痴，水解其中味！ 开篇姑苏城仁青巷中有一乡宦甄士隐，梦中忽逢一僧一道了结灵石公案。原来那石头各地游玩，入警幻仙子麾下，任赤霞宫神瑛侍者。因以甘露灌溉西方灵河绛珠草，结下姻缘。绛珠草为感谢雨露之惠，欲“还泪”解缘。一僧一道携一众风流冤家下凡。三人行至“太虚幻境”，两边有一对联 假作真时真亦假 无为有处有还无 甄士隐与附近葫芦庙穷儒贾雨村交好。中秋佳节两人畅饮，甄士隐资助贾雨村进京赶考后，独女英莲走失，家院因火灾烧成瓦砾，投靠岳父封肃遭受白眼非议。一日碰一跛足道人，听道人语有感 金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧？训有方，保不定日后做强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛。昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。故荒唐，到头来都是“为他人作嫁衣裳”。 便于道人飘飘而去。 第二回 贾夫人仙逝扬州城 冷子兴演说荣国府贾雨村受甄士隐赠银、进京赶考，中了进士，升任本县太爷，遣人至封府答谢甄士隐，同时将当年在甄士隐家中回首相顾的丫头娇杏娶作二房。然其恃才贪腐，不到一年便被革职，于是前往各地游览。 游至维扬时，入当朝盐政官林如海府中给其幼女林黛玉作西席。林如海年过五十，黛玉为嫡妻贾氏所生，聪明俊秀但体弱多病，其母一病身亡，需守丧尽礼，旧病复发。贾雨村便闲居无聊。 一日贾雨村郊外村肆中偶遇旧友冷子兴，二人聊起荣、宁两府。宁国公与荣国公是一母同胞兄弟。宁国公贾演生有两子，长子贾代化同有两子，稍长之子贾敷早死，次子贾敬袭官，然而一味好道终日炼丹。贾敬有一子贾珍，生下一子名贾蓉。荣国公贾源的长子贾代善在其去世后袭官，娶金陵世家史侯的小姐为妻，生有两子，长子贾赦袭官，次子贾政任员外郎。贾政夫人王氏生下二胎女儿十几年后，竟又生一嘴衔五彩晶玉的男孩，其名贾宝玉。 贾宝玉抓阄时只取脂粉钗环，引得贾政不喜。如今十来岁，淘气异常，聪明乖觉，自言 女儿是水做的骨肉，男子是泥做的骨肉。我见了女儿便清爽，建了男子便觉浊臭逼人。 必得两个女儿陪着我读书，我方能认得字，心上也明白，不然我心里自己糊涂 这女儿两个字极尊贵极清静的，比那瑞兽珍禽、奇花异草更觉稀罕尊贵 贾雨村道天下运隆，清明灵秀之气比比皆是，与那残忍乖邪之气搏击掀发。邪气附于人，上则不能为仁人君子、下亦不能为大凶大恶，正所谓“成则公侯败则贼”。复感慨其必不能守祖父基业、从师友规劝。 贾政长女因正月初一出生，故名元春、贤孝才德，入宫作女史官；二女名迎春，三女名探春，四女名惜春，俱在祖母身边读书。林如海其妻、林黛玉其母名贾敏，原来是贾赦、贾政胞妹。贾赦有一子稍长于宝玉，名贾琏，娶了贾政夫人王氏的侄女，模样极标志、言谈又爽利、心机又极深细，正是王熙凤。 第三回 托内兄如海荐西宾 接外孙贾母惜孤女都中（一说南京）要起复旧员，林如海为贾雨村写荐书投身贾政，恰巧林黛玉祖母念其无人依傍，派遣船只接其入贾府，两人便一同进京。 黛玉弃舟登岸后，有轿子伺候，行半日见一大门，有匾敕造宁国府，往西不远一大门，正是荣国府。贾母一见黛玉，搂入怀中，“心肝儿肉”叫着大哭，旁人无不下泪。不一时有三位姑娘前来接客，正是迎、探、惜春三姐妹 第一个肌肤微丰，身材合中，腮凝新荔，鼻腻鹅脂，温柔沉默，观之可亲。第二个削肩细腰，长挑身材，鸭蛋脸儿，俊眼修眉，顾盼神飞，文彩精华，见之忘俗。第三个身量未足，形容尚小。其钗环裙袄，三人皆是一样的妆束。 黛玉谈起自己的病患，言其三岁时有一癞头和尚要其出家，父母不从，和尚便说 既舍不得他，但只怕他的病一生也不能好的！若要好时，除非从此以后总不许见哭声…方可平安了此一生 此时后院中有笑语声，“我来迟了，没得迎接远客！”黛玉思忖旁人皆敛声屏气，唯独此人放诞无礼。来者正是王熙凤 彩绣辉煌，恍若神妃仙子。头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗，项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩，身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂，下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未启笑先闻 相互打过招呼，王熙凤笑道，“天下竟有这样标致人儿！我今日才算看见了！”又交代好贾府上下事务。 黛玉在丫鬟嬷嬷带领下拜见王夫人，用膳饮茶，正巧宝玉归来由寺庙还原归来 头上戴着束发嵌宝紫金冠，齐眉勒着二龙抢珠金抹额，穿一件二色金百蝶穿花大红箭袖，束着五彩丝攒花结长穗宫绦，外罩石青起花八团倭锻排穗褂，登着青缎粉底小朝靴。面若中秋之月，色如春晓之花，鬓若刀裁，眉如墨画，面如桃瓣，目若秋波。虽怒时而若笑，即瞋视而有情。项上金螭璎珞，又有一根五色丝绦，系着一块美玉 黛玉心惊，“好生奇怪，倒像在那里见过的，何等眼熟！”宝玉见过其母，又换一身行头 身上穿着银红撒花半旧大袄，仍旧带着项圈、宝玉、寄名锁、护身符等物，下面半露松绿撒花绫裤，锦边弹墨袜，厚底大红鞋。越显得面如傅粉，唇若施脂，转盼多情，语言若笑。天然一段风韵，全在眉梢；平生万种情思，悉堆眼角 有词曰 无故寻愁觅恨，有时似傻如狂。纵然生得好皮囊，腹内原来草莽。 潦倒不通庶务，愚顽怕读文章。行为偏僻性乖张，那管世人诽谤！ 富贵不知乐业，贫穷难耐凄凉。可怜辜负好时光，于国于家无望。 天下无能第一，古今不肖无双。寄言纨绔与膏粱：莫效此儿形状！ 宝玉见了黛玉，细看形容，与众各别 两弯似蹙非蹙罥烟眉，一双似喜非喜含情目。态生两靥之愁，娇袭一身之病。泪光点点，娇喘微微。闲静时如姣花照水，行动处似弱柳扶风。心较比干多一窍，病如西子胜三分。 看罢笑道：“这个妹妹我曾见过的。”又问黛玉是否有玉，黛玉答无，发起痴狂，便欲摔玉。 黛玉安置于贾府碧纱橱，身旁有奶娘王嬷嬷、随身丫头雪雁、鹦哥，外又有宝玉乳母李嬷嬷、大丫鬟袭人服侍。袭人本名花珍珠，贾母溺爱宝玉，便令心地纯良、恪尽职守的袭人侍奉宝玉。宝玉曾见诗云“花气袭人”，便命其改名。 次日贾府收到金陵书信，说是城中所居薛家姨母之子薛蟠，倚财仗势，闹出了人命。 第四回 薄命女偏逢薄命郎 葫芦僧乱判葫芦案 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"文学","slug":"文学","permalink":"http://yoursite.com/categories/文学/"}],"tags":[{"name":"文学","slug":"文学","permalink":"http://yoursite.com/tags/文学/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"红楼梦","slug":"红楼梦","permalink":"http://yoursite.com/tags/红楼梦/"}]},{"title":"Dart 面向对象","slug":"Dart-面向对象","date":"2019-04-23T01:10:53.000Z","updated":"2019-06-02T04:55:22.000Z","comments":true,"path":"Dart-面向对象/","link":"","permalink":"http://yoursite.com/Dart-面向对象/","excerpt":"作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。","text":"作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。 定义使用 class 关键字定义一个类。与 Java 类似，如果没有显示地定义构造函数，会默认一个无参构造函数。使用 new 关键字和构造函数来创建对象。 class Point { num x; num y; num z;}void main() { var point = new Point(); print(point.hasCode);//未定义父类的时候，默认继承自Object} 构造函数可以在构造函数的参数前加 this 关键字直接赋值 class Point { num x; num y; num z; //第一个值传递给this.x，第二个值传递给this.y Point(this.x, this.y, z) { this.z = z; } //命名构造函数，格式为Class.name(var param) Point.fromeList(var list): x = list[0], y = list[1], z = list[2]{ //使用冒号初始化变量 } //当然，上面也可以简写为： //Point.fromeList(var list):this(list[0], list[1], list[2]); String toString() => 'x:$x y:$y z:$z';}//调用父类的构造方法class ColorPoint extends Point { String color; ColorPoint.fromXYZAndColor(num x, num y, num z, String color) : super.fromXYZ(x, y, z) { this.color = color; print('ColorPoint'); }}void main() { var p1 = new Point(1, 2, 3); var p2 = new Point.fromeList([1, 2, 3]); print(p1); //默认调用toString()函数} 需要创建不可变对象的话，可以在构造函数前使用const关键字定义编译时常量对象 class ImmutablePoint { final num x; final num y; const ImmutablePoint(this.x, this.y); // 常量构造函数 static final ImmutablePoint origin = const ImmutablePoint(0, 0); // 创建一个常量对象不能用new，要用const} 工厂构造函数Dart 中一种获取单例对象的方式，使用工厂模式来定义构造函数。对于调用者来说，仍然使用 new 关键字来获取对象，具体的实现细节对外隐藏。 class Logger { final String name; bool mute = false; // 变量前加下划线表示私有属性 static final Map _cache = {}; factory Logger(String name) { if (_cache.containsKey(name)) { return _cache[name]; } else { final logger = new Logger._internal(name); _cache[name] = logger; return logger; } } Logger._internal(this.name); void log(String msg) { if (!mute) { print('$name: $msg'); } } } var logger = new Logger('UI'); logger.log('Button clicked'); Getter / Setter用来读写对象的属性，每个属性都对应一个隐式的 Getter 和 Setter，通过obj.x调用。类似于 Kotlin，可以使用get、set关键字拓展相应的功能。如果属性为final或者const，则只有对外的 Getter。 class Rectangle { num left; num top; num width; num height; Rectangle(this.left, this.top, this.width, this.height); // right 和 bottom 两个属性的计算方法 num get right => left + width; set right(num value) => left = value - width; num get bottom => top + height; set bottom(num value) => top = value - height;}void main() { var rect = new Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8);} 类方法实例方法跟 Java 类似，抽象方法有所不同，不需要使用abstract显示定义，只需要在方法签名后用;来代替方法体即表示其为一抽象方法，Dart 中非抽象类也可以定义抽象方法。 abstract class Bird { void fly();}class Sparrow extends Bird { void fly() { } void sleep();} 继承在 Dart 中没有“接口”这一概念，类分为抽象类和非抽象类，唯一的区别是后者不可直接实例化。Dart 中仍然使用了implements和extends关键字，不过两者有所不同 implements 代表实现，子类无法访问父类的参数，可以实现多个类 extends 代表继承，可继承父类的非私有变量，使用单继承机制 在构造函数体前使用 super关键字调用父类构造函数，使用@override来注解复写父类的方法。 Mixin 继承机制继承歧义在了解该机制之前先认识“继承歧义”，也叫“菱形问题”。当两个类 B 和 C 继承自 A，D类继承自 B 和 C 时将产生歧义。当 A 中有一个方法在 B 和 C 中已经重写，而 D 没有 重写，那么 D 继承的方法的版本是 B 还是 C？ 不同的编程语言有不同的方法处理该问题 语言 解决方案 C++ 需要显式地声明要使用的特性是从哪个父类调用的(如：Worker::Human.Age)。C++不支持显式的重复继承，因为无法限定要使用哪个父类 Java 8 Java 8 在接口上引入默认方法。如果A、B、C是接口，B、C可以为A的抽象方法提供不同的实现，从而导致菱形问题。D类必须重新实现该方法，否则发生编译错误。（Java 8 之前不支持多重继承、没有默认方法） Dart 使用 Mixin 机制解决该方法，或者写作“mix-in（混入）”更容易理解。 Mixin在 Java8 之前，由于单继承机制以及接口没有默认方法，避免了继承歧义，而 Dart 虽然也使用了单继承机制，但是没有interface这一概念 —— 实际上，Dart 中的每一个类都可以被implements —— 所以使用了基于线性逻辑的Mixin解决该问题。 Mixin即为混入：Mixins are a way of reusing a class’s code in multiple class hierarchies。 通过一个例子理解 class A { var s = 'A'; get() => 'A';}class B { var s = 'B'; get() => 'B';}class P { var s = 'P'; get() => 'P';}class AB extends P with A, B { var s = 'AB';}class BA extends P with B, A {}void main() { AB ab = AB(); print(ab.get()); print(ab.s); BA ba = BA(); print(ba.get());} 控制台输出为： BABA 这是因为下面的代码 class AB extends P with A, B {}class BA extends P with B, A {} 相当于 class PA = P with A;class PAB = PA with B;class AB extends PAB {}class PB = P with B;class PBA = PB with A;class BA extends PBA {} 继承图如下 有意思的是，当我们将上面的代码中的with换成implements时，输出的结果将为 PABP extends、with、implements在 Dart 中，类声明必须严格按照 extends -> with -> implements 的顺序 extends 的用法类似于 Java，唯一的不同在于子类可以完全访问父类的属性和函数，因为在 Dart 中并没有私有、公有的概念，下划线_的仅仅是一种约定。 除了上面的内容，with还可以与之搭配关键字on，表示要进行 mixin 的类必须先 “implements” 被 mixin 的类声明中 on 关键字后面的类，否则编译失败 abstract class D { void fromD();}mixin C on D { fromC() => 'C';}/* 下面的代码将编译失败，因为 F 要 mixin C 必须先“implements” D 但是 implements 关键字又必须在 with 的后面，所以只能定义一个新的类 E 使 E implements D，F 再 extends E，才能 mixin C */class F with C { } 正确的做法 class E implements D { @override void fromD() => 'E';}class F extends E with C { } Dart 中每个类都是一个隐式地接口。implements一个类之后，必须override所有的方法和成员变量 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/tags/Dart/"}]},{"title":"Dart 基础入门","slug":"Dart 基础入门","date":"2019-04-22T06:27:18.000Z","updated":"2019-06-02T04:55:08.000Z","comments":true,"path":"Dart 基础入门/","link":"","permalink":"http://yoursite.com/Dart 基础入门/","excerpt":"终于开始 Flutter 的具体学习，一切从 Dart 语言开始。 void main() { print('hello world');}","text":"终于开始 Flutter 的具体学习，一切从 Dart 语言开始。 void main() { print('hello world');} 环境搭建Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。 创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的main函数作为运行的入口。在run之前需要edit configuration，很简单，只要指定对应的文件即可。 声明变量Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为null。可以使用具体的类型声明，也可以使用var、dynamic、const、final等关键字 void main() { var i = 0; var d = 2.0; var s = 'hello'; var b = true; var l = [1, 2, 3]; var m = {0: 'a', 1: 'b'}; print(main is Function); //true} 通过查看官方库的core包，可以大概看出其结构 数据类型Numbers包括 int 和 double，分别代表整形和浮点型。 int 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。 String在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码 var s1 = \"hello\";var s2 = 'world';var s3 = 'hello' + 'world';var s4 = 'hello' 'world';var s5 = \"\"\"hello world\"\"\"; 如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。 var clapping = '\\u{1f44f}';print(clapping);Runes runes = new Runes('\\u{1f44d}');print(new String.fromCharCode(runes.first)); 上面的输出为 👏👍 Boolean提供 bool 用来声明布尔型变量，默认为 false。 List 和 MapList l = [1,2,3];l.forEach((x) => print(x)); //forEach的参数为 Functionfor(var x in l) { //使用for-in print(x);}Map map = {0: \"a\", 1: \"b\"};map[0] = \"c\"; Function普通Function函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。 void main() { single1('Tom', 20); single2('Tom', 20); single3('Tom', 20, weight: 30); //由于没有位置约束，必须指定形参名称 single4('Tom', 20, 20, 30);}bool single1(String name, int age) { return true;}//返回类型和参数类型可省略，支持返回表达式single2(name, age) => true;//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值bool single3(String name, int age, {int weight = 60, int height}) => true;//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weightbool single4(String name, int age, [int weight, int height]) => true; 对于main方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为： void main() => runApp(MyApp()); Lambda表达式在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量 var f = (c) { print(c);};f('hello');var list = [1, 2, 3];printElement(x) { //方法签名写成 void printElement(int x) 更直观 print(x);}list.forEach(printElement); forEach的函数定义如下 void forEach(void f(E element)) { for (E element in this) f(element);} 下面的例子直观展示将函数作为变量传递的思想 Function makeAdder(num n) { return (num i) => n + i;} //更明晰的写法Function makeAdder_(num n) { Function add = (num i) { return i + n; }; return add;}var adder2 = makeAdder(2);print(adder2(3)); 控制台将输出 5 运算符赋值操作符除了=，还有??=，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。 相等==将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的identical方法 external bool identical(Object a, Object b); 除法 操作符 含义 / 除，比如 5/2 = 2.5 ~/ 整除， 5/2 = 2 类型判断 操作符 含义 is 对象属于指定类型则返回true is! 对象不属于指定类型返回true as 类型转换 条件表达式分为两种 condition ? expr1 : expr2 //通用表达式expr1 ?? expr2 //如果 expr1 非空，返回其值，否则返回 expr2 级联调用与非空调用//常规写法var button = querySelector('#button');button.text = 'Confirm';button.classes.add('important');button.onClick.listen((e) => window.alert('Confirmed!'));//使用级联表达式querySelector('#button') // Get an object. ..text = 'Confirm' // Use its members. ..classes.add('important') ..onClick.listen((e) => window.alert('Confirmed!'));//非空调用print(button?.text); 其他Dart 语言在比如 if/else、[do、]while、for、switch/case等语句上跟 Java 类似，不再赘述。 异常处理的做法如下 //抛出异常throw 'x should be less than 10'; throw new FormatException('Expected at least 1 section');//捕获异常try { breedMoreLlamas();} on OutOfLlamasException { buyMoreLlamas();}try { //...} on Exception catch (e) { print('Unknown exception: $e');} catch (e, s) { print('Exception details:\\n $e'); print('Stack trace:\\n $s');} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/tags/Dart/"}]},{"title":"Android Binder 源码解析","slug":"Android-Binder-源码解析","date":"2019-03-23T04:18:53.000Z","updated":"2019-04-24T05:31:52.000Z","comments":true,"path":"Android-Binder-源码解析/","link":"","permalink":"http://yoursite.com/Android-Binder-源码解析/","excerpt":"","text":"TODO document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Java 线程和线程池详解","slug":"Java-线程和线程池详解","date":"2019-03-20T09:29:06.000Z","updated":"2019-06-02T05:02:18.000Z","comments":true,"path":"Java-线程和线程池详解/","link":"","permalink":"http://yoursite.com/Java-线程和线程池详解/","excerpt":"线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情： java.lang.Thread 类的一个实例； 线程的执行。","text":"线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情： java.lang.Thread 类的一个实例； 线程的执行。 Java 线程线程和进程概念进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。 区别进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。 一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。 Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。 由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。 实际开发中使用多线程的优势在于 进程之间不能共享内存，而线程之间可以共享内存。 系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。 Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。 线程的状态图一 图二 分类Java 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。 只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。public class Main { public static void main(String[] args) { Thread thread = new Thread(); thread.setDaemon(true); System.out.println(\"is daemon thread? \" + thread.isDaemon()); }} 输出为is daemon thread? true 使用守护线程要注意的点 thread.setDaemon(true) 必须在 thread.start() 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。 在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 Runnable 和 ThreadRunnable 是一个线程接口，查看其构造public interface Runnable { public abstract void run();} 其中只定义了一个run方法 Thread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的initprivate void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) 观察 Thread 中重写的run方法@Overridepublic void run() { if (target != null) { target.run(); }} 其中 target 为 Runnable 对象，即调用 Thread 的run实际上是调用我们传进去的 Runnable 的对应方法 观察其start方法public synchronized void start() { //不能重复调用 start 方法 if (threadStatus != 0) throw new IllegalThreadStateException(); //将线程加入线程组 group.add(this); //线程开始标志 boolean started = false; try { //调用native方法开始多线程 start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } }} 其中start0是 native 方法，在其中新建线程，然后回调 target 的 run 方法。 也就是说，如果我们直接调用run方法，相当于调用普通方法，不会有多线程效果。只有调用start才会在后台开启另一个线程，等待 CPU 调度。 多线程 APIObject实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法 方法 描述 wait() 锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池 wait(long) 锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。 wait(long, int) 和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000 notify() 随机唤醒一个处于等待中的线程（同一个等待阻塞池中） notifyAll() 唤醒所有等待中的线程（同一个等待阻塞池中） 以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行object.wait()方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下public class ThreadTest { public static void main(String[] args) { Thread t = Thread.currentThread(); try { t.wait(2000); //由于没有获得锁，将抛出 IllegalMonitorStateException 异常 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"current Thread info in Main: \" + t.toString()); A a = new A(); a.printThreadInfo(); }}class A { public synchronized void printThreadInfo() { Thread t = Thread.currentThread(); try { wait(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"current Thread info in A: \" + t.toString()); }} 删除main中 try/catch 语句之后，控制台输出如下current Thread info in Main: Thread[main,5,main]//等待两秒current Thread info in A: Thread[main,5,main] 为什么需要在 synchronized 中？ wait和notify用于线程间通信。以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性 一般对队列的操作如下:while(queue.size() == MAX_SIZE){ wait() } 假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2 t1判断队列满，需要 wait 阻塞线程。 但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。 这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。 假如此时消费者不消费了，那么生产者则会一直阻塞下去。 所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。 为什么定义在 Object 中？ Object 中的wait(), notify()等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。 wait()会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！当线程释放它持有的“同步锁”之后变成等待线程，可以被notify()或notifyAll()唤醒。那么，notify()依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间通过什么关联起来？答案是：依据“对象的同步锁”。 负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。 总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！ 这就是notify(), wait()等函数定义在 Object 类，而不是 Thread 类中的原因。 来自 JAVA 线程状态及转化 Thread 方法 描述 Thread.currentThread() 返回对当前线程对象的引用 Thread.interrupted() 检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false） Thread.sleep(long millis) 使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会） Thread.yield() 使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会） t.getId()… 返回该线程的 id 等等信息 t.interrupt() 将该线程中断（实际并不会中断，只是将中断标志设置为true） t.isInterrupted() 检测该线程是否已经中断 t.join() 在a线程中调用b.join()，则a线程阻塞，直到b线程执行完 t.join(long millis) 同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。 关于 interrupt，JAVA interrupt、interrupted和isInterrupted的区别 interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。 注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。 废弃方法 stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止 suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。 resume：用来回复被挂起的线程，跟 suspend 对应。 线程池Java 中关于线程池的继承关系如下 Executor 是一个顶层接口，其中只声明了一个方法execute(Runnable)，用来执行传进去的任务 ExecutorService 接口继承了 Executor 接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown 等 抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法 ThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize < 0 || maximumPoolSize { System.out.println(Thread.currentThread()); });} 控制台输出Thread[main,5,main]Thread[pool-1-thread-1,5,main] 工作原理观察 ThreadPoolExecutor 中的execute方法public void execute(Runnable command) { if (command == null) throw new NullPointerException(); /** * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务 * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。 * 三、如果加入 workQueue 失败，则创建线程执行任务， * 如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。 */ int c = ctl.get(); if (workerCountOf(c) < corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) && remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) reject(command); } 跟踪addWorker方法private boolean addWorker(Runnable firstTask, boolean core) { retry: for (int c = ctl.get();;) { // Check if queue empty only if necessary. if (runStateAtLeast(c, SHUTDOWN) && (runStateAtLeast(c, STOP) || firstTask != null || workQueue.isEmpty())) return false; for (;;) { /* *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize， *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况 */ if (workerCountOf(c) >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateAtLeast(c, SHUTDOWN)) continue retry; // else CAS failed due to workerCount change; retry inner loop } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { /* * 创建Worker时会调用threadFactory来创建一个线程。 * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。 */ w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { int c = ctl.get(); if (isRunning(c) || (runStateLessThan(c, STOP) && firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s > largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted;} 新建 Work ，同时也会利用工厂类实例化一个线程Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this);} 如果 workerAdded，调用t.start()public void run() { runWorker(this);} 跟踪runWorkerfinal void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { while (task != null || (task = getTask()) != null) { if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted()) wt.interrupt(); try { beforeExecute(wt, task); try { task.run(); afterExecute(task, null); } catch (Throwable ex) { afterExecute(task, ex); throw ex; } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); }} 可以看到getTask方法不断从 workerQueue 中读取任务然后执行。只要getTask方法不返回 null，循环就不会退出。private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); if (runStateAtLeast(c, SHUTDOWN) && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) { decrementWorkerCount(); return null; } int wc = workerCountOf(c); //是判断当前线程数是否大于 corePoolSize boolean timed = allowCoreThreadTimeOut || wc > corePoolSize; if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) { if (compareAndDecrementWorkerCount(c)) return null; continue; } /* * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务 * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出 * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前 */ try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } }} 最后用一张图总结上述过程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/线程池/"}]},{"title":"Java 数据库知识整理","slug":"Java-数据库知识整理","date":"2019-03-18T02:45:26.000Z","updated":"2019-04-24T05:32:46.000Z","comments":true,"path":"Java-数据库知识整理/","link":"","permalink":"http://yoursite.com/Java-数据库知识整理/","excerpt":"","text":"TODO document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"《剑指offer》题目 Java 实现","slug":"《剑指offer》题目-Java-实现","date":"2019-03-18T02:42:29.000Z","updated":"2019-03-25T09:17:06.000Z","comments":true,"path":"《剑指offer》题目-Java-实现/","link":"","permalink":"http://yoursite.com/《剑指offer》题目-Java-实现/","excerpt":"Problem1：单例模式实现public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }","text":"Problem1：单例模式实现public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } Problem2：二维数组中的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 /** * 从二维数组的右上角开始选取与 key 比较的整数 * column 的变化:arr[0].length - 1 ---> 0 * row 的变化 0 ---> arr.length * * @param arr * @param key */public static boolean find(int[][] arr, int key) { int col = arr[0].length - 1; int row = 0; while (col >= 0 && row < arr.length) { if (arr[row][col] == key) { return true; } else if (arr[row][col] > key) { //大于查找值，则往前推一列 col--; } else { //小于查找值，则往下推一行 row++; } } return false;} Problem3：替换空格请实现一个函数，将字符串的每个空格替换为”%20”。例如输入We are happy，则输出We%20are%20happy。 /** * 使用 StringBuilder * * @param str * @return */public static String replace(String str) { if (str.isEmpty()) { return \"\"; } StringBuilder builder = new StringBuilder(); for (int i = 0; i < str.length(); i++) { if (str.charAt(i) == ' ') { builder.append(\"%20\"); } else { builder.append(str.charAt(i)); } } return builder.toString();} Problem4：从尾到头打印链表输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值 static class ListNode { T value; ListNode next; public ListNode(T value) { this.value = value; }}/** * 使用栈实现 * * @param headNode */public static void printListReverse(ListNode headNode) { Stack stack = new Stack(); while (headNode != null) { stack.push(headNode); headNode = headNode.next; } while (!stack.empty()) { System.out.println(stack.pop().value + \" \"); }}public static void main(String[] args) { ListNode node = new ListNode(1); node.next = new ListNode(2); node.next.next = new ListNode(3); printListReverse(node);} Problem5：重建二叉树输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。 假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。 例如输入前序遍历序列： {1, 2, 4, 7, 3, 5, 6, 8} 中序遍历序列：{4, 7, 2, 1, 5, 3, 8, 6} 重建出所示二叉树并且输出它的头结点。 1 / \\ 2 3 / / \\4 5 6 \\ / 7 8 知识点补充 前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右） 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右） 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根） 二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。 二叉树的特例是堆和红黑树。 堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。 红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。 Problem6：用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead,分别完成在队列尾部插入结点和在队列头部删除结点的功能public class ConstructQueue { /* s1 用来实现放入新的元素，直接放到栈顶 s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2 然后删除底部元素，再将 s2 元素移回 s1 */ Stack stack1 = new Stack(); Stack stack2 = new Stack(); // 实现appendTail函数 public void appendTail(String s) { stack1.push(s); } // 实现deleteHead函数 public String deleteHead() { while (!stack1.empty()) { stack2.push(stack1.pop()); } String head = stack2.pop(); while (!stack2.empty()) { stack1.push(stack2.pop()); } return head; } public static void main(String[] args) { ConstructQueue queue = new ConstructQueue(); queue.appendTail(\"a\"); queue.appendTail(\"b\"); queue.appendTail(\"c\"); queue.appendTail(\"d\"); System.out.println(queue.deleteHead()); System.out.println(queue.deleteHead()); }} 输出如下ab Problem7：旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为 1; public static void main(String[] args) { int[] a = {3, 4, 5, 1, 2}; System.out.println(minNumInRotateArray(a));}/** * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。 * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。 * * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。 * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素， * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。 * 同理第二个指针的范围也将逐渐缩小 * * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。 * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素， * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。 * * @param array */public static int minNumInRotateArray(int[] array) { if (array == null) { return 0; } int left = 0; int right = array.length - 1; int mid = 0; while (array[left] >= array[right]) { if (right - left == 1) { mid = right; break; } mid = (left + right) / 2; // 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组 if (array[left] == array[right] && array[right] == array[mid]) { return findInOrder(array, left, right); } if (array[left] 1, f(n) = f(n-1) + f(n-2). public static void main(String[] args) { for (int i = 0; i < 11; i++) { System.out.print(fibonacci(i) + \" \"); }}public static int fibonacci(int n) { if (n == 0) { return 0; } if (n == 1) { return 1; } return fibonacci(n-1) + fibonacci(n-2);} 输出结果0 1 1 2 3 5 8 13 21 34 55 Problem9：二进制中1的个数请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。 例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。 public static int oneCountsOfBinary(int i) { char[] chars = Integer.toBinaryString(i).toCharArray(); int count = 0; for (char c : chars) { if (c == '1') { count++; } } return count;}public static int _oneCountsOfBinary(int i) { int count = 0; int flag = 1; while (flag != 0) { if ((i & flag) != 0) { count++; } flag = flag next删除掉 * * @param head * @param delNode */public static void deleteNode(Node head, Node delNode) { if (head == null || delNode == null) { return; } if (head == delNode) { head = null; return; } if (delNode.next == null) { Node temp = head; while (temp.next != delNode) { temp = temp.next; } temp.next = null; return; } delNode.value = delNode.next.value; delNode.next = delNode.next.next;} Problem12：调整数组中奇数和偶数的先后顺序输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;public static void orderArray(int[] array) { int left = 0; int right = array.length - 1; while (left < right) { while (left < right && !isEven(array[left])) { left ++; } while (left < right && isEven(array[right])) { right --; } if (left < right) { int temp = array[left]; array[left] = array[right]; array[right] = temp; } }}static boolean isEven(int i) { return ((i & 1) == 0);} Problem13：链表中倒数第K个结点输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。 例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第三个结点是值为4的结点。 /** * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动 * 从第k步开始，第二个指针也开始从链表的头指针开始遍历 * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上 * * @param head 头结点 * @param k 倒数第k个节点 */public static int find(ListNode head, int k){ if (head == null) { return 0; } ListNode first = head; ListNode second = head; for (int i = 1; i < k; i++) { if (first.next != null) { first = first.next; } else { return 0; } } System.out.println(first.val); while (first.next != null) { first = first.next; second = second.next; } System.out.println(first.val); return second.val;}static class ListNode { int val; ListNode next; public ListNode(int val) { this.val = val; }} Problem14：翻转链表定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点 /** * 翻转单链表 * * @param head 原链表的头节点 * @return 翻转之后的头节点 */public static ListNode getReversedListHead(ListNode head) { if (head == null) { return null; } //current节点是head的下一个节点 ListNode current = head.next; //当前的head变为链表的尾，所以next为空 head.next = null; while (current != null) { //currentNext节点是current的下一个节点。 ListNode currentNext = current.next; //current.next反方向指向以前的节点 current.next = head; //移动head和current指针，到后面head重新成为头节点 head = current; current = currentNext; } return head;}/** * 翻转单链表的递归实现 * * @param head 原链表的头节点 * @return 翻转之后的头节点 */public static ListNode reverseListByRecursion(ListNode head) { if (head == null || head.next == null) { return head; } ListNode newList = reverseListByRecursion(head.next); head.next.next = head; head.next = null; return newList;} Problem15：合并两个排序的链表输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 public static ListNode merge(ListNode n1, ListNode n2) { if (n1 == null) { return n2; } if (n2 == null) { return n1; } ListNode mergeNode = null; if (n1.val < n2.val) { mergeNode = n1; mergeNode.next = merge(n1.next, n2); } else { mergeNode = n2; mergeNode.next = merge(n1, n2.next); } return mergeNode;} Problem16：树的子结构判断Problem17：二叉树的镜像Problem18：顺时针打印矩阵Problem19：包含min函数的栈Problem20：栈的压入、弹出序列Problem21：从上往下打印二叉树Problem22：二叉搜索树的后序遍历Problem23：二叉树中和为某一值的路径Problem24：字符串的排列Problem25：数组中出现次数超过一半的数字Problem26：连续子数组的最大和Problem27：整数中1出现的次数Problem28：把数组排成最小的数Problem29：丑数Problem30：第一个只出现一次的字符Problem31：数组中的逆序对Problem32：两个链表的第一个公共节点Problem33：二叉树的深度&&平衡二叉树判断Problem34：数字在排序数组中出现的次数Problem35：数组中只出现一次的数字Problem36：和为S的两个数字Problem37：和为S的连续正数序列Problem38：翻转单词的顺序Problem39：扑克牌的顺子Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）Problem41：计算1+2+3+ ··· + nProblem42：不用加减乘除做加法Problem43：把字符串转换为整数Problem44：数组中重复的数字Problem45：构建乘积数组Problem46：正则表达式匹配Problem47：表示数值的字符串Problem48：字符流中第一个不重复的字符Problem49：链表中环的入口结点Problem50：删除链表中欧冠重复的节点Problem51：二叉树的下一个节点Problem52：把二叉树打印成多行Problem53：按之字形顺序打印二叉树Problem54：序列化二叉树Problem55：二叉搜索树的第K个节点Problem56：滑动窗口的最大值大值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Android 多线程技术","slug":"Android-多线程技术","date":"2019-03-17T03:56:59.000Z","updated":"2019-03-17T04:43:46.000Z","comments":true,"path":"Android-多线程技术/","link":"","permalink":"http://yoursite.com/Android-多线程技术/","excerpt":"多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。","text":"多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"Android LruCache 缓存详解","slug":"Android-LruCache-缓存详解","date":"2019-03-17T02:49:27.000Z","updated":"2019-05-03T11:34:44.000Z","comments":true,"path":"Android-LruCache-缓存详解/","link":"","permalink":"http://yoursite.com/Android-LruCache-缓存详解/","excerpt":"","text":"Android 缓存策略一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。 LRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。 LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图： 使用LruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而 DisLruCache 目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。 讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。 LinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数 public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder) 中的最后一个参数 accessOrder 来指定。 对于get、put、remove等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 get(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用put 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。 LruCache 的使用非常简单，以图片缓存为例：int maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);int cacheSize = maxMemory/8;mMemoryCache = new LruCache(cacheSize) { @Override protected int sizeOf(String key, Bitmap value) { return value.getRowBytes() * value.getHeight() / 1024; }}; 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。 重写sizeOf方法，计算出要缓存的每张图片的大小。 注意：缓存的总容量和每个缓存对象的大小所用单位要一致。 原理LruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的对按照一定顺序排列起来。 通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。 public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder;} accessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。 以具体例子解释，当设置为true时 public static final void main(String[] args) { LinkedHashMap map = new LinkedHashMap(0, 0.75f, true); map.put(0, 0); map.put(1, 1); map.put(2, 2); map.put(3, 3); map.put(4, 4); map.put(5, 5); map.put(6, 6); map.get(1); map.get(2); for (Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey() + \":\" + entry.getValue()); }} 输出结果为:0:03:34:45:56:61:12:2 即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。 下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除 构造方法 public LruCache(int maxSize) { if (maxSize { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"LRU","slug":"LRU","permalink":"http://yoursite.com/tags/LRU/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"}]},{"title":"Java 反射详解","slug":"Java-反射详解","date":"2019-03-16T15:25:47.000Z","updated":"2019-06-02T05:00:54.000Z","comments":true,"path":"Java-反射详解/","link":"","permalink":"http://yoursite.com/Java-反射详解/","excerpt":"反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。","text":"反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。 使用Examplepublic class Apple { private int price; public Apple(){} public Apple(int price) { this.price = price; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { //正常调用 Apple apple = new Apple(); apple.setPrice(10); System.out.println(\"Price is \" + apple.getPrice()); //反射调用 Class clazz = Class.forName(\"Apple\"); //使用 getFields() 无法获取私有属性 Field[] fields = clazz.getDeclaredFields(); for (Field field: fields) { System.out.println(\"Field is \" + field.getName()); } Method setPriceMethod = clazz.getMethod(\"setPrice\", int.class); Constructor appleConstructor = clazz.getConstructor(); Object appleObj = appleConstructor.newInstance(); //Constructor appleConstructor = clazz.getConstructor(int.class); //获得有参构造器 //Object appleObj = appleConstructor.newInstance(int.class) //调用有参构造器 setPriceMethod.invoke(appleObj, 12); Method getPriceMethod = clazz.getMethod(\"getPrice\"); System.out.println(\"Price is \" + getPriceMethod.invoke(appleObj)); }} API类的实例化和构造函数 获取公有构造函数，不包括父类，Class.classpublic Constructor[] getConstructors()public Constructor getConstructor(Class… parameterTypes) 获取当前类构造函数，忽略修饰符public Constructor[] getDeclaredConstructors()public Constructor getDeclaredConstructor(Class… parameterTypes) 构造函数调用，Constructor.classpublic T newInstance(Object… initargs) 忽略修饰符，强制调用public void setAccessible(boolean flag) 类成员变量的获取 获取公有变量，包括父类，Class.classpublic Field[] getFields()public Field getField(String name) 获取当前类成员变量，忽略修饰符public Field[] getDeclaredFields()public Field getDeclaredField(String name) 成员变量赋值，Field.class//obj为实例对象public void set(Object obj,Object value) 忽略修饰符，强制调用public void setAccessible(boolean flag) 类方法的获取 获取公有方法，包括父类，Class.classpublic Method[] getMethods()public Method getMethod(String name, Class… parameterTypes) 获取当前类方法，忽略修饰符public Method[] getDeclaredMethods()public Method getDeclaredMethod(String name, Class… parameterTypes) 方法调用，Method.class//obj为类实例化对象，如果为静态方法obj为Nullinvoke(Object obj, Object… args) 忽略修饰符，强制调用public void setAccessible(boolean flag) 类注解的获取 获取类的”annotationClass”类型的注解，包括父类public Annotation getAnnotation(Class annotationClass) // 获取类的全部注解 ，包括父类public Annotation[] getAnnotations() // 获取类自身声明的全部注解 ，忽略修饰符public Annotation[] getDeclaredAnnotations() 类父类的获取 获取实现的全部接口public Type[] getGenericInterfaces() 获取父类public Type getGenericSuperclass() 原理RTTI和Class对象RTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。 很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。 而这些类型信息是通过一个特殊对象Class（java.lang.Class）实现的，它包含跟类相关的信息。 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。 加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。 连接： 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。 获取 Class 对象的方式有三种 Object 类的 getClass() 方法，执行静态块和动态构造块 数据类型的静态属性 class ，不会初始化该类 Class类中的静态方法public static Class forName(String className)，执行静态块，不执行动态构造块 RTTI和反射Java 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。 RTTI和反射之间的真正区别只在于： RTTI：编译器在编译时打开和检查.class文件反射：运行时打开和检查.class文件 严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能 未完待续 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/反射/"}]},{"title":"基本数据结构的简单Java实现","slug":"基本数据结构的简单Java实现","date":"2019-03-16T14:08:55.000Z","updated":"2019-06-02T05:04:48.000Z","comments":true,"path":"基本数据结构的简单Java实现/","link":"","permalink":"http://yoursite.com/基本数据结构的简单Java实现/","excerpt":"JDK 中提供了很多数据结构，如下所示 Collection├ List│ ├ LinkedList│ ├ ArrayList│ └ Vector│ └Stack└ Set Map├ Hashtable├ HashMap└ WeakHashMap 本文将进行部分数据结构的简单实现。","text":"JDK 中提供了很多数据结构，如下所示 Collection├ List│ ├ LinkedList│ ├ ArrayList│ └ Vector│ └Stack└ Set Map├ Hashtable├ HashMap└ WeakHashMap 本文将进行部分数据结构的简单实现。 Stackpublic class MyStack { private Object[] dataArray; private int maxSize; private int nowSize = 0; public MyStack() { this(10); } public MyStack(int initialCapacity) { maxSize = initialCapacity; dataArray = new Object[maxSize]; } public void push(T data) { if (size() >= maxSize) { resize(); } dataArray[nowSize++] = data; } public T pop() { if (empty()) { return null; } return (T)dataArray[--nowSize]; } public T peek() { if (empty()) { return null; } return (T)dataArray[nowSize-1]; } public int search(T target) { int p = nowSize; while (p >= 0) { if (dataArray[p] == target) { return p; } p--; } return -1; } private void resize() { maxSize = maxSize = maxSize) { resize(); } //非循环队列 dataArray[rear++] = newData; //循环队列 //dataArray[rear] = newData; //rear = (rear+1) % maxSize; } public T dequeue() { if (empty()) { return null; } T value = (T)dataArray[front]; //非循环队列 dataArray[front++] = null; //循环队列 //dataArray[front] = null; //front = (front+1) % maxSize; return value; } public void resize() { maxSize = maxSize { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"Android 消息机制详解","slug":"Android-消息机制详解","date":"2019-03-16T06:13:19.000Z","updated":"2019-06-02T04:54:48.000Z","comments":true,"path":"Android-消息机制详解/","link":"","permalink":"http://yoursite.com/Android-消息机制详解/","excerpt":"Android 的消息机制，主要是指 Handler 的运行机制。","text":"Android 的消息机制，主要是指 Handler 的运行机制。 ANRApplication Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。 原因Android系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。 以下四种条件都可以造成 ANR InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件 BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive方法中10秒没有处理完成，后台则为60秒。 Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。 ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。 分析和解决分析 查看 log 信息 Java 线程调用分析，jstack {pid}，其中 pid 为虚拟机进程 id，可以通过jps查看当前所有线程。 查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令./adb pull /data/anr/traces.txt查看 解决 避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。 避免在主线程 query provider、不要滥用SharePreferences 文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。 BroadcastReciever 的onRecieve不要进行耗时操作。 Handler 机制由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的checkThread进行验证void checkThread() { if (mThread != Thread.currrentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views\"); }} 使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？ 答案是使用 Handler 。 创建//接收消息@SuppressLint(\"HandlerLeak\")private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); if (msg.what == 1) { log.e(\"MSG\", \"收到消息\")； } }};//发送消息new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(1000); mHandler.sendEmptyMessage(1); } catch (InterruptedException e) { e.printStackTrace(); } }}).start(); 使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用MyHandler hander = new MyHandler(context);static class MyHandler extends Handler { private WeakReference out; MyHandler(Context ctx) { super(); out = new WeakReference(ctx); } @Override public void handleMessage(Message msg) { if (out.get() != null) { //进行消息处理 } }} Handler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。 Handler观察 Handler 的构造函数public Handler(Callback callback, boolean async) { ...... mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called\" + \" Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;} 在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用Looper.prepare的线程内创建 handler。 不过，为什么在主线程中创建 Handler 不需要调用Looper.prepare和Looper.loop方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的main方法，在其中调用了prepareMainLooperpublic static void main(String[] args) { ...... Looper.prepareMainLooper(); ...... Looper.loop(); ......}public static void prepareMainLooper() { prepare(false); //quitAllowed 参数传false synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); }} 关于 ActivityThread：Android线程管理（二）——ActivityThread MessageQueue顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。 由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。 当 Handler 调用sendMessage时，最后会调用到 public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis);} 查看enqueueMessage方法， boolean enqueueMessage(Message msg, long when) { ...... synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when < p.when) { msg.next = p; mMessages = msg; needWake = mBlocked; } else { needWake = mBlocked && p.target == null && msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when < p.when) { break; } if (needWake && p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } ...... } return true;} 首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒 如果队列已有消息，则根据 Message 创建的时间进行插入 Looper通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用Looper.prepare方法使消息循环初始化，并且调用Looper.loop使消息循环一直处于运行状态，取出 MessageQueue 中的消息分发给 Handler。 public static void prepare() { prepare(true);}private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed));} 可以看到，prepare(boolean quitAllowed)实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当Looper.prepare执行完毕之后才可以执行loop方法public static void loop() { //获取当前线程绑定的Looper final Looper me = myLooper(); //当前线程的MessageQueue final MessageQueue queue = me.mQueue; ...... //循环从 MessageQueue 取出消息. for (;;) { Message msg = queue.next(); ...... //将消息分发出去 msg.target.dispatchMessage(msg); ...... //将消息回收 msg.recycle(); }} 可以看到，如果消息队列的 next 返回了新消息，就会调用msg.target.dispatchMessage(msg)，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。 public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} 首先检查 Message 的 callBack 是否为空，不为空则handlerCallback(msg)，最终调用 callback 的run方法 如果为空，检查 mCallBack 是否为空，不为空则调用它的handleMassage，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。 如果都为空，调用 Handler 内部的handleMessage，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。 ThreadLocal一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。 使用一个简单的例子演示 ThreadLocal 的真正含义//新建一个 boolean 类型的变量private ThreadLocal value = new ThreadLocal();//在主线程中将其设为 truevalue.set(true);log.e(\"MainThread\", value.get());//子线程中设为 falsenew Thread(\"Thread1\") { @Override public void run() { value.set(false); log.e(\"Thread1\", value.get()); }}//另一个子线程直接读取new Thread(\"Thread2\") { @Override public void run() { log.e(\"Thread2\", value.get()); }} 运行日志如下 MainThread, trueThread1, falseThread2, null 由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：Java并发编程：深入剖析ThreadLocal 总结Handler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的runOnUiThread public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } ...... } 比如 View 的post public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); ① } // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); ② return true; } 最后用一张图来结束本文 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"http://yoursite.com/tags/Handler/"}]},{"title":"Java 排序算法","slug":"Java-排序算法","date":"2019-03-15T10:36:47.000Z","updated":"2019-06-02T05:01:02.000Z","comments":true,"path":"Java-排序算法/","link":"","permalink":"http://yoursite.com/Java-排序算法/","excerpt":"排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。","text":"排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。 稳定性对于一个数组a {6,2,4,6,1}，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种 1 2 4 6 6 a[4] a[1] a[2] a[0] a[3] a[4] a[1] a[2] a[3] a[0] 如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法 冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等 否则，属于不稳定的排序算法 选择排序，希尔排序，堆排序，快速排序等 冒泡排序/** * 冒泡排序，O(n^2) * 每一次内层循环中，两两比较，将较大的数放到后面 * * @param a 待排序数据 */public static void bubbleSort(int[] a) { int length = a.length; int i = 0; int temp; for ( ; i < length - 1; i++) { int j = 0; for ( ; j < length - 1 - i; j++) { if (a[j] > a[j+1]) { temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } }} 插入排序插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序 直接插入排序/** * 直接插入排序，O(n^2) * i从第一个元素开始，默认i前面的序列已经排好序 * 取出i的下一个元素，从后往前比较，找到适合的位置就插入 * * @param a 待排序序列 */public static void insertSort(int[] a) { int length = a.length; for (int i = 0; i < length; i++) { int temp = a[i]; for (int j = i; j > 0; j--) { if (a[j] < a[j-1]) { a[j] = a[j-1]; a[j-1] = temp; } } }} 折半插入排序/** * 折半插入排序，O(n^2) * 对直接插入排序算法进行了改进 * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要 * 折半插入排序则使用了折半查找/二分查找 * * Arrays类的binarySearch()方法便是折半查找的实现 * * @param a 待排序序列 */public static void binaryInsertSort(int[] a) { int length = a.length; for (int i = 0; i < length; i++) { int temp = a[i]; int low = 0; int high = i-1; while (low = low; j--) { //元素后移，为插入temp做准备 a[j+1] = a[j]; } a[low] = temp; }} 希尔排序/** * 希尔排序，也称 递减增量排序，O(n*(logn)^2) * 对于n个元素的序列，假设增量为increment * 从第一个元素开始，每隔increment取一个元素组成一个子序列 * 对每个子序列进行直接插入排序，increment /= 2 * 重复上述过程，直至increment为1 * * @param a 待排序序列 */public static void shellSort(int[] a) { int length = a.length; // increment为增量，每次减为原来的一半，直至为1 for (int increment = length / 2; increment > 0; increment /= 2) { // 共increment个组，对每一组都执行直接插入排序 for (int i = 0; i < increment; i++) { for (int j = i + increment; j < length; j += increment) { // 如果a[j] < a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。 if (a[j] < a[j - increment]) { int temp = a[j]; int k = j - increment; while (k >= 0 && a[k] > temp) { a[k + increment] = a[k]; k -= increment; } a[k + increment] = temp; } } } }} 桶排序（基数排序）/** * 基数排序，也称桶排序，O(d(k+n)) * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。 * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 * * @param a 待排序数组 * @param d 位数，如果最大数为9527，则d为10000，如果为7，则d为10 */public static void radixSort(int[] a,int d) { int n = 1; //代表位数对应的数：1,10,100... int k = 0; //保存每一位排序后的结果用于下一位的排序输入 int length = a.length; int[][] bucket = new int[10][length]; //排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里 int[] order = new int[length]; //用于保存每个桶里有多少个数字 while(n < d) { for(int num : a) { //将数组array里的每个数字放在相应的桶里 int digit = (num/n)%10; bucket[digit][order[digit]] = num; order[digit]++; } int i = 0; for( ; i","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Android View 的工作原理","slug":"Android-View-的工作原理","date":"2019-03-01T05:10:14.000Z","updated":"2019-06-02T04:54:16.000Z","comments":true,"path":"Android-View-的工作原理/","link":"","permalink":"http://yoursite.com/Android-View-的工作原理/","excerpt":"在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。","text":"在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。 整体过程Window首先简单认识 Window，其表示一个窗口，属于一个抽象类，具体的实现为 PhoneWindow。通过 WindowManager 向 WindowManagerService 发起请求，WMS 负责 Window 的具体生成。 实际上每一个 Window 对应一个 View 和 ViewRootImpl， 因此 Window 不是实际存在的，它通过 ViewRootImpl 以 View 的形式存在。 ViewRoot 和 DecorViewViewRoot 的具体实现就是上一节所提及的 ViewRootImpl，View 的三大流程（measure、layout、draw）都是通过它来实现的。 在 ActivityThread 中，当 Activity 对象被创建后，会将一个 DecorView 添加到 Window，然后创建 ViewRootImpl 对象，并将 DecorView 和 ViewRootImpl 建立关联，这也验证了上一节的观点。 root = new ViewRootImpl(view.getContext(), display);root.setView(view, vparams, panelParentView); View 的绘制流程是从 ViewRoot 的 performTraversals 开始的，经过measure（测量 View 的宽高）、layout（确定 View 在父容器的位置）、draw（将 View 绘制在屏幕上）三个过程，呈现出一个 View。 如图所示，performTraversals会依次调用performMeasure、performLayout、performDraw，然后这三个方法分别完成顶级 View 的三大流程。而后，measure又会调用onMeasure，在其中对所有子元素进行 measure 过程，此时 measure 流程就从父容器传递到子元素了，接着子元素重复上述过程。如此完成整个 View 树的遍历。 measure 过程决定了 View 的宽高，可以通过getMeasuredWidth和getMeasuredHeight获得 View 测量后的宽高，在几乎所有情况下都可以得到 View 最终的数值。 layout 过程决定了 View 的四个顶点的坐标和实际的 View 的宽高，可以通过getTop、getBottom、getLeft、getRight拿到四个顶点的位置，通过getWidth、getHeight获得 View 的最终宽高。只有 draw 过程完成之后才能呈现 View。 由上图我们可以看出，一般 DecorView 会包含一个 LinearLayout，其中上面是标题栏，下面是内容栏。在创建 Activity 的时候需要setContentView而不是setView的原因便是如此。我们的布局加到了 id 为android.R.id.content的 FrameLayout 中。 //得到 contentViewGroup content = (ViewGroup) findViewById(android.R.id.content)；//得到开发者设置的 ViewView view = content.getChildAt(0); 具体流程MeasureSpec“测量规格”，是 View 测量过程中非常重要的参数。measure 时系统会将 View 的 LayoutParams 根据父容器施加的规则转换成对应的 MeasureSpec，然后再根据 该 MeasureSpec 测量出 View 的宽高。 MeasureSpec 代表一个32位的 int 值，其中高2位代表 SpecMode（测量模式），低30位代表 SpecSize（某种测量模式下的规格大小）。将两个参数打包成一个 int 值的原因是避免过多的对象内存分配。 SpecMode 有三类 SpecMode 含义 UNSPECIFIED 父容器不限制 View，一般用于系统内部 EXACTLY 父容器已检测 VIew 的精确大小，对应参数为match_parent和具体的数值 AT_MOST 父容器指定了 View 的最大值，具体大小由 View 决定，对应参数为wrap_content MeasureSpec 和 LayoutParams对于 DecorView，其 MeasureSpec 由窗口尺寸和其自身 LayoutParams 决定，对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和 自身的LayoutParams 共同决定。一旦 MeasureSpec 确定，onMeasure 中就可以确定 View 的测量宽高。 ViewRootImpl 的源码地址：ViewRootImpl.java。查阅源码，得到 DecorView 的测量规则如下 LayoutParams.MATCH_PARENT：精确模式，大小为窗口大小 LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口 固定大小：精确模式，大小为 LayoutParams 指定的大小 ViewGroup 的源码地址：ViewGroup.java。查看 ViewGroup 的measureChildWithMargins方法 protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 可以看到在调用子元素的measure之前，会先得到子元素的 MeasureSpec，很显然其和父容器的 MeasureSpec 以及子元素自身的 LayoutParams 包括 margin、padding 参数有关。具体的逻辑在 ViewGroup 中的 getChildMeasureSpec 中实现。 getChildMeasureSpec方法清楚展示了 普通 View 的 MeasureSpec 的创建规则，下表是该方法的直观展示（表中 parentSize 指父容器中目前可使用的大小） 由此可以看出 当 View 采用固定宽高时，View 的 MeasureSpec 与父容器无关，为精确模式、大小为 LayoutParams 设定的值 当 View 的宽高为match_parent时，如果父容器为精确模式/最大模式，则其也为精确模式/最大模式，且大小为父容器的剩余空间 当 View 的宽高为wrap_content时，View 的模式总是最大化模式，且大小不超过父容器的剩余空间 UNSPECIFIED 模式主要用于系统内部多次 Measure 的情形，一般情况下无需关注 measure 过程View对于 View，measure 完成其自身的测量过程；对于 ViewGroup，除了完成自己的测量过程，还会遍历调用所有子元素的measure方法，各子元素再递归执行这一过程。measure 是一个final方法（View.java 第 23267 行），这意味着子类不能重写该方法。在measure中会调用 View 的onMeasure，所以开发者只需要重写该方法即可。 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));} setMeasuredDimension会设置 View 宽高的测量值，getDefaultSize返回 View 测量后的大小。 对于getSuggestedMinimumWidth，如果 View 没有设置背景，那么宽度为mMinWidth，其对应android:minWidth属性，如果不指定属性，则mMinWidth默认为0；如果 View 设置了背景，则 View 的宽度为max(mMinWidth, mBackground.getMinimumWidth())。那么mBackground.getMinimumWidth()所为何物？ 观察 Drawable 的getMinimumWidth方法（Drawable.java 第 798 行） public int getMinimumWidth() { final int intrinsicWidth = getIntrinsicWidth(); return intrinsicWidth > 0 ? intrinsicWidth : 0;} 可以发现该方法返回 Drawable 的原始宽度（如果存在，否则返回0 —— 比如 ShapeDrawable 就无原始宽高）。 直接继承 View 的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。原因在于，由上面的表格我们知道，当使用wrap_content时，View 的 SpecMode 为 AT_MOST，此时宽高等于 SpecSize，SpecSize 此时又等于 parentSize，效果跟使用match_parent是一样的。 解决该问题的方法很简单，给 View 指定一个默认的内部宽高（mWidth 和 mHeight），并在wrap_content时设置此宽高即可 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(int widthMeasureSpec, int heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST && heightSpecMode == MeasureSpec.AT_MOST) { setMeasuredDimension(mWidth, mHeight); } else if (widthSpecMode == MeasureSpec.AT_MOST) { setMeasuredDimension(mWidth, heightSpecSize); } else if (heightSpecMode == MeasureSpec.AT_MOST) { setMeasuredDimension(widthSpecSize, mHeight); }} ViewGroup对于 ViewGroup 来说，其属于 View 的子类，但同时也是抽象的，它没有重写 View 的onMeasure，而是提供了measureChildren的方法用于测量子元素 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i < size; ++i) { final View child = children[i]; if ((child.mViewFlags & VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } }} 其中调用了measureChild protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);} 显然该方法的思想是取出子元素的 LayoutParams 然后通过getChildMeasureSpec（如 MeasureSpec 小节的分析）创建子元素的 MeasureSpec，接着将 MeasureSpec 传递给 View 的measure方法进行测量。 ViewGroup 并没有测量的具体过程，而是交给其子类实现，比如 LinearLayout、RelativeLayout 等。 宽高的获取一般情况下，measure 完成后即可通过getMeasuredWidth/height获得 View 的测量宽高，但是极端情况下系统可能需要多次 measure 才能确定最终的宽高，所以最好是在onLayout中获取宽高，而不是在onMeasure中。 考虑 View 外部，比如当我们在 Activity 的onCreate或者onResume中获取 View 的宽高时，会发现结果是不正确的，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步的，因此无法保证在 Activity 执行onCreate、onResume时某个 View 已经测量完毕。有四种方法解决该问题： Activity/View.onWindowFocusChanged，此时 View 已经初始化完毕。注意该方法可能会被调用多次，比如每次 Activity 的窗口获得/失去焦点 public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); if (hasFocus) { int width = view.getMeasuredWidth(); int height = view.getMeasuredHeigth(); }} view.post(Runnable runnable)，通过 post 将一个 Runnable 投递到消息队列尾部，当 Looper 调用此 Runnable 时，View 已经被初始化 view.post(() -> { int width = view.getMeasuredWidth(); int height = view.getMeasuredHeigth();}) ViewTreeObserver，该类拥有一系列回调方法，比如使用 OnGlobalLayoutListener 接口监听 View 树的状态，同样接口方法会被调用多次 ViewTreeObserver observer = view.getViewTreeObserver();observer.addOnGlobalLayoutListener(() -> { int width = view.getMeasuredWidth(); int height = view.getMeasuredHeigth();}) view.measure(int widthMeasureSpec, int heightMeasureSpec)，手动 measure，较为复杂，不再赘述。 layout 过程View / ViewGroup 使用layout过程确定自身位置，然后在onLayout中遍历所有的子元素并调用其layout方法，重复上述过程。 View 中的layout方法 public void layout(int l, int t, int r, int b) { ...... int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); ...... mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null && li.mOnLayoutChangeListeners != null) { ArrayList listenersCopy = (ArrayList)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i < numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } ......} 首先通过setFrame设定 View 的四个顶点（mLeft、mTop、mBottom、mRight）的值，以此确定 View 在父容器中的位置。接着调用onLayout确定子元素的位置，和onMeasure类似，View / ViewGroup 都没有提供该方法的实现，而是交给具体的布局。 在 ViewRoot 和 DecorView 小节，提及了在 View 的 layout 之后通过getWidth、getHeight获得 View 的“最终宽高”，那么getMeasuredWidth和getWidth的区别到底是什么？ public final int getWidth() { return mRight - mLeft;}public final int getHeight() { return mBottom - mTop;} 从上面的代码可以看出，getWidth的返回值刚好就是 View 的测量宽度，也就是说，View 的测量宽高等于最终宽高，只不过测量宽高形成与 measure 过程，而最终宽高形成与 layout 过程 —— 赋值时机不同。但是如果重写 View 的layout方法，改变了super的参数值，比如 public void layout(int l, int t, int r, int b) { super.layout(l, t, r + 100, b + 100);} 就会导致 View 的最终宽高总是比测量宽高大 100px。 draw 过程将 View 绘制到屏幕上，具体步骤 绘制背景 background.draw(canvas) 绘制自身 onDraw 绘制子元素 dispatchDraw 绘制装饰 onDrawScrollBars 其他Android 提供了一些 API 供开发调用，实现对 View 绘制过程的操纵 requestLayout 调用此方法会导致 View 树调用 layout 和 measure 过程，但不会触发 draw 流程 invalidate 请求重绘 View 树，即 draw 过程。在子线程中可以通过postInvalidate实现 当开发者调用 View 的setVisibility方法实现 VISIBLE / INVISIBLE -> GONE 时，相当于间接调用 requestLayout 和 invalidate。 当开发者调用 View 的setVisibility方法实现 INVISIBLE -> VISIBLE 时，相当于间接调用 invalidate。 本文主要参考了《Android 开发艺术探索》——任玉刚 著 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"Android IPC 机制详解","slug":"Android-IPC-机制详解","date":"2019-02-23T11:12:35.000Z","updated":"2019-06-02T04:53:58.000Z","comments":true,"path":"Android-IPC-机制详解/","link":"","permalink":"http://yoursite.com/Android-IPC-机制详解/","excerpt":"IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。","text":"IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。 应用场景只有在多进程场景下才需要 IPC 机制。 多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。 使用多进程会造成如下的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences 可靠性下降 Application 会多次创建 对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。 基础概念Serializable 接口Java 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个seriaVersionUID即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。 public class User implements Serializable { private static final long seriaVersionUID = 519067123721295773L ...}//序列化过程User user = new User(\"name\", 18);ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\"file.txt\"));out.writeObject(user);out.close//反序列化过程ObjectInputStream in = new ObjectInputStream( new FileInputStream(\"file.txt\"));User user = (User) in.readObject();in.close 使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。 Java 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。 Parcelable 接口Android 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。 其与 Serializable 的区别在于 Parcelable 使用更复杂，后者如上面的代码，足够简洁。 使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。 使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。 标准写法如下public class User implements Parcelable { private String name; private int id; protected User(Parcel in) { name = in.readString(); id = in.readInt(); } /* 实例化静态变量CREATOR 从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法 */ public static final Creator CREATOR = new Creator() { @Override public User createFromParcel(Parcel in) { return new User(in); } @Override public User[] newArray(int size) { return new User[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); dest.writeInt(id); }} 通过 Intent 传递和获取数据//传递User user = new User(\"Name\", 18);Intent intent = new Intent();intent.putExtra(\"data\", user);//使用User user = getIntent().getParcelableExtra(\"data\"); BinderBinder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。 从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。 从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。 更多关于 Binder：图解Android - Binder 和 Service 实现方式BundleBundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。 文件共享利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。 缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。 SocketSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。 AIDL概念Android Interface Definition Language，Android 接口定义语言。 数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下 Java 中的八种基本数据类型、String、CharSequence。 List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。 Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。 定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。 in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。 关于更多：你真的理解AIDL中的in，out，inout么? 两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。 实现第一类 AIDL 文件：// Book.aidl// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用// 注意：Book.aidl 与 Book.java的包名应当是一样的package com.febers.aidldemo;//注意parcelable是小写parcelable Book; 自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 writeToParcel方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现readFromParcel方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。 第二类 AIDL 文件：// BookManager.aidlpackage com.lypeer.ipcclient;//导入所需要使用的非默认支持数据类型的包import com.febers.aidldemo.Book;interface BookManager { //所有的返回值前都不需要加任何东西，不管是什么数据类型 List getBooks(); Book getBook(); int getBookCount(); //传参时，Java基本数据类型、String 以及 CharSequence 之外的类型 //都需要在前面加上定向tag，具体加什么量需而定 void setBookPrice(in Book book , int price) void setBookName(in Book book , String name) void addBookIn(in Book book); void addBookOut(out Book book); void addBookInout(inout Book book);} 完成上面的步骤之后，build项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。 服务端public class AIDLService extends Service { public final String TAG = this.getClass().getSimpleName(); //包含Book对象的list private List mBooks = new ArrayList(); //由AIDL文件生成的BookManager private final BookManager.Stub mBookManager = new BookManager.Stub() { @Override public List getBooks() throws RemoteException { synchronized (this) { Log.e(TAG, \"invoking getBooks() method , now the list is : \" + mBooks.toString()); if (mBooks != null) { return mBooks; } return new ArrayList(); } } @Override public void addBook(Book book) throws RemoteException { synchronized (this) { if (mBooks == null) { mBooks = new ArrayList(); } if (book == null) { Log.e(TAG, \"Book is null in In\"); book = new Book(); } //尝试修改book的参数，主要是为了观察其到客户端的反馈 book.setPrice(2333); if (!mBooks.contains(book)) { mBooks.add(book); } //打印mBooks列表，观察客户端传过来的值 Log.e(TAG, \"invoking addBooks() method , now the list is : \" + mBooks.toString()); } } }; @Override public void onCreate() { super.onCreate(); Book book = new Book(); book.setName(\"Android开发艺术探索\"); book.setPrice(28); mBooks.add(book); } @Nullable @Override public IBinder onBind(Intent intent) { Log.e(getClass().getSimpleName(), String.format(\"on bind,intent = %s\", intent.toString())); return mBookManager; }} 客户端public class AIDLActivity extends AppCompatActivity { //由AIDL文件生成的 Java 类 private BookManager mBookManager = null; //标志当前与服务端连接状况的布尔值，false为未连接，true为连接中 private boolean mBound = false; //包含Book对象的list private List mBooks; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_aidl); } /** * 按钮的点击事件，点击之后调用服务端的addBookIn方法 * * @param view */ public void addBook(View view) { //如果与服务端的连接处于未连接状态，则尝试连接 if (!mBound) { attemptToBindService(); Toast.makeText(this, \"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\", Toast.LENGTH_SHORT).show(); return; } if (mBookManager == null) return; Book book = new Book(); book.setName(\"APP研发录In\"); book.setPrice(30); try { mBookManager.addBook(book); Log.e(getLocalClassName(), book.toString()); } catch (RemoteException e) { e.printStackTrace(); } } /** * 尝试与服务端建立连接 */ private void attemptToBindService() { Intent intent = new Intent(); intent.setAction(\"com.febers.aidl\"); intent.setPackage(\"com.febers.aidldemo\"); bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); } @Override protected void onStart() { super.onStart(); if (!mBound) { attemptToBindService(); } } @Override protected void onStop() { super.onStop(); if (mBound) { unbindService(mServiceConnection); mBound = false; } } private ServiceConnection mServiceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { Log.e(getLocalClassName(), \"service connected\"); mBookManager = BookManager.Stub.asInterface(service); mBound = true; if (mBookManager != null) { try { mBooks = mBookManager.getBooks(); Log.e(getLocalClassName(), mBooks.toString()); } catch (RemoteException e) { e.printStackTrace(); } } } @Override public void onServiceDisconnected(ComponentName name) { Log.e(getLocalClassName(), \"service disconnected\"); mBound = false; } };} 当然不要忘记在 Manifest 文件中注册 Service。控制台显示信息如下： //服务端的 log 信息1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333] //客户端的 log 信息1，service connected2，[name : Android开发艺术探索 , price : 28]3，name : APP研发录In , price : 2333 MessagerMessager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。 概念Messenger 有两个构造函数，分贝以 Handler 和 Binder 为参数private final IMessenger mTarget;public Messenger(Handler target) { mTarget = target.getIMessenger();}public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target); //和前面的 AIDL 很相似吧} Handler.getIMessenger源码：final IMessenger getIMessenger() { synchronized (mQueue) { if (mMessenger != null) { return mMessenger; } mMessenger = new MessengerImpl(); return mMessenger; }} IMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法send(android.os.Message msg)。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：private final class MessengerImpl extends IMessenger.Stub { public void send(Message msg) { msg.sendingUid = Binder.getCallingUid(); Handler.this.sendMessage(msg); }} 所以可以使用Handler.handlerMessage接收消息。Messenger 中对send的实现如下：public void send(Message message) throws RemoteException { mTarget.send(message);} Messenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部send方法实际上是调用 IMessenger 实现的send方法。 Messenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。 实现服务端public class MessengerService extends Service { private final String TAG = this.getClass().getSimpleName(); Messenger mMessenger = new Messenger(new Handler() { @Override public void handleMessage(final Message msg) { if (msg != null && msg.arg1 == 9527) { if (msg.getData() == null) { return; } String content = (String) msg.getData().get(\"MSG_CONTENT\"); //接收客户端的消息 Log.e(TAG, \"Message from client: \" + content); //回复消息给客户端 Message replyMsg = Message.obtain(); replyMsg.arg1 = 9528; Bundle bundle = new Bundle(); bundle.putString(\"MSG_CONTENT\", \"已收到消息\"); replyMsg.setData(bundle); try { msg.replyTo.send(replyMsg); //回信 } catch (RemoteException e) { e.printStackTrace(); } } } }); @Nullable @Override public IBinder onBind(final Intent intent) { return mMessenger.getBinder(); }} 客户端代码片段public class MessagerActivity extends AppCompatActivity { Messenger mClientMessenger = new Messenger(new Handler() { @Override public void handleMessage(final Message msg) { if (msg != null && msg.arg1 == 9528){ if (msg.getData() == null){ return; } String content = (String) msg.getData().get(\"MSG_CONTENT\"); Log.e(TAG, \"Message from server: \" + content); } } }); //服务端的 Messenger private Messenger mServerMessenger; private ServiceConnection mMessengerConnection = new ServiceConnection() { @Override public void onServiceConnected(final ComponentName name, final IBinder service) { mServerMessenger = new Messenger(service); } @Override public void onServiceDisconnected(final ComponentName name) { mServerMessenger = null; } }; //发送消息 public void sendMsg() { String msgContent = \"消息\"； Message message = Message.obtain(); message.arg1 = 9527; Bundle bundle = new Bundle(); bundle.putString(\"MSG_CONTENT\", msgContent); message.setData(bundle); message.replyTo = mClientMessenger; //指定回信人是客户端定义的 try { mServerMessenger.send(message); } catch (RemoteException e) { e.printStackTrace(); } }} ContentProvider主要用于不同的应用程序之间实现数据共享功能 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"多进程通信","slug":"多进程通信","permalink":"http://yoursite.com/tags/多进程通信/"}]},{"title":"Android 动画详解","slug":"Android-动画详解","date":"2019-02-18T11:12:22.000Z","updated":"2019-06-02T04:54:28.000Z","comments":true,"path":"Android-动画详解/","link":"","permalink":"http://yoursite.com/Android-动画详解/","excerpt":"Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。","text":"Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。 View Animation视图动画的作用对象是 View，可分为补间动画和帧动画。 补间动画动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。 XML 方式创建一个 set.xml 文件，通过动画集合标签将四种效果结合起来 使用以上动画的方式如下Animation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);view.startAnimation(anim); Java 代码方式使用 Java 代码实现动画的方式如下public void startAnimationSet() { //创建动画，参数表示他的子动画是否共用一个插值器 AnimationSet animationSet = new AnimationSet(true); //添加动画 animationSet.addAnimation(new AlphaAnimation(1.0f, 0.0f)); //设置插值器 animationSet.setInterpolator(new LinearInterpolator()); //设置动画持续时长 animationSet.setDuration(3000); //设置动画结束之后是否保持动画的目标状态 animationSet.setFillAfter(true); //设置动画结束之后是否保持动画开始时的状态 animationSet.setFillBefore(false); //设置重复模式 animationSet.setRepeatMode(AnimationSet.REVERSE); //设置重复次数 animationSet.setRepeatCount(AnimationSet.INFINITE); //设置动画延时时间 animationSet.setStartOffset(2000); //取消动画 animationSet.cancel(); //释放资源 animationSet.reset(); //开始动画 view.startAnimation(animationSet);} 自定义除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的initialize和applyTransformation方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 特殊使用View 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。 帧动画帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。 首先需要定义一个 XML 文件frame_animation.xml 然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可view.setBackgroundResource(R.drawable.frame_animation)；AnimationDrawable drawable = (AnimationDrawable) view.getBackground();drawable.start(); Property Animation属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在： 补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。 补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。 与补间动画类似，属性动画也需要定义几个方面的属性： 动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。 动画插值方式。通过 android:interploator 指定。 动画重复次数。通过 android:repeatCount 指定。 重复行为。通过 android:repeatMode 指定。 动画集。在属性资源文件中通过 来组合。 帧刷新率。指定多长时间播放一帧。默认为 10 ms。 API ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。 ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。 AnimatorSet：Animator 的子类，用于组合多个 Animator。 属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。 IntEvaluator：计算 int 类型属性值的计算器。 FloatEvaluator：用于计算 float 类型属性值的计算器。 ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。 TypeEvaluator：可以自定义计算器。 ValueAniamtorValueAnimator 类中有3个重要方法： ValueAnimator.ofInt(int values)ValueAnimator.ofFloat(float values)ValueAnimator.ofObject(int values) ofInt将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator 下面的代码将实现按钮的宽度从 150px 放大到 500px Button mButton = (Button) findViewById(R.id.Button); // 设置属性数值的初始值 & 结束值 // ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500 ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, 500); // 设置动画的播放各种属性 valueAnimator.setDuration(2000); // 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度 // 设置更新监听器，数值每次变化更新都会调用该方法 valueAnimator.addUpdateListener(new AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animator) { // 获得每次变化后的属性值 int currentValue = (Integer) animator.getAnimatedValue(); // 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化 mButton.getLayoutParams().width = currentValue; // 刷新视图，即重新绘制 mButton.requestLayout(); } }); valueAnimator.start(); // 启动动画} ofFloat其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）public class FloatEvaluator implements TypeEvaluator { /** * 重写evaluate() * * @param fraction 动画完成度（根据它来计算当前动画的值） * @param startValue 动画的初始值 * @param endValue 动画的结束值 * @return */ public Object evaluate(float fraction, Object startValue, Object endValue) { float startFloat = ((Number) startValue).floatValue(); // 初始值过渡到结束值的算法 // 1. 用结束值减去初始值，算出它们之间的差值 // 2. 用上述差值乘以 fraction 系数 // 3. 加上初始值，得到当前动画的值 return startFloat + fraction * (((Number) endValue).floatValue() - startFloat); } } ofObject对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。 但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。 自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。 public class PointEvaluator implements TypeEvaluator { @Override public Object evaluate(float fraction, Object startValue, Object endValue) { // 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象 Point startPoint = (Point) startValue; Point endPoint = (Point) endValue; // 根据fraction来计算当前动画的x和y的值 float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX()); float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY()); // 将计算后的坐标封装到一个新的Point对象中并返回 Point point = new Point(x, y); return point; }} 将属性动画作用到自定义View当中public class MyView extends View { public static final float RADIUS = 70f;// 圆的半径 private Point currentPoint;// 当前点坐标 private Paint mPaint;// 绘图画笔 // 构造方法，初始化画笔 public MyView(Context context, AttributeSet attrs) { super(context, attrs); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.BLUE); } // 实现绘制逻辑 // 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果 @Override protected void onDraw(Canvas canvas) { // 如果当前点坐标为空(即第一次) if (currentPoint == null) { currentPoint = new Point(RADIUS, RADIUS); // 创建一个点对象(坐标是(70,70)) float x = currentPoint.getX(); float y = currentPoint.getY(); canvas.drawCircle(x, y, RADIUS, mPaint); // 将属性动画作用到View中 Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70) Point endPoint = new Point(700, 1000);// 结束点为(700,1000) ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint); anim.setDuration(5000); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { currentPoint = (Point) animation.getAnimatedValue(); // 每次赋值后就重新绘制，从而实现动画效果 // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次 invalidate(); } }); anim.start(); } else { // 如果坐标值不为0,则画圆 float x = currentPoint.getX(); float y = currentPoint.getY(); canvas.drawCircle(x, y, RADIUS, mPaint); } }} ObjectAnimator继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。ObjectAnimator 与 ValueAnimator类的区别在于 ValueAnimator 类是先改变值，然后手动赋值给对象的属性从而实现动画，属于间接对对象属性进行操作 ObjectAnimator 类是先改变值，然后自动赋值给对象的属性从而实现动画，属于直接对对象属性进行操作 具体使用对于 ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ….values); 其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值 对 Button 进行变换ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f); // 效果:常规->全透明->常规ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);......animator.setDuration(5000);animator.start(); 自定义在上面的例子中，我们给ObjectAnimator.ofFloat的第二个参数String property传入alpha、rotation、translationX 和scaleY等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的get/set方法进行的。 所以自定义属性就可以通过为对象设置需要操作属性的set/get方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。 还是对一个球做变换public class MyView2 extends View { public static final float RADIUS = 100f; private Paint mPaint; private String color; // 设置背景颜色属性 // 设置背景颜色的get() & set()方法 public String getColor() { return color; } public void setColor(String color) { this.color = color; mPaint.setColor(Color.parseColor(color)); // 将画笔的颜色设置成方法参数传入的颜色 invalidate(); } public MyView2(Context context, AttributeSet attrs) { super(context, attrs); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.BLUE); } @Override protected void onDraw(Canvas canvas) { canvas.drawCircle(500, 500, RADIUS, mPaint); }} 实现自定义估值器，完成颜色过渡的逻辑public class ColorEvaluator implements TypeEvaluator { private int mCurrentRed; private int mCurrentGreen ; private int mCurrentBlue ; // 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡 @Override public Object evaluate(float fraction, Object startValue, Object endValue) { String startColor = (String) startValue; String endColor = (String) endValue; // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字 // 那么每个颜色的取值范围是0-255 int startRed = Integer.parseInt(startColor.substring(1, 3), 16); int startGreen = Integer.parseInt(startColor.substring(3, 5), 16); int startBlue = Integer.parseInt(startColor.substring(5, 7), 16); int endRed = Integer.parseInt(endColor.substring(1, 3), 16); int endGreen = Integer.parseInt(endColor.substring(3, 5), 16); int endBlue = Integer.parseInt(endColor.substring(5, 7), 16); // 将初始化颜色的值定义为当前需要操作的颜色值 mCurrentRed = startRed; mCurrentGreen = startGreen; mCurrentBlue = startBlue; // 计算初始颜色和结束颜色之间的差值 // 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢 int redDiff = Math.abs(startRed - endRed); int greenDiff = Math.abs(startGreen - endGreen); int blueDiff = Math.abs(startBlue - endBlue); int colorDiff = redDiff + greenDiff + blueDiff; if (mCurrentRed != endRed) { // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1 mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0, fraction); } else if (mCurrentGreen != endGreen) { mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction); } else if (mCurrentBlue != endBlue) { mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction); } // 将计算出的当前颜色的值组装返回 String currentColor = \"#\" + getHexString(mCurrentRed) + getHexString(mCurrentGreen) + getHexString(mCurrentBlue); return currentColor; } // 根据fraction值来计算当前的颜色。 private int getCurrentColor(int startColor, int endColor, int colorDiff, int offset, float fraction) { int currentColor; if (startColor > endColor) { currentColor = (int) (startColor - (fraction * colorDiff - offset)); if (currentColor < endColor) { currentColor = endColor; } } else { currentColor = (int) (startColor + (fraction * colorDiff - offset)); if (currentColor > endColor) { currentColor = endColor; } } return currentColor; } // 将10进制颜色值转换成16进制。 private String getHexString(int value) { String hexString = Integer.toHexString(value); if (hexString.length() == 1) { hexString = \"0\" + hexString; } return hexString; }} 具体调用ObjectAnimator anim = ObjectAnimator.ofObject(myView2, \"color\", new ColorEvaluator(), \"#0000FF\", \"#FF0000\");anim.setDuration(2000);anim.start(); 此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中setWidth并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过get/set无法改变控件的宽度，也就无法实现动画效果。 解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的get/set方法。ButtonWrapper wrapper = new ViewWrapper(button);ObjectAnimator.ofInt(wrapper, \"width\", 500) .setDuration(3000) .start();private static class ViewWrapper { private View mTarget; public ViewWrapper(View target) { mTarget = target; } // 为宽度设置get/set public int getWidth() { return mTarget.getLayoutParams().width; } public void setWidth(int width) { mTarget.getLayoutParams().width = width; mTarget.requestLayout(); }} AnimatorSet最后介绍组合动画类，仅展示用法ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, \"translationX\", curTranslationX, 300,curTranslationX); ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f); ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(translation).with(rotate).before(alpha); animSet.setDuration(5000); animSet.start(); Spring AnimationSpringAnimation，弹簧动画，位于android.support.animation包中，属性动画位于android.animation.Animator包中，其实通过 BounceInterpolator 或者 OvershootInterpolator 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。 使用之前需要导入com.android.support:support-dynamic-animation包 APIpublic SpringAnimation(View v, ViewProperty property)public SpringAnimation(View v, ViewProperty property, float finalPosition) 参数分别是操作对应的View，对应的变化属性及最终的位置。 ViewProperty 包括(Z轴支持需要API >= 21)： TRANSLATION_XTRANSLATION_YTRANSLATION_ZSCALE_XSCALE_YROTATIONROTATION_XROTATION_YXYZALPHASCROLL_XSCROLL_Y 在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量 Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快 DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ > 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 < ζ { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"动画开发","slug":"动画开发","permalink":"http://yoursite.com/tags/动画开发/"}]},{"title":"LeakCanary源码解析","slug":"LeakCanary源码解析","date":"2019-02-13T05:28:31.000Z","updated":"2019-06-02T05:02:42.000Z","comments":true,"path":"LeakCanary源码解析/","link":"","permalink":"http://yoursite.com/LeakCanary源码解析/","excerpt":"内存泄漏是 Android 开发中无法避免的问题，LeakCanary 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。","text":"内存泄漏是 Android 开发中无法避免的问题，LeakCanary 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。 ActivityLifecycleCallbacksLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。 接口方法可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。 public interface ActivityLifecycleCallbacks { void onActivityCreated(Activity activity, Bundle savedInstanceState); void onActivityStarted(Activity activity); void onActivityResumed(Activity activity); void onActivityPaused(Activity activity); void onActivityStopped(Activity activity); void onActivitySaveInstanceState(Activity activity, Bundle outState); void onActivityDestroyed(Activity activity);} 简单用法开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。public class MyApplication extends Application { public static List activityList; public static final int ACTIVITY_MAX_NUM = 10; @Override public void onCreate() { super.onCreate(); activityList = new LinkedList(); registerActivityLifecycleCallbacks(new MyActivityCallbacks()); } class MyActivityCallbacks implements ActivityLifecycleCallbacks { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { if (activityList.size() >= ACTIVITY_MAX_NUM) { activityList.remove(activityList.size()-1).finish(); } activityList.add(activity); } @Override public void onActivityStarted(Activity activity) { } @Override public void onActivityResumed(Activity activity) { } @Override public void onActivityPaused(Activity activity) { } @Override public void onActivityStopped(Activity activity) { } @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) { } @Override public void onActivityDestroyed(Activity activity) { activityList.remove(activity); } } public static Activity getCurrentActivity() { return activityList.get(0); }} 引用类型在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 强引用强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的A a = new A()中的引用a。 软引用软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。SoftReference sr = new SoftReference(new String(\"hello\"));System.out.println(sr.get()); 弱引用弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。WeakReference sr = new WeakReference(new String(\"hello\")); System.out.println(sr.get());System.gc(); //通知JVM的gc进行垃圾回收System.out.println(sr.get()); 打印的结果为 hellonull 弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。ReferenceQueue queue = new ReferenceQueue();WeakReference pr = new WeakReference(object, queue); 虚引用PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其get()永远返回null 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 public class PhantomReference extends Reference { public T get() { return null; } public PhantomReference(T referent, ReferenceQueue q) { super(referent, q); }} LeakCanary源码实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。 执行流程跟踪调用的入口方法installpublic static @NonNull RefWatcher install(@NonNull Application application) { return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall();} listenerServiceClass方法位于 AndroidRefWatcherBuilder public @NonNull AndroidRefWatcherBuilder listenerServiceClass( @NonNull Class listenerServiceClass) { enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass); return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));} 该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和excludedRefs方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法： public @NonNull RefWatcher buildAndInstall() { if (LeakCanaryInternals.installedRefWatcher != null) { throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\"); } RefWatcher refWatcher = build(); if (refWatcher != DISABLED) { if (enableDisplayLeakActivity) { LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); } if (watchActivities) { ActivityRefWatcher.install(context, refWatcher); } if (watchFragments) { FragmentRefWatcher.Helper.install(context, refWatcher); } } LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher;} 该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪install方法 public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) { Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);}//成员变量 lifecycleCallbacksprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter { @Override public void onActivityDestroyed(Activity activity) { refWatcher.watch(activity); } }; 由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对 Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。 watch方法由 RefWatcher 默认实现： public void watch(Object watchedReference, String referenceName) { ...... retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue); ensureGoneAsync(watchStartNanoTime, reference);} 其中 retainedKeys 是一个 Set 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。 private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) { watchExecutor.execute(new Retryable() { @Override public Retryable.Result run() { return ensureGone(reference, watchStartNanoTime); } });} watchExecutor 为 AndroidWatchExecutor 对象public AndroidWatchExecutor(long initialDelayMillis) { mainHandler = new Handler(Looper.getMainLooper()); HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME); handlerThread.start(); backgroundHandler = new Handler(handlerThread.getLooper()); this.initialDelayMillis = initialDelayMillis; maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;}@Override public void execute(@NonNull Retryable retryable) { if (Looper.getMainLooper().getThread() == Thread.currentThread()) { waitForIdle(retryable, 0); } else { postWaitForIdle(retryable, 0); }} 在execute中，不管是waitForIdle还是postWaitForIdle都会切换到主线程执行，最终会调用以下代码：Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() { @Override public boolean queueIdle() { postToBackgroundWithDelay(retryable, failedAttempts); return false; } }); 那么 IdleHandler 到底是什么呢？ 我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。 ensureGoneAsync方法最终会调用ensureGone Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) { ...... removeWeaklyReachableReferences(); ...... gcTrigger.runGc(); removeWeaklyReachableReferences(); if (!gone(reference)) { ...... File heapDumpFile = heapDumper.dumpHeap(); ...... HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key) .referenceName(reference.name) .watchDurationMs(watchDurationMs) .gcDurationMs(gcDurationMs) .heapDumpDurationMs(heapDumpDurationMs) .build(); heapdumpListener.analyze(heapDump); } return DONE;} removeWeaklyReachableReferences遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。 调用gcTrigger.runGc去进行内存回收，这里没有使用System.gc，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。 主动进行 GC 之后会再次调用removeWeaklyReachableReferences清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。 生成性能统计文件.hprof，进行内存泄漏的分析。 那么 hprof 文件是被解析成信息的呢 AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey); public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) { ...... MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile); HprofParser parser = new HprofParser(e); Snapshot snapshot = parser.parse(); this.deduplicateGcRoots(snapshot); Instance leakingRef = this.findLeakingReference(referenceKey, snapshot); return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ： this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);} checkForLeak方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的parse方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。 得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。 总结LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://yoursite.com/tags/内存泄漏/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"Java设计模式：创建型模式","slug":"Java设计模式：创建型模式","date":"2019-01-20T16:58:21.000Z","updated":"2019-03-15T15:27:56.000Z","comments":true,"path":"Java设计模式：创建型模式/","link":"","permalink":"http://yoursite.com/Java设计模式：创建型模式/","excerpt":"设计模式及其分类设计模式设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。","text":"设计模式及其分类设计模式设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 分类模式描述包含创建型模式工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）行为型模式这些设计模式特别关注对象之间的通信。责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 可以使用一张图来展示设计模式之间的关系： 六个原则： 开闭原则（Open Close Principle） 对扩展开放，对修改关闭。 里氏代换原则（Liskov Substitution Principle） 基类可以出现的任何地方，子类一定可以出现。 依赖倒转原则（Dependence Inversion Principle） 针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 降低类之间的耦合度。 迪米特法则，又称最少知道原则（Demeter Principle） 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。 合成复用原则（Composite Reuse Principle） 尽量使用合成/聚合的方式，而不是使用继承。 三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。 创建者模式工厂模式创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。 工厂模式可分为简单工厂、工厂方法、抽象工厂。 简单工厂工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。 简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。 工厂方法工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。 从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。 抽象工厂工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。 以上介绍的三种工厂方法各有优缺点 简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） 工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品） 抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族） 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。 单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。 懒汉式支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 要支持多线程，可以给getInstance方法加锁synchronized，但是效率会变得很低。 饿汉式不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。 public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 双检式双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。getInstance 的性能对应用程序很关键。 public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 该方法使用了关键字volatile，关于该关键字的分析：Java并发编程：volatile关键字解析 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。 静态内部类式能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 与双检式方式一样利用ClassLoder机制来保证初始化instance时只有一个线程。关于 ClassLoader：一看你就懂，超详细java中的ClassLoader详解 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用getInstance之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。 枚举实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。 public enum Singleton { INSTANCE; public void whateverMethod() {} } 建造者模式使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。 public class Human { private final String name; private final int height; private final int weight; public static class Builder { // 必要参数 private final int name; // 可选参数 private int height = 170; private int weight = 60; public Builder(String name) { this.name = name } public Builder height(int height) { this.height = height; return this; } public Builder weight(int weight) { this.weight = weight; return this; } public Human build() { return new Human(this); } } private Human(Builder builder) { name = builder.name; height = builder.height; weight = builder.weight; } public static void main(String[] args) { Human human = new Human.Builder(\"Jack\") .height(175) .weight(60) .build(); }} 原型模式当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。 Java的clone方法便是使用了这种方法，关于该方法：java对象克隆以及深拷贝和浅拷贝 public inteface Prototype { Prototype clone();}public class ConcretePrototype implement Prototype { public override Prototype clone() { Prototype prototype = new ConcretePrototype(); return prototype; } public static void main(String[] args) { Prototype p1 = new ConcretePrototype(); Prototype p2 = p1.clone(); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Java设计模式：行为型模式","slug":"Java设计模式：行为型模式","date":"2019-01-20T16:57:00.000Z","updated":"2019-03-15T15:27:46.000Z","comments":true,"path":"Java设计模式：行为型模式/","link":"","permalink":"http://yoursite.com/Java设计模式：行为型模式/","excerpt":"责任链模式责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。","text":"责任链模式责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。 创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。 abstract class AbstractLogger { public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger) { this.nextLogger = nextLogger; } public void logMessage(int level, String message) { if (this.level { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Java设计模式：结构型模式","slug":"Java设计模式：结构型模式","date":"2019-01-20T16:56:04.000Z","updated":"2019-03-15T15:27:32.000Z","comments":true,"path":"Java设计模式：结构型模式/","link":"","permalink":"http://yoursite.com/Java设计模式：结构型模式/","excerpt":"适配器模式在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。","text":"适配器模式在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此Volt5V称为Target，而不兼容的220V电压称之为Adaptee，我们的目的是适配设计一个Adpater，方法有两种。 类适配器模式interface Volt5V { int get5V();}class Volt220V { public int get220V() { return 220; }}class Adapter extends Volt220V implements Volt5V { @Override public int get5V() { return 5; }}public static void main(String[] args) { Adapter adapter = new Adapter(); System.out.println(\"获取需要的5V电源：\" + adapter.get5V());} 对象适配器模式与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 class ObjectAdapter implements Volt5V { private Volt220V volt220V; public ObjectAdapter(Volt220V adaptee) { volt220V = adaptee; } @Override public int get5V() { return 5; } public int get220V() { return volt220V.get220V(); } } 关于 Android 中 ListView 中的 Adapter，可以参考：Android源码之ListView的适配器模式 组合模式将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。 对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。 //抽象构件，声明一个接口用于访问和管理Component的子部件abstract class Component { public Component() { } public abstract void add(Component component); public abstract void remove(Component component); //显示层级结构 public abstract void Display(int level);}//叶子节点class Leaf extends Component { public Leaf() { super(); } //无意义的实现 @Override public void add(Component component) { } //无意义的实现 @Override public void remove(Component component) { } @Override public void Display(int level) { System.out.println(\"-\" + level); }}//枝节点class Composite extends Component { public Composite() { super(); } private List children = new ArrayList(); @Override public void add(Component component) { children.add(component); } @Override public void remove(Component component) { children.remove(component); } @Override public void Display(int level) { children.forEach( component -> component.Display(level + 2) ); }} 对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。 装饰器模式向一个现有的对象添加新的功能，同时又不改变其结构。创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。 interface Shape { void draw();}class Circle implements Shape { @Override public void draw() { System.out.println(\"Draw a circle\"); }}//实现了 Shape 接口的抽象装饰类。abstract class ShapeDecorator implements Shape { Shape decoratedShape; public ShapeDecorator(Shape decoratedShape) { this.decoratedShape = decoratedShape; } @Override public void draw() { decoratedShape.draw(); }}//具体的装饰类class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape) { System.out.println(\"Border color: Red\"); }} 代理模式下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。 interface Image { void display();}class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); }}class ProxyImage implements Image { private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } realImage.display(); }} 静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。 import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DisplayHandler implements InvocationHandler { //要代理的真实对象 private Object obj; public DisplayHandler(Object obj) { this.obj = obj; } /** * * @param proxy 代理类代理的真实代理对象 * @param method 所要调用某个对象真实的方法的Method对象 * @param args 指代代理对象方法传递的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //真实的对象执行之前 System.out.println(\"Before invoke...\"); Object invoke = method.invoke(obj, args); //真实的对象执行之后 System.out.println(\"After invoke...\"); return invoke; }}public static void main(String[] args) { Image image = new RealImage(\"hello.jpg\"); InvocationHandler handler = new DisplayHandler(image); /* * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象 * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法 * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上 */ Image proxy = (Image) Proxy.newProxyInstance( handler.getClass().getClassLoader(), image.getClass().getInterfaces(), handler); proxy.display();} 控制台输出结果为Loading hello.jpgBefore invoke...Displaying hello.jpgAfter invoke... 代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。 其他过滤器模式简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。 桥接模式桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。 举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。 外观模式外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。 简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。 享元模式所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点 public class FlyweightFactory{ static Map shapes = new HashMap(); public static Shape getShape(String key){ Shape shape = shapes.get(key); if(shape == null){ shape = new Circle(key); shapes.put(key, shape); } return shape; } public static int getSum(){ return shapes.size(); }} 补充从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","slug":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","date":"2019-01-13T15:09:12.000Z","updated":"2019-06-02T05:04:10.000Z","comments":true,"path":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》/","link":"","permalink":"http://yoursite.com/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》/","excerpt":"第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。","text":"第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。 “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：巴赫《六首无伴奏大提琴组曲》斯塔克 正文1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。 如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。 回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。 探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。 如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。 应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。 12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。 马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。 在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。 在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。 最感人的还是大师们晚年的演奏，情感饱足，回归天真。 罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。 罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。 俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。 法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。 只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"艺术","slug":"艺术","permalink":"http://yoursite.com/categories/艺术/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://yoursite.com/tags/音乐/"},{"name":"巴洛克","slug":"巴洛克","permalink":"http://yoursite.com/tags/巴洛克/"},{"name":"巴赫","slug":"巴赫","permalink":"http://yoursite.com/tags/巴赫/"}]},{"title":"翻越GFW记","slug":"翻越GFW记","date":"2019-01-12T15:31:31.000Z","updated":"2019-06-02T05:04:36.000Z","comments":true,"path":"翻越GFW记/","link":"","permalink":"http://yoursite.com/翻越GFW记/","excerpt":"GFW 是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录GFW所为何物，以及翻的原理。","text":"GFW 是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录GFW所为何物，以及翻的原理。 GFW所为何物GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音 the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 形象的描述，在没有 GFW 的时代，访问互联网的方式如下 GFW 出现之后，则变成 其内部构造如下 它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。 GFW的具体原理可以查看此文章：全面学习GFW 如何工作关键字过滤阻断关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。 IP地址封锁路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。 DNS污染、劫持DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 DNS劫持和污染的方式有两种： 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。 值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：中国防火长城-污染攻击大事记。 除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。 翻越记翻修改Hosts文件足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。 Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。 所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS 污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。 SSH TunnelSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1) 用户通过建立起的隧道进行代理，通过 SSH Server 向真实的服务发起请求 (2-3) 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5) 由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。 VPN对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。 VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。 VPN 的特点如下： VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。 VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。 ShadowsocksVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。 技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。 相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。 Shadowsocks-R虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。 作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。 V2RayV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。 记 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。 2004年，维基百科遭遇网络封锁，至今未解封。 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。 结语从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。 翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。 本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/categories/互联网/"}],"tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://yoursite.com/tags/翻墙/"},{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/tags/互联网/"}]},{"title":"LeetCode：最长回文子串（Longest Palindromic Substring）的解法","slug":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法","date":"2019-01-12T06:32:23.000Z","updated":"2019-03-15T15:26:40.000Z","comments":true,"path":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/","link":"","permalink":"http://yoursite.com/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/","excerpt":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 Input: “babcd”Output: “bab”","text":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 Input: “babcd”Output: “bab” 本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。 O(n^3)算法思路 从最长的子串开始，遍历所有该原字符串的子串； 每找出一个字符串，就判断该字符串是否为回文； 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。 时间复杂度 遍历字符串子串：嵌套一个循环：O(n^2)； 判断是否为回文：再次嵌套一个循环：O(n^3)。 代码public static String longestPalindrome(String s) { if(s.length() 0; i--) {//子串长度 for(int j = 0; j #a#abaf -> #a#b#a#f# 可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。 借助两个变量center、right分别记录回文子串对应的中心点和右端点 可以直接看出，right就是2*center-i（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;反之，就只能从1个长度开始匹配了，就是下面的这行代码: r[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1 这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。 时间复杂度只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。 代码public static String longestPalindrome(String s) { if(s == null || s.length() < 1) { return s; } StringBuilder builder = new StringBuilder(); // 防止左端点越界 builder.append(\"&#\"); char[] c = s.toCharArray(); for (char a : c) { builder.append(a).append(\"#\"); } String newStr = builder.toString(); c = newStr.toCharArray(); // 回文半径 int[] r = new int[newStr.length()]; // 回文子串最大右端点、中心点 int right=0, center=0; // 最大回文半径、最大中心点 int maxR=0, maxC=0; for (int i=1;i < c.length;i++) { // 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径 r[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1; while (i+r[i] { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Github Pages+Hexo搭建个人博客","slug":"Github-Pages-Hexo搭建个人博客","date":"2019-01-11T15:22:07.000Z","updated":"2019-06-02T05:00:36.000Z","comments":true,"path":"Github-Pages-Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/Github-Pages-Hexo搭建个人博客/","excerpt":"上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。","text":"上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。 作者的环境基于Windows，其他环境的搭建过程大同小异。 准备工作Github Pages创建 Github Pages，首先需要一个 Github 帐号，新建一个仓库，仓库名为{账户名}.github.io，系统会自动识别并将其设为 Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：https://{账户名}.github.io便可以看到缺省的界面。 HexoHexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下： 安装Git客户端，前往Git主页下载，安装后登录帐号。 安装Node.js环境，前往Node主页下载。 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令： npm install -g hexo-cli 初始化Hexo，projectname省略时，要求当前文件夹为空。 hexo init [projectname] 关联经过前面的过程，已经获得了 Github Pages 和本地的 Hexo 环境，接下来就是关联两者。在博客的文件夹中有_config.yml文件，为 Hexo 的配置文件，打开并将相应位置设置为： deploy: type: gitrepo: 该处填写仓库的完整路径branch: master 该过程其实是给hexo d这一命令做相应的配置，让 hexo 知道 blog 部署的位置，显然部署在 GitHub 的仓库里。保存文件之后，安装 Git 部署插件，在 Git Bash 中键入命令： npm install hexo-deployer-git --save 接下来就是清除 hexo 缓存：hexo clean 生成静态文件hexo g 部署网站，d 的意思是 deploy hexo d 后两个命令可以合并为一条，关于 Hexo 的命令请访问：Hexo指令。 hexo g -d 至此，博客已经搭建完毕，浏览器键入https://{账户名}.github.io，发现打开了一个使用 Hexo 搭建的 Github Pages 博客。 配置博客文件夹下的_config.yml文件可以配置整个博客的名称、主题等基本功能，/theme/文件夹下的_config.yml文件则用于配置具体的主题配置。 发表与删除在博客文件夹打开 Git Bash，键入 hexo n \"文章的标题\" 之后便会生成一个md文件，在md文件中编辑文章保存，然后键入hexo g -d便会发布文章。 如果要删除文章，直接删除对应的 md 文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。 主题网络上有很多优秀的 Hexo 主题，关于主题选择，可以查看这个知乎问答：有哪些好看的 Hexo主题。笔者使用的是NexT。 在博客文件夹下的_config.yml文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客_config.yml文件的更改，保存片刻即生效。 域名绑定具体过程如下： 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github 的 IP 地址，{账户名}.github.io的 IP 地址，还有一个的记录类型为CNAME，记录值为：{账户名}.github.io。 进入 GitHub Pages 的仓库，点击 settings，设置 Custom domain，输入购买的域名，保存。 进入博客文件夹中的/source/，新建一个记事本文件，只需填写域名即可。如果在域名前填了 www，则每次浏览器访问都要填入 www，不填则没这个必要。之后将该文件保存为所有文件，名称为CNAME。 备份与恢复由于在 Github Pages 的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。 备份创建一个分支，用来保存网站源文件，具体步骤如下: 新建一个分支，如 hexo，并将其设置为默认 本地 clone 你的 Github Pages 仓库，得到一个 io 文件夹：{账户名}.github.io的文件夹。 将原来博客文件夹中的_config.yml，themes/，source/，scffolds/，package.json，.gitignore复制到 clone 下来的文件夹，注意要将theme/主题的.git/删除。 在 clone 下的文件夹执行npm install，npm install hexo-deployer-git。 此时{账户名}.github.io文件夹已经成为包含你博客所有文件的工作文件夹，在部署(hexo g -d)之前，执行下面三条命令，以使用 hexo 分支更新 git 上的源文件:git add .git commit -m \"更新源文件\"git push origin hexo 这样一来，达到了在 master 分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。 恢复当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js 的安装，步骤如下: clone 你的 Github Pages 仓库，得到一个 io 文件夹。 在文件夹中打开 Git Bash，键入以下命令:npm install hexo-cli -gnpm install npm install hexo-deployer-git 现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用 pull 命令更新本地文件，且分支始终为 hexo。 如果在拉取过程中提示本地分支与远程仓库冲突，可以使用git reset --hard命令重置之后再次 pull。如果提示 The following untracked working tree files would be overwritten by merge 可以使用git clean -d -fx，关于该命令 git clean -f -n //选项-n将显示执行下一步时将会移除哪些文件。 git clean -f //该命令会移除所有上一条命令中显示的文件。 git clean -fd //移除文件夹，使用选项-d。 git clean -fX //只想移除已被忽略的文件，使用选项-X。 git clean -fx //想移除已被忽略和未被忽略的文件，使用选项-x。 Hexo各文件（夹）说明 _config.yml：站点的配置文件，备份过程中需要拷贝； themes/：主题文件夹，需要拷贝； source：博客文章的.md文件，需要拷贝； scaffolds/：文章的模板，需要拷贝； package.json：安装包的名称，需要拷贝； .gitignore：限定在push时哪些文件可以忽略，需要拷贝； .git/：主题和站点都有，标志这是一个git项目，不需要拷贝； node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； public：hexo g生成的静态网页，不需要拷贝； .deploy_git：同上，hexo g也会生成，不需要拷贝； db.json：文件，不需要拷贝。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/categories/互联网/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"坐过山车的人","slug":"坐过山车的人","date":"2019-01-10T09:57:55.000Z","updated":"2019-06-02T05:06:00.000Z","comments":true,"path":"坐过山车的人/","link":"","permalink":"http://yoursite.com/坐过山车的人/","excerpt":"距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。","text":"距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。 前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。 我们乘坐过山车飞向未来，他和我的手里各捏着一张票，那是飞向未来的小舢板，起伏的波浪是我无畏的想象力。乘坐我的想象力，他们尽情蹂躏这些无辜的女孩和男孩，这些无辜的小狗和小猫。在波浪之下，在波浪的下面一直匍匐着衰弱的故事人，他曾经是最伟大的创造者，匍匐在最下面的飞得最高，全是痛苦，全部都是痛苦。那些与我耳语者，个个聪明无比，他们说智慧来自痛苦，他们说：来，给你智慧之路。哦，每一个坐过山车的人都是过山车建造厂的工人，每一双手都充满智慧，是痛苦的工艺匠。他们也制造不同的心灵，这些心灵里孕育着奖励，那些渴望奖励的人，那些最智慧的人，他们总在沉默，不停地被从过山车上推下去，在空中飘荡，在飘荡中，我们接吻，就像那些恋人，那些被压缩在词典册页中的爱情故事，还有家庭，人间的互相拯救。如果存在一个空间，漂浮着无数列过山车，痛苦的过山车…… ——马雁：《我们乘坐着过山车飞向未来》 元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。 在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。 武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。 这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。 等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。 生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。 和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"诗歌","slug":"诗歌","permalink":"http://yoursite.com/tags/诗歌/"}]}]}