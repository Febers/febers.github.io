<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 反射详解]]></title>
    <url>%2FJava-%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。 使用Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Apple &#123; private int price; public Apple()&#123;&#125; public Apple(int price) &#123; this.price = price; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; //正常调用 Apple apple = new Apple(); apple.setPrice(10); System.out.println("Price is " + apple.getPrice()); //反射调用 Class clazz = Class.forName("Apple"); //使用 getFields() 无法获取私有属性 Field[] fields = clazz.getDeclaredFields(); for (Field field: fields) &#123; System.out.println("Field is " + field.getName()); &#125; Method setPriceMethod = clazz.getMethod("setPrice", int.class); Constructor appleConstructor = clazz.getConstructor(); Object appleObj = appleConstructor.newInstance(); //Constructor appleConstructor = clazz.getConstructor(int.class); //获得有参构造器 //Object appleObj = appleConstructor.newInstance(int.class) //调用有参构造器 setPriceMethod.invoke(appleObj, 12); Method getPriceMethod = clazz.getMethod("getPrice"); System.out.println("Price is " + getPriceMethod.invoke(appleObj)); &#125;&#125; API类的实例化和构造函数 获取公有构造函数，不包括父类，Class.classpublic Constructor&lt;?&gt;[] getConstructors()public Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 获取当前类构造函数，忽略修饰符public Constructor&lt;?&gt;[] getDeclaredConstructors()public Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 构造函数调用，Constructor.classpublic T newInstance(Object… initargs) 忽略修饰符，强制调用public void setAccessible(boolean flag) 类成员变量的获取 获取公有变量，包括父类，Class.classpublic Field[] getFields()public Field getField(String name) 获取当前类成员变量，忽略修饰符public Field[] getDeclaredFields()public Field getDeclaredField(String name) 成员变量赋值，Field.class//obj为实例对象public void set(Object obj,Object value) 忽略修饰符，强制调用public void setAccessible(boolean flag) 类方法的获取 获取公有方法，包括父类，Class.classpublic Method[] getMethods()public Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 获取当前类方法，忽略修饰符public Method[] getDeclaredMethods()public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 方法调用，Method.class//obj为类实例化对象，如果为静态方法obj为Nullinvoke(Object obj, Object… args) 忽略修饰符，强制调用public void setAccessible(boolean flag) 原理RTTI和Class对象RTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。 很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，但是现有的方法只需要将 Fruit 作为参数，如果这时传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特备是在用接口类型作为参数的时候，向上转型更是被频繁使用。 而这些类型信息是通过一个特殊对象Class（java.lang.Class）实现的，它包含跟类相关的信息。 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。 加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。 连接： 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 获取 Class 对象的方式有三种 Object 类的 getClass() 方法 数据类型的静态属性 class Class类中的静态方法public static Class forName(String className)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据结构的简单Java实现]]></title>
    <url>%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95Java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[引言JDK 中提供了很多数据结构，如下所示 Collection├ List│ ├ LinkedList│ ├ ArrayList│ └ Vector│ └Stack└ Set Map├ Hashtable├ HashMap└ WeakHashMap 本文将进行部分数据结构的简单实现。 Stack12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MyStack&lt;T&gt; &#123; private Object[] dataArray; private int maxSize; private int nowSize = 0; public MyStack() &#123; this(10); &#125; public MyStack(int initialCapacity) &#123; maxSize = initialCapacity; dataArray = new Object[maxSize]; &#125; public void push(T data) &#123; if (size() &gt;= maxSize) &#123; resize(); &#125; dataArray[nowSize++] = data; &#125; public T pop() &#123; if (empty()) &#123; return null; &#125; return (T)dataArray[--nowSize]; &#125; public T peek() &#123; if (empty()) &#123; return null; &#125; return (T)dataArray[nowSize-1]; &#125; public int search(T target) &#123; int p = nowSize; while (p &gt;= 0) &#123; if (dataArray[p] == target) &#123; return p; &#125; p--; &#125; return -1; &#125; private void resize() &#123; maxSize = maxSize &lt;&lt; 1; Object[] newArray = new Object[maxSize]; for (int i = 0; i &lt; dataArray.length; i++) &#123; newArray[i] = dataArray[i]; &#125; this.dataArray = newArray; &#125; public int size() &#123; return nowSize; &#125; public boolean empty() &#123; return nowSize == 0 ? true : false; &#125;&#125; Queue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyQueue&lt;T&gt; &#123; private Object[] dataArray; private int maxSize; private int front; private int rear; public MyQueue() &#123; this(10); &#125; public MyQueue(int initialSize) &#123; maxSize = initialSize; dataArray = new Object[maxSize]; front = rear = 0; &#125; public void enqueue(T newData) &#123; if (size() &gt;= maxSize) &#123; resize(); &#125; //非循环队列 dataArray[rear++] = newData; //循环队列 //dataArray[rear] = newData; //rear = (rear+1) % maxSize; &#125; public T dequeue() &#123; if (empty()) &#123; return null; &#125; T value = (T)dataArray[front]; //非循环队列 dataArray[front++] = null; //循环队列 //dataArray[front] = null; //front = (front+1) % maxSize; return value; &#125; public void resize() &#123; maxSize = maxSize &lt;&lt; 1; Object[] temp = new Object[maxSize]; for (int i = 0; i &lt; dataArray.length; i++) &#123; temp[i] = dataArray[i]; &#125; dataArray = temp; &#125; public int size() &#123; return Math.abs(front - rear); &#125; public boolean empty() &#123; return front == rear ? true : false; &#125;&#125; BinaryTree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class MyBinaryTree&lt;T&gt; &#123; private Node root; class Node &#123; private int key; private T value; private Node leftChild; private Node rightChild; public Node(int key, T value) &#123; this.key = key; this.value = value; &#125; &#125; public Node find(int key) &#123; Node currentNode = root; while (currentNode != null &amp;&amp; currentNode.key != key) &#123; if (key &lt; currentNode.leftChild.key) &#123; currentNode = currentNode.leftChild; &#125; else &#123; currentNode = currentNode.rightChild; &#125; &#125; return currentNode; &#125; public void insert(int key, T value) &#123; if (root == null) &#123; root = new Node(key, value); return; &#125; Node currentNode = root; Node parentNode = root; Boolean isLeftChild = true; while (currentNode != null) &#123; parentNode = currentNode; if (key &lt; currentNode.key) &#123; currentNode = currentNode.leftChild; isLeftChild = true; &#125; else &#123; currentNode = currentNode.rightChild; &#125; &#125; Node newNode = new Node(key, value); if (isLeftChild) &#123; parentNode.leftChild = newNode; &#125; else &#123; parentNode.rightChild = newNode; &#125; &#125; public boolean delete(int key) &#123; Node currentNode = root; //待删除节点 Node parentNode = root; //待删除节点的父节点 Boolean isLeftChild = true; while (currentNode != null &amp;&amp; currentNode.key != key) &#123; parentNode = currentNode; if (key &lt; currentNode.key) &#123; currentNode = currentNode.leftChild; isLeftChild = true; &#125; else &#123; currentNode = currentNode.rightChild; isLeftChild = false; &#125; &#125; if (currentNode == null) &#123; return false; &#125; //删除节点为叶子节点 if (currentNode.leftChild == null &amp;&amp; currentNode.rightChild == null) &#123; if (currentNode == root) &#123; root = null; &#125; else if (isLeftChild) &#123; parentNode.leftChild = null; &#125; else &#123; parentNode.rightChild = null; &#125; &#125; else if (currentNode.rightChild == null) &#123; //待删除节点只有左子节点 if (currentNode == root) &#123; root = currentNode.leftChild; &#125; else if (isLeftChild) &#123; parentNode.leftChild = currentNode.leftChild; &#125; else &#123; parentNode.rightChild = currentNode.leftChild; &#125; &#125; else if (currentNode.leftChild == null) &#123; //待删除节点只有右子节点 if (currentNode == root) &#123; root = currentNode.rightChild; &#125; else if (isLeftChild) &#123; parentNode.leftChild = currentNode.rightChild; &#125; else &#123; parentNode.rightChild = currentNode.rightChild; &#125; &#125; else &#123; //待删除节点既有左子节点又有右子节点 Node directPostNode = getDirectPostNode(currentNode); currentNode.key = directPostNode.key; currentNode.value = directPostNode.value; &#125; return true; &#125; /** * 获得待删除节点的直接后继节点 * * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点 * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点 * 并删除 key 值为 10 的节点的中序后继节点， * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点， * 所以此中序后继节点一定不含子节点或者只含有一个右孩子 * * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11）， * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值 * * @param delNode 待删除节点 * @return 返回直接后继节点 */ private Node getDirectPostNode(Node delNode) &#123; Node parentNode = delNode; //保存待删除节点的直接后继节点的父节点 Node direcrPostNode = delNode; //保存待删除节点的直接后继节点 Node currentNode = delNode.rightChild; while (currentNode != null) &#123; parentNode = direcrPostNode; direcrPostNode = currentNode; currentNode = currentNode.leftChild; &#125; if (direcrPostNode != delNode.rightChild) &#123; //从树中删除此直接后继节点 parentNode.leftChild = direcrPostNode.rightChild; direcrPostNode.rightChild = null; &#125; return direcrPostNode; &#125; public void preOrder(Node rootNode) &#123; if (rootNode != null) &#123; System.out.println(rootNode.key + ": " + rootNode.value); preOrder(rootNode.leftChild); preOrder(rootNode.rightChild); &#125; &#125; public void inOrder(Node rootNode) &#123; if (rootNode != null) &#123; preOrder(rootNode.leftChild); System.out.println(rootNode.key + ": " + rootNode.value); preOrder(rootNode.rightChild); &#125; &#125; public void postOrder(Node rootNode) &#123; if (rootNode != null) &#123; preOrder(rootNode.leftChild); preOrder(rootNode.rightChild); System.out.println(rootNode.key + ": " + rootNode.value); &#125; &#125;&#125; HashMap]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 消息机制详解]]></title>
    <url>%2FAndroid-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言Android 的消息机制，主要是指 Handler 的运行机制。 ANRApplication Not Responding，即应用程序无响应，在介绍多线程的相关知识之前先了解 ANR。 原因Android系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。 以下四种条件都可以造成 ANR InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件 BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive方法中10秒没有处理完成，后台则为60秒。 Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。 ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。 分析和解决分析 查看 log 信息 Java 线程调用分析，jstack {pid}，其中 pid 为虚拟机进程 id，可以通过jps查看当前所有线程。 查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令./adb pull /data/anr/traces.txt查看 解决 避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。 避免在主线程 query provider、不要滥用SharePreferences 文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。 BroadcastReciever 的onRecieve不要进行耗时操作。 Handler 机制由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的checkThread进行验证1234567void checkThread() &#123; if (mThread != Thread.currrentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views"); &#125;&#125; 使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？ 答案是使用 Handler 。 创建123456789101112131415161718192021222324//接收消息@SuppressLint("HandlerLeak")private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if (msg.what == 1) &#123; log.e("MSG", "收到消息")； &#125; &#125;&#125;;//发送消息new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); mHandler.sendEmptyMessage(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start(); 使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用1234567891011121314151617MyHandler hander = new MyHandler(context);static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; out; MyHandler(Context ctx) &#123; super(); out = new WeakReference&lt;&gt;(ctx); &#125; @Override public void handleMessage(Message msg) &#123; if (out.get() != null) &#123; //进行消息处理 &#125; &#125;&#125; Handler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。 Handler观察 Handler 的构造函数123456789101112public Handler(Callback callback, boolean async) &#123; ...... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called" + " Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用Looper.prepare的线程内创建 handler。 不过，为什么在主线程中创建 Handler 不需要调用Looper.prepare和Looper.loop方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的main方法，在其中调用了prepareMainLooper1234567891011121314151617public static void main(String[] args) &#123; ...... Looper.prepareMainLooper(); ...... Looper.loop(); ......&#125;public static void prepareMainLooper() &#123; prepare(false); //quitAllowed 参数传false synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; 关于 ActivityThread：Android线程管理（二）——ActivityThread MessageQueue顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。 由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。 当 Handler 调用sendMessage时，最后会调用到 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 查看enqueueMessage方法， 1234567891011121314151617181920212223242526272829303132333435363738boolean enqueueMessage(Message msg, long when) &#123; ...... synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; ...... &#125; return true;&#125; 首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒 如果队列已有消息，则根据 Message 创建的时间进行插入 Looper通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用Looper.prepare方法使消息循环初始化，并且调用Looper.loop使消息循环一直处于运行状态，取出 MessageQueue 中的消息分发给 Handler。 12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 可以看到，prepare(boolean quitAllowed)实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当Looper.prepare执行完毕之后才可以执行loop方法123456789101112131415161718public static void loop() &#123; //获取当前线程绑定的Looper final Looper me = myLooper(); //当前线程的MessageQueue final MessageQueue queue = me.mQueue; ...... //循环从 MessageQueue 取出消息. for (;;) &#123; Message msg = queue.next(); ...... //将消息分发出去 msg.target.dispatchMessage(msg); ...... //将消息回收 msg.recycle(); &#125;&#125; 可以看到，如果消息队列的 next 返回了新消息，就会调用msg.target.dispatchMessage(msg)，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 首先检查 Message 的 callBack 是否为空，不为空则handlerCallback(msg)，最终调用 callback 的run方法 如果为空，检查 mCallBack 是否为空，不为空则调用它的handleMassage，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。 如果都为空，调用 Handler 内部的handleMessage，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。 ThreadLocal一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。 使用一个简单的例子演示 ThreadLocal 的真正含义1234567891011121314151617181920212223//新建一个 boolean 类型的变量private ThreadLocal&lt;Boolean&gt; value = new ThreadLocal&lt;&gt;();//在主线程中将其设为 truevalue.set(true);log.e("MainThread", value.get());//子线程中设为 falsenew Thread("Thread1") &#123; @Override public void run() &#123; value.set(false); log.e("Thread1", value.get()); &#125;&#125;//另一个子线程直接读取new Thread("Thread2") &#123; @Override public void run() &#123; log.e("Thread2", value.get()); &#125;&#125; 运行日志如下 MainThread, trueThread1, falseThread2, null 由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：Java并发编程：深入剖析ThreadLocal 总结Handler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的runOnUiThread 12345678public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; ...... &#125; 比如 View 的post 123456789public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); ① &#125; // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); ② return true; &#125; 最后用一张图来结束本文]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 排序算法]]></title>
    <url>%2FJava-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引言排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。 稳定性对于一个数组a {6,2,4,6,1}，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种 1 2 4 6 6 a[4] a[1] a[2] a[0] a[3] a[4] a[1] a[2] a[3] a[0] 如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法 冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等 否则，属于不稳定的排序算法 选择排序，希尔排序，堆排序，快速排序等 冒泡排序1234567891011121314151617181920212223/** * 冒泡排序，O(n^2) * 每一次内层循环中，两两比较，将较大的数放到后面 * * @param a 待排序数据 */public static void bubbleSort(int[] a) &#123; int length = a.length; int i = 0; int temp; for ( ; i &lt; length - 1; i++) &#123; int j = 0; for ( ; j &lt; length - 1 - i; j++) &#123; if (a[j] &gt; a[j+1]) &#123; temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125;&#125; 插入排序插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序 直接插入排序123456789101112131415161718192021/** * 直接插入排序，O(n^2) * i从第一个元素开始，默认i前面的序列已经排好序 * 取出i的下一个元素，从后往前比较，找到适合的位置就插入 * * @param a 待排序序列 */public static void insertSort(int[] a) &#123; int length = a.length; for (int i = 0; i &lt; length; i++) &#123; int temp = a[i]; for (int j = i; j &gt; 0; j--) &#123; if (a[j] &lt; a[j-1]) &#123; a[j] = a[j-1]; a[j-1] = temp; &#125; &#125; &#125;&#125; 折半插入排序1234567891011121314151617181920212223242526272829303132/** * 折半插入排序，O(n^2) * 对直接插入排序算法进行了改进 * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要 * 折半插入排序则使用了折半查找/二分查找 * * Arrays类的binarySearch()方法便是折半查找的实现 * * @param a 待排序序列 */public static void binaryInsertSort(int[] a) &#123; int length = a.length; for (int i = 0; i &lt; length; i++) &#123; int temp = a[i]; int low = 0; int high = i-1; while (low &lt;= high) &#123; int middle = (low+high) / 2; if (a[middle] &lt; temp) &#123; low = middle+1; &#125; else &#123; high = middle-1; &#125; &#125; for(int j = i-1; j &gt;= low; j--) &#123; //元素后移，为插入temp做准备 a[j+1] = a[j]; &#125; a[low] = temp; &#125;&#125; 希尔排序1234567891011121314151617181920212223242526272829303132333435/** * 希尔排序，也称 递减增量排序，O(n*(logn)^2) * 对于n个元素的序列，假设增量为increment * 从第一个元素开始，每隔increment取一个元素组成一个子序列 * 对每个子序列进行直接插入排序，increment /= 2 * 重复上述过程，直至increment为1 * * @param a 待排序序列 */public static void shellSort(int[] a) &#123; int length = a.length; // increment为增量，每次减为原来的一半，直至为1 for (int increment = length / 2; increment &gt; 0; increment /= 2) &#123; // 共increment个组，对每一组都执行直接插入排序 for (int i = 0; i &lt; increment; i++) &#123; for (int j = i + increment; j &lt; length; j += increment) &#123; // 如果a[j] &lt; a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。 if (a[j] &lt; a[j - increment]) &#123; int temp = a[j]; int k = j - increment; while (k &gt;= 0 &amp;&amp; a[k] &gt; temp) &#123; a[k + increment] = a[k]; k -= increment; &#125; a[k + increment] = temp; &#125; &#125; &#125; &#125;&#125; 桶排序（基数排序）12345678910111213141516171819202122232425262728293031323334353637/** * 基数排序，也称桶排序，O(d(k+n)) * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。 * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 * * @param a 待排序数组 * @param d 位数，如果最大数为9527，则d为10000，如果为7，则d为10 */public static void radixSort(int[] a,int d) &#123; int n = 1; //代表位数对应的数：1,10,100... int k = 0; //保存每一位排序后的结果用于下一位的排序输入 int length = a.length; int[][] bucket = new int[10][length]; //排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里 int[] order = new int[length]; //用于保存每个桶里有多少个数字 while(n &lt; d) &#123; for(int num : a) &#123; //将数组array里的每个数字放在相应的桶里 int digit = (num/n)%10; bucket[digit][order[digit]] = num; order[digit]++; &#125; int i = 0; for( ; i&lt;length; i++) &#123; //将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果 if(order[i] != 0) &#123; //这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中 int j = 0; for( ; j &lt; order[i]; j++) &#123; a[k] = bucket[i][j]; k++; &#125; &#125; order[i]=0; //将桶里计数器置0，用于下一次位排序 &#125; n *= 10; k = 0; //将k置0，用于下一轮保存位排序结果 &#125;&#125; 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 归并排序，O(nlog(n)) * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1 * 然合并以上序列 * * @param array * @param left * @param right */public static void mergeSort(int[] array, int left, int right) &#123; if (left &lt; right) &#123; int center = (left + right) / 2; mergeSort(array, left, center); mergeSort(array, center+1, right); merge(array, left, center, right); &#125;&#125;static void merge(int[] array, int low, int mid, int high) &#123; int[] tempArray = new int[high - low + 1]; int temp = 0; int i = low; int j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (array[i] &lt;= array[j]) &#123; tempArray[temp++] = array[i++]; &#125; else &#123; tempArray[temp++] = array[j++]; &#125; &#125; while (i &lt;= mid) &#123; //此时右边已到底 tempArray[temp++] = array[i++]; &#125; while (j &lt;= high) &#123; //此时左边已到底 tempArray[temp++] = array[j++]; &#125; //将新数组中的数 覆盖原数组low之后的数据 for (int k = 0; k &lt; tempArray.length; k++) &#123; array[k+low] = tempArray[k]; &#125;&#125; 选择排序12345678910111213141516171819202122232425/** * 选择排序，O(n^2) * 遍历整个序列，将最小的数放在最前面 * 遍历剩下的序列，将最小的数放在最前面，重复上述过程 * * @param a 待排序序列 */ public static void selectSort(int[] a)&#123; int length = a.length; int i = 0; for( ; i &lt; length; i++)&#123; //外层循环 int temp = a[i]; int position = i; int j = i+1; for( ; j &lt; length; j++) &#123; //往后遍历，找到最小的值以及其位置 if(a[j] &lt; temp) &#123; temp = a[j]; position = j; &#125; &#125; a[position]=a[i]; //进行交换 a[i] = temp; &#125; 快速排序12345678910111213141516171819202122232425262728293031323334353637/** * 快速排序，O(nlog(n)) * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分 * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序 * * @param a 待排序序列 * @param start 序列开始值 * @param end 序列结束值 */public static void quickSort(int[] a, int start, int end) &#123; int baseNum = a[start]; int temp; int left = start; int right = end; do &#123; while (a[left] &lt; baseNum &amp;&amp; left &lt; end) &#123; left++; &#125; while (a[right] &gt; baseNum &amp;&amp; right &gt; start) &#123; right--; &#125; if (left &lt;= right) &#123; //左边出现大于基准值或者右边出现小于基准值，且left&lt;=right temp = a[left]; a[left] = a[right]; a[right] = temp; left++; right--; &#125; &#125; while (left &lt;= right); if (start &lt; right) &#123; quickSort(a, start, right); &#125; if (end &gt; left) &#123; quickSort(a, left, end); &#125;&#125; 二叉树排序通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\log_2 n)$近似于折半查找。 如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class BinarySortTree &#123; static class Node &#123; private Comparable data; private Node left; private Node right; public Node(Comparable data) &#123; this.data = data; &#125; public void addNode(Node newNode) &#123; if (newNode.data.compareTo(this.data) &lt; 0) &#123; if (left == null) &#123; left = newNode; &#125; else &#123; left.addNode(newNode); &#125; &#125; else &#123; if (right == null) &#123; right = newNode; &#125; else &#123; right.addNode(newNode); &#125; &#125; &#125; public void printNode() &#123; //中序遍历 if (left != null) &#123; left.printNode(); &#125; System.out.println(this.data); if (right != null) &#123; right.printNode(); &#125; &#125; &#125; private Node root; public void add(Comparable data) &#123; //向二叉树中插入元素 Node node = new Node(data); if (root == null) &#123; root = node; &#125; else &#123; root.addNode(node); &#125; &#125; public void print() &#123; root.printNode(); &#125;&#125; 调用如下12345678public static void main(String[] args) &#123; int[] a = &#123;12,0,34,5,2,8,456&#125;; BinarySortTree tree = new BinarySortTree(); for (int i : a) &#123; tree.add(i); &#125; tree.print();&#125; 查找算法二分查找只能对有序序列进行查找123456789101112131415161718192021222324252627public static int binarySearch(int[] array, int low, int high, int target) &#123; if (low &gt; high) return -1; int mid = low + (high - low) / 2; if (array[mid] &gt; target) return binarySearch(array, low, mid - 1, target); if (array[mid] &lt; target) return binarySearch(array, mid + 1, high, target); return mid;&#125;public static int bSearchWithoutRecursion(int a[], int key) &#123; int low = 0; int high = a.length - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (a[mid] &gt; key) high = mid - 1; else if (a[mid] &lt; key) low = mid + 1; else return mid; &#125; return -1;&#125; 顺序查找实现较简单，略过 二叉树查找可以通过构建一个二叉搜索树实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View 的工作原理]]></title>
    <url>%2FAndroid-View-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[引言 工作原理ViewRoot 和 DecorViewMeasureSpec工作流程measure 过程layout 过程draw 过程自定义 View]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC 机制详解]]></title>
    <url>%2FAndroid-IPC-%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。 应用场景只有在多进程场景下才需要 IPC 机制。 多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。 使用多进程会造成如下的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences 可靠性下降 Application 会多次创建 对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。 基础概念Serializable 接口Java 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个seriaVersionUID即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。 1234567891011121314151617public class User implements Serializable &#123; private static final long seriaVersionUID = 519067123721295773L ...&#125;//序列化过程User user = new User("name", 18);ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream("file.txt"));out.writeObject(user);out.close//反序列化过程ObjectInputStream in = new ObjectInputStream( new FileInputStream("file.txt"));User user = (User) in.readObject();in.close 使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。 Java 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。 Parcelable 接口Android 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。 其与 Serializable 的区别在于 Parcelable 使用更复杂，后者如上面的代码，足够简洁。 使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。 使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。 标准写法如下12345678910111213141516171819202122232425262728293031323334353637public class User implements Parcelable &#123; private String name; private int id; protected User(Parcel in) &#123; name = in.readString(); id = in.readInt(); &#125; /* 实例化静态变量CREATOR 从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法 */ public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeInt(id); &#125;&#125; 通过 Intent 传递和获取数据1234567//传递User user = new User("Name", 18);Intent intent = new Intent();intent.putExtra("data", user);//使用User user = getIntent().getParcelableExtra("data"); BinderBinder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。 从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。 从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。 更多关于 Binder：图解Android - Binder 和 Service 实现方式BundleBundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。 文件共享利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。 缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。 SocketSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。 AIDL概念Android Interface Definition Language，Android 接口定义语言。 数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下 Java 中的八种基本数据类型、String、CharSequence。List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。 定向tag：AIDLv中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。 in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。 关于更多：你真的理解AIDL中的in，out，inout么? 两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。 实现第一类 AIDL 文件：1234567// Book.aidl// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用// 注意：Book.aidl 与 Book.java的包名应当是一样的package com.febers.aidldemo;//注意parcelable是小写parcelable Book; 自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 writeToParcel方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现readFromParcel方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。 第二类 AIDL 文件：1234567891011121314151617181920// BookManager.aidlpackage com.lypeer.ipcclient;//导入所需要使用的非默认支持数据类型的包import com.febers.aidldemo.Book;interface BookManager &#123; //所有的返回值前都不需要加任何东西，不管是什么数据类型 List&lt;Book&gt; getBooks(); Book getBook(); int getBookCount(); //传参时，Java基本数据类型、String 以及 CharSequence 之外的类型 //都需要在前面加上定向tag，具体加什么量需而定 void setBookPrice(in Book book , int price) void setBookName(in Book book , String name) void addBookIn(in Book book); void addBookOut(out Book book); void addBookInout(inout Book book);&#125; 完成上面的步骤之后，build项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class AIDLService extends Service &#123; public final String TAG = this.getClass().getSimpleName(); //包含Book对象的list private List&lt;Book&gt; mBooks = new ArrayList&lt;&gt;(); //由AIDL文件生成的BookManager private final BookManager.Stub mBookManager = new BookManager.Stub() &#123; @Override public List&lt;Book&gt; getBooks() throws RemoteException &#123; synchronized (this) &#123; Log.e(TAG, "invoking getBooks() method , now the list is : " + mBooks.toString()); if (mBooks != null) &#123; return mBooks; &#125; return new ArrayList&lt;&gt;(); &#125; &#125; @Override public void addBook(Book book) throws RemoteException &#123; synchronized (this) &#123; if (mBooks == null) &#123; mBooks = new ArrayList&lt;&gt;(); &#125; if (book == null) &#123; Log.e(TAG, "Book is null in In"); book = new Book(); &#125; //尝试修改book的参数，主要是为了观察其到客户端的反馈 book.setPrice(2333); if (!mBooks.contains(book)) &#123; mBooks.add(book); &#125; //打印mBooks列表，观察客户端传过来的值 Log.e(TAG, "invoking addBooks() method , now the list is : " + mBooks.toString()); &#125; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); Book book = new Book(); book.setName("Android开发艺术探索"); book.setPrice(28); mBooks.add(book); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; Log.e(getClass().getSimpleName(), String.format("on bind,intent = %s", intent.toString())); return mBookManager; &#125;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class AIDLActivity extends AppCompatActivity &#123; //由AIDL文件生成的 Java 类 private BookManager mBookManager = null; //标志当前与服务端连接状况的布尔值，false为未连接，true为连接中 private boolean mBound = false; //包含Book对象的list private List&lt;Book&gt; mBooks; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_aidl); &#125; /** * 按钮的点击事件，点击之后调用服务端的addBookIn方法 * * @param view */ public void addBook(View view) &#123; //如果与服务端的连接处于未连接状态，则尝试连接 if (!mBound) &#123; attemptToBindService(); Toast.makeText(this, "当前与服务端处于未连接状态，正在尝试重连，请稍后再试", Toast.LENGTH_SHORT).show(); return; &#125; if (mBookManager == null) return; Book book = new Book(); book.setName("APP研发录In"); book.setPrice(30); try &#123; mBookManager.addBook(book); Log.e(getLocalClassName(), book.toString()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; /** * 尝试与服务端建立连接 */ private void attemptToBindService() &#123; Intent intent = new Intent(); intent.setAction("com.febers.aidl"); intent.setPackage("com.febers.aidldemo"); bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStart() &#123; super.onStart(); if (!mBound) &#123; attemptToBindService(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if (mBound) &#123; unbindService(mServiceConnection); mBound = false; &#125; &#125; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.e(getLocalClassName(), "service connected"); mBookManager = BookManager.Stub.asInterface(service); mBound = true; if (mBookManager != null) &#123; try &#123; mBooks = mBookManager.getBooks(); Log.e(getLocalClassName(), mBooks.toString()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.e(getLocalClassName(), "service disconnected"); mBound = false; &#125; &#125;;&#125; 当然不要忘记在 Manifest 文件中注册 Service。控制台显示信息如下： //服务端的 log 信息1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333] //客户端的 log 信息1，service connected2，[name : Android开发艺术探索 , price : 28]3，name : APP研发录In , price : 2333 MessagerMessager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。 概念Messenger 有两个构造函数，分贝以 Handler 和 Binder 为参数1234567private final IMessenger mTarget;public Messenger(Handler target) &#123; mTarget = target.getIMessenger();&#125;public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target); //和前面的 AIDL 很相似吧&#125; Handler.getIMessenger源码：123456789final IMessenger getIMessenger() &#123; synchronized (mQueue) &#123; if (mMessenger != null) &#123; return mMessenger; &#125; mMessenger = new MessengerImpl(); return mMessenger; &#125;&#125; IMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法send(android.os.Message msg)。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：123456private final class MessengerImpl extends IMessenger.Stub &#123; public void send(Message msg) &#123; msg.sendingUid = Binder.getCallingUid(); Handler.this.sendMessage(msg); &#125;&#125; 所以可以使用Handler.handlerMessage接收消息。Messenger 中对send的实现如下：123public void send(Message message) throws RemoteException &#123; mTarget.send(message);&#125; Messenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部send方法实际上是调用 IMessenger 实现的send方法。 Messenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。 实现服务端123456789101112131415161718192021222324252627282930313233343536public class MessengerService extends Service &#123; private final String TAG = this.getClass().getSimpleName(); Messenger mMessenger = new Messenger(new Handler() &#123; @Override public void handleMessage(final Message msg) &#123; if (msg != null &amp;&amp; msg.arg1 == 9527) &#123; if (msg.getData() == null) &#123; return; &#125; String content = (String) msg.getData().get("MSG_CONTENT"); //接收客户端的消息 Log.e(TAG, "Message from client: " + content); //回复消息给客户端 Message replyMsg = Message.obtain(); replyMsg.arg1 = 9528; Bundle bundle = new Bundle(); bundle.putString("MSG_CONTENT", "已收到消息"); replyMsg.setData(bundle); try &#123; msg.replyTo.send(replyMsg); //回信 &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); @Nullable @Override public IBinder onBind(final Intent intent) &#123; return mMessenger.getBinder(); &#125;&#125; 客户端代码片段12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MessagerActivity extends AppCompatActivity &#123; Messenger mClientMessenger = new Messenger(new Handler() &#123; @Override public void handleMessage(final Message msg) &#123; if (msg != null &amp;&amp; msg.arg1 == 9528)&#123; if (msg.getData() == null)&#123; return; &#125; String content = (String) msg.getData().get("MSG_CONTENT"); Log.e(TAG, "Message from server: " + content); &#125; &#125; &#125;); //服务端的 Messenger private Messenger mServerMessenger; private ServiceConnection mMessengerConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(final ComponentName name, final IBinder service) &#123; mServerMessenger = new Messenger(service); &#125; @Override public void onServiceDisconnected(final ComponentName name) &#123; mServerMessenger = null; &#125; &#125;; //发送消息 public void sendMsg() &#123; String msgContent = "消息"； Message message = Message.obtain(); message.arg1 = 9527; Bundle bundle = new Bundle(); bundle.putString("MSG_CONTENT", msgContent); message.setData(bundle); message.replyTo = mClientMessenger; //指定回信人是客户端定义的 try &#123; mServerMessenger.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ContentProvider主要用于不同的应用程序之间实现数据共享功能]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>多进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 动画详解]]></title>
    <url>%2FAndroid-%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。 View Animation视图动画的作用对象是 View，可分为补间动画和帧动画。 补间动画动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。 XML 方式创建一个 set.xml 文件，通过动画集合标签&lt;set&gt;将四种效果结合起来12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;--动画集合interpolator 表示所采用的的差值器，其影响动画的速度，可以不指定shareInterpolator 表示集合中的动画是否和集合共享同一个差值器--&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:fillAfter="true" android:shareInterpolator="true" android:repeatMode="reverse"&gt; &lt;!-- 缩放动画 fromXScale 表示水平方向缩放的起始值 toXScale 表示水平方向的结束值 fillAfter 表示动画显示结束保持最后一帧--&gt; &lt;scale android:duration="1000" android:fillAfter="true" android:fromXScale="0.5" android:fromYScale="0.5" android:toXScale="1" android:toYScale="1" android:repeatCount="infinite"/&gt;&lt;!--次数 ,infinite 为无线循环播放--&gt; &lt;!-- 透明度动画 fromAlpha 表示起始透明度 toAlpha 表示结束透明度--&gt; &lt;alpha android:duration="2000" android:fillAfter="true" android:fromAlpha="0.7" android:toAlpha="1"/&gt; &lt;!--旋转动画 fromDegrees 表示起始角度 toDegrees 表示结束角度--&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="90" android:fillAfter="true" android:duration="1000"/&gt; &lt;!--平移动画--&gt; &lt;translate android:fromXDelta="0" android:fromYDelta="0" android:toXDelta="100%" android:toYDelta="-100%" android:fillAfter="true" android:duration="2000" /&gt;&lt;/set&gt; 使用以上动画的方式如下12Animation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);view.startAnimation(anim); Java 代码方式使用 Java 代码实现动画的方式如下1234567891011121314151617181920212223242526public void startAnimationSet() &#123; //创建动画，参数表示他的子动画是否共用一个插值器 AnimationSet animationSet = new AnimationSet(true); //添加动画 animationSet.addAnimation(new AlphaAnimation(1.0f, 0.0f)); //设置插值器 animationSet.setInterpolator(new LinearInterpolator()); //设置动画持续时长 animationSet.setDuration(3000); //设置动画结束之后是否保持动画的目标状态 animationSet.setFillAfter(true); //设置动画结束之后是否保持动画开始时的状态 animationSet.setFillBefore(false); //设置重复模式 animationSet.setRepeatMode(AnimationSet.REVERSE); //设置重复次数 animationSet.setRepeatCount(AnimationSet.INFINITE); //设置动画延时时间 animationSet.setStartOffset(2000); //取消动画 animationSet.cancel(); //释放资源 animationSet.reset(); //开始动画 view.startAnimation(animationSet);&#125; 自定义除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的initialize和applyTransformation方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 特殊使用View 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。 帧动画帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。 首先需要定义一个 XML 文件frame_animation.xml12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@mipmap/image1" android:duration="100" /&gt; &lt;item android:drawable="@mipmap/image2" android:duration="100" /&gt; &lt;item android:drawable="@mipmap/iamge2" android:duration="100" /&gt;&lt;/animation-list&gt; 然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可123view.setBackgroundResource(R.drawable.frame_animation)；AnimationDrawable drawable = (AnimationDrawable) view.getBackground();drawable.start(); Property Animation属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在： 补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。 补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。 与补间动画类似，属性动画也需要定义几个方面的属性： 动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。 动画插值方式。通过 android:interploator 指定。 动画重复次数。通过 android:repeatCount 指定。 重复行为。通过 android:repeatMode 指定。 动画集。在属性资源文件中通过 &lt;set&gt; 来组合。 帧刷新率。指定多长时间播放一帧。默认为 10 ms。 API ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。 ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。 AnimatorSet：Animator 的子类，用于组合多个 Animator。 属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。 IntEvaluator：计算 int 类型属性值的计算器。 FloatEvaluator：用于计算 float 类型属性值的计算器。 ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。 TypeEvaluator：可以自定义计算器。 ValueAniamtorValueAnimator 类中有3个重要方法： ValueAnimator.ofInt(int values)ValueAnimator.ofFloat(float values)ValueAnimator.ofObject(int values) ofInt将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator 下面的代码将实现按钮的宽度从 150px 放大到 500px12345678910111213141516171819202122232425 Button mButton = (Button) findViewById(R.id.Button); // 设置属性数值的初始值 &amp; 结束值 // ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500 ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, 500); // 设置动画的播放各种属性 valueAnimator.setDuration(2000); // 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度 // 设置更新监听器，数值每次变化更新都会调用该方法 valueAnimator.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animator) &#123; // 获得每次变化后的属性值 int currentValue = (Integer) animator.getAnimatedValue(); // 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化 mButton.getLayoutParams().width = currentValue; // 刷新视图，即重新绘制 mButton.requestLayout(); &#125; &#125;); valueAnimator.start(); // 启动动画&#125; ofFloat其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）123456789101112131415161718192021public class FloatEvaluator implements TypeEvaluator &#123; /** * 重写evaluate() * * @param fraction 动画完成度（根据它来计算当前动画的值） * @param startValue 动画的初始值 * @param endValue 动画的结束值 * @return */ public Object evaluate(float fraction, Object startValue, Object endValue) &#123; float startFloat = ((Number) startValue).floatValue(); // 初始值过渡到结束值的算法 // 1. 用结束值减去初始值，算出它们之间的差值 // 2. 用上述差值乘以 fraction 系数 // 3. 加上初始值，得到当前动画的值 return startFloat + fraction * (((Number) endValue).floatValue() - startFloat); &#125; &#125; ofObject对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。 但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。 自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。 123456789101112131415161718public class PointEvaluator implements TypeEvaluator &#123; @Override public Object evaluate(float fraction, Object startValue, Object endValue) &#123; // 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象 Point startPoint = (Point) startValue; Point endPoint = (Point) endValue; // 根据fraction来计算当前动画的x和y的值 float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX()); float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY()); // 将计算后的坐标封装到一个新的Point对象中并返回 Point point = new Point(x, y); return point; &#125;&#125; 将属性动画作用到自定义View当中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyView extends View &#123; public static final float RADIUS = 70f;// 圆的半径 private Point currentPoint;// 当前点坐标 private Paint mPaint;// 绘图画笔 // 构造方法，初始化画笔 public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.BLUE); &#125; // 实现绘制逻辑 // 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果 @Override protected void onDraw(Canvas canvas) &#123; // 如果当前点坐标为空(即第一次) if (currentPoint == null) &#123; currentPoint = new Point(RADIUS, RADIUS); // 创建一个点对象(坐标是(70,70)) float x = currentPoint.getX(); float y = currentPoint.getY(); canvas.drawCircle(x, y, RADIUS, mPaint); // 将属性动画作用到View中 Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70) Point endPoint = new Point(700, 1000);// 结束点为(700,1000) ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint); anim.setDuration(5000); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; currentPoint = (Point) animation.getAnimatedValue(); // 每次赋值后就重新绘制，从而实现动画效果 // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次 invalidate(); &#125; &#125;); anim.start(); &#125; else &#123; // 如果坐标值不为0,则画圆 float x = currentPoint.getX(); float y = currentPoint.getY(); canvas.drawCircle(x, y, RADIUS, mPaint); &#125; &#125;&#125; ObjectAnimator继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。ObjectAnimator 与 ValueAnimator类的区别在于 ValueAnimator 类是先改变值，然后手动赋值给对象的属性从而实现动画，属于间接对对象属性进行操作 ObjectAnimator 类是先改变值，然后自动赋值给对象的属性从而实现动画，属于直接对对象属性进行操作 具体使用对于 ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ….values); 其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值 对 Button 进行变换123456ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f); // 效果:常规-&gt;全透明-&gt;常规ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f);......animator.setDuration(5000);animator.start(); 自定义在上面的例子中，我们给ObjectAnimator.ofFloat的第二个参数String property传入alpha、rotation、translationX 和scaleY等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的get/set方法进行的。 所以自定义属性就可以通过为对象设置需要操作属性的set/get方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。 还是对一个球做变换12345678910111213141516171819202122232425262728public class MyView2 extends View &#123; public static final float RADIUS = 100f; private Paint mPaint; private String color; // 设置背景颜色属性 // 设置背景颜色的get() &amp; set()方法 public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; mPaint.setColor(Color.parseColor(color)); // 将画笔的颜色设置成方法参数传入的颜色 invalidate(); &#125; public MyView2(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.BLUE); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawCircle(500, 500, RADIUS, mPaint); &#125;&#125; 实现自定义估值器，完成颜色过渡的逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class ColorEvaluator implements TypeEvaluator &#123; private int mCurrentRed; private int mCurrentGreen ; private int mCurrentBlue ; // 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡 @Override public Object evaluate(float fraction, Object startValue, Object endValue) &#123; String startColor = (String) startValue; String endColor = (String) endValue; // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字 // 那么每个颜色的取值范围是0-255 int startRed = Integer.parseInt(startColor.substring(1, 3), 16); int startGreen = Integer.parseInt(startColor.substring(3, 5), 16); int startBlue = Integer.parseInt(startColor.substring(5, 7), 16); int endRed = Integer.parseInt(endColor.substring(1, 3), 16); int endGreen = Integer.parseInt(endColor.substring(3, 5), 16); int endBlue = Integer.parseInt(endColor.substring(5, 7), 16); // 将初始化颜色的值定义为当前需要操作的颜色值 mCurrentRed = startRed; mCurrentGreen = startGreen; mCurrentBlue = startBlue; // 计算初始颜色和结束颜色之间的差值 // 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢 int redDiff = Math.abs(startRed - endRed); int greenDiff = Math.abs(startGreen - endGreen); int blueDiff = Math.abs(startBlue - endBlue); int colorDiff = redDiff + greenDiff + blueDiff; if (mCurrentRed != endRed) &#123; // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 -&gt;&gt;关注1 mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0, fraction); &#125; else if (mCurrentGreen != endGreen) &#123; mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction); &#125; else if (mCurrentBlue != endBlue) &#123; mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction); &#125; // 将计算出的当前颜色的值组装返回 String currentColor = "#" + getHexString(mCurrentRed) + getHexString(mCurrentGreen) + getHexString(mCurrentBlue); return currentColor; &#125; // 根据fraction值来计算当前的颜色。 private int getCurrentColor(int startColor, int endColor, int colorDiff, int offset, float fraction) &#123; int currentColor; if (startColor &gt; endColor) &#123; currentColor = (int) (startColor - (fraction * colorDiff - offset)); if (currentColor &lt; endColor) &#123; currentColor = endColor; &#125; &#125; else &#123; currentColor = (int) (startColor + (fraction * colorDiff - offset)); if (currentColor &gt; endColor) &#123; currentColor = endColor; &#125; &#125; return currentColor; &#125; // 将10进制颜色值转换成16进制。 private String getHexString(int value) &#123; String hexString = Integer.toHexString(value); if (hexString.length() == 1) &#123; hexString = "0" + hexString; &#125; return hexString; &#125;&#125; 具体调用123ObjectAnimator anim = ObjectAnimator.ofObject(myView2, "color", new ColorEvaluator(), "#0000FF", "#FF0000");anim.setDuration(2000);anim.start(); 此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中setWidth并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过get/set无法改变控件的宽度，也就无法实现动画效果。 解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的get/set方法。12345678910111213141516171819202122ButtonWrapper wrapper = new ViewWrapper(button);ObjectAnimator.ofInt(wrapper, "width", 500) .setDuration(3000) .start();private static class ViewWrapper &#123; private View mTarget; public ViewWrapper(View target) &#123; mTarget = target; &#125; // 为宽度设置get/set public int getWidth() &#123; return mTarget.getLayoutParams().width; &#125; public void setWidth(int width) &#123; mTarget.getLayoutParams().width = width; mTarget.requestLayout(); &#125;&#125; AnimatorSet最后介绍组合动画类，仅展示用法12345678910ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX); ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f); ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(translation).with(rotate).before(alpha); animSet.setDuration(5000); animSet.start(); Spring AnimationSpringAnimation，弹簧动画，位于android.support.animation包中，属性动画位于android.animation.Animator包中，其实通过 BounceInterpolator 或者 OvershootInterpolator 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。 使用之前需要导入com.android.support:support-dynamic-animation包 API12public SpringAnimation(View v, ViewProperty property)public SpringAnimation(View v, ViewProperty property, float finalPosition) 参数分别是操作对应的View，对应的变化属性及最终的位置。 ViewProperty 包括(Z轴支持需要API &gt;= 21)： TRANSLATION_XTRANSLATION_YTRANSLATION_ZSCALE_XSCALE_YROTATIONROTATION_XROTATION_YXYZALPHASCROLL_XSCROLL_Y 在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量 Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快 DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ &gt; 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 &lt; ζ &lt;1)。 简单使用1234567SpringAnimation btnAnim = new SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, 0);btnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);btnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);btnAnim.setStartVelocity(10000); //开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反btnAnim.start();]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeakCanary源码解析]]></title>
    <url>%2FLeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[引言内存泄漏是 Android 开发中无法避免的问题，LeakCanary 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。 ActivityLifecycleCallbacksLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。 接口方法可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。 123456789public interface ActivityLifecycleCallbacks &#123; void onActivityCreated(Activity activity, Bundle savedInstanceState); void onActivityStarted(Activity activity); void onActivityResumed(Activity activity); void onActivityPaused(Activity activity); void onActivityStopped(Activity activity); void onActivitySaveInstanceState(Activity activity, Bundle outState); void onActivityDestroyed(Activity activity);&#125; 简单用法开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyApplication extends Application &#123; public static List&lt;Activity&gt; activityList; public static final int ACTIVITY_MAX_NUM = 10; @Override public void onCreate() &#123; super.onCreate(); activityList = new LinkedList&lt;&gt;(); registerActivityLifecycleCallbacks(new MyActivityCallbacks()); &#125; class MyActivityCallbacks implements ActivityLifecycleCallbacks &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; if (activityList.size() &gt;= ACTIVITY_MAX_NUM) &#123; activityList.remove(activityList.size()-1).finish(); &#125; activityList.add(activity); &#125; @Override public void onActivityStarted(Activity activity) &#123; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; activityList.remove(activity); &#125; &#125; public static Activity getCurrentActivity() &#123; return activityList.get(0); &#125;&#125; 引用类型在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 强引用强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的A a = new A()中的引用a。 软引用软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。12SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String("hello"));System.out.println(sr.get()); 弱引用弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。12345WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String("hello")); System.out.println(sr.get());System.gc(); //通知JVM的gc进行垃圾回收System.out.println(sr.get()); 打印的结果为 hellonull 弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。12ReferenceQueue queue = new ReferenceQueue();WeakReference pr = new WeakReference(object, queue); 虚引用PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其get()永远返回null 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 12345678910public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public T get() &#123; return null; &#125; public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125; LeakCanary源码实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。 执行流程跟踪调用的入口方法install12345public static @NonNull RefWatcher install(@NonNull Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall();&#125; listenerServiceClass方法位于 AndroidRefWatcherBuilder 123456public @NonNull AndroidRefWatcherBuilder listenerServiceClass( @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) &#123; enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass); return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));&#125; 该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和excludedRefs方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法： 12345678910111213141516171819public @NonNull RefWatcher buildAndInstall() &#123; if (LeakCanaryInternals.installedRefWatcher != null) &#123; throw new UnsupportedOperationException("buildAndInstall() should only be called once."); &#125; RefWatcher refWatcher = build(); if (refWatcher != DISABLED) &#123; if (enableDisplayLeakActivity) &#123; LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); &#125; if (watchActivities) &#123; ActivityRefWatcher.install(context, refWatcher); &#125; if (watchFragments) &#123; FragmentRefWatcher.Helper.install(context, refWatcher); &#125; &#125; LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher;&#125; 该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪install方法 1234567891011121314public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) &#123; Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);&#125;//成员变量 lifecycleCallbacksprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter &#123; @Override public void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity); &#125; &#125;; 由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对 Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。 watch方法由 RefWatcher 默认实现： 12345678public void watch(Object watchedReference, String referenceName) &#123; ...... retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue); ensureGoneAsync(watchStartNanoTime, reference);&#125; 其中 retainedKeys 是一个 Set 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。 1234567private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123; watchExecutor.execute(new Retryable() &#123; @Override public Retryable.Result run() &#123; return ensureGone(reference, watchStartNanoTime); &#125; &#125;);&#125; watchExecutor 为 AndroidWatchExecutor 对象12345678910111213141516public AndroidWatchExecutor(long initialDelayMillis) &#123; mainHandler = new Handler(Looper.getMainLooper()); HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME); handlerThread.start(); backgroundHandler = new Handler(handlerThread.getLooper()); this.initialDelayMillis = initialDelayMillis; maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;&#125;@Override public void execute(@NonNull Retryable retryable) &#123; if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123; waitForIdle(retryable, 0); &#125; else &#123; postWaitForIdle(retryable, 0); &#125;&#125; 在execute中，不管是waitForIdle还是postWaitForIdle都会切换到主线程执行，最终会调用以下代码：123456Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; postToBackgroundWithDelay(retryable, failedAttempts); return false; &#125; &#125;); 那么 IdleHandler 到底是什么呢？ 我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。 ensureGoneAsync方法最终会调用ensureGone 123456789101112131415161718192021Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; ...... removeWeaklyReachableReferences(); ...... gcTrigger.runGc(); removeWeaklyReachableReferences(); if (!gone(reference)) &#123; ...... File heapDumpFile = heapDumper.dumpHeap(); ...... HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key) .referenceName(reference.name) .watchDurationMs(watchDurationMs) .gcDurationMs(gcDurationMs) .heapDumpDurationMs(heapDumpDurationMs) .build(); heapdumpListener.analyze(heapDump); &#125; return DONE;&#125; removeWeaklyReachableReferences遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。 调用gcTrigger.runGc去进行内存回收，这里没有使用System.gc，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。 主动进行 GC 之后会再次调用removeWeaklyReachableReferences清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。 生成性能统计文件.hprof，进行内存泄漏的分析。 那么 hprof 文件是被解析成信息的呢 1AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey); 12345678910public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) &#123; ...... MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile); HprofParser parser = new HprofParser(e); Snapshot snapshot = parser.parse(); this.deduplicateGcRoots(snapshot); Instance leakingRef = this.findLeakingReference(referenceKey, snapshot); return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ： this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);&#125; checkForLeak方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的parse方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。 得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。 总结LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存泄漏</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式：创建型模式]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式及其分类设计模式设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 分类模式描述包含创建型模式工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）行为型模式这些设计模式特别关注对象之间的通信。责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 可以使用一张图来展示设计模式之间的关系： 六个原则： 开闭原则（Open Close Principle） 对扩展开放，对修改关闭。 里氏代换原则（Liskov Substitution Principle） 基类可以出现的任何地方，子类一定可以出现。 依赖倒转原则（Dependence Inversion Principle） 针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 降低类之间的耦合度。 迪米特法则，又称最少知道原则（Demeter Principle） 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。 合成复用原则（Composite Reuse Principle） 尽量使用合成/聚合的方式，而不是使用继承。 三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。 创建者模式工厂模式创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。 工厂模式可分为简单工厂、工厂方法、抽象工厂。 简单工厂工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。 简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。 工厂方法工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。 从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。 抽象工厂工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。 以上介绍的三种工厂方法各有优缺点 简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） 工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品） 抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族） 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。 单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。 懒汉式支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。 123456789101112public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 要支持多线程，可以给getInstance方法加锁synchronized，但是效率会变得很低。 饿汉式不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。 123456789public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 双检式双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。getInstance 的性能对应用程序很关键。 12345678910111213141516public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 该方法使用了关键字volatile，关于该关键字的分析：Java并发编程：volatile关键字解析 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。 静态内部类式能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 与双检式方式一样利用ClassLoder机制来保证初始化instance时只有一个线程。关于 ClassLoader：一看你就懂，超详细java中的ClassLoader详解 123456789101112public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用getInstance之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。 枚举实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。 123456public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123;&#125; &#125; 建造者模式使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Human &#123; private final String name; private final int height; private final int weight; public static class Builder &#123; // 必要参数 private final int name; // 可选参数 private int height = 170; private int weight = 60; public Builder(String name) &#123; this.name = name &#125; public Builder height(int height) &#123; this.height = height; return this; &#125; public Builder weight(int weight) &#123; this.weight = weight; return this; &#125; public Human build() &#123; return new Human(this); &#125; &#125; private Human(Builder builder) &#123; name = builder.name; height = builder.height; weight = builder.weight; &#125; public static void main(String[] args) &#123; Human human = new Human.Builder("Jack") .height(175) .weight(60) .build(); &#125;&#125; 原型模式当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。 Java的clone方法便是使用了这种方法，关于该方法：java对象克隆以及深拷贝和浅拷贝 12345678910111213141516public inteface Prototype &#123; Prototype clone();&#125;public class ConcretePrototype implement Prototype &#123; public override Prototype clone() &#123; Prototype prototype = new ConcretePrototype(); return prototype; &#125; public static void main(String[] args) &#123; Prototype p1 = new ConcretePrototype(); Prototype p2 = p1.clone(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式：行为型模式]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。 创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。 12345678910111213141516171819202122232425abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger) &#123; this.nextLogger = nextLogger; &#125; public void logMessage(int level, String message) &#123; if (this.level &lt;= level) &#123; write(message); &#125; if (nextLogger != null) &#123; nextLogger.logMessage(level, message); &#125; &#125; abstract protected void write(String message);&#125; 在 DebugLogger 中123456789101112class DebugLogger extends AbstractLogger &#123; public DebugLogger() &#123; super(); level = 2; &#125; @Override protected void write(String message) &#123; System.out.println("DebugLogger: " + message); &#125;&#125; 调用1234567891011121314151617static AbstractLogger getChainOfLogger() &#123; AbstractLogger infoLogger = new InfoLogger(); AbstractLogger debugLogger = new DebugLogger(); AbstractLogger errorLogger = new ErrorLogger(); infoLogger.setNextLogger(debugLogger); debugLogger.setNextLogger(errorLogger); return infoLogger;&#125;public static void main(String[] args) &#123; AbstractLogger logger = getChainOfLogger(); logger.logMessage(AbstractLogger.INFO, "an info msg"); logger.logMessage(AbstractLogger.DEBUG, "a debug msg"); logger.logMessage(AbstractLogger.ERROR, "an error msg");&#125; 控制台输出结果为123456InfoLogger: an info msgInfoLogger: a debug msgDebugLogger: a debug msgInfoLogger: an error msgDebugLogger: an error msgErrorLogger: an error msg 其他命令模式一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：Java设计模式–命令模式（以管理智能家电为例）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式：结构型模式]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此Volt5V称为Target，而不兼容的220V电压称之为Adaptee，我们的目的是适配设计一个Adpater，方法有两种。 类适配器模式123456789101112131415161718192021interface Volt5V &#123; int get5V();&#125;class Volt220V &#123; public int get220V() &#123; return 220; &#125;&#125;class Adapter extends Volt220V implements Volt5V &#123; @Override public int get5V() &#123; return 5; &#125;&#125;public static void main(String[] args) &#123; Adapter adapter = new Adapter(); System.out.println("获取需要的5V电源：" + adapter.get5V());&#125; 对象适配器模式与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 1234567891011121314151617class ObjectAdapter implements Volt5V &#123; private Volt220V volt220V; public ObjectAdapter(Volt220V adaptee) &#123; volt220V = adaptee; &#125; @Override public int get5V() &#123; return 5; &#125; public int get220V() &#123; return volt220V.get220V(); &#125; &#125; 关于 Android 中 ListView 中的 Adapter，可以参考：Android源码之ListView的适配器模式 组合模式将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。 对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//抽象构件，声明一个接口用于访问和管理Component的子部件abstract class Component &#123; public Component() &#123; &#125; public abstract void add(Component component); public abstract void remove(Component component); //显示层级结构 public abstract void Display(int level);&#125;//叶子节点class Leaf extends Component &#123; public Leaf() &#123; super(); &#125; //无意义的实现 @Override public void add(Component component) &#123; &#125; //无意义的实现 @Override public void remove(Component component) &#123; &#125; @Override public void Display(int level) &#123; System.out.println("-" + level); &#125;&#125;//枝节点class Composite extends Component &#123; public Composite() &#123; super(); &#125; private List&lt;Component&gt; children = new ArrayList&lt;&gt;(); @Override public void add(Component component) &#123; children.add(component); &#125; @Override public void remove(Component component) &#123; children.remove(component); &#125; @Override public void Display(int level) &#123; children.forEach( component -&gt; component.Display(level + 2) ); &#125;&#125; 对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。 装饰器模式向一个现有的对象添加新的功能，同时又不改变其结构。创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243interface Shape &#123; void draw();&#125;class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Draw a circle"); &#125;&#125;//实现了 Shape 接口的抽象装饰类。abstract class ShapeDecorator implements Shape &#123; Shape decoratedShape; public ShapeDecorator(Shape decoratedShape) &#123; this.decoratedShape = decoratedShape; &#125; @Override public void draw() &#123; decoratedShape.draw(); &#125;&#125;//具体的装饰类class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; private void setRedBorder(Shape decoratedShape) &#123; System.out.println("Border color: Red"); &#125;&#125; 代理模式下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。 12345678910111213141516171819202122232425262728293031323334353637383940interface Image &#123; void display();&#125;class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println("Displaying " + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println("Loading " + fileName); &#125;&#125;class ProxyImage implements Image &#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; 静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DisplayHandler implements InvocationHandler &#123; //要代理的真实对象 private Object obj; public DisplayHandler(Object obj) &#123; this.obj = obj; &#125; /** * * @param proxy 代理类代理的真实代理对象 * @param method 所要调用某个对象真实的方法的Method对象 * @param args 指代代理对象方法传递的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //真实的对象执行之前 System.out.println("Before invoke..."); Object invoke = method.invoke(obj, args); //真实的对象执行之后 System.out.println("After invoke..."); return invoke; &#125;&#125;public static void main(String[] args) &#123; Image image = new RealImage("hello.jpg"); InvocationHandler handler = new DisplayHandler(image); /* * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象 * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法 * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上 */ Image proxy = (Image) Proxy.newProxyInstance( handler.getClass().getClassLoader(), image.getClass().getInterfaces(), handler); proxy.display();&#125; 控制台输出结果为1234Loading hello.jpgBefore invoke...Displaying hello.jpgAfter invoke... 代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。 其他过滤器模式简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。 桥接模式桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。 举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。 外观模式外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。 简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。 享元模式所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点 1234567891011121314151617public class FlyweightFactory&#123; static Map&lt;String, Shape&gt; shapes = new HashMap&lt;String, Shape&gt;(); public static Shape getShape(String key)&#123; Shape shape = shapes.get(key); if(shape == null)&#123; shape = new Circle(key); shapes.put(key, shape); &#125; return shape; &#125; public static int getSum()&#123; return shapes.size(); &#125;&#125; 补充从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》]]></title>
    <url>%2F%E5%B7%B4%E6%B4%9B%E5%85%8B%E7%9A%84%E7%8F%8D%E7%8F%A0%EF%BC%9A%E5%B7%B4%E8%B5%AB%E3%80%8A%E5%85%AD%E9%A6%96%E6%97%A0%E4%BC%B4%E5%A5%8F%E5%A4%A7%E6%8F%90%E7%90%B4%E7%BB%84%E6%9B%B2%E3%80%8B%2F</url>
    <content type="text"><![CDATA[引言 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。 “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：巴赫《六首无伴奏大提琴组曲》斯塔克 正文 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。 如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。 回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。 探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。 如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。 应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。 12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。 马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。 在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。 在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。 最感人的还是大师们晚年的演奏，情感饱足，回归天真。 罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。 罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。 俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。 法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。 只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜]]></content>
      <categories>
        <category>艺术</category>
      </categories>
      <tags>
        <tag>音乐</tag>
        <tag>巴洛克</tag>
        <tag>巴赫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻越GFW记]]></title>
    <url>%2F%E7%BF%BB%E8%B6%8AGFW%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言GFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录GFW所为何物，以及翻的原理。 GFW所为何物GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 形象的描述，在没有 GFW 的时代，访问互联网的方式如下 GFW 出现之后，则变成 其内部构造如下 它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。 GFW的具体原理可以查看此文章：全面学习GFW 如何工作关键字过滤阻断关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。 IP地址封锁路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。 DNS污染、劫持DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 DNS劫持和污染的方式有两种： 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。 值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：中国防火长城-污染攻击大事记。 除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。 翻越记翻修改Hosts文件足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。 Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。 所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS 污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。 SSH TunnelSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1) 用户通过建立起的隧道进行代理，通过 SSH Server 向真实的服务发起请求 (2-3) 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5) 由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。 VPN对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。 VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。 VPN 的特点如下： VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。 VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。 ShadowsocksVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。 技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。 相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。 Shadowsocks-R虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。 作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。 V2RayV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。 记 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。 2004年，维基百科遭遇网络封锁，至今未解封。 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。 结语从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。 翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。 本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。]]></content>
      <categories>
        <category>互联网</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode：最长回文子串（Longest Palindromic Substring）的解法]]></title>
    <url>%2FLeetCode%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Palindromic-Substring%EF%BC%89%E7%9A%84%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 Input: “babcd”Output: “bab” 本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。 O(n^3)算法思路 从最长的子串开始，遍历所有该原字符串的子串； 每找出一个字符串，就判断该字符串是否为回文； 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。 时间复杂度 遍历字符串子串：嵌套一个循环：O(n^2)； 判断是否为回文：再次嵌套一个循环：O(n^3)。 代码1234567891011121314151617public static String longestPalindrome(String s) &#123; if(s.length() &lt;= 1) return s; for(int i = s.length();i &gt; 0; i--) &#123;//子串长度 for(int j = 0; j &lt;= s.length() - i; j++) &#123; String sub = s.substring(j , i + j);//子串位置 int count = 0;//计数，用来判断是否对称 for (int k = 0; k &lt; sub.length() / 2; k++) &#123;//左右对称判断 if (sub.charAt(k) == sub.charAt(sub.length() - k - 1)) count++; &#125; if (count == sub.length() / 2) return sub; &#125; &#125; return "";//表示字符串中无回文子串&#125; O(n^2)算法思路 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数； 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）； 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的； 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。 时间复杂度 遍历字符：一层循环——O(n-1)； 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2) 代码12345678910111213141516171819202122232425262728private static int maxLen = 0;private static String sub = "";public static String longestPalindrome(String s) &#123; if(s.length() &lt;= 1) return s; for(int i = 0;i &lt; s.length()-1;i++)&#123; findLongestPalindrome(s,i,i);//单核回文 findLongestPalindrome(s,i,i+1);//双核回文 &#125; return sub;&#125;public static void findLongestPalindrome(String s,int low,int high) &#123; while (low &gt;= 0 &amp;&amp; high &lt;= s.length()-1)&#123; if(s.charAt(low) == s.charAt(high))&#123; if(high - low + 1 &gt; maxLen)&#123; maxLen = high - low + 1; sub = s.substring(low , high+1); &#125; low --;//向两边扩散找当前字符为中心的最大回文子串 high ++; &#125; else break; &#125;&#125; O(n)算法——Manacher算法思路Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以＃号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如： a -&gt; #a#abaf -&gt; #a#b#a#f# 可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。 借助两个变量center、right分别记录回文子串对应的中心点和右端点 可以直接看出，right就是2*center-i（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;反之，就只能从1个长度开始匹配了，就是下面的这行代码: 1r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1 这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。 时间复杂度只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。 代码12345678910111213141516171819202122232425262728293031323334353637383940public static String longestPalindrome(String s) &#123; if(s == null || s.length() &lt; 1) &#123; return s; &#125; StringBuilder builder = new StringBuilder(); // 防止左端点越界 builder.append("&amp;#"); char[] c = s.toCharArray(); for (char a : c) &#123; builder.append(a).append("#"); &#125; String newStr = builder.toString(); c = newStr.toCharArray(); // 回文半径 int[] r = new int[newStr.length()]; // 回文子串最大右端点、中心点 int right=0, center=0; // 最大回文半径、最大中心点 int maxR=0, maxC=0; for (int i=1;i &lt; c.length;i++) &#123; // 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径 r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1; while (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123; ++r[i]; &#125; // 更新右端点和中心点 if (right &lt; i+r[i]) &#123; right = i+r[i]; center = i; &#125; // 更新最大半径和最大中心点 if (maxR &lt; r[i]) &#123; maxR = r[i]; maxC = i; &#125; &#125; //计算在原字符串中的起始点 int start = (maxC-maxR)/2; return s.substring(start, start+maxR-1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages+Hexo搭建个人博客]]></title>
    <url>%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[引言&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。 &emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。 准备工作Github Pages&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为{账户名}.github.io，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：https://{账户名}.github.io便可以看到缺省的界面。 Hexo&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下： 安装Git客户端，前往Git主页下载，安装后登录帐号。 安装Node.js环境，前往Node主页下载。 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令： 1npm install -g hexo-cli 初始化Hexo，projectname省略时，要求当前文件夹为空。 1hexo init [projectname] 关联&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。在博客的文件夹中有_config.yml文件，为Hexo的配置文件，打开并将相应位置设置为：1234deploy: type: gitrepo: 该处填写仓库的完整路径branch: master 该过程其实是给hexo d这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。保存文件之后，安装Git部署插件，在Git Bash中键入命令：1npm install hexo-deployer-git --save 接下来就是清除hexo缓存：1hexo clean 生成静态文件1hexo g 部署网站，d的意思是deploy 1hexo d 后两个命令可以合并为一条，关于Hexo的命令请访问：Hexo指令。 1hexo g -d &emsp;&emsp;至此，博客已经搭建完毕，浏览器键入https://{账户名}.github.io，发现打开了一个使用Hexo搭建的Github Pages博客。 配置&emsp;&emsp;博客文件夹下的_config.yml文件可以配置整个博客的名称、主题等基本功能，/theme/文件夹下的_config.yml文件则用于配置具体的主题配置。 发表与删除&emsp;&emsp;在博客文件夹打开Git Bash，键入 1hexo n &quot;文章的标题&quot; 之后便会生成一个md文件，在md文件中编辑文章保存，然后键入hexo g -d便会发布文章。 &emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。 主题&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：有哪些好看的 Hexo主题。笔者使用的是NexT。 &emsp;&emsp;在博客文件夹下的_config.yml文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客_config.yml文件的更改，保存片刻即生效。 域名绑定&emsp;&emsp;具体过程如下： 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，{账户名}.github.io的IP地址，还有一个的记录类型为CNAME，记录值为：{账户名}.github.io。 进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。 进入博客文件夹中的/source/，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为所有文件，名称为CNAME。 备份与恢复&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。 备份&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下: 新建一个分支，如hexo，并将其设置为默认 本地clone你的Github Pages仓库，得到一个io文件夹：{账户名}.github.io的文件夹。 将原来博客文件夹中的_config.yml，themes/，source/，scffolds/，package.json，.gitignore复制到clone下来的文件夹，注意要将theme/主题的.git/删除。 在clone下的文件夹执行npm install，npm install hexo-deployer-git。 此时{账户名}.github.io文件夹已经成为包含你博客所有文件的工作文件夹，在部署(hexo g -d)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:123git add .git commit -m &quot;更新源文件&quot;git push origin hexo 这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。 恢复&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下: clone你的Github Pages仓库，得到一个io文件夹。 在文件夹中打开Git Bash，键入以下命令:123npm install hexo-cli -gnpm install npm install hexo-deployer-git 现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。 如果在拉取过程中提示本地分支与远程仓库冲突，可以使用git reset --hard命令重置之后再次pull。如果提示 The following untracked working tree files would be overwritten by merge 可以使用git clean -d -fx，关于该命令 git clean -f -n //选项-n将显示执行下一步时将会移除哪些文件。 git clean -f //该命令会移除所有上一条命令中显示的文件。 git clean -fd //移除文件夹，使用选项-d。 git clean -fX //只想移除已被忽略的文件，使用选项-X。 git clean -fx //想移除已被忽略和未被忽略的文件，使用选项-x。 Hexo各文件（夹）说明 _config.yml：站点的配置文件，备份过程中需要拷贝； themes/：主题文件夹，需要拷贝； source：博客文章的.md文件，需要拷贝； scaffolds/：文章的模板，需要拷贝； package.json：安装包的名称，需要拷贝； .gitignore：限定在push时哪些文件可以忽略，需要拷贝； .git/：主题和站点都有，标志这是一个git项目，不需要拷贝； node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； public：hexo g生成的静态网页，不需要拷贝； .deploy_git：同上，hexo g也会生成，不需要拷贝； db.json：文件，不需要拷贝。]]></content>
      <categories>
        <category>互联网</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坐过山车的人]]></title>
    <url>%2F%E5%9D%90%E8%BF%87%E5%B1%B1%E8%BD%A6%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。 我们乘坐过山车飞向未来，他和我的手里各捏着一张票，那是飞向未来的小舢板，起伏的波浪是我无畏的想象力。乘坐我的想象力，他们尽情蹂躏这些无辜的女孩和男孩，这些无辜的小狗和小猫。在波浪之下，在波浪的下面一直匍匐着衰弱的故事人，他曾经是最伟大的创造者，匍匐在最下面的飞得最高，全是痛苦，全部都是痛苦。那些与我耳语者，个个聪明无比，他们说智慧来自痛苦，他们说：来，给你智慧之路。哦，每一个坐过山车的人都是过山车建造厂的工人，每一双手都充满智慧，是痛苦的工艺匠。他们也制造不同的心灵，这些心灵里孕育着奖励，那些渴望奖励的人，那些最智慧的人，他们总在沉默，不停地被从过山车上推下去，在空中飘荡，在飘荡中，我们接吻，就像那些恋人，那些被压缩在词典册页中的爱情故事，还有家庭，人间的互相拯救。如果存在一个空间，漂浮着无数列过山车，痛苦的过山车…… ——马雁：《我们乘坐着过山车飞向未来》 &emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗歌</tag>
      </tags>
  </entry>
</search>
