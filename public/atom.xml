<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ReBE</title>
  
  <subtitle>Febers的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-19T13:13:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Febers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown 语法详解</title>
    <link href="http://yoursite.com/Markdown-%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Markdown-语法详解/</id>
    <published>2019-05-19T07:36:02.000Z</published>
    <updated>2019-05-19T13:13:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown  的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。</p><p><img src="/Markdown-语法详解/markdown.png" alt="logo"></p><a id="more"></a><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>Markdown 是一门轻量级的标记语言，由美国工程师 John Gruber 于2004年创造。这门语言的目的是让人们<code>使用易于阅读、易于撰写的纯文字格式，并选择性地转换成有效的 XHTML（或是 HTML）</code>。</p><p>Markdown 所谓的<strong>易读</strong>并不是指排版之后呈现的结果易读，而是指原始格式下的文件依然拥有优秀的可读性，不会像阅读原始 HTML 代码一样，满眼都是尖括号（可以通过 右键浏览器页面 -> 查看源代码 体验）。Markdown 的<strong>易写</strong>则体现在其语法足够简单，学习曲线平缓，并且在写作中基本可以脱离鼠标操作。</p><p>Markdown 的轻量级是相对于 LaTeX 来说的，这种基于 Tex 的排版系统广泛运用在高质量书籍印刷和复杂公式论文中。不过使用 Markdown 仍然可以使用一些基本的数学公式，比如<code>$ E = mc^2 $</code>、<code>$ \int_0^xf(x)dx $</code></p><p>$ E = mc^2 $</p><p>$ \int_0^xf(x)dx $</p><p>这需要不同平台上的 Markdown 数学公式插件的支持，本博客使用<code>Hexo</code> + <code>Github Pages</code>搭建，可以通过安装 <a href="https://www.mathjax.org" target="_blank" rel="noopener">MathJax</a> 实现。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>跟早期的 HTML 类似，Markdown 在发展的过程中衍生出了不同的版本，它们的基本语法上相通，但是在诸如表格、锚点、时序图等实现上出现了不一致。在关于语法规范化的讨论中，作者 John Gruber 认为，<code>不同的网站（和人们）有不同的需求，没有一种语法可以让所有人满意</code>。</p><p>现今 Markdown 的主要分类如下</p><ul><li>CommonMark：由 Stack Exchange、Github、Reddit 等组织发起的标准化项目。一开始名称为<code>Standard Markdown</code>，由于遭到作者的反对，更名<code>CommonMark</code></li><li>GFM：Github Flavored Markdown，由 Github 于2017年发布，基于 CommonMark。相信很多开发者都是通过一份<code>README.md</code>文件认识 Markdown，这也是本博客采用的版本。</li><li>Markdown Extra：基于 PHP、Python 和 Rudy 中实现的 Markdown。</li></ul><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>市面上优秀的 Markdown 编辑器层出不穷，这也有力推动了 Markdown 的发展。可以使用<code>Sublime Text</code>配合插件编辑写作，可以使用<code>Typora</code>等优秀的跨平台工具实现所见即所得，也可以通过 <a href="https://www.zybuluo.com" target="_blank" rel="noopener">Cmd Markdown </a>在线书写并导出、发布。</p><p>博主使用的是<code>Typora。</code></p><p><img src="/Markdown-语法详解/编辑器.png" alt="编辑器"></p><p>相关链接：<a href="https://sspai.com/post/32483" target="_blank" rel="noopener">码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点</a>、 <a href="https://www.zhihu.com/question/19637157" target="_blank" rel="noopener">用 Markdown 写作用什么文本编辑器？ - 知乎</a></p><h2 id="初级语法"><a href="#初级语法" class="headerlink" title="初级语法"></a>初级语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><p>另外在 GFM 中，任意 1-6 个 <strong>#</strong> 标注的标题都会被添加上同名的锚点链接，比如<code># First Title</code>会被标注成<code>[First Title](#first-title)</code>（注意小写转换），因此我们可以在文章的其他地方，使用标注之后的格式跳转到任何标题，比如<code>[跳转至引言](#引言)</code></p><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><table><thead><tr><th>格式</th><th>效果</th></tr></thead><tbody><tr><td><code>*斜体1*</code></td><td><em>斜体1</em></td></tr><tr><td><code>_斜体2_</code></td><td><em>斜体2</em></td></tr><tr><td><code>**粗体1**</code></td><td><strong>粗体1</strong></td></tr><tr><td><code>__粗体2__</code></td><td><strong>粗体2</strong></td></tr><tr><td><code>~~删除线~~</code></td><td><del>删除线</del></td></tr><tr><td><code>***斜粗体1***</code></td><td><strong><em>斜粗体1</em></strong></td></tr><tr><td><code>___斜粗体2___</code></td><td><strong><em>斜粗体2</em></strong></td></tr><tr><td><code>***~~斜粗体删除线1~~***</code>、<code>~~***斜粗体删除线2***~~</code></td><td><strong><em><del>斜粗体删除线</del></em></strong></td></tr></tbody></table><h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p>GFM 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。比如<code>:stuck_out_tongue_winking_eye:</code>：<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span></p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f47b.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f47b.png?v8">👻</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f436.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f436.png?v8">🐶</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v8">💩</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v8">🔥</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f647.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f647.png?v8">🙇</span></p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/2049.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/2049.png?v8">⁉</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a3.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a3.png?v8">🚣</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f349.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f349.png?v8">🍉</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f3ca.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f3ca.png?v8">🏊</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f342.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f342.png?v8">🍂</span></p><p>可以在此找到不同表情对应的符号码：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">Emoji cheat sheet for GitHub, Basecamp, Slack & more</a></p><p>Hexo 默认不支持 emoji 表情，可以通过安装 <a href="https://github.com/crimx/hexo-filter-github-emojis" target="_blank" rel="noopener">hexo-filter-github-emojis</a> 实现</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>使用三个（或多个连续）的<code>-</code>、<code>*</code>、<code>-</code>实现分割线效果</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="emphasis">___</span></span><br><span class="line"><span class="strong">*****</span>*</span><br></pre></td></tr></tbody></table></figure><hr><hr><hr><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接分为文字链接和图片链接B</p><h4 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h4><p><code>[ReBe](https://febers.github.io "鼠标悬停显示")</code>：[ReBe</p><p>支持使用标识符标志地址，将真正的URL地址放在文末，比如</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Github</span>][<span class="symbol">Github URL</span>]</span><br><span class="line">[<span class="symbol">Github URL</span>]:<span class="link">https://github.com/Febers</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下:</p><p><a href="https://github.com/Febers" target="_blank" rel="noopener">Github</a></p><h4 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h4><p>基本格式为<code>![title](url)</code>，其中<code>title</code>可省略，<code>![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067)</code></p><p><img src="https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067" alt></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>看起来并不明显</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>PHP是最好的语言？</span><br><span class="line"><span class="bullet">2. </span>PHP是最好的语言！</span><br></pre></td></tr></tbody></table></figure><ol><li><p>PHP是最好的语言？</p></li><li><p>PHP是最好的语言！</p></li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>可以使用<code>-</code>、<code>*</code>、<code>+</code>开头接空格，但在多级列表中最好使用<code>-</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>PHP是最好的语言？</span><br><span class="line"><span class="bullet">* </span>PHP是最好的语言。</span><br><span class="line"><span class="bullet">+ </span>PHP是最好的语言！</span><br><span class="line"><span class="code">- 毫无疑问</span></span><br><span class="line"><span class="code">- 众所周知</span></span><br></pre></td></tr></tbody></table></figure><ul><li>PHP是最好的语言？</li></ul><ul><li>PHP是最好的语言。</li></ul><ul><li>PHP是最好的语言！<ul><li>毫无疑问<ul><li>众所周知</li></ul></li></ul></li></ul><h4 id="复选框列表"><a href="#复选框列表" class="headerlink" title="复选框列表"></a>复选框列表</h4><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[x] 大一</span><br><span class="line"><span class="bullet">- </span>[x] 大二</span><br><span class="line"><span class="bullet">- </span>[ ] 大三</span><br><span class="line"><span class="bullet">- </span>[ ] 大四</span><br></pre></td></tr></tbody></table></figure><ul><li>[x] 大一</li><li>[x] 大二</li><li>[ ] 大三</li><li>[ ] 大四</li></ul><p>Hexo 默认的渲染引擎 Marked 不支持 TODO list，可以更换为 markdown-it，之后实现的效果如 Typora 预览</p><p><img src="/Markdown-语法详解/todo-list.png" alt="todo-list"></p><h3 id="引用与高亮"><a href="#引用与高亮" class="headerlink" title="引用与高亮"></a>引用与高亮</h3><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>使用<code>></code>实现引用，多个<code>></code>实现引用层级</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">> PHP</span></span><br><span class="line">>> 是</span><br><span class="line">>>> 最好的</span><br><span class="line">>>>> 语言</span><br></pre></td></tr></tbody></table></figure><blockquote><p>PHP</p><blockquote><p>是</p><blockquote><p>最好的</p><blockquote><p>语言</p></blockquote></blockquote></blockquote></blockquote><p>一般用在引用原文内容中</p><blockquote><p>一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！”黛玉纳罕道：“这些人个个皆敛声屏气，恭肃严整如此，这来者系谁，这样放诞无礼？”心下想时，只见一群媳妇丫鬟围拥着一个人从后房门进来。这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子：头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗；项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩；身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂；下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未起笑先闻。黛玉连忙起身接见。</p></blockquote><h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><p>使用单个反引号实现单行文本高亮，三个反引号实现代码块高亮。可以在第一个</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```markdown</span><br><span class="line">PHP是`最好的`语言</span><br><span class="line"></span><br><span class="line">​```Kotlin</span><br><span class="line">fun main(args: Array<String>) {</span><br><span class="line">    print("hello")</span><br><span class="line">}</span><br><span class="line">​</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP是`最好的`语言</span><br><span class="line"></span><br><span class="line">```Kotlin</span><br><span class="line">fun main(args: Array<String>) {</span><br><span class="line">    print("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h2><p>在不同的 Markdown 版本中实现可能不同</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 序号 | 列名1 | 列名2 |</span><br><span class="line">| - | - | - |</span><br><span class="line">| 0 | 一一  | 一二  |</span><br><span class="line">| 1 | 二一  | 二二  |</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>序号</th><th>列名1</th><th>列名2</th></tr></thead><tbody><tr><td>0</td><td>一一</td><td>一二</td></tr><tr><td>1</td><td>二一</td><td>二二</td></tr></tbody></table><p>在分隔行（第二行）中的<code>-</code>右边添加<code>:</code>，表格内容实现右对齐效果，两边都加则为居中对齐，默认为左对齐</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 序号 | 列名1 | 列名2 |</span><br><span class="line">| :-: | :-: | :-: |</span><br><span class="line">| 0 | 一一  | 一二  |</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">列名1</th><th style="text-align:center">列名2</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">一一</td><td style="text-align:center">一二</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>分为两部分，第一部分定义元素，第二部分定义元素走向。定义元素语法为<code>tag=>type: content:>url</code>，其中<code>tag</code>为元素名称，<code>type</code>为元素类型，有以下6种</p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>start</td><td>开始</td></tr><tr><td>end</td><td>结束</td></tr><tr><td>operation</td><td>操作</td></tr><tr><td>subroutine</td><td>子程序</td></tr><tr><td>condition</td><td>条件</td></tr><tr><td>inputoutput</td><td>输入或输出</td></tr></tbody></table><p><code>content</code>为在流程图方框中显示的内容</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=>start: 开始:>https://www.markdown-syntax.com</span><br><span class="line">io=>inputoutput: 输入或输出</span><br><span class="line">op=>operation: 操作</span><br><span class="line">cond=>condition: Yes or No?</span><br><span class="line">sub=>subroutine: 子程序</span><br><span class="line">e=>end: 结束</span><br><span class="line"></span><br><span class="line">st->io->op->cond</span><br><span class="line">cond(yes)->e</span><br><span class="line">cond(no)->sub->io</span><br></pre></td></tr></tbody></table></figure><div id="flowchart-0" class="flow-chart"></div><p>Hexo 原生并不支持流程图，需要安装<a href="https://github.com/bubkoo/hexo-filter-flowchart" target="_blank" rel="noopener">hexo-filter-flowchart</a></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><code>title</code>为时序图标题，<code>participant</code>定义时序图对象，<code>note</code>定义时序图中的说明，有三种方位控制</p><ul><li>left of, 表示说明位于当前对象的左侧</li><li>right of, 表示说明位于当前对象的右侧</li><li>over, 表示说明覆盖在当前对象（们）上</li></ul><p>不同对象之间使用箭头控制指向</p><ul><li>->：实线实箭头</li><li>–>：虚线实箭头</li><li>->>：实线虚箭头</li><li>–>>：虚线虚箭头</li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">title: 时序图标题</span><br><span class="line">participant 大一</span><br><span class="line">participant 大二</span><br><span class="line">participant 大三</span><br><span class="line"></span><br><span class="line">note left of 大一: 大一好好学习</span><br><span class="line">note over 大二: 大二课程很多</span><br><span class="line">note right of 大三: 大三面临毕业</span><br><span class="line"></span><br><span class="line">大一->大一:大一留级</span><br><span class="line">大一->大二:大一迟早要到大二</span><br><span class="line">大二-->大三:大二不一定能升大三</span><br><span class="line">大二->>大三:大二不一定能升大三</span><br><span class="line">大三-->>大一:大三也可能回炉重造</span><br></pre></td></tr></tbody></table></figure><div id="sequence-0"></div><p>Hexo 默认同样不支持时序图，使用`<a href="https://github.com/bubkoo/hexo-filter-sequence" target="_blank" rel="noopener">hexo-filter-sequence</a>。具体的做法参考 <a href="http://wewelove.github.io/fcoder/2017/09/06/markdown-sequence/" target="_blank" rel="noopener">为 Hexo 增加时序图解析功能</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始:>https://www.markdown-syntax.comio=>inputoutput: 输入或输出op=>operation: 操作cond=>condition: Yes or No?sub=>subroutine: 子程序e=>end: 结束st->io->op->condcond(yes)->econd(no)->sub->io</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js"></script><script src="https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">title: 大学生活participant 大一participant 大二participant 大三note left of 大一: 大一好好学习note over 大二: 大二课程很多note right of 大三: 大三面临毕业大一->大一:大一惨遭留级大一->大二:大一迟早要到大二大二-->大三:大二不一定能升大三大二->>大三:大二不一定能升大三大三-->>大一:大三也可能回炉重造</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown  的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Markdown-语法详解/markdown.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>利用反射实现 DrawerLayout 全屏滑动</title>
    <link href="http://yoursite.com/%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0-DrawerLayout-%E5%85%A8%E5%B1%8F%E6%BB%91%E5%8A%A8/"/>
    <id>http://yoursite.com/利用反射实现-DrawerLayout-全屏滑动/</id>
    <published>2019-05-06T04:58:30.000Z</published>
    <updated>2019-05-19T07:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。<a id="more"></a></p><h2 id="DrawerLayout-侧滑"><a href="#DrawerLayout-侧滑" class="headerlink" title="DrawerLayout 侧滑"></a>DrawerLayout 侧滑</h2><p>在 DrawerLayout 中定义了两个变量，分别对应 Gravity 为 Left 和 Right 的滑动情景，两者并无实质分别，本文只分析 Left 的情况。此外，DrawerLayout 包含三种状态，STATE_IDLE（已打开或已关闭），STATE_DRAGGING（正在拖动），STATE_SETTLING（执行打开或关闭的动画过程中）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ViewDragHelper mLeftDragger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ViewDragHelper mRightDragger;</span><br></pre></td></tr></tbody></table></figure><p> 构造函数对一些变量做了初始化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mLeftCallback = <span class="keyword">new</span> ViewDragCallback(Gravity.LEFT);</span><br><span class="line"></span><br><span class="line">mLeftDragger = ViewDragHelper.create(<span class="keyword">this</span>, TOUCH_SLOP_SENSITIVITY, mLeftCallback);</span><br><span class="line">mLeftDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);</span><br><span class="line">mLeftDragger.setMinVelocity(minVel);</span><br><span class="line">mLeftCallback.setDragger(mLeftDragger);</span><br></pre></td></tr></tbody></table></figure><p>ViewDraghelper 是官方提供的专门为自定义 ViewGroup 处理拖拽的手势类。此处用到的构造方法为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(@NonNull ViewGroup forParent, <span class="keyword">float</span> sensitivity,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull Callback cb)</span></span></span><br></pre></td></tr></tbody></table></figure><p>DrawerLayout 中侧滑打开界面正是通过 ViewDragHelper 实现的，查看 DrawerLayout 的<code>onTouchEvent</code>方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>{</span><br><span class="line">mLeftDragger.processTouchEvent(ev);</span><br><span class="line">mRightDragger.processTouchEvent(ev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line"><span class="keyword">boolean</span> wantTouchEvents = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (action & MotionEvent.ACTION_MASK) {</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wantTouchEvents;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其明显调用了 ViewDragHelper 的<code>processTouchEvent</code>方法处理 Touch 事件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>{</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> (action) {</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//找到当前触摸点的最顶层的子View,作为需要操作的View</span></span><br><span class="line">            <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">            <span class="comment">//保存当前Touch点发生的初始状态</span></span><br><span class="line">            saveInitialMotion(x, y, pointerId);</span><br><span class="line">            <span class="comment">//这里是点在一个正在滑动的侧滑栏上，使侧滑栏的状态由正在滑动状态变为正在拖动状态</span></span><br><span class="line">            tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class="line">            <span class="comment">//处理侧滑栏的触摸触发区域是否触摸，如果触摸则通知回调，在DrawerLayout中处理，执行一个侧滑微弹的操作，也就是稍微弹出一点，表示触发了侧滑操作</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line">            <span class="keyword">if</span> ((edgesTouched & mTrackingEdges) != <span class="number">0</span>) {</span><br><span class="line">                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重点在<code>mInitialEdgesTouched[pointerId]</code>，其为一个保存边缘滑动值的 int 数组。在<code>saveInitialMotion</code>方法中发现其赋值过程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveInitialMotion</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">int</span> pointerId)</span> </span>{</span><br><span class="line">ensureMotionHistorySizeForId(pointerId);</span><br><span class="line">mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;</span><br><span class="line">mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;</span><br><span class="line">mInitialEdgesTouched[pointerId] = getEdgesTouched((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">mPointersDown |= <span class="number">1</span> << pointerId;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原来是调用了<code>getEdgesTouched</code>方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEdgesTouched</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x < mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;</span><br><span class="line"><span class="keyword">if</span> (y < mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;</span><br><span class="line"><span class="keyword">if</span> (x > mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;</span><br><span class="line"><span class="keyword">if</span> (y > mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，该方法将判断<code>x < mParentView.get*() + mEdgeSize</code>，然后将对应的 result 返回。<code>mEdgeSize</code>即为边缘滑动的临界值，其初始化值为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br></pre></td></tr></tbody></table></figure><p>因此，要让 DrawerLayout 支持全屏滑动打开侧滑菜单而不是边缘滑动，重点便是要修改该值，将其设为屏幕宽度。</p><p>具体的反射代码（kotlin）</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 ViewDragHelper，更改 edgeSizeField</span></span><br><span class="line"><span class="keyword">val</span> leftDraggerField = drawerLayout.javaClass.getDeclaredField(<span class="string">"mLeftDragger"</span>)</span><br><span class="line">leftDraggerField.isAccessible = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> leftDragger = leftDraggerField.<span class="keyword">get</span>(drawerLayout) <span class="keyword">as</span> ViewDragHelper</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> edgeSizeField = leftDragger.javaClass.getDeclaredField(<span class="string">"mEdgeSize"</span>)</span><br><span class="line">edgeSizeField.isAccessible = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> edgeSize = edgeSizeField.getInt(leftDragger)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> displaySize = Point()</span><br><span class="line">activity.windowManager.defaultDisplay.getSize(displaySize)</span><br><span class="line">edgeSizeField.setInt(leftDragger, displaySize.x)</span><br></pre></td></tr></tbody></table></figure><h2 id="DrawerLayout-长按弹出"><a href="#DrawerLayout-长按弹出" class="headerlink" title="DrawerLayout 长按弹出"></a>DrawerLayout 长按弹出</h2><p><a href="#引言">引言</a></p><p>在 DrawerLayout 中，用户在非侧滑界面的 mEdgeSize 范围内长按，侧滑界面将弹出。当我们修改 mEdgeSize 为屏幕宽度之后，用户所有的长按动作都将触发原来的弹出逻辑，而且触发范围为屏幕宽度，侧滑菜单将过度右移，造成左侧边缘有空白。</p><p>原来是 DrawerLayout 的私有内部类 ViewDragCallback 重写了<code>onEdgeTouched</code>方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragCallback</span> <span class="keyword">extends</span> <span class="title">ViewDragHelper</span>.<span class="title">Callback</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeTouched</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>{</span><br><span class="line">postDelayed(mPeekRunnable, PEEK_DELAY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该方法会执行一个 mPeekRunnable，其为内部类的私有 Runnable 类型的属性，其<code>run</code>方法执行了<code>peekDrawer</code>方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peekDrawer</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">final</span> View toCapture;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childLeft;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> peekDistance = mDragger.getEdgeSize();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> leftEdge = mAbsGravity == Gravity.LEFT;</span><br><span class="line"><span class="keyword">if</span> (leftEdge) {</span><br><span class="line">toCapture = findDrawerWithGravity(Gravity.LEFT);</span><br><span class="line">childLeft = (toCapture != <span class="keyword">null</span> ? -toCapture.getWidth() : <span class="number">0</span>) + peekDistance;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">toCapture = findDrawerWithGravity(Gravity.RIGHT);</span><br><span class="line">childLeft = getWidth() - peekDistance;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Only peek if it would mean making the drawer more visible and the drawer isn't locked</span></span><br><span class="line"><span class="keyword">if</span> (toCapture != <span class="keyword">null</span> && ((leftEdge && toCapture.getLeft() < childLeft)</span><br><span class="line">|| (!leftEdge && toCapture.getLeft() > childLeft))</span><br><span class="line">&& getDrawerLockMode(toCapture) == LOCK_MODE_UNLOCKED) {</span><br><span class="line"><span class="keyword">final</span> LayoutParams lp = (LayoutParams) toCapture.getLayoutParams();</span><br><span class="line">mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop());</span><br><span class="line">lp.isPeeking = <span class="keyword">true</span>;</span><br><span class="line">invalidate();</span><br><span class="line"></span><br><span class="line">closeOtherDrawer();</span><br><span class="line">cancelChildViewTouch();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意<code>mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop())</code>就是长按屏幕时，侧滑菜单会自动滑出来的原因。</p><p>解决这个问题着实费了一番脑筋，因为 ViewDragCallback 为私有内部类，外部无法直接得到其引用。幸好观察之后发现其实现了 ViewDragHelper.Callback 接口，从而让我们可以利用多态的方式，获取其反射实例</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”</span></span><br><span class="line"><span class="comment">//更改其属性 mPeekRunnable</span></span><br><span class="line"><span class="keyword">val</span> leftCallbackField = drawerLayout.javaClass.getDeclaredField(<span class="string">"mLeftCallback"</span>)</span><br><span class="line">leftCallbackField.isAccessible = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例</span></span><br><span class="line"><span class="keyword">val</span> leftCallback = leftCallbackField.<span class="keyword">get</span>(drawerLayout) <span class="keyword">as</span> ViewDragHelper.Callback</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> peekRunnableField = leftCallback.javaClass.getDeclaredField(<span class="string">"mPeekRunnable"</span>)</span><br><span class="line">peekRunnableField.isAccessible = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> nullRunnable = Runnable {  }</span><br><span class="line">peekRunnableField.<span class="keyword">set</span>(leftCallback, nullRunnable)</span><br></pre></td></tr></tbody></table></figure><p>完美解决问题！</p><p>最后便是构建一个工具类</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DrawerLayoutHelper {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射的方式将 DrawerLayout 的侧滑范围设为全屏</span></span><br><span class="line"><span class="comment">     * 该方法存在一个问题，在侧滑范围内长按，也会划出菜单</span></span><br><span class="line"><span class="comment">     * 通过查看 DrawerLayout 的源码分析，其内部类 ViewDragCallback</span></span><br><span class="line"><span class="comment">     * 重写了 onEdgeTouched 方法，然后调用一个 Runnable 属性的变量 “mPeekRunnable”</span></span><br><span class="line"><span class="comment">     * 该变量调用了 peekDraw 方法，实现了长按划出侧滑菜单的功能</span></span><br><span class="line"><span class="comment">     * 同样使用反射将该 Runnable 更改为空实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawerLayout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> displayWidthPercentage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setDrawerLeftEdgeSize</span><span class="params">(activity: <span class="type">Activity</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                              drawerLayout: <span class="type">DrawerLayout</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                              displayWidthPercentage: <span class="type">Float</span>)</span></span> {</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="literal">null</span> || drawerLayout == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小</span></span><br><span class="line">            <span class="keyword">val</span> leftDraggerField = drawerLayout.javaClass.getDeclaredField(<span class="string">"mLeftDragger"</span>)</span><br><span class="line">            leftDraggerField.isAccessible = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> leftDragger = leftDraggerField.<span class="keyword">get</span>(drawerLayout) <span class="keyword">as</span> ViewDragHelper</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> edgeSizeField = leftDragger.javaClass.getDeclaredField(<span class="string">"mEdgeSize"</span>)</span><br><span class="line">            edgeSizeField.isAccessible = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> edgeSize = edgeSizeField.getInt(leftDragger)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> displaySize = Point()</span><br><span class="line">            activity.windowManager.defaultDisplay.getSize(displaySize)</span><br><span class="line">            edgeSizeField.setInt(leftDragger, Math.max(edgeSize, (displaySize.x * displayWidthPercentage).toInt()))</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”</span></span><br><span class="line">            <span class="comment">//更改其属性 mPeekRunnable</span></span><br><span class="line">            <span class="keyword">val</span> leftCallbackField = drawerLayout.javaClass.getDeclaredField(<span class="string">"mLeftCallback"</span>)</span><br><span class="line">            leftCallbackField.isAccessible = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例</span></span><br><span class="line">            <span class="keyword">val</span> leftCallback = leftCallbackField.<span class="keyword">get</span>(drawerLayout) <span class="keyword">as</span> ViewDragHelper.Callback</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> peekRunnableField = leftCallback.javaClass.getDeclaredField(<span class="string">"mPeekRunnable"</span>)</span><br><span class="line">            peekRunnableField.isAccessible = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> nullRunnable = Runnable {  }</span><br><span class="line">            peekRunnableField.<span class="keyword">set</span>(leftCallback, nullRunnable)</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (e: Exception) {</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setDrawerLeftEdgeFullScreen</span><span class="params">(activity: <span class="type">Activity</span>?, drawerLayout: <span class="type">DrawerLayout</span>?)</span></span> {</span><br><span class="line">        setDrawerLeftEdgeSize(activity, drawerLayout, <span class="number">1.0f</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义 View 详解</title>
    <link href="http://yoursite.com/Android-%E8%87%AA%E5%AE%9A%E4%B9%89-View-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Android-自定义-View-详解/</id>
    <published>2019-05-03T10:34:00.000Z</published>
    <updated>2019-05-19T07:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。</p><a id="more"></a><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h2 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h2><h2 id="自定义-View"><a href="#自定义-View" class="headerlink" title="自定义 View"></a>自定义 View</h2><h2 id="自定义-ViewGroup"><a href="#自定义-ViewGroup" class="headerlink" title="自定义 ViewGroup"></a>自定义 ViewGroup</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Dart 异步编程</title>
    <link href="http://yoursite.com/Dart-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/Dart-异步编程/</id>
    <published>2019-04-30T00:21:26.000Z</published>
    <updated>2019-04-30T14:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Dart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。</p><a id="more"></a><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>作为一个事件驱动语言，Dart 同样拥有事件循环（Event Loop，类似于 Android 中的Looper/Handler）。Dart 有两个队列，一个是微任务队列（MicroTask Queue），一个是事件队列（Event Queue）</p><ul><li>微任务队列包含 Dart 内部的微任务，主要通过<code>scheduleMicrotask</code>调度</li><li>事件队列包含外部事件，如 I/O、Timer、绘制事件等</li></ul><p><img src="/Dart-异步编程/事件循环.png.jpg" alt></p><p>从上图可以看出，Dart 处理事件循环的逻辑</p><ul><li>首先处理所有微任务队列里的微任务</li><li>处理完所有微任务之后，处理事件队列里的一个事件</li><li>回到微任务队列继续循环</li></ul><p>对于微任务队列，一次性全部处理，对于事件队列，一次只处理一个。</p><h2 id="微任务和事件"><a href="#微任务和事件" class="headerlink" title="微任务和事件"></a>微任务和事件</h2><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p><code>dart:async</code>定义了一个顶级函数<code>scheduleMicrotask</code>，使用其让代码以微任务的方式异步执行</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;<span class="comment">//下文不再显式导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'开始'</span>);</span><br><span class="line">  scheduleMicrotask(() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'这是一个微任务'</span>);</span><br><span class="line">  });</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"结束"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台输出</p><blockquote><p>开始<br>结束<br>这是一个微任务</p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>使用<code>Timer.run(callback)</code>让代码以事件的方式异步执行</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'开始'</span>);</span><br><span class="line"></span><br><span class="line">  Timer.run(() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'这是一个事件'</span>);</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  scheduleMicrotask((){ <span class="built_in">print</span>(<span class="string">'这是微任务0'</span>); });</span><br><span class="line">  scheduleMicrotask((){ <span class="built_in">print</span>(<span class="string">'这是微任务1'</span>); });</span><br><span class="line">  scheduleMicrotask((){ <span class="built_in">print</span>(<span class="string">'这是微任务2'</span>); });</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"结束"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台输出</p><blockquote><p>开始<br>结束<br>这是微任务0<br>这是微任务1<br>这是微任务2<br>这是一个事件</p></blockquote><p>同时可以看出和 Java 使用<code>new Thread（Runnable r）</code>不同，在 Dart 中，微任务的执行顺序是有序的。</p><p>考虑下面的代码，会输出<code>这是一个事件</code>吗？</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Timer.run(() {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'这是一个事件'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">foo() {</span><br><span class="line">  scheduleMicrotask(foo);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></tbody></table></figure><p>根据上面 Dart 处理事件循环的逻辑图，<code>Timer.run</code>永远不会被执行，因为<code>scheduleMicrotask</code>永远在执行。</p><p>仅仅使用回调函数实现异步很容易陷入“回调地狱（Callback hell）”，为此 Dart 引入了<code>Future</code></p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future 封装了一系列静态函数完成异步操作，其内部通过<code>scheduleMicrotask</code>和<code>Timer</code>实现。此外还有一个<code>then</code>方法，接收一个名为<code>onValue</code>的闭包作为参数，该闭包在 Future 成功完成时被调用</p><table><thead><tr><th>函数</th><th>用途</th></tr></thead><tbody><tr><td>Future(FutureOr<t> computation())</t></td><td>创建事件任务</td></tr><tr><td>microtask(FutureOr<t> computation())</t></td><td>创建microtask任务</td></tr><tr><td>sync(FutureOr<t> computation())</t></td><td>创建同步任务</td></tr><tr><td>delayed(Duration duration, [FutureOr<t> computation()])</t></td><td>创建延迟任务</td></tr></tbody></table><p>通过代码理解</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'开始'</span>);</span><br><span class="line"></span><br><span class="line">  Timer.run(() => <span class="built_in">print</span>(<span class="string">'这是一个事件'</span>));</span><br><span class="line"></span><br><span class="line">  scheduleMicrotask((){<span class="built_in">print</span>(<span class="string">'这是微任务0'</span>);});</span><br><span class="line">  scheduleMicrotask((){<span class="built_in">print</span>(<span class="string">'这是微任务1'</span>);});</span><br><span class="line">  scheduleMicrotask((){<span class="built_in">print</span>(<span class="string">'这是微任务2'</span>);});</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"结束"</span>);</span><br><span class="line"></span><br><span class="line">  Future(() => <span class="built_in">print</span>(<span class="string">'普通Future，通过Timer实现'</span>));</span><br><span class="line"></span><br><span class="line">  Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () => <span class="built_in">print</span>(<span class="string">'延迟Future，通过Timer实现'</span>));</span><br><span class="line"></span><br><span class="line">  Future.microtask(() => <span class="built_in">print</span>(<span class="string">'Future创建微任务，通过scheduleMicrotask实现'</span>));</span><br><span class="line"></span><br><span class="line">  Future.<span class="keyword">sync</span>(() => <span class="built_in">print</span>(<span class="string">'同步Future，执行同步代码'</span>))</span><br><span class="line">      .then((a) => <span class="built_in">print</span>(<span class="string">'then中的代码0'</span>))</span><br><span class="line">      .then((b) => <span class="built_in">print</span>(<span class="string">'then中的代码1'</span>))</span><br><span class="line">      .then((c) { <span class="keyword">throw</span> <span class="string">'抛出then中的错误'</span>; })</span><br><span class="line">      .catchError((error) => <span class="built_in">print</span>(<span class="string">'捕获Error <span class="subst">$error<span class="string">'))</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      .whenComplete(() {print('</span></span>then任务完成'</span>);});</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果</p><blockquote><p>开始<br>结束<br>同步Future，执行同步代码<br>这是微任务0<br>这是微任务1<br>这是微任务2<br>Future创建微任务，通过scheduleMicrotask实现<br>then中的代码0<br>then中的代码1<br>捕获Error 抛出then中的错误<br>then任务完成<br>这是一个事件<br>普通Future，通过Timer实现</p><p>//延迟2s</p><p>延迟Future，通过Timer实现</p></blockquote><hr><p>在<code>dart:async</code>中，除了 Future，还有 Completer，用来将具体的 Future 流程控制权交给开发者</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completer = Completer();</span><br><span class="line"><span class="keyword">var</span> future = completer.future;</span><br><span class="line">future.then((d) => <span class="string">'返回的字符串'</span>)</span><br><span class="line">    .then((e) => <span class="built_in">print</span>(<span class="string">'获得Completer中的future <span class="subst">$e<span class="string">'));</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">completer.complete((e) => print('</span></span>设为完成状态'</span>));</span><br></pre></td></tr></tbody></table></figure><p>控制台输出</p><blockquote><p>获得Completer中的future 返回的字符串</p></blockquote><p>虽然 Future 缓解了回调地狱的问题，但如果串太多的<code>then</code>代码，可读性仍然会非常差，特别是各种 Future 嵌套的时候。与 JavaScript 类似，Dart 引入了<code>async/await</code>。</p><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 关键字修饰的函数与传统函数并无区别，只是将返回值类型使用 Future 进行了封装。</p><p>通过代码具体理解</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> {</span><br><span class="line">  getInt().then((i) => <span class="built_in">print</span>(<span class="string">'getInt: <span class="subst">$i<span class="string">'));</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  getString().then((s) => print('</span></span>getString: <span class="subst">$s<span class="string">'));</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>main'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getInt() <span class="keyword">async</span> => <span class="number">2333</span>;</span><br><span class="line">getString() <span class="keyword">async</span> => <span class="string">'hello'</span>;</span><br></pre></td></tr></tbody></table></figure><p>控制台输出</p><blockquote><p>main<br>getInt: 2333<br>getString: hello</p></blockquote><p>可以看到，调用<code>async</code>方法的代码转换成了异步任务。要想使之变成同步顺序，使用<code>await</code>关键字。不过需要注意的是，该关键字必须要在<code>async</code>函数中使用</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> {</span><br><span class="line">  <span class="keyword">var</span> i = <span class="keyword">await</span> getInt();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'getInt: <span class="subst">$i<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  var s = await getString();</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>getString: <span class="subst">$s<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>main'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台输出</p><blockquote><p>getInt: 2333<br>getString: hello<br>main</p></blockquote><p>继续下面的例子</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main 0'</span>);</span><br><span class="line">  foo();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main 1'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo() <span class="keyword">async</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Foo'</span>);</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">await</span> bar();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'from bar: <span class="subst">$s<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">}</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">bar() {</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>Bar'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台输出为</p><blockquote><p>main 0<br>Foo<br>Bar<br>main 1<br>from bar: hello</p></blockquote><p>也就是说，在<code>foo</code>中，除了第一行代码以及<code>bar()</code>这一函数调用之外的其他代码均为异步执行。当使用<code>await</code>的时候，其右边会马上返回一个 Future 对象，下面的代码则会以<code>then</code>的形式运行。</p><p>上面的代码转换成 Future 风格</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo() {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Foo'</span>);</span><br><span class="line">  <span class="keyword">return</span> Future.<span class="keyword">sync</span>(bar).then((s) => <span class="built_in">print</span>(<span class="string">'from bar: <span class="subst">$s<span class="string">'));</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">}</span></span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>stream 是 Dart 中一个长度不确定的值列表，可以是有限的或者无限的，重要的是我们不知道 stream 何时结束或已经结束。随时间改变的鼠标位置、所有素数的列表或者网络上的视频流，都可以看做一个 stream。</p><p>可以通过为 stream 注册一个或多个回调函数的方式，对其进行订阅监听。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield 语句被用于生成器函数内，目的是给生成的集合添加新的结果。yield 语句总是使它的表达式被求值，通常情况下，求值结果会被追加到外层生成器所关联的集合中。如果生成器是同步的，则关联的集合是一个 iterable；如果是异步的，则关联的集合是一个 stream。</p><p>此外，yield 也会因外层的生成器是否同步产生不同的行为：同步时 yield 会暂停外层生成器，直至调用<code>moveNext</code>且返回值为 true，异步时生成器的执行会继续。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>一个函数体标记有<code>async*</code>修饰符的函数，将作为 stream 的生成函数。下面的函数生成一个包含自然数序列的 stream</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> naturals <span class="keyword">async</span>* {</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k < <span class="number">3</span>) {</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> k++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> {</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> naturals) {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'get a natural <span class="subst">$i<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  }</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">}</span></span></span></span><br></pre></td></tr></tbody></table></figure><p>运行<code>main</code>函数，控制台将输出</p><blockquote><p>get a natural 0<br>get a natural 1<br>get a natural 2</p></blockquote><p>当 naturals 被调用时，立即返回一个新的 stream，一旦 stream 被监听，函数体将运行，以便生成值来填充 stream。每一次迭代执行一次 yield 语句，k 将自增（由于 await 的存在，函数会有短暂停止），然后函数将继续执行并使用新的 k 值，该值将被 yield 追加到 stream 中。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>上述函数的同步形式</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> naturalsTo(n) <span class="keyword">sync</span>* {</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(k < n) {</span><br><span class="line">    <span class="keyword">yield</span> k++;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>通过一个混合编程的例子来体会两者的区别</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Iterable nSync(n) sync* {</span><br><span class="line">  int k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k < n)  {</span><br><span class="line">    print(<span class="string">'sync before k++ and k is $k'</span>);</span><br><span class="line">    <span class="keyword">yield</span> k++;</span><br><span class="line">    print(<span class="string">'sync after k++ and k is $k'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Stream nAsync(n) <span class="keyword">async</span>* {</span><br><span class="line">  int k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k < n)  {</span><br><span class="line">    print(<span class="string">'async before k++ and k is $k'</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> k++;</span><br><span class="line">    print(<span class="string">'async after k++ and k is $k'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  nAsync(<span class="number">2</span>).last;</span><br><span class="line">  nSync(<span class="number">2</span>).last;</span><br><span class="line">  print(<span class="string">'main'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台输出为</p><blockquote><p>sync before k++ and k is 0<br>sync after k++ and k is 1<br>sync before k++ and k is 1<br>sync after k++ and k is 2<br>main<br>async before k++ and k is 0<br>async after k++ and k is 1<br>async before k++ and k is 1<br>async after k++ and k is 2</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Dart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="Dart" scheme="http://yoursite.com/categories/Dart/"/>
    
    
      <category term="Dart" scheme="http://yoursite.com/tags/Dart/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>《红楼梦》读书笔记</title>
    <link href="http://yoursite.com/%E3%80%8A%E7%BA%A2%E6%A5%BC%E6%A2%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/《红楼梦》读书笔记/</id>
    <published>2019-04-24T03:35:40.000Z</published>
    <updated>2019-04-24T04:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。前几天，某个姑娘说她看《红楼梦》的时候最平静，“看了好多遍”，顿感愧疚。随即动身阅读。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促。</p><a id="more"></a><h2 id="第一回-甄士隐梦幻识通灵-贾雨村风尘怀闺秀"><a href="#第一回-甄士隐梦幻识通灵-贾雨村风尘怀闺秀" class="headerlink" title="第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀"></a>第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀</h2><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><blockquote><p>曾历过一番梦幻之后，故将真事隐去，而借通灵说此《石头记》一书也，故曰“甄士隐”云云。</p><p>“….我虽不学无文，又何妨用假语村言敷演出来？亦可使闺阁昭传。复可破一时之闷，醒同人之目，不亦宜乎？”故曰“贾雨村”云云。</p></blockquote><p>女娲补天所用三万六千五百零一块石头剩一块通灵，被一道人镌刻文字于其上，名《石头记》</p><blockquote><p>上面述着堕落之乡、投胎之处，以及家庭琐事、闺阁闲情、诗词谜语，倒还全备</p></blockquote><p>后所记录被空空道人所抄写，改《情僧录》，东鲁孔梅溪题《风月宝鉴》，曹雪芹于悼红轩批阅增删、分目录章节，题曰《金陵十二衩》，此为《石头记》缘起。曹雪芹题诗</p><blockquote><p>满纸荒唐言，一把辛酸泪。</p><p>都云作者痴，水解其中味！</p></blockquote><h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>姑苏城仁青巷中有一乡宦甄士隐，梦中忽逢一僧一道了结灵石公案。原来那石头各地游玩，入警幻仙子麾下，任赤霞宫神瑛侍者。因以甘露灌溉西方灵河绛珠草，结下姻缘。绛珠草为感谢雨露之惠，欲“还泪”解缘。一僧一道携一众风流冤家下凡。三人行至“太虚幻境”，两边有一对联</p><blockquote><p>假作真时真亦假</p><p>无为有处有还无</p></blockquote><p>甄士隐与附近葫芦庙穷儒贾雨村交好。中秋佳节两人畅饮，甄士隐资助贾雨村进京赶考后，独女英莲走失，家院因火灾烧成瓦砾，投靠岳父封肃遭受白眼非议。一日碰一跛足道人，听道人语有感</p><blockquote><p>金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧？训有方，保不定日后做强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛。昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。故荒唐，到头来都是“为他人作嫁衣裳”。</p></blockquote><p>便于道人飘飘而去。</p><h2 id="第二回-贾夫人仙逝扬州城-冷子兴演说荣国府"><a href="#第二回-贾夫人仙逝扬州城-冷子兴演说荣国府" class="headerlink" title="第二回 贾夫人仙逝扬州城　冷子兴演说荣国府"></a>第二回 贾夫人仙逝扬州城　冷子兴演说荣国府</h2><p>贾雨村受甄士隐赠银、进京赶考，中了进士，升任本县太爷，遣人至封府答谢甄士隐，同时将当年在甄士隐家中回首相顾的丫头娇杏娶作二房。然其恃才贪腐，不到一年便被革职，于是前往各地游览。</p><p>游至维扬时，入当朝盐政官林如海府中给其幼女林黛玉作西席。林如海年过五十，黛玉为嫡妻贾氏所生，聪明俊秀但体弱多病，其母一病身亡，需守丧尽礼，旧病复发。贾雨村便闲居无聊。</p><p>一日贾雨村郊外村肆中偶遇旧友冷子兴，二人聊起荣、宁两府。宁国公与荣国公是一母同胞兄弟。宁国公贾演生有两子，长子贾代化同有两子，稍长之子贾敷早死，次子贾敬袭官，然而一味好道终日炼丹。贾敬有一子贾珍，生下一子名贾蓉。荣国公贾源的长子贾代善在其去世后袭官，娶金陵世家史侯的小姐为妻，生有两子，长子贾赦袭官，次子贾政任员外郎。贾政夫人王氏生下二胎女儿十几年后，竟又生一嘴衔五彩晶玉的男孩，其名贾宝玉。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。前几天，某个姑娘说她看《红楼梦》的时候最平静，“看了好多遍”，顿感愧疚。随即动身阅读。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促。&lt;/p&gt;
    
    </summary>
    
      <category term="文学" scheme="http://yoursite.com/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="文学" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%A6/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="红楼梦" scheme="http://yoursite.com/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
    
  </entry>
  
  <entry>
    <title>Dart 面向对象</title>
    <link href="http://yoursite.com/Dart-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/Dart-面向对象/</id>
    <published>2019-04-23T01:10:53.000Z</published>
    <updated>2019-04-24T05:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用 class 关键字定义一个类。与 Java 类似，如果没有显示地定义构造函数，会默认一个无参构造函数。使用 new 关键字和构造函数来创建对象。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  <span class="built_in">num</span> z;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  <span class="keyword">var</span> point = <span class="keyword">new</span> Point();</span><br><span class="line">  <span class="built_in">print</span>(point.hasCode);<span class="comment">//未定义父类的时候，默认继承自Object</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>可以在构造函数的参数前加 this 关键字直接赋值</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">    <span class="built_in">num</span> x;</span><br><span class="line">    <span class="built_in">num</span> y;</span><br><span class="line">    <span class="built_in">num</span> z;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一个值传递给this.x，第二个值传递给this.y</span></span><br><span class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, z) {</span><br><span class="line">            <span class="keyword">this</span>.z = z;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//命名构造函数，格式为Class.name(var param)</span></span><br><span class="line">    Point.fromeList(<span class="keyword">var</span> list): </span><br><span class="line">            x = list[<span class="number">0</span>], y = list[<span class="number">1</span>], z = list[<span class="number">2</span>]{<span class="comment">//使用冒号初始化变量</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当然，上面也可以简写为：</span></span><br><span class="line">    <span class="comment">//Point.fromeList(var list):this(list[0], list[1], list[2]);</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">String</span> toString() => <span class="string">'x:<span class="subst">$x</span>  y:<span class="subst">$y</span>  z:<span class="subst">$z<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">}</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">//调用父类的构造方法</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">class ColorPoint extends Point {</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  String color;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  ColorPoint.fromXYZAndColor(num x, num y, num z, String color)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      : super.fromXYZ(x, y, z) {</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    this.color = color;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    print('</span></span>ColorPoint'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromeList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">print</span>(p1);<span class="comment">//默认调用toString()函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要创建不可变对象的话，可以在构造函数前使用<code>const</code>关键字定义编译时常量对象</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">    <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y); <span class="comment">// 常量构造函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 创建一个常量对象不能用new，要用const</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h3><p>Dart 中一种获取单例对象的方式，使用工厂模式来定义构造函数。对于调用者来说，仍然使用 new 关键字来获取对象，具体的实现细节对外隐藏。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>{ </span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> name; </span><br><span class="line">    <span class="built_in">bool</span> mute = <span class="keyword">false</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变量前加下划线表示私有属性 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span><<span class="built_in">String</span>, Logger> _cache = <<span class="built_in">String</span>, Logger>{}; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) { </span><br><span class="line">        <span class="keyword">if</span> (_cache.containsKey(name)) { </span><br><span class="line">            <span class="keyword">return</span> _cache[name]; </span><br><span class="line">        } <span class="keyword">else</span> { </span><br><span class="line">            <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name); </span><br><span class="line">            _cache[name] = logger; </span><br><span class="line">            <span class="keyword">return</span> logger; </span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Logger._internal(<span class="keyword">this</span>.name); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> log(<span class="built_in">String</span> msg) { </span><br><span class="line">        <span class="keyword">if</span> (!mute) { </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>: <span class="subst">$msg<span class="string">'); </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        } </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    } </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">} </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">var logger = new Logger('</span></span>UI'</span>); </span><br><span class="line">logger.log(<span class="string">'Button clicked'</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="Getter / Setter"></a>Getter / Setter</h3><p>用来读写对象的属性，每个属性都对应一个隐式的 Getter 和 Setter，通过<code>obj.x</code>调用。类似于 Kotlin，可以使用<code>get</code>、<code>set</code>关键字拓展相应的功能。如果属性为<code>final</code>或者<code>const</code>，则只有对外的 Getter。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>{</span><br><span class="line">    <span class="built_in">num</span> left;</span><br><span class="line">    <span class="built_in">num</span> top;</span><br><span class="line">    <span class="built_in">num</span> width;</span><br><span class="line">    <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">    Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// right 和 bottom 两个属性的计算方法</span></span><br><span class="line">    <span class="built_in">num</span> <span class="keyword">get</span> right => left + width;</span><br><span class="line">    <span class="keyword">set</span> right(<span class="built_in">num</span> value) => left = value - width;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">num</span> <span class="keyword">get</span> bottom => top + height;</span><br><span class="line">    <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) => top = value - height;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">    <span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    rect.right = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>实例方法跟 Java 类似，抽象方法有所不同，不需要使用<code>abstract</code>显示定义，只需要在方法签名后用<code>;</code>来代替方法体即表示其为一抽象方法，Dart 中非抽象类也可以定义抽象方法。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">  <span class="keyword">void</span> fly();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>{</span><br><span class="line">  <span class="keyword">void</span> fly() {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">void</span> sleep();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Dart 中没有“接口”这一概念，类分为抽象类和非抽象类，唯一的区别是后者不可直接实例化。Dart 中仍然使用了<code>implements</code>和<code>extends</code>关键字，不过两者有所不同</p><ul><li>implements 代表实现，子类无法访问父类的参数，可以实现多个类</li><li>extends 代表继承，可继承父类的非私有变量，使用单继承机制</li></ul><p>在构造函数体前使用 <code>super</code>关键字调用父类构造函数，使用<code>@override</code>来注解复写父类的方法。</p><h3 id="Mixin-继承机制"><a href="#Mixin-继承机制" class="headerlink" title="Mixin 继承机制"></a>Mixin 继承机制</h3><h4 id="继承歧义"><a href="#继承歧义" class="headerlink" title="继承歧义"></a>继承歧义</h4><p>在了解该机制之前先认识“继承歧义”，也叫“菱形问题”。当两个类 B 和 C 继承自 A，D类继承自 B 和 C 时将产生歧义。当 A 中有一个方法在 B 和 C 中已经重写，而 D 没有 重写，那么 D 继承的方法的版本是 B 还是 C？</p><p><img src="/Dart-面向对象/继承歧义.png" alt="继承歧义"></p><p>不同的编程语言有不同的方法处理该问题</p><table><thead><tr><th>语言</th><th style="text-align:center">解决方案</th></tr></thead><tbody><tr><td>C++</td><td style="text-align:center">需要显式地声明要使用的特性是从哪个父类调用的(如：<code>Worker::Human.Age</code>)。C++不支持显式的重复继承，因为无法限定要使用哪个父类</td></tr><tr><td>Java 8</td><td style="text-align:center">Java 8 在接口上引入默认方法。如果<code>A、B、C</code>是接口，<code>B、C</code>可以为<code>A</code>的抽象方法提供不同的实现，从而导致<code>菱形问题</code>。<code>D</code>类必须重新实现该方法，否则发生编译错误。（Java 8 之前不支持多重继承、没有默认方法）</td></tr></tbody></table><p>Dart 使用 Mixin 机制解决该方法，或者写作“mix-in（混入）”更容易理解。</p><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>在 Java8 之前，由于单继承机制以及接口没有默认方法，避免了继承歧义，而 Dart 虽然也使用了单继承机制，但是没有<code>interface</code>这一概念 —— 实际上，Dart 中的每一个类都可以被<code>implements</code> —— 所以使用了基于线性逻辑的<code>Mixin</code>解决该问题。</p><p><code>Mixin</code>即为混入：<code>Mixins are a way of reusing a class’s code in multiple class hierarchies</code>。</p><p>通过一个例子理解</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">'A'</span>;</span><br><span class="line">  <span class="keyword">get</span>() => <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">'B'</span>;</span><br><span class="line">  <span class="keyword">get</span>() => <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">'P'</span>;</span><br><span class="line">  <span class="keyword">get</span>() => <span class="string">'P'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="title">with</span> <span class="title">A</span>, <span class="title">B</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">'AB'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BA</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">A</span> </span>{}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  AB ab = AB();</span><br><span class="line">  <span class="built_in">print</span>(ab.<span class="keyword">get</span>());</span><br><span class="line">  <span class="built_in">print</span>(ab.s);</span><br><span class="line"></span><br><span class="line">  BA ba = BA();</span><br><span class="line">  <span class="built_in">print</span>(ba.<span class="keyword">get</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台输出为：</p><blockquote><p>B<br>AB<br>A</p></blockquote><p>这是因为下面的代码</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="title">with</span> <span class="title">A</span>, <span class="title">B</span> </span>{}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BA</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">A</span> </span>{}</span><br></pre></td></tr></tbody></table></figure><p>相当于</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PA</span> = <span class="title">P</span> <span class="title">with</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PAB</span> = <span class="title">PA</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AB</span> <span class="keyword">extends</span> <span class="title">PAB</span> </span>{}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PB</span> = <span class="title">P</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PBA</span> = <span class="title">PB</span> <span class="title">with</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BA</span> <span class="keyword">extends</span> <span class="title">PBA</span> </span>{}</span><br></pre></td></tr></tbody></table></figure><p>继承图如下</p><p><img src="/Dart-面向对象/ABP继承图.png" alt="ABP继承图"></p><p>有意思的是，当我们将上面的代码中的<code>with</code>换成<code>implements</code>时，输出的结果将为</p><blockquote><p>P<br>AB<br>P</p></blockquote><h3 id="extends、with、implements"><a href="#extends、with、implements" class="headerlink" title="extends、with、implements"></a>extends、with、implements</h3><p>在 Dart 中，类声明必须严格按照 extends -> with -> implements 的顺序</p><ul><li><p>extends 的用法类似于 Java，唯一的不同在于子类可以完全访问父类的属性和函数，因为在 Dart 中并没有私有、公有的概念，下划线<code>_</code>的仅仅是一种约定。</p></li><li><p>除了上面的内容，<code>with</code>还可以与之搭配关键字<code>on</code>，表示要进行 mixin 的类必须先 “implements” 被 mixin 的类声明中 on 关键字后面的类，否则编译失败</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>{</span><br><span class="line">  <span class="keyword">void</span> fromD();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">mixin C on D {</span><br><span class="line">  fromC() => <span class="string">'C'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  下面的代码将编译失败，因为 F 要 mixin C 必须先“implements” D</span></span><br><span class="line"><span class="comment">  但是 implements 关键字又必须在 with 的后面，所以只能定义一个新的类 E</span></span><br><span class="line"><span class="comment">  使 E implements D，F 再 extends E，才能 mixin C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="title">with</span> <span class="title">C</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure><p>正确的做法</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> <span class="keyword">implements</span> <span class="title">D</span> </span>{</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> fromD() => <span class="string">'E'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">E</span> <span class="title">with</span> <span class="title">C</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure></li><li><p>Dart 中每个类都是一个隐式地接口。<code>implements</code>一个类之后，必须<code>override</code>所有的方法和成员变量</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Dart" scheme="http://yoursite.com/categories/Dart/"/>
    
    
      <category term="Dart" scheme="http://yoursite.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Dart 基础入门</title>
    <link href="http://yoursite.com/Dart%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/Dart 基础入门/</id>
    <published>2019-04-22T06:27:18.000Z</published>
    <updated>2019-04-22T12:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>终于开始 Flutter 的具体学习，一切从 Dart 语言开始。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() {</span><br><span class="line">    print('hello world');</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。</p><p><img src="/Dart 基础入门/idea_create.png" alt></p><p>创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的<code>main</code>函数作为运行的入口。在<code>run</code>之前需要<code>edit configuration</code>，很简单，只要指定对应的文件即可。</p><p><img src="/Dart 基础入门/idea_category.png" alt></p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为<code>null</code>。可以使用具体的类型声明，也可以使用<code>var</code>、<code>dynamic</code>、<code>const</code>、<code>final</code>等关键字</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void main() {</span><br><span class="line">  var i = 0;</span><br><span class="line">  var d = 2.0;</span><br><span class="line">  var s = 'hello';</span><br><span class="line">  var b = true;</span><br><span class="line">  var l = [1, 2, 3];</span><br><span class="line">  var m = {0: 'a', 1: 'b'};</span><br><span class="line">  </span><br><span class="line">  print(main is Function);  //true</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过查看官方库的<code>core</code>包，可以大概看出其结构</p><p><img src="/Dart 基础入门/dart_core.png" alt="dart_core"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>包括 int 和 double，分别代表整形和浮点型。</p><p>int 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">'hello'</span> + <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">'hello'</span> <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">var</span> s5 = <span class="string">"""hello </span></span><br><span class="line"><span class="string">              world"""</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clapping = <span class="string">'\u{1f44f}'</span>;</span><br><span class="line"><span class="built_in">print</span>(clapping);</span><br><span class="line"></span><br><span class="line">Runes runes = <span class="keyword">new</span> Runes(<span class="string">'\u{1f44d}'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCode(runes.first));</span><br></pre></td></tr></tbody></table></figure><p>上面的输出为</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">👏</span><br><span class="line">👍</span><br></pre></td></tr></tbody></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>提供 bool 用来声明布尔型变量，默认为 false。</p><h3 id="List-和-Map"><a href="#List-和-Map" class="headerlink" title="List 和 Map"></a>List 和 Map</h3><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><<span class="built_in">int</span>> l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">l.forEach((x) => <span class="built_in">print</span>(x)); <span class="comment">//forEach的参数为 Function</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">in</span> l) { <span class="comment">//使用for-in</span></span><br><span class="line">  <span class="built_in">print</span>(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span><<span class="built_in">int</span>, <span class="built_in">String</span>> map = {<span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>};</span><br><span class="line">map[<span class="number">0</span>] = <span class="string">"c"</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="普通Function"><a href="#普通Function" class="headerlink" title="普通Function"></a>普通Function</h3><p>函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() {</span><br><span class="line">  single1(<span class="string">'Tom'</span>, <span class="number">20</span>);</span><br><span class="line">  single2(<span class="string">'Tom'</span>, <span class="number">20</span>);</span><br><span class="line">  single3(<span class="string">'Tom'</span>, <span class="number">20</span>, weight: <span class="number">30</span>); <span class="comment">//由于没有位置约束，必须指定形参名称</span></span><br><span class="line">  single4(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> single1(<span class="built_in">String</span> name, <span class="built_in">int</span> age) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回类型和参数类型可省略，支持返回表达式</span></span><br><span class="line">single2(name, age) => <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值</span></span><br><span class="line"><span class="built_in">bool</span> single3(<span class="built_in">String</span> name, <span class="built_in">int</span> age, {<span class="built_in">int</span> weight = <span class="number">60</span>, <span class="built_in">int</span> height}) => <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight</span></span><br><span class="line"><span class="built_in">bool</span> single4(<span class="built_in">String</span> name, <span class="built_in">int</span> age, [<span class="built_in">int</span> weight, <span class="built_in">int</span> height]) => <span class="keyword">true</span>;</span><br></pre></td></tr></tbody></table></figure><p>对于<code>main</code>方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() => runApp(MyApp());</span><br></pre></td></tr></tbody></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = (c) {</span><br><span class="line">  <span class="built_in">print</span>(c);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">f(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">printElement(x) {<span class="comment">//方法签名写成 void printElement(int x) 更直观</span></span><br><span class="line">  <span class="built_in">print</span>(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></tbody></table></figure><p><code>forEach</code>的函数定义如下</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> forEach(<span class="keyword">void</span> f(E element)) {</span><br><span class="line">  <span class="keyword">for</span> (E element <span class="keyword">in</span> <span class="keyword">this</span>) f(element);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面的例子直观展示将函数作为变量传递的思想</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> n) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) => n + i;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="comment">//更明晰的写法</span></span><br><span class="line"><span class="built_in">Function</span> makeAdder_(<span class="built_in">num</span> n) {</span><br><span class="line">  <span class="built_in">Function</span> add = (<span class="built_in">num</span> i) {</span><br><span class="line">    <span class="keyword">return</span> i + n;</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(adder2(<span class="number">3</span>));</span><br></pre></td></tr></tbody></table></figure><p>控制台将输出 5</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>除了<code>=</code>，还有<code>??=</code>，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。</p><h3 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h3><p><code>==</code>将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的<code>identical</code>方法</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">external</span> <span class="built_in">bool</span> identical(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br></pre></td></tr></tbody></table></figure><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><table><thead><tr><th style="text-align:center">操作符</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">/</td><td>除，比如 5/2 = 2.5</td></tr><tr><td style="text-align:center">~/</td><td>整除， 5/2 = 2</td></tr></tbody></table><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><table><thead><tr><th style="text-align:center">操作符</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">is</td><td>对象属于指定类型则返回true</td></tr><tr><td style="text-align:center">is!</td><td>对象不属于指定类型返回true</td></tr><tr><td style="text-align:center">as</td><td>类型转换</td></tr></tbody></table><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>分为两种</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">condition ? expr1 : expr2<span class="comment">//通用表达式</span></span><br><span class="line">expr1 ?? expr2<span class="comment">//如果 expr1 非空，返回其值，否则返回 expr2</span></span><br></pre></td></tr></tbody></table></figure><h3 id="级联调用与非空调用"><a href="#级联调用与非空调用" class="headerlink" title="级联调用与非空调用"></a>级联调用与非空调用</h3><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规写法</span></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">'#button'</span>);</span><br><span class="line">button.text = <span class="string">'Confirm'</span>;</span><br><span class="line">button.classes.add(<span class="string">'important'</span>);</span><br><span class="line">button.onClick.listen((e) => <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用级联表达式</span></span><br><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#button'</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">'Confirm'</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">'important'</span>)</span><br><span class="line">  ..onClick.listen((e) => <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//非空调用</span></span><br><span class="line"><span class="built_in">print</span>(button?.text);</span><br></pre></td></tr></tbody></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Dart 语言在比如 <code>if/else</code>、<code>[do、]while</code>、<code>for</code>、<code>switch/case</code>等语句上跟 Java 类似，不再赘述。</p><p>异常处理的做法如下</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">'x should be less than 10'</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FormatException(<span class="string">'Expected at least 1 section'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获异常</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">} on OutOfLlamasException {</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">} on Exception <span class="keyword">catch</span> (e) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: <span class="subst">$e<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">} catch (e, s) {</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>Exception details:\n <span class="subst">$e<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>Stack trace:\n <span class="subst">$s<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">}</span></span></span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;终于开始 Flutter 的具体学习，一切从 Dart 语言开始。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void main() {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&#39;hello world&#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Dart" scheme="http://yoursite.com/categories/Dart/"/>
    
    
      <category term="Dart" scheme="http://yoursite.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Android Binder 源码解析</title>
    <link href="http://yoursite.com/Android-Binder-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/Android-Binder-源码解析/</id>
    <published>2019-03-23T04:18:53.000Z</published>
    <updated>2019-04-24T05:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Binder" scheme="http://yoursite.com/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程和线程池详解</title>
    <link href="http://yoursite.com/Java-%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Java-线程和线程池详解/</id>
    <published>2019-03-20T09:29:06.000Z</published>
    <updated>2019-03-21T10:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：</p><blockquote><p>java.lang.Thread 类的一个实例；</p><p>线程的执行。</p></blockquote><a id="more"></a><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p><p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</p><p>线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。</p><blockquote><p>一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。</p><p>Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。</p><p>由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。</p></blockquote><p>实际开发中使用多线程的优势在于</p><ul><li>进程之间不能共享内存，而线程之间可以共享内存。</li><li>系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。</li><li>Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>图一</p><p><img src="/Java-线程和线程池详解/线程状态1.png" alt></p><p>图二</p><p><img src="/Java-线程和线程池详解/线程状态2.png" alt></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>Java 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。</p><p>只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"is daemon thread? "</span> + thread.isDaemon());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>输出为<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is daemon thread? true</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用守护线程要注意的点</p><ul><li><code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。</li><li>在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 </li><li>不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 </li></ul><h3 id="Runnable-和-Thread"><a href="#Runnable-和-Thread" class="headerlink" title="Runnable 和 Thread"></a>Runnable 和 Thread</h3><p>Runnable 是一个线程接口，查看其构造<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>其中只定义了一个<code>run</code>方法</p><p>Thread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的<code>init</code><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                      long stackSize, AccessControlContext acc,</span><br><span class="line">                      boolean inheritThreadLocals)</span><br></pre></td></tr></tbody></table></figure><p></p><p>观察 Thread 中重写的<code>run</code>方法<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) {</span><br><span class="line">        target.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>其中 target 为 Runnable 对象，即调用 Thread 的<code>run</code>实际上是调用我们传进去的 Runnable 的对应方法</p><p>观察其<code>start</code>方法<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//不能重复调用 start 方法</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//将线程加入线程组</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//线程开始标志</span></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//调用native方法开始多线程</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!started) {</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>其中<code>start0</code>是 native 方法，在其中新建线程，然后回调 target 的 run 方法。</p><p>也就是说，如果我们直接调用<code>run</code>方法，相当于调用普通方法，不会有多线程效果。只有调用<code>start</code>才会在后台开启另一个线程，等待 CPU 调度。</p><h3 id="多线程-API"><a href="#多线程-API" class="headerlink" title="多线程 API"></a>多线程 API</h3><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>wait()</td><td>锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池</td></tr><tr><td>wait(long)</td><td>锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。</td></tr><tr><td>wait(long, int)</td><td>和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000</td></tr><tr><td>notify()</td><td>随机唤醒一个处于等待中的线程（同一个等待阻塞池中）</td></tr><tr><td>notifyAll()</td><td>唤醒所有等待中的线程（同一个等待阻塞池中）</td></tr></tbody></table><p>以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行<code>object.wait()</code>方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            t.wait(<span class="number">2000</span>);   <span class="comment">//由于没有获得锁，将抛出 IllegalMonitorStateException 异常</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"current Thread info in Main: "</span> + t.toString());</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.printThreadInfo();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printThreadInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            wait(<span class="number">2000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"current Thread info in A: "</span> + t.toString());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>删除<code>main</code>中 try/catch 语句之后，控制台输出如下<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current Thread info in Main: Thread[main,5,main]</span><br><span class="line">//等待两秒</span><br><span class="line">current Thread info in A: Thread[main,5,main]</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>为什么需要在 synchronized 中？</strong></p><blockquote><p>wait和notify用于线程间通信。<br>以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性</p><p>一般对队列的操作如下:<br>while(queue.size() == MAX_SIZE){ wait() }</p><p>假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2</p><ul><li><p>t1判断队列满，需要 wait 阻塞线程。</p></li><li><p>但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。</p></li><li><p>这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。</p></li><li><p>假如此时消费者不消费了，那么生产者则会一直阻塞下去。</p></li><li><p>所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。</p></li></ul></blockquote><p><strong>为什么定义在 Object 中？</strong></p><blockquote><p>Object 中的<code>wait()</code>, <code>notify()</code>等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。</p><p><code>wait()</code>会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！<br>当线程释放它持有的“同步锁”之后变成等待线程，可以被<code>notify()</code>或<code>notifyAll()</code>唤醒。那么，<code>notify()</code>依据什么唤醒等待线程的？或者说，<code>wait()</code>等待线程和<code>notify()</code>之间通过什么关联起来？答案是：依据“对象的同步锁”。</p><p>负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用<code>notify()</code>或<code>notifyAll()</code>方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p><p>总之，<code>notify()</code>, <code>wait()</code>依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！</p><p>这就是<code>notify()</code>, <code>wait()</code>等函数定义在 Object 类，而不是 Thread 类中的原因。</p><p>来自 <a href="https://www.cnblogs.com/happy-coder/p/6587092.html" target="_blank" rel="noopener">JAVA 线程状态及转化</a></p></blockquote><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Thread.currentThread()</td><td>返回对当前线程对象的引用</td></tr><tr><td>Thread.interrupted()</td><td>检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false）</td></tr><tr><td>Thread.sleep(long millis)</td><td>使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会）</td></tr><tr><td>Thread.yield()</td><td>使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会）</td></tr><tr><td>t.getId()…</td><td>返回该线程的 id 等等信息</td></tr><tr><td>t.interrupt()</td><td>将该线程中断（实际并不会中断，只是将中断标志设置为true）</td></tr><tr><td>t.isInterrupted()</td><td>检测该线程是否已经中断</td></tr><tr><td>t.join()</td><td>在a线程中调用b.join()，则a线程阻塞，直到b线程执行完</td></tr><tr><td>t.join(long millis)</td><td>同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。</td></tr></tbody></table><hr><p>关于 interrupt，<a href="https://blog.csdn.net/qpc908694753/article/details/61414495" target="_blank" rel="noopener">JAVA interrupt、interrupted和isInterrupted的区别</a></p><blockquote><p>interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。</p><p>注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p></blockquote><h4 id="废弃方法"><a href="#废弃方法" class="headerlink" title="废弃方法"></a>废弃方法</h4><ul><li>stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止</li><li>suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。</li><li>resume：用来回复被挂起的线程，跟 suspend 对应。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java 中关于线程池的继承关系如下</p><p><img src="/Java-线程和线程池详解/继承图.png" alt></p><p>Executor 是一个顶层接口，其中只声明了一个方法<code>execute(Runnable)</code>，用来执行传进去的任务</p><p>ExecutorService 接口继承了 Executor 接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code> 等</p><p>抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法</p><p>ThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue<Runnable> workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize < <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize <= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize < corePoolSize ||</span><br><span class="line">        keepAliveTime < <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用<code>prestartAllCoreThreads</code>或者<code>prestartCoreThread</code>方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中</li><li>maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程</li><li>keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0</li><li><p>unit：参数keepAliveTime的时间单位，有7种取值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               //天</span><br><span class="line">TimeUnit.HOURS;             //小时</span><br><span class="line">TimeUnit.MINUTES;           //分钟</span><br><span class="line">TimeUnit.SECONDS;           //秒</span><br><span class="line">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class="line">TimeUnit.MICROSECONDS;      //微妙</span><br><span class="line">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></tbody></table></figure></li><li><p>workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></tbody></table></figure></li><li><p>threadFactory：线程工厂，主要用来创建线程</p></li><li>handler：表示当拒绝处理任务时的策略，有以下四种选择：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="为何使用"><a href="#为何使用" class="headerlink" title="为何使用"></a>为何使用</h4><ul><li>降低资源消耗<br><br>可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li><li>提高响应速度<br><br>当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li><li>提高线程的可管理性 <br><br>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li></ul><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的</span></span><br><span class="line"><span class="comment">//线程池满了就不再添加线程；</span></span><br><span class="line"><span class="comment">//如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue<Runnable>(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列</span></span><br><span class="line"><span class="comment">//因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务</span></span><br><span class="line"><span class="comment">//若池中线程空闲时间超过指定大小，则该线程会被销毁。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue<Runnable>(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建只有一个线程的线程池，且线程的存活时间是无限的</span></span><br><span class="line"><span class="comment">//当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue<Runnable>(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行</span></span><br><span class="line"><span class="comment">//如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中</span></span><br><span class="line"><span class="comment">//这是一种按照超时时间排序的队列结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>ThreadPoolExecutor 中比较重要的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>execute()</td><td>向线程池提交一个任务，交由线程池去执行</td></tr><tr><td>submit()</td><td>向线程池提交任务的，能够返回任务执行的结果（利用 Future）</td></tr><tr><td>shutdown()</td><td>关闭线程池</td></tr><tr><td>shutdownNow()</td><td>关闭线程池</td></tr></tbody></table><p>还有其他的方法比如：<code>getQueue()</code>、<code>getPoolSize()</code> 、<code>getActiveCount()</code>、<code>getCompletedTaskCount()</code>等用来获取线程池的相关属性。</p><p>简单使用<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">    System.out.println(Thread.currentThread());</span><br><span class="line">    executor.execute(()-> {</span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>控制台输出<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,5,main]</span><br><span class="line">Thread[pool-1-thread-1,5,main]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>观察 ThreadPoolExecutor 中的<code>execute</code>方法<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务</span></span><br><span class="line"><span class="comment">         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。</span></span><br><span class="line"><span class="comment">         * 三、如果加入 workQueue 失败，则创建线程执行任务，</span></span><br><span class="line"><span class="comment">         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) < corePoolSize) {</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) && workQueue.offer(command)) {</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) && remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p></p><p>跟踪<code>addWorker</code>方法<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>{</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) {</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            && (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，</span></span><br><span class="line"><span class="comment">             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建Worker时会调用threadFactory来创建一个线程。</span></span><br><span class="line"><span class="comment">         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) && firstTask == <span class="keyword">null</span>)) {</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s > largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>新建 Work ，同时也会利用工厂类实例化一个线程<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) {</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果 workerAdded，调用<code>t.start()</code><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>跟踪<code>runWorker</code><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>{</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &&</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &&</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到<code>getTask</code>方法不断从 workerQueue 中读取任务然后执行。只要<code>getTask</code>方法不返回 null，循环就不会退出。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是判断当前线程数是否大于 corePoolSize</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc > corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc > maximumPoolSize || (timed && timedOut))</span><br><span class="line">            && (wc > <span class="number">1</span> || workQueue.isEmpty())) {</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务</span></span><br><span class="line"><span class="comment">         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出</span></span><br><span class="line"><span class="comment">         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException retry) {</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>最后用一张图总结上述过程</p><p><img src="/Java-线程和线程池详解/线程池流程.png" alt></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.lang.Thread 类的一个实例；&lt;/p&gt;
&lt;p&gt;线程的执行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java 数据库知识整理</title>
    <link href="http://yoursite.com/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/Java-数据库知识整理/</id>
    <published>2019-03-18T02:45:26.000Z</published>
    <updated>2019-04-24T05:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》题目 Java 实现</title>
    <link href="http://yoursite.com/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E9%A2%98%E7%9B%AE-Java-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/《剑指offer》题目-Java-实现/</id>
    <published>2019-03-18T02:42:29.000Z</published>
    <updated>2019-03-25T09:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Problem1：单例模式实现"><a href="#Problem1：单例模式实现" class="headerlink" title="Problem1：单例模式实现"></a>Problem1：单例模式实现</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>{}  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {  </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {  </span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                }  </span><br><span class="line">            }  </span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h3 id="Problem2：二维数组中的查找"><a href="#Problem2：二维数组中的查找" class="headerlink" title="Problem2：二维数组中的查找"></a>Problem2：二维数组中的查找</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从二维数组的右上角开始选取与 key 比较的整数</span></span><br><span class="line"><span class="comment">     * column 的变化:arr[0].length - 1 ---> 0</span></span><br><span class="line"><span class="comment">     * row 的变化 0 ---> arr.length</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> col = arr[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (col >= <span class="number">0</span> && row < arr.length) {</span><br><span class="line">        <span class="keyword">if</span> (arr[row][col] == key) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (arr[row][col] > key) {   <span class="comment">//大于查找值，则往前推一列</span></span><br><span class="line">            col--;</span><br><span class="line">        } <span class="keyword">else</span> {    <span class="comment">//小于查找值，则往下推一行</span></span><br><span class="line">            row++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem3：替换空格"><a href="#Problem3：替换空格" class="headerlink" title="Problem3：替换空格"></a>Problem3：替换空格</h3><p>请实现一个函数，将字符串的每个空格替换为”%20”。例如输入<code>We are happy</code>，则输出<code>We%20are%20happy</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 StringBuilder</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replace</span><span class="params">(String str)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < str.length(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) {</span><br><span class="line">            builder.append(<span class="string">"%20"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            builder.append(str.charAt(i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem4：从尾到头打印链表"><a href="#Problem4：从尾到头打印链表" class="headerlink" title="Problem4：从尾到头打印链表"></a>Problem4：从尾到头打印链表</h3><p>输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><<span class="title">T</span>> </span>{</span><br><span class="line">    T value;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(T value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListReverse</span><span class="params">(ListNode headNode)</span> </span>{</span><br><span class="line">    Stack<ListNode> stack = <span class="keyword">new</span> Stack<>();</span><br><span class="line">    <span class="keyword">while</span> (headNode != <span class="keyword">null</span>) {</span><br><span class="line">        stack.push(headNode);</span><br><span class="line">        headNode = headNode.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) {</span><br><span class="line">        System.out.println(stack.pop().value + <span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    ListNode<Integer> node = <span class="keyword">new</span> ListNode<>(<span class="number">1</span>);</span><br><span class="line">    node.next = <span class="keyword">new</span> ListNode<>(<span class="number">2</span>);</span><br><span class="line">    node.next.next = <span class="keyword">new</span> ListNode<>(<span class="number">3</span>);</span><br><span class="line">    printListReverse(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem5：重建二叉树"><a href="#Problem5：重建二叉树" class="headerlink" title="Problem5：重建二叉树"></a>Problem5：重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。</p><p>假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。</p><p>例如输入前序遍历序列： <code>{1, 2, 4, 7, 3, 5, 6, 8}</code></p><p>中序遍历序列：<code>{4, 7, 2, 1, 5, 3, 8, 6}</code></p><p>重建出所示二叉树并且输出它的头结点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> /     / \</span><br><span class="line"><span class="number">4</span>     <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"> \        /</span><br><span class="line"> <span class="number">7</span>        <span class="number">8</span></span><br></pre></td></tr></tbody></table></figure><h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><blockquote><p>前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）</p><p>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）</p><p>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）</p></blockquote><blockquote><p>二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。</p><p>二叉树的特例是<strong>堆</strong>和<strong>红黑树</strong>。</p><p>堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。</p><p>红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。</p></blockquote><h3 id="Problem6：用两个栈实现队列"><a href="#Problem6：用两个栈实现队列" class="headerlink" title="Problem6：用两个栈实现队列"></a>Problem6：用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<br><code>appendTail</code>和<code>deleteHead</code>,分别完成在队列尾部插入结点和在队列头部删除结点的功能<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructQueue</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     s1 用来实现放入新的元素，直接放到栈顶</span></span><br><span class="line"><span class="comment">     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2</span></span><br><span class="line"><span class="comment">     然后删除底部元素，再将 s2 元素移回 s1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack<String> stack1 = <span class="keyword">new</span> Stack<>();</span><br><span class="line">    Stack<String> stack2 = <span class="keyword">new</span> Stack<>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现appendTail函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        stack1.push(s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现deleteHead函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteHead</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) {</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        }</span><br><span class="line">        String head = stack2.pop();</span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty()) {</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ConstructQueue queue = <span class="keyword">new</span> ConstructQueue();</span><br><span class="line">        queue.appendTail(<span class="string">"a"</span>);</span><br><span class="line">        queue.appendTail(<span class="string">"b"</span>);</span><br><span class="line">        queue.appendTail(<span class="string">"c"</span>);</span><br><span class="line">        queue.appendTail(<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(queue.deleteHead());</span><br><span class="line">        System.out.println(queue.deleteHead());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>输出如下<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Problem7：旋转数组的最小数字"><a href="#Problem7：旋转数组的最小数字" class="headerlink" title="Problem7：旋转数组的最小数字"></a>Problem7：旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。<br>例如数组 <code>{3, 4, 5, 1, 2}</code>为<code>{1, 2, 3, 4, 5}</code>的一个旋转，该数组的最小值为 1;</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] a = {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line">    System.out.println(minNumInRotateArray(a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。</span></span><br><span class="line"><span class="comment">     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。</span></span><br><span class="line"><span class="comment">     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，</span></span><br><span class="line"><span class="comment">     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。</span></span><br><span class="line"><span class="comment">     * 同理第二个指针的范围也将逐渐缩小</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。</span></span><br><span class="line"><span class="comment">     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，</span></span><br><span class="line"><span class="comment">     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (array[left] >= array[right]) {</span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">1</span>) {</span><br><span class="line">            mid = right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组</span></span><br><span class="line">        <span class="keyword">if</span> (array[left] == array[right] && array[right] == array[mid]) {</span><br><span class="line">            <span class="keyword">return</span> findInOrder(array, left, right);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (array[left] <= array[mid]) {</span><br><span class="line">            left = mid;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> array[mid];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findInOrder</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> k = array[left];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < right; i++) {</span><br><span class="line">        <span class="keyword">if</span> (array[i] < k) {</span><br><span class="line">            k = array[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem8：斐波那契数列"><a href="#Problem8：斐波那契数列" class="headerlink" title="Problem8：斐波那契数列"></a>Problem8：斐波那契数列</h3><p>写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： </p><blockquote><p>n=0, f(n)=0;<br>n=1, f(n)=1;<br>n>1, f(n) = f(n-1) + f(n-2).</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">11</span>; i++) {</span><br><span class="line">        System.out.print(fibonacci(i) + <span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Problem9：二进制中1的个数"><a href="#Problem9：二进制中1的个数" class="headerlink" title="Problem9：二进制中1的个数"></a>Problem9：二进制中1的个数</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。</p><p>例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int oneCountsOfBinary(int i) {</span><br><span class="line">    char[] chars = Integer.toBinaryString(i).toCharArray();</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (char c : chars) {</span><br><span class="line">        if (c == '1') {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public static int _oneCountsOfBinary(int i) {</span><br><span class="line">    int count = 0;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    while (flag != 0) {</span><br><span class="line">        if ((i & flag) != 0) {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        flag = flag << 1;</span><br><span class="line">    }</span><br><span class="line">    return count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem10：数值的整数次方"><a href="#Problem10：数值的整数次方" class="headerlink" title="Problem10：数值的整数次方"></a>Problem10：数值的整数次方</h3><p> 实现函数<code>double power(double base, int exponent)</code>，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (base <= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算无意义"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (exponent < <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / powerUnsigned(base, -exponent);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> powerUnsigned(base, exponent);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">powerUnsigned</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>{</span><br><span class="line">    <span class="keyword">double</span> result = base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < exponent; i++) {</span><br><span class="line">        result = result * base;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Problem11：O（1）时间删除链表结点"><a href="#Problem11：O（1）时间删除链表结点" class="headerlink" title="Problem11：O（1）时间删除链表结点"></a>Problem11：O（1）时间删除链表结点</h3><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有一个节点时，直接置空</span></span><br><span class="line"><span class="comment"> * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null</span></span><br><span class="line"><span class="comment"> * 否则 p->next 的值赋值给p，把p->next删除掉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node head, Node delNode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || delNode == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (head == delNode) {</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (delNode.next == <span class="keyword">null</span>) {</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != delNode) {</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    delNode.value = delNode.next.value;</span><br><span class="line">    delNode.next = delNode.next.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Problem12：调整数组中奇数和偶数的先后顺序"><a href="#Problem12：调整数组中奇数和偶数的先后顺序" class="headerlink" title="Problem12：调整数组中奇数和偶数的先后顺序"></a>Problem12：调整数组中奇数和偶数的先后顺序</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">orderArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left < right) {</span><br><span class="line">        <span class="keyword">while</span> (left < right && !isEven(array[left])) {</span><br><span class="line">            left ++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (left < right && isEven(array[right])) {</span><br><span class="line">            right --;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (left < right) {</span><br><span class="line">            <span class="keyword">int</span> temp = array[left];</span><br><span class="line">            array[left] = array[right];</span><br><span class="line">            array[right] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ((i & <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Problem13：链表中倒数第K个结点"><a href="#Problem13：链表中倒数第K个结点" class="headerlink" title="Problem13：链表中倒数第K个结点"></a>Problem13：链表中倒数第K个结点</h3><p>输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。</p><p>例如一个链表有6个结点，从头结点开始它们的值依次是<code>1、2、3、4、5、6</code>。这个链表的倒数第三个结点是值为4的结点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动</span></span><br><span class="line"><span class="comment"> * 从第k步开始，第二个指针也开始从链表的头指针开始遍历</span></span><br><span class="line"><span class="comment"> * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 倒数第k个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    ListNode second = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < k; i++) {</span><br><span class="line">        <span class="keyword">if</span> (first.next != <span class="keyword">null</span>) {</span><br><span class="line">            first = first.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(first.val);</span><br><span class="line">    <span class="keyword">while</span> (first.next != <span class="keyword">null</span>) {</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    }</span><br><span class="line">    System.out.println(first.val);</span><br><span class="line">    <span class="keyword">return</span> second.val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem14：翻转链表"><a href="#Problem14：翻转链表" class="headerlink" title="Problem14：翻转链表"></a>Problem14：翻转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p><p><img src="/《剑指offer》题目-Java-实现/翻转链表.png" alt></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻转单链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 翻转之后的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getReversedListHead</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//current节点是head的下一个节点</span></span><br><span class="line">    ListNode current = head.next;</span><br><span class="line">    <span class="comment">//当前的head变为链表的尾，所以next为空</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//currentNext节点是current的下一个节点。</span></span><br><span class="line">        ListNode currentNext = current.next;</span><br><span class="line">        <span class="comment">//current.next反方向指向以前的节点</span></span><br><span class="line">        current.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移动head和current指针，到后面head重新成为头节点</span></span><br><span class="line">        head = current;</span><br><span class="line">        current = currentNext;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻转单链表的递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 翻转之后的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseListByRecursion</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    ListNode newList = reverseListByRecursion(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem15：合并两个排序的链表"><a href="#Problem15：合并两个排序的链表" class="headerlink" title="Problem15：合并两个排序的链表"></a>Problem15：合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode n1, ListNode n2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n2 == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    }</span><br><span class="line">    ListNode mergeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (n1.val < n2.val) {</span><br><span class="line">        mergeNode = n1;</span><br><span class="line">        mergeNode.next = merge(n1.next, n2);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mergeNode = n2;</span><br><span class="line">        mergeNode.next = merge(n1, n2.next);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mergeNode;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Problem16：树的子结构判断"><a href="#Problem16：树的子结构判断" class="headerlink" title="Problem16：树的子结构判断"></a>Problem16：树的子结构判断</h3><h3 id="Problem17：二叉树的镜像"><a href="#Problem17：二叉树的镜像" class="headerlink" title="Problem17：二叉树的镜像"></a>Problem17：二叉树的镜像</h3><h3 id="Problem18：顺时针打印矩阵"><a href="#Problem18：顺时针打印矩阵" class="headerlink" title="Problem18：顺时针打印矩阵"></a>Problem18：顺时针打印矩阵</h3><h3 id="Problem19：包含min函数的栈"><a href="#Problem19：包含min函数的栈" class="headerlink" title="Problem19：包含min函数的栈"></a>Problem19：包含min函数的栈</h3><h3 id="Problem20：栈的压入、弹出序列"><a href="#Problem20：栈的压入、弹出序列" class="headerlink" title="Problem20：栈的压入、弹出序列"></a>Problem20：栈的压入、弹出序列</h3><h3 id="Problem21：从上往下打印二叉树"><a href="#Problem21：从上往下打印二叉树" class="headerlink" title="Problem21：从上往下打印二叉树"></a>Problem21：从上往下打印二叉树</h3><h3 id="Problem22：二叉搜索树的后序遍历"><a href="#Problem22：二叉搜索树的后序遍历" class="headerlink" title="Problem22：二叉搜索树的后序遍历"></a>Problem22：二叉搜索树的后序遍历</h3><h3 id="Problem23：二叉树中和为某一值的路径"><a href="#Problem23：二叉树中和为某一值的路径" class="headerlink" title="Problem23：二叉树中和为某一值的路径"></a>Problem23：二叉树中和为某一值的路径</h3><h3 id="Problem24：字符串的排列"><a href="#Problem24：字符串的排列" class="headerlink" title="Problem24：字符串的排列"></a>Problem24：字符串的排列</h3><h3 id="Problem25：数组中出现次数超过一半的数字"><a href="#Problem25：数组中出现次数超过一半的数字" class="headerlink" title="Problem25：数组中出现次数超过一半的数字"></a>Problem25：数组中出现次数超过一半的数字</h3><h3 id="Problem26：连续子数组的最大和"><a href="#Problem26：连续子数组的最大和" class="headerlink" title="Problem26：连续子数组的最大和"></a>Problem26：连续子数组的最大和</h3><h3 id="Problem27：整数中1出现的次数"><a href="#Problem27：整数中1出现的次数" class="headerlink" title="Problem27：整数中1出现的次数"></a>Problem27：整数中1出现的次数</h3><h3 id="Problem28：把数组排成最小的数"><a href="#Problem28：把数组排成最小的数" class="headerlink" title="Problem28：把数组排成最小的数"></a>Problem28：把数组排成最小的数</h3><h3 id="Problem29：丑数"><a href="#Problem29：丑数" class="headerlink" title="Problem29：丑数"></a>Problem29：丑数</h3><h3 id="Problem30：第一个只出现一次的字符"><a href="#Problem30：第一个只出现一次的字符" class="headerlink" title="Problem30：第一个只出现一次的字符"></a>Problem30：第一个只出现一次的字符</h3><h3 id="Problem31：数组中的逆序对"><a href="#Problem31：数组中的逆序对" class="headerlink" title="Problem31：数组中的逆序对"></a>Problem31：数组中的逆序对</h3><h3 id="Problem32：两个链表的第一个公共节点"><a href="#Problem32：两个链表的第一个公共节点" class="headerlink" title="Problem32：两个链表的第一个公共节点"></a>Problem32：两个链表的第一个公共节点</h3><h3 id="Problem33：二叉树的深度-amp-amp-平衡二叉树判断"><a href="#Problem33：二叉树的深度-amp-amp-平衡二叉树判断" class="headerlink" title="Problem33：二叉树的深度&&平衡二叉树判断"></a>Problem33：二叉树的深度&&平衡二叉树判断</h3><h3 id="Problem34：数字在排序数组中出现的次数"><a href="#Problem34：数字在排序数组中出现的次数" class="headerlink" title="Problem34：数字在排序数组中出现的次数"></a>Problem34：数字在排序数组中出现的次数</h3><h3 id="Problem35：数组中只出现一次的数字"><a href="#Problem35：数组中只出现一次的数字" class="headerlink" title="Problem35：数组中只出现一次的数字"></a>Problem35：数组中只出现一次的数字</h3><h3 id="Problem36：和为S的两个数字"><a href="#Problem36：和为S的两个数字" class="headerlink" title="Problem36：和为S的两个数字"></a>Problem36：和为S的两个数字</h3><h3 id="Problem37：和为S的连续正数序列"><a href="#Problem37：和为S的连续正数序列" class="headerlink" title="Problem37：和为S的连续正数序列"></a>Problem37：和为S的连续正数序列</h3><h3 id="Problem38：翻转单词的顺序"><a href="#Problem38：翻转单词的顺序" class="headerlink" title="Problem38：翻转单词的顺序"></a>Problem38：翻转单词的顺序</h3><h3 id="Problem39：扑克牌的顺子"><a href="#Problem39：扑克牌的顺子" class="headerlink" title="Problem39：扑克牌的顺子"></a>Problem39：扑克牌的顺子</h3><h3 id="Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）"></a>Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）</h3><h3 id="Problem41：计算1-2-3-···-n"><a href="#Problem41：计算1-2-3-···-n" class="headerlink" title="Problem41：计算1+2+3+ ··· + n"></a>Problem41：计算1+2+3+ ··· + n</h3><h3 id="Problem42：不用加减乘除做加法"><a href="#Problem42：不用加减乘除做加法" class="headerlink" title="Problem42：不用加减乘除做加法"></a>Problem42：不用加减乘除做加法</h3><h3 id="Problem43：把字符串转换为整数"><a href="#Problem43：把字符串转换为整数" class="headerlink" title="Problem43：把字符串转换为整数"></a>Problem43：把字符串转换为整数</h3><h3 id="Problem44：数组中重复的数字"><a href="#Problem44：数组中重复的数字" class="headerlink" title="Problem44：数组中重复的数字"></a>Problem44：数组中重复的数字</h3><h3 id="Problem45：构建乘积数组"><a href="#Problem45：构建乘积数组" class="headerlink" title="Problem45：构建乘积数组"></a>Problem45：构建乘积数组</h3><h3 id="Problem46：正则表达式匹配"><a href="#Problem46：正则表达式匹配" class="headerlink" title="Problem46：正则表达式匹配"></a>Problem46：正则表达式匹配</h3><h3 id="Problem47：表示数值的字符串"><a href="#Problem47：表示数值的字符串" class="headerlink" title="Problem47：表示数值的字符串"></a>Problem47：表示数值的字符串</h3><h3 id="Problem48：字符流中第一个不重复的字符"><a href="#Problem48：字符流中第一个不重复的字符" class="headerlink" title="Problem48：字符流中第一个不重复的字符"></a>Problem48：字符流中第一个不重复的字符</h3><h3 id="Problem49：链表中环的入口结点"><a href="#Problem49：链表中环的入口结点" class="headerlink" title="Problem49：链表中环的入口结点"></a>Problem49：链表中环的入口结点</h3><h3 id="Problem50：删除链表中欧冠重复的节点"><a href="#Problem50：删除链表中欧冠重复的节点" class="headerlink" title="Problem50：删除链表中欧冠重复的节点"></a>Problem50：删除链表中欧冠重复的节点</h3><h3 id="Problem51：二叉树的下一个节点"><a href="#Problem51：二叉树的下一个节点" class="headerlink" title="Problem51：二叉树的下一个节点"></a>Problem51：二叉树的下一个节点</h3><h3 id="Problem52：把二叉树打印成多行"><a href="#Problem52：把二叉树打印成多行" class="headerlink" title="Problem52：把二叉树打印成多行"></a>Problem52：把二叉树打印成多行</h3><h3 id="Problem53：按之字形顺序打印二叉树"><a href="#Problem53：按之字形顺序打印二叉树" class="headerlink" title="Problem53：按之字形顺序打印二叉树"></a>Problem53：按之字形顺序打印二叉树</h3><h3 id="Problem54：序列化二叉树"><a href="#Problem54：序列化二叉树" class="headerlink" title="Problem54：序列化二叉树"></a>Problem54：序列化二叉树</h3><h3 id="Problem55：二叉搜索树的第K个节点"><a href="#Problem55：二叉搜索树的第K个节点" class="headerlink" title="Problem55：二叉搜索树的第K个节点"></a>Problem55：二叉搜索树的第K个节点</h3><h3 id="Problem56：滑动窗口的最大值大值"><a href="#Problem56：滑动窗口的最大值大值" class="headerlink" title="Problem56：滑动窗口的最大值大值"></a>Problem56：滑动窗口的最大值大值</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Problem1：单例模式实现&quot;&gt;&lt;a href=&quot;#Problem1：单例模式实现&quot; class=&quot;headerlink&quot; title=&quot;Problem1：单例模式实现&quot;&gt;&lt;/a&gt;Problem1：单例模式实现&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;{  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton singleton;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{}  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getSingleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (singleton == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) {  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (Singleton.class) {  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (singleton == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) {  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    singleton = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                }  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            }  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        }  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; singleton;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    }  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android 多线程技术</title>
    <link href="http://yoursite.com/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/Android-多线程技术/</id>
    <published>2019-03-17T03:56:59.000Z</published>
    <updated>2019-03-17T04:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。<a id="more"></a> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android LruCache 缓存详解</title>
    <link href="http://yoursite.com/Android-LruCache-%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Android-LruCache-缓存详解/</id>
    <published>2019-03-17T02:49:27.000Z</published>
    <updated>2019-05-03T11:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/Android-LruCache-缓存详解/LruCache.png" alt><br><a id="more"></a></p><h2 id="Android-缓存策略"><a href="#Android-缓存策略" class="headerlink" title="Android 缓存策略"></a>Android 缓存策略</h2><p>一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。</p><p>LRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。</p><p>LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp" alt></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>LruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。</p><p>讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。</p><p>LinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></tbody></table></figure><p>中的最后一个参数 accessOrder 来指定。</p><p>对于<code>get</code>、<code>put</code>、<code>remove</code>等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 <code>get</code>(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用<code>put</code> 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。</p><p><img src="https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp" alt></p><p>LruCache 的使用非常简单，以图片缓存为例：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().totalMemory()/<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> cacheSize = maxMemory/<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">mMemoryCache = <span class="keyword">new</span> LruCache<String, Bitmap>(cacheSize) {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><ol><li>设置LruCache缓存的大小，一般为当前进程可用容量的1/8。</li><li>重写sizeOf方法，计算出要缓存的每张图片的大小。</li></ol><p>注意：缓存的总容量和每个缓存对象的大小所用单位要一致。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>LruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。<br>这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的<code><key,value></code>对按照一定顺序排列起来。</p><p>通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>accessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。</p><p>以具体例子解释，当设置为true时</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    LinkedHashMap<Integer, Integer> map = <span class="keyword">new</span> LinkedHashMap<>(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">    map.get(<span class="number">1</span>);</span><br><span class="line">    map.get(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry<Integer, Integer> entry : map.entrySet()) {</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为:<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">0</span></span><br><span class="line"><span class="number">3</span>:<span class="number">3</span></span><br><span class="line"><span class="number">4</span>:<span class="number">4</span></span><br><span class="line"><span class="number">5</span>:<span class="number">5</span></span><br><span class="line"><span class="number">6</span>:<span class="number">6</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span></span><br><span class="line"><span class="number">2</span>:<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。</p><p>下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除</p><p>构造方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (maxSize <= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize <= 0"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap<K, V>(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line">​```</span><br><span class="line">`put`方法</span><br><span class="line"></span><br><span class="line">​```Java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="comment">//插入的缓存对象值加1</span></span><br><span class="line">        putCount++;</span><br><span class="line">        <span class="comment">//增加已有缓存的大小</span></span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        <span class="comment">//向map中加入缓存对象</span></span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="comment">//如果已有缓存对象，则缓存大小恢复到之前</span></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) {</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//entryRemoved()是个空方法，可以自行实现</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) {</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整缓存大小(关键方法)</span></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">}</span><br><span class="line">​```</span><br><span class="line">可以看到，添加过缓存对象后会调用`trimToSize`方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象</span><br><span class="line"></span><br><span class="line">`trimToSize`方法</span><br><span class="line"></span><br><span class="line">​```Java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>{</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">if</span> (size < <span class="number">0</span> || (map.isEmpty() && size != <span class="number">0</span>)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                        + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (size <= maxSize || map.isEmpty()) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//迭代器获取第一个对象，即队尾的元素，近期最少访问的元素</span></span><br><span class="line">            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();</span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//删除该对象，并更新缓存大小</span></span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        }</span><br><span class="line">        entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">​```</span><br><span class="line">该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。</span><br><span class="line"></span><br><span class="line">当调用 LruCache 的`get`方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的`get`方法中完成的。</span><br><span class="line"></span><br><span class="line">先看 LruCache 的`get`方法</span><br><span class="line"></span><br><span class="line">​```Java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>{</span><br><span class="line">    <span class="comment">//key为空抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">    <span class="comment">//获取对应的缓存对象</span></span><br><span class="line">    <span class="comment">//get()方法会实现将访问的元素更新到队列头部的功能</span></span><br><span class="line">    mapValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) {</span><br><span class="line">            hitCount++;</span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        }</span><br><span class="line">        missCount++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LinkedHashMap 的`get`方法如下：</span><br><span class="line"></span><br><span class="line">​```Java</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    LinkedHashMapEntry<K,V> e = (LinkedHashMapEntry<K,V>)getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//实现排序的关键方法</span></span><br><span class="line">    e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">}</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line">​```Java</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap<K,V> m)</span> </span>{</span><br><span class="line">    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;</span><br><span class="line">    <span class="comment">//判断是否是访问排序</span></span><br><span class="line">    <span class="keyword">if</span> (lm.accessOrder) {</span><br><span class="line">        lm.modCount++;</span><br><span class="line">        <span class="comment">//删除此元素</span></span><br><span class="line">        remove();</span><br><span class="line">        <span class="comment">//将此元素移动到队列的头部</span></span><br><span class="line">        addBefore(lm.header);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用`put`方法时，就会在队列中添加元素，并调用`trimToSize`判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用`get(`方法访问缓存对象时，就会调用 LinkedHashMap 的`get`方法获得对应集合元素，同时更新该元素到队头。**</span><br><span class="line"></span><br><span class="line">以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。</span><br><span class="line"></span><br><span class="line">本文转自 [彻底解析Android缓存机制——LruCache](https:<span class="comment">//www.jianshu.com/p/b49a111147ee)</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/Android-LruCache-缓存详解/LruCache.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="LRU" scheme="http://yoursite.com/tags/LRU/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射详解</title>
    <link href="http://yoursite.com/Java-%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Java-反射详解/</id>
    <published>2019-03-16T15:25:47.000Z</published>
    <updated>2019-03-17T02:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。<a id="more"></a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">int</span> price)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, </span></span><br><span class="line"><span class="function">            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>{</span><br><span class="line">        <span class="comment">//正常调用</span></span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.setPrice(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Price is "</span> + apple.getPrice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射调用</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"Apple"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 getFields() 无法获取私有属性</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field: fields) {</span><br><span class="line">            System.out.println(<span class="string">"Field is "</span> + field.getName());</span><br><span class="line">        }</span><br><span class="line">        Method setPriceMethod = clazz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        Constructor appleConstructor = clazz.getConstructor();</span><br><span class="line">        Object appleObj = appleConstructor.newInstance();</span><br><span class="line">        <span class="comment">//Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器</span></span><br><span class="line">        <span class="comment">//Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器</span></span><br><span class="line"></span><br><span class="line">        setPriceMethod.invoke(appleObj, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        Method getPriceMethod = clazz.getMethod(<span class="string">"getPrice"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Price is "</span> + getPriceMethod.invoke(appleObj));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="类的实例化和构造函数"><a href="#类的实例化和构造函数" class="headerlink" title="类的实例化和构造函数"></a>类的实例化和构造函数</h4><blockquote><p>获取公有构造函数，不包括父类，Class.class<br>public Constructor<?>[] getConstructors()<br>public Constructor<t> getConstructor(Class<?>… parameterTypes)</t></p><p>获取当前类构造函数，忽略修饰符<br>public Constructor<?>[] getDeclaredConstructors()<br>public Constructor<t> getDeclaredConstructor(Class<?>… parameterTypes)</t></p></blockquote><blockquote><p>构造函数调用，Constructor.class<br>public T newInstance(Object… initargs)</p><p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p></blockquote><h4 id="类成员变量的获取"><a href="#类成员变量的获取" class="headerlink" title="类成员变量的获取"></a>类成员变量的获取</h4><blockquote><p>获取公有变量，包括父类，Class.class<br>public Field[] getFields()<br>public Field getField(String name)</p><p>获取当前类成员变量，忽略修饰符<br>public Field[] getDeclaredFields()<br>public Field getDeclaredField(String name)</p></blockquote><blockquote><p>成员变量赋值，Field.class<br>//obj为实例对象<br>public void set(Object obj,Object value)</p><p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p></blockquote><h4 id="类方法的获取"><a href="#类方法的获取" class="headerlink" title="类方法的获取"></a>类方法的获取</h4><blockquote><p>获取公有方法，包括父类，Class.class<br>public Method[] getMethods()<br>public Method getMethod(String name, Class<?>… parameterTypes)</p><p>获取当前类方法，忽略修饰符<br>public Method[] getDeclaredMethods()<br>public Method getDeclaredMethod(String name, Class<?>… parameterTypes)</p></blockquote><blockquote><p>方法调用，Method.class<br>//obj为类实例化对象，如果为静态方法obj为Null<br>invoke(Object obj, Object… args)</p><p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p></blockquote><h4 id="类注解的获取"><a href="#类注解的获取" class="headerlink" title="类注解的获取"></a>类注解的获取</h4><blockquote><p>获取类的”annotationClass”类型的注解，包括父类<br>public Annotation<a>    getAnnotation(Class annotationClass)</a></p><p>// 获取类的全部注解 ，包括父类<br>public Annotation[]    getAnnotations()</p><p>// 获取类自身声明的全部注解 ，忽略修饰符<br>public Annotation[]    getDeclaredAnnotations()</p></blockquote><h4 id="类父类的获取"><a href="#类父类的获取" class="headerlink" title="类父类的获取"></a>类父类的获取</h4><blockquote><p>获取实现的全部接口<br>public Type[]    getGenericInterfaces()</p><p>获取父类<br>public Type    getGenericSuperclass()</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="RTTI和Class对象"><a href="#RTTI和Class对象" class="headerlink" title="RTTI和Class对象"></a>RTTI和Class对象</h3><p>RTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。</p><p>很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。</p><p>而这些类型信息是通过一个特殊对象<strong>Class（java.lang.Class）</strong>实现的，它包含跟类相关的信息。</p><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。</p><ul><li>加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。</li><li><p>连接：</p><ul><li>验证 是否有正确的内部结构，并和其他类协调一致</li><li>准备 负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析 将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li><p>初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。</p></li></ul><p>获取 Class 对象的方式有三种</p><ol><li><p>Object 类的 getClass() 方法，执行静态块和动态构造块</p></li><li><p>数据类型的静态属性 class ，不会初始化该类</p></li><li><p>Class类中的静态方法<code>public static Class forName(String className)</code>，执行静态块，不执行动态构造块</p></li></ol><h3 id="RTTI和反射"><a href="#RTTI和反射" class="headerlink" title="RTTI和反射"></a>RTTI和反射</h3><p>Java 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。</p><p>RTTI和反射之间的真正区别只在于：</p><blockquote><p>RTTI：编译器在编译时打开和检查.class文件<br>反射：运行时打开和检查.class文件</p></blockquote><p>严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能</p><p>未完待续</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>基本数据结构的简单Java实现</title>
    <link href="http://yoursite.com/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95Java%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/基本数据结构的简单Java实现/</id>
    <published>2019-03-16T14:08:55.000Z</published>
    <updated>2019-03-16T14:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>JDK 中提供了很多数据结构，如下所示</p><blockquote><p>Collection<br>├ List<br>│   ├ LinkedList<br>│   ├ ArrayList<br>│   └ Vector<br>│　    └Stack<br>└ Set</p><p>Map<br>├ Hashtable<br>├ HashMap<br>└ WeakHashMap</p></blockquote><p>本文将进行部分数据结构的简单实现。</p><a id="more"></a><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span><<span class="title">T</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] dataArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nowSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        maxSize = initialCapacity;</span><br><span class="line">        dataArray = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T data)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size() >= maxSize) {</span><br><span class="line">            resize();</span><br><span class="line">        }</span><br><span class="line">        dataArray[nowSize++] = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (empty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (T)dataArray[--nowSize];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (empty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (T)dataArray[nowSize-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(T target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> p = nowSize;</span><br><span class="line">        <span class="keyword">while</span> (p >= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (dataArray[p] == target) {</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        maxSize = maxSize << <span class="number">1</span>;</span><br><span class="line">        Object[] newArray = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < dataArray.length; i++) {</span><br><span class="line">            newArray[i] = dataArray[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.dataArray = newArray;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nowSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nowSize == <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span><<span class="title">T</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] dataArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>{</span><br><span class="line">        maxSize = initialSize;</span><br><span class="line">        dataArray = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        front = rear = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T newData)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size() >= maxSize) {</span><br><span class="line">            resize();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//非循环队列</span></span><br><span class="line">        dataArray[rear++] = newData;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环队列</span></span><br><span class="line">        <span class="comment">//dataArray[rear] = newData;</span></span><br><span class="line">        <span class="comment">//rear = (rear+1) % maxSize;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (empty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        T value = (T)dataArray[front];</span><br><span class="line">        <span class="comment">//非循环队列</span></span><br><span class="line">        dataArray[front++] = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环队列</span></span><br><span class="line">        <span class="comment">//dataArray[front] = null;</span></span><br><span class="line">        <span class="comment">//front = (front+1) % maxSize;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        maxSize = maxSize << <span class="number">1</span>;</span><br><span class="line">        Object[] temp = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < dataArray.length; i++) {</span><br><span class="line">            temp[i] = dataArray[i];</span><br><span class="line">        }</span><br><span class="line">        dataArray = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Math.abs(front - rear);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> front == rear ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="BinaryTree"><a href="#BinaryTree" class="headerlink" title="BinaryTree"></a>BinaryTree</h2><p><img src="/基本数据结构的简单Java实现/二叉搜索树.png" alt="二叉搜索树"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinaryTree</span><<span class="title">T</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> T value;</span><br><span class="line">        <span class="keyword">private</span> Node leftChild;</span><br><span class="line">        <span class="keyword">private</span> Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, T value)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span> && currentNode.key != key) {</span><br><span class="line">            <span class="keyword">if</span> (key < currentNode.leftChild.key) {</span><br><span class="line">                currentNode = currentNode.leftChild;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                currentNode = currentNode.rightChild;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, T value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            root = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        Boolean isLeftChild = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) {</span><br><span class="line">            parentNode = currentNode;</span><br><span class="line">            <span class="keyword">if</span> (key < currentNode.key) {</span><br><span class="line">                currentNode = currentNode.leftChild;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                currentNode = currentNode.rightChild;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (isLeftChild) {</span><br><span class="line">            parentNode.leftChild = newNode;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parentNode.rightChild = newNode;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        Node currentNode = root;    <span class="comment">//待删除节点</span></span><br><span class="line">        Node parentNode = root;     <span class="comment">//待删除节点的父节点</span></span><br><span class="line">        Boolean isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span> && currentNode.key != key) {</span><br><span class="line">            parentNode = currentNode;</span><br><span class="line">            <span class="keyword">if</span> (key < currentNode.key) {</span><br><span class="line">                currentNode = currentNode.leftChild;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                currentNode = currentNode.rightChild;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//删除节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.leftChild == <span class="keyword">null</span> && currentNode.rightChild == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (currentNode == root) {</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) {</span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.rightChild == <span class="keyword">null</span>) {    <span class="comment">//待删除节点只有左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == root) {</span><br><span class="line">                root = currentNode.leftChild;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) {</span><br><span class="line">                parentNode.leftChild = currentNode.leftChild;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                parentNode.rightChild = currentNode.leftChild;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.leftChild == <span class="keyword">null</span>) {    <span class="comment">//待删除节点只有右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == root) {</span><br><span class="line">                root = currentNode.rightChild;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) {</span><br><span class="line">                parentNode.leftChild = currentNode.rightChild;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                parentNode.rightChild = currentNode.rightChild;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {    <span class="comment">//待删除节点既有左子节点又有右子节点</span></span><br><span class="line">            Node directPostNode = getDirectPostNode(currentNode);</span><br><span class="line">            currentNode.key = directPostNode.key;</span><br><span class="line">            currentNode.value = directPostNode.value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得待删除节点的直接后继节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点</span></span><br><span class="line"><span class="comment">     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点</span></span><br><span class="line"><span class="comment">     * 并删除 key 值为 10 的节点的中序后继节点，</span></span><br><span class="line"><span class="comment">     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，</span></span><br><span class="line"><span class="comment">     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），</span></span><br><span class="line"><span class="comment">     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delNode 待删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回直接后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getDirectPostNode</span><span class="params">(Node delNode)</span> </span>{</span><br><span class="line">        Node parentNode = delNode;  <span class="comment">//保存待删除节点的直接后继节点的父节点</span></span><br><span class="line">        Node direcrPostNode = delNode;  <span class="comment">//保存待删除节点的直接后继节点</span></span><br><span class="line">        Node currentNode = delNode.rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) {</span><br><span class="line">            parentNode = direcrPostNode;</span><br><span class="line">            direcrPostNode = currentNode;</span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (direcrPostNode != delNode.rightChild) { <span class="comment">//从树中删除此直接后继节点</span></span><br><span class="line">            parentNode.leftChild = direcrPostNode.rightChild;</span><br><span class="line">            direcrPostNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> direcrPostNode;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node rootNode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (rootNode != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(rootNode.key + <span class="string">": "</span> + rootNode.value);</span><br><span class="line">            preOrder(rootNode.leftChild);</span><br><span class="line">            preOrder(rootNode.rightChild);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node rootNode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (rootNode != <span class="keyword">null</span>) {</span><br><span class="line">            preOrder(rootNode.leftChild);</span><br><span class="line">            System.out.println(rootNode.key + <span class="string">": "</span> + rootNode.value);</span><br><span class="line">            preOrder(rootNode.rightChild);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node rootNode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (rootNode != <span class="keyword">null</span>) {</span><br><span class="line">            preOrder(rootNode.leftChild);</span><br><span class="line">            preOrder(rootNode.rightChild);</span><br><span class="line">            System.out.println(rootNode.key + <span class="string">": "</span> + rootNode.value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><img src="/基本数据结构的简单Java实现/HashMap.png" alt="HashMap"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;JDK 中提供了很多数据结构，如下所示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Collection&lt;br&gt;├ List&lt;br&gt;│   ├ LinkedList&lt;br&gt;│   ├ ArrayList&lt;br&gt;│   └ Vector&lt;br&gt;│　    └Stack&lt;br&gt;└ Set&lt;/p&gt;
&lt;p&gt;Map&lt;br&gt;├ Hashtable&lt;br&gt;├ HashMap&lt;br&gt;└ WeakHashMap&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将进行部分数据结构的简单实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android 消息机制详解</title>
    <link href="http://yoursite.com/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Android-消息机制详解/</id>
    <published>2019-03-16T06:13:19.000Z</published>
    <updated>2019-03-17T03:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Android 的消息机制，主要是指 Handler 的运行机制。<a id="more"></a></p><h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><p>Application Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Android系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。</p><p>以下四种条件都可以造成 ANR</p><ul><li>InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件</li><li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的<code>onReceive</code>方法中10秒没有处理完成，后台则为60秒。</li><li>Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。</li><li>ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。</li></ul><h3 id="分析和解决"><a href="#分析和解决" class="headerlink" title="分析和解决"></a>分析和解决</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>查看 log 信息</li><li>Java 线程调用分析，<code>jstack {pid}</code>，其中 pid 为虚拟机进程 id，可以通过<code>jps</code>查看当前所有线程。</li><li>查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令<code>./adb pull /data/anr/traces.txt</code>查看</li></ul><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul><li>避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。</li><li>避免在主线程 query provider、不要滥用SharePreferences</li><li>文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。</li><li>BroadcastReciever 的<code>onRecieve</code>不要进行耗时操作。</li></ul><h2 id="Handler-机制"><a href="#Handler-机制" class="headerlink" title="Handler 机制"></a>Handler 机制</h2><p>由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的<code>checkThread</code>进行验证<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currrentThread()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">            <span class="string">"Only the original thread that created a view hierarchy can</span></span><br><span class="line"><span class="string">            touch its views"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。<br>那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？</p><p>答案是使用 Handler 。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收消息</span></span><br><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</span><br><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="keyword">if</span> (msg.what == <span class="number">1</span>) {</span><br><span class="line">            log.e(<span class="string">"MSG"</span>, <span class="string">"收到消息"</span>)；</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            mHandler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}).start();</span><br></pre></td></tr></tbody></table></figure><p>使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MyHandler hander = <span class="keyword">new</span> MyHandler(context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> WeakReference<Context> out;</span><br><span class="line">    </span><br><span class="line">    MyHandler(Context ctx) {</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        out = <span class="keyword">new</span> WeakReference<>(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (out.get() != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//进行消息处理</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>Handler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。</p><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>观察 Handler 的构造函数<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()  + <span class="string">" that has not called"</span> </span><br><span class="line">            + <span class="string">" Looper.prepare()"</span>);</span><br><span class="line">    }</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用<code>Looper.prepare</code>的线程内创建 handler。</p><p>不过，为什么在主线程中创建 Handler 不需要调用<code>Looper.prepare</code>和<code>Looper.loop</code>方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的<code>main</code>方法，在其中调用了<code>prepareMainLooper</code><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ......</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ......</span><br><span class="line">        Looper.loop();</span><br><span class="line">        ......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>{</span><br><span class="line">    prepare(<span class="keyword">false</span>);     <span class="comment">//quitAllowed 参数传false</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) {</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        }</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>关于 ActivityThread：<a href="http://www.cnblogs.com/younghao/p/5126408.html" target="_blank" rel="noopener">Android线程管理（二）——ActivityThread</a></p><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。</p><p>由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。</p><p>当 Handler 调用<code>sendMessage</code>时，最后会调用到</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>{</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) {</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>查看<code>enqueueMessage</code>方法，</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) {</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when < p.when) {</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            needWake = mBlocked && p.target == <span class="keyword">null</span> && msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when < p.when) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (needWake && p.isAsynchronous()) {</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        }</span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒</li><li>如果队列已有消息，则根据 Message 创建的时间进行插入</li></ul><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用<code>Looper.prepare</code>方法使消息循环初始化，并且调用<code>Looper.loop</code>使消息循环一直处于运行状态，<strong>取出 MessageQueue 中的消息分发给 Handler</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>{</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    }</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，<code>prepare(boolean quitAllowed)</code>实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当<code>Looper.prepare</code>执行完毕之后才可以执行<code>loop</code>方法<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//获取当前线程绑定的Looper</span></span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前线程的MessageQueue</span></span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//循环从 MessageQueue 取出消息.</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            Message msg = queue.next();</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//将消息分发出去</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//将消息回收</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到，如果消息队列的 next 返回了新消息，就会调用<code>msg.target.dispatchMessage(msg)</code>，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先检查 Message 的 callBack 是否为空，不为空则<code>handlerCallback(msg)</code>，最终调用 callback 的<code>run</code>方法</li><li>如果为空，检查 mCallBack 是否为空，不为空则调用它的<code>handleMassage</code>，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。</li><li>如果都为空，调用 Handler 内部的<code>handleMessage</code>，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。</p><p>使用一个简单的例子演示 ThreadLocal 的真正含义<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个 boolean 类型的变量</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal<Boolean> value = <span class="keyword">new</span> ThreadLocal<>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在主线程中将其设为 true</span></span><br><span class="line">value.set(<span class="keyword">true</span>);</span><br><span class="line">log.e(<span class="string">"MainThread"</span>, value.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程中设为 false</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        value.set(<span class="keyword">false</span>);</span><br><span class="line">        log.e(<span class="string">"Thread1"</span>, value.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个子线程直接读取</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        log.e(<span class="string">"Thread2"</span>, value.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>运行日志如下</p><blockquote><p>MainThread, true<br>Thread1, false<br>Thread2, null</p></blockquote><p>由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：<a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Handler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的<code>runOnUiThread</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>{ </span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread() != mUiThread) { </span><br><span class="line">mHandler.post(action); </span><br><span class="line">} <span class="keyword">else</span> { </span><br><span class="line">action.run(); </span><br><span class="line">} </span><br><span class="line">...... </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>比如 View 的<code>post</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>{</span><br><span class="line"><span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> attachInfo.mHandler.post(action);         ①</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Assume that post will succeed later</span></span><br><span class="line">        ViewRootImpl.getRunQueue().post(action);        ②</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>最后用一张图来结束本文</p><p><img src="/Android-消息机制详解/消息流程图.jpg" alt="流程图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Android 的消息机制，主要是指 Handler 的运行机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Handler" scheme="http://yoursite.com/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Java 排序算法</title>
    <link href="http://yoursite.com/Java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/Java-排序算法/</id>
    <published>2019-03-15T10:36:47.000Z</published>
    <updated>2019-03-15T15:53:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。<a id="more"></a></p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>对于一个数组<code>a {6,2,4,6,1}</code>，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">4</th><th style="text-align:center">6</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">a[4]</td><td style="text-align:center">a[1]</td><td style="text-align:center">a[2]</td><td style="text-align:center"><b>a[0]</b></td><td style="text-align:center"><b>a[3]</b></td></tr><tr><td style="text-align:center">a[4]</td><td style="text-align:center">a[1]</td><td style="text-align:center">a[2]</td><td style="text-align:center"><b>a[3]</b></td><td style="text-align:center"><b>a[0]</b></td></tr></tbody></table><p>如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法</p><blockquote><p>冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等</p></blockquote><p>否则，属于不稳定的排序算法</p><blockquote><p>选择排序，希尔排序，堆排序，快速排序等</p></blockquote><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序，O(n^2)</span></span><br><span class="line"><span class="comment"> * 每一次内层循环中，两两比较，将较大的数放到后面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; i < length - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( ; j < length - <span class="number">1</span> - i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (a[j] > a[j+<span class="number">1</span>]) {</span><br><span class="line">                temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序，O(n^2)</span></span><br><span class="line"><span class="comment"> * i从第一个元素开始，默认i前面的序列已经排好序</span></span><br><span class="line"><span class="comment"> * 取出i的下一个元素，从后往前比较，找到适合的位置就插入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < length; i++) {</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j > <span class="number">0</span>; j--) {</span><br><span class="line">            <span class="keyword">if</span> (a[j] < a[j-<span class="number">1</span>]) {</span><br><span class="line">                a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折半插入排序，O(n^2)</span></span><br><span class="line"><span class="comment"> * 对直接插入排序算法进行了改进</span></span><br><span class="line"><span class="comment"> * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要</span></span><br><span class="line"><span class="comment"> * 折半插入排序则使用了折半查找/二分查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Arrays类的binarySearch()方法便是折半查找的实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < length; i++) {</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low <= high) {</span><br><span class="line">            <span class="keyword">int</span> middle = (low+high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[middle] < temp) {</span><br><span class="line">                low = middle+<span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                high = middle-<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j >= low; j--) {</span><br><span class="line">             <span class="comment">//元素后移，为插入temp做准备</span></span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        }</span><br><span class="line">        a[low] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序，也称 递减增量排序，O(n*(logn)^2)</span></span><br><span class="line"><span class="comment"> * 对于n个元素的序列，假设增量为increment</span></span><br><span class="line"><span class="comment"> * 从第一个元素开始，每隔increment取一个元素组成一个子序列</span></span><br><span class="line"><span class="comment"> * 对每个子序列进行直接插入排序，increment /= 2</span></span><br><span class="line"><span class="comment"> * 重复上述过程，直至increment为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment为增量，每次减为原来的一半，直至为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> increment = length / <span class="number">2</span>; increment > <span class="number">0</span>; increment /= <span class="number">2</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共increment个组，对每一组都执行直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < increment; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + increment; j < length; j += increment) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果a[j] < a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] < a[j - increment]) {</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                    <span class="keyword">int</span> k = j - increment;</span><br><span class="line">                    <span class="keyword">while</span> (k >= <span class="number">0</span> && a[k] > temp) {</span><br><span class="line">                        a[k + increment] = a[k];</span><br><span class="line">                        k -= increment;</span><br><span class="line">                    }</span><br><span class="line">                    a[k + increment] = temp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="桶排序（基数排序）"><a href="#桶排序（基数排序）" class="headerlink" title="桶排序（基数排序）"></a>桶排序（基数排序）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序，也称桶排序，O(d(k+n))</span></span><br><span class="line"><span class="comment"> * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。</span></span><br><span class="line"><span class="comment"> * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> d 位数，如果最大数为9527，则d为10000，如果为7，则d为10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;  <span class="comment">//代表位数对应的数：1,10,100...</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];  <span class="comment">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[length];  <span class="comment">//用于保存每个桶里有多少个数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n < d) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : a) { <span class="comment">//将数组array里的每个数字放在相应的桶里</span></span><br><span class="line">            <span class="keyword">int</span> digit = (num/n)%<span class="number">10</span>;</span><br><span class="line">            bucket[digit][order[digit]] = num;</span><br><span class="line">            order[digit]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; i<length; i++) { <span class="comment">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class="line">            <span class="keyword">if</span>(order[i] != <span class="number">0</span>) {  <span class="comment">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>( ; j < order[i]; j++) {</span><br><span class="line">                    a[k] = bucket[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            order[i]=<span class="number">0</span>;  <span class="comment">//将桶里计数器置0，用于下一次位排序</span></span><br><span class="line">        }</span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>;  <span class="comment">//将k置0，用于下一轮保存位排序结果</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序，O(nlog(n))</span></span><br><span class="line"><span class="comment"> * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1</span></span><br><span class="line"><span class="comment"> * 然合并以上序列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">   <span class="keyword">if</span> (left < right) {</span><br><span class="line">       <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">       mergeSort(array, left, center);</span><br><span class="line">       mergeSort(array, center+<span class="number">1</span>, right);</span><br><span class="line">       merge(array, left, center, right);</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] tempArray = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i <= mid && j <= high) {</span><br><span class="line">        <span class="keyword">if</span> (array[i] <= array[j]) {</span><br><span class="line">            tempArray[temp++] = array[i++];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            tempArray[temp++] = array[j++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i <= mid) {  <span class="comment">//此时右边已到底</span></span><br><span class="line">        tempArray[temp++] = array[i++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (j <= high) { <span class="comment">//此时左边已到底</span></span><br><span class="line">        tempArray[temp++] = array[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将新数组中的数 覆盖原数组low之后的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k < tempArray.length; k++) {</span><br><span class="line">        array[k+low] = tempArray[k];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 选择排序，O(n^2)</span></span><br><span class="line"><span class="comment">  * 遍历整个序列，将最小的数放在最前面</span></span><br><span class="line"><span class="comment">  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> a 待排序序列</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>{</span><br><span class="line">     <span class="keyword">int</span> length = a.length;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>( ; i < length; i++){  <span class="comment">//外层循环</span></span><br><span class="line">         <span class="keyword">int</span> temp = a[i];</span><br><span class="line">         <span class="keyword">int</span> position = i;</span><br><span class="line">         <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>( ; j < length; j++) {  <span class="comment">//往后遍历，找到最小的值以及其位置</span></span><br><span class="line">             <span class="keyword">if</span>(a[j] < temp) {</span><br><span class="line">                 temp = a[j];</span><br><span class="line">                 position = j;</span><br><span class="line">             }</span><br><span class="line">         }</span><br><span class="line">         a[position]=a[i];  <span class="comment">//进行交换</span></span><br><span class="line">         a[i] = temp;</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序，O(nlog(n))</span></span><br><span class="line"><span class="comment"> * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分</span></span><br><span class="line"><span class="comment"> * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序序列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 序列开始值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 序列结束值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> baseNum = a[start];</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> left = start;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">while</span> (a[left] < baseNum && left < end) {</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (a[right] > baseNum && right > start) {</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left <= right) {  <span class="comment">//左边出现大于基准值或者右边出现小于基准值，且left<=right</span></span><br><span class="line">            temp = a[left];</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">            a[right] = temp;</span><br><span class="line">            left++; right--;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">while</span> (left <= right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start < right) {</span><br><span class="line">        quickSort(a, start, right);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (end > left) {</span><br><span class="line">        quickSort(a, left, end);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树排序"><a href="#二叉树排序" class="headerlink" title="二叉树排序"></a>二叉树排序</h2><p>通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\log_2 n)$<br>近似于折半查找。</p><p>如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> Comparable data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Comparable data)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node newNode)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (newNode.data.compareTo(<span class="keyword">this</span>.data) < <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span>) {</span><br><span class="line">                    left = newNode;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    left.addNode(newNode);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (right == <span class="keyword">null</span>) {</span><br><span class="line">                    right = newNode;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    right.addNode(newNode);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">()</span> </span>{   <span class="comment">//中序遍历</span></span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span>) {</span><br><span class="line">                left.printNode();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.data);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span>) {</span><br><span class="line">                right.printNode();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Comparable data)</span> </span>{  <span class="comment">//向二叉树中插入元素</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            root = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            root.addNode(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        root.printNode();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>调用如下<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] a = {<span class="number">12</span>,<span class="number">0</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">456</span>};</span><br><span class="line">    BinarySortTree tree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : a) {            </span><br><span class="line">        tree.add(i);</span><br><span class="line">    }</span><br><span class="line">    tree.print();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>只能对有序序列进行查找<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (low > high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (array[mid] > target)</span><br><span class="line">        <span class="keyword">return</span> binarySearch(array, low, mid - <span class="number">1</span>, target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array[mid] < target)</span><br><span class="line">        <span class="keyword">return</span> binarySearch(array, mid + <span class="number">1</span>, high, target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bSearchWithoutRecursion</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low <= high) {</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] > key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] < key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>实现较简单，略过</p><h3 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h3><p>可以通过构建一个二叉搜索树实现</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android View 的工作原理</title>
    <link href="http://yoursite.com/Android-View-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/Android-View-的工作原理/</id>
    <published>2019-03-01T05:10:14.000Z</published>
    <updated>2019-05-01T14:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。</p><a id="more"></a><h2 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h2><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>首先简单认识 Window，其表示一个窗口，属于一个抽象类，具体的实现为 PhoneWindow。通过 WindowManager 向 WindowManagerService 发起请求，WMS 负责 Window 的具体生成。</p><p>实际上每一个 Window 对应一个 View 和 ViewRootImpl，  因此 Window 不是实际存在的，它通过 ViewRootImpl 以 View 的形式存在。</p><h3 id="ViewRoot-和-DecorView"><a href="#ViewRoot-和-DecorView" class="headerlink" title="ViewRoot 和 DecorView"></a>ViewRoot 和 DecorView</h3><p>ViewRoot 的具体实现就是上一节所提及的 ViewRootImpl，View 的三大流程（measure、layout、draw）都是通过它来实现的。</p><p>在 ActivityThread 中，当 Activity 对象被创建后，会将一个 DecorView 添加到 Window，然后创建 ViewRootImpl 对象，并将 DecorView 和 ViewRootImpl 建立关联，这也验证了上一节的观点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">root.setView(view, vparams, panelParentView);</span><br></pre></td></tr></tbody></table></figure><p>View 的绘制流程是从 ViewRoot 的 <code>performTraversals</code> 开始的，经过<code>measure</code>（测量 View 的宽高）、<code>layout</code>（确定 View 在父容器的位置）、<code>draw</code>（将 View 绘制在屏幕上）三个过程，呈现出一个 View。</p><p><img src="/Android-View-的工作原理/performTraversals.png" alt="performTraversals"></p><p>如图所示，<code>performTraversals</code>会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>，然后这三个方法分别完成顶级 View 的三大流程。而后，<code>measure</code>又会调用<code>onMeasure</code>，在其中对所有子元素进行 measure 过程，此时 measure 流程就从父容器传递到子元素了，接着子元素重复上述过程。如此完成整个 View 树的遍历。</p><p>measure 过程决定了 View 的宽高，可以通过<code>getMeasuredWidth</code>和<code>getMeasuredHeight</code>获得 View 测量后的宽高，在几乎所有情况下都可以得到 View 最终的数值。</p><p>layout 过程决定了 View 的四个顶点的坐标和实际的 View 的宽高，可以通过<code>getTop</code>、<code>getBottom</code>、<code>getLeft</code>、<code>getRight</code>拿到四个顶点的位置，通过<code>getWidth</code>、<code>getHeight</code>获得 View 的最终宽高。只有 draw 过程完成之后才能呈现 View。</p><hr><p><img src="/Android-View-的工作原理/整体布局.webp.jpg" alt="整体布局.webp"></p><p>由上图我们可以看出，一般 DecorView 会包含一个 LinearLayout，其中上面是标题栏，下面是内容栏。在创建 Activity 的时候需要<code>setContentView</code>而不是<code>setView</code>的原因便是如此。我们的布局加到了  id 为<code>android.R.id.content</code>的 FrameLayout 中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到 content</span></span><br><span class="line">ViewGroup content = (ViewGroup) findViewById(android.R.id.content)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到开发者设置的 View</span></span><br><span class="line">View view = content.getChildAt(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>“测量规格”，是 View 测量过程中非常重要的参数。measure 时系统会将 View 的 LayoutParams 根据父容器施加的规则转换成对应的 MeasureSpec，然后再根据 该 MeasureSpec 测量出 View 的宽高。</p><p>MeasureSpec 代表一个32位的 int 值，其中高2位代表 SpecMode（测量模式），低30位代表 SpecSize（某种测量模式下的规格大小）。将两个参数打包成一个 int 值的原因是避免过多的对象内存分配。</p><p>SpecMode 有三类</p><table><thead><tr><th>SpecMode</th><th>含义</th></tr></thead><tbody><tr><td>UNSPECIFIED</td><td>父容器不限制 View，一般用于系统内部</td></tr><tr><td>EXACTLY</td><td>父容器已检测 VIew 的精确大小，对应参数为<code>match_parent</code>和具体的数值</td></tr><tr><td>AT_MOST</td><td>父容器指定了 View 的最大值，具体大小由 View 决定，对应参数为<code>wrap_content</code></td></tr></tbody></table><h3 id="MeasureSpec-和-LayoutParams"><a href="#MeasureSpec-和-LayoutParams" class="headerlink" title="MeasureSpec 和 LayoutParams"></a>MeasureSpec 和 LayoutParams</h3><p>对于 DecorView，其 MeasureSpec 由窗口尺寸和其自身 LayoutParams 决定，对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和 自身的LayoutParams 共同决定。一旦 MeasureSpec 确定，onMeasure 中就可以确定 View 的测量宽高。</p><p>ViewRootImpl 的源码地址：<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewRootImpl.java" target="_blank" rel="noopener">ViewRootImpl.java</a>。查阅源码，得到 DecorView 的测量规则如下</p><ul><li><p>LayoutParams.MATCH_PARENT：精确模式，大小为窗口大小</p></li><li><p>LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口</p></li><li><p>固定大小：精确模式，大小为 LayoutParams 指定的大小</p></li></ul><p>ViewGroup  的源码地址：<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewGroup.java" target="_blank" rel="noopener">ViewGroup.java</a>。查看 ViewGroup 的<code>measureChildWithMargins</code>方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                        + widthUsed, lp.width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                        + heightUsed, lp.height);</span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>可以看到在调用子元素的<code>measure</code>之前，会先得到子元素的 MeasureSpec，很显然其和父容器的 MeasureSpec 以及子元素自身的 LayoutParams 包括 margin、padding 参数有关。具体的逻辑在 ViewGroup 中的 <code>getChildMeasureSpec</code> 中实现。</p><p><code>getChildMeasureSpec</code>方法清楚展示了 普通 View 的 MeasureSpec 的创建规则，下表是该方法的直观展示（表中 parentSize 指父容器中目前可使用的大小）</p><p><img src="/Android-View-的工作原理/MeasureSpec创建规则.png" alt="MeasureSpec创建规则"></p><p>由此可以看出</p><ul><li>当 View 采用固定宽高时，View 的 MeasureSpec 与父容器无关，为精确模式、大小为 LayoutParams 设定的值</li><li>当 View 的宽高为<code>match_parent</code>时，如果父容器为精确模式/最大模式，则其也为精确模式/最大模式，且大小为父容器的剩余空间</li><li>当 View 的宽高为<code>wrap_content</code>时，View 的模式总是最大化模式，且大小不超过父容器的剩余空间</li><li>UNSPECIFIED 模式主要用于系统内部多次 Measure 的情形，一般情况下无需关注 </li></ul><h3 id="measure-过程"><a href="#measure-过程" class="headerlink" title="measure 过程"></a>measure 过程</h3><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>对于 View，measure 完成其自身的测量过程；对于 ViewGroup，除了完成自己的测量过程，还会遍历调用所有子元素的<code>measure</code>方法，各子元素再递归执行这一过程。<code>measure</code> 是一个<code>final</code>方法（<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/View.java" target="_blank" rel="noopener">View.java</a> 第 23267 行），这意味着子类不能重写该方法。在<code>measure</code>中会调用 View 的<code>onMeasure</code>，所以开发者只需要重写该方法即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),</span><br><span class="line">                         getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>setMeasuredDimension</code>会设置 View 宽高的测量值，<code>getDefaultSize</code>返回 View 测量后的大小。</p><p>对于<code>getSuggestedMinimumWidth</code>，如果 View 没有设置背景，那么宽度为<code>mMinWidth</code>，其对应<code>android:minWidth</code>属性，如果不指定属性，则<code>mMinWidth</code>默认为0；如果 View 设置了背景，则 View 的宽度为<code>max(mMinWidth, mBackground.getMinimumWidth())</code>。那么<code>mBackground.getMinimumWidth()</code>所为何物？</p><p>观察 Drawable 的<code>getMinimumWidth</code>方法（<a href="https://android.googlesource.com/platform/frameworks/base/+/c80ad99a33ee49d0bac994c1749ff24d243c3862/graphics/java/android/graphics/drawable/Drawable.java" target="_blank" rel="noopener">Drawable.java</a> 第 798 行）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumWidth</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = getIntrinsicWidth();</span><br><span class="line">    <span class="keyword">return</span> intrinsicWidth > <span class="number">0</span> ? intrinsicWidth : <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以发现该方法返回 Drawable 的原始宽度（如果存在，否则返回0 —— 比如 ShapeDrawable 就无原始宽高）。</p><p>直接继承 View 的自定义控件需要重写<code>onMeasure</code>方法并设置<code>wrap_content</code>时的自身大小，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。原因在于，由上面的表格我们知道，当使用<code>wrap_content</code>时，View 的 SpecMode 为 AT_MOST，此时宽高等于 SpecSize，SpecSize 此时又等于 parentSize，效果跟使用<code>match_parent</code>是一样的。</p><p>解决该问题的方法很简单，给 View 指定一个默认的内部宽高（mWidth 和 mHeight），并在<code>wrap_content</code>时设置此宽高即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST </span><br><span class="line">        && heightSpecMode == MeasureSpec.AT_MOST) {</span><br><span class="line">        setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) {</span><br><span class="line">        setMeasuredDimension(mWidth, heightSpecSize);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) {</span><br><span class="line">        setMeasuredDimension(widthSpecSize, mHeight);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h4><p>对于 ViewGroup 来说，其属于 View 的子类，但同时也是抽象的，它没有重写 View 的<code>onMeasure</code>，而是提供了<code>measureChildren</code>的方法用于测量子元素</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; ++i) {</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags & VISIBILITY_MASK) != GONE) {</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中调用了<code>measureChild</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>显然该方法的思想是取出子元素的 LayoutParams 然后通过<code>getChildMeasureSpec</code>（如 MeasureSpec 小节的分析）创建子元素的 MeasureSpec，接着将 MeasureSpec 传递给 View 的<code>measure</code>方法进行测量。</p><p>ViewGroup 并没有测量的具体过程，而是交给其子类实现，比如 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/LinearLayout.java" target="_blank" rel="noopener">LinearLayout</a>、<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/RelativeLayout.java" target="_blank" rel="noopener">RelativeLayout</a> 等。</p><h4 id="宽高的获取"><a href="#宽高的获取" class="headerlink" title="宽高的获取"></a>宽高的获取</h4><p>一般情况下，measure 完成后即可通过<code>getMeasuredWidth/height</code>获得 View 的测量宽高，但是极端情况下系统可能需要多次 measure 才能确定最终的宽高，所以最好是在<code>onLayout</code>中获取宽高，而不是在<code>onMeasure</code>中。</p><p>考虑 View 外部，比如当我们在 Activity 的<code>onCreate</code>或者<code>onResume</code>中获取 View 的宽高时，会发现结果是不正确的，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步的，因此无法保证在 Activity 执行<code>onCreate</code>、<code>onResume</code>时某个 View 已经测量完毕。有四种方法解决该问题：</p><ul><li><p>Activity/View.onWindowFocusChanged，此时 View 已经初始化完毕。注意该方法可能会被调用多次，比如每次 Activity 的窗口获得/失去焦点</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    <span class="keyword">if</span> (hasFocus) {</span><br><span class="line">        <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getMeasuredHeigth();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>view.post(Runnable runnable)，通过 post 将一个 Runnable 投递到消息队列尾部，当 Looper 调用此 Runnable 时，View 已经被初始化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">view.post(() -> {</span><br><span class="line">    <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">    <span class="keyword">int</span> height = view.getMeasuredHeigth();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>ViewTreeObserver，该类拥有一系列回调方法，比如使用 OnGlobalLayoutListener 接口监听 View 树的状态，同样接口方法会被调用多次</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ViewTreeObserver observer = view.getViewTreeObserver();</span><br><span class="line">observer.addOnGlobalLayoutListener(() -> {</span><br><span class="line">    <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">    <span class="keyword">int</span> height = view.getMeasuredHeigth();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>view.measure(int widthMeasureSpec, int heightMeasureSpec)，手动 measure，较为复杂，不再赘述。</li></ul><h3 id="layout-过程"><a href="#layout-过程" class="headerlink" title="layout 过程"></a>layout 过程</h3><p>View / ViewGroup 使用<code>layout</code>过程确定自身位置，然后在<code>onLayout</code>中遍历所有的子元素并调用其<code>layout</code>方法，重复上述过程。</p><p>View 中的<code>layout</code>方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">        <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">        <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            ......</span><br><span class="line">            mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> && li.mOnLayoutChangeListeners != <span class="keyword">null</span>) {</span><br><span class="line">                ArrayList<OnLayoutChangeListener> listenersCopy =</span><br><span class="line">                        (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < numListeners; ++i) {</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先通过<code>setFrame</code>设定 View 的四个顶点（mLeft、mTop、mBottom、mRight）的值，以此确定 View 在父容器中的位置。接着调用<code>onLayout</code>确定子元素的位置，和<code>onMeasure</code>类似，View / ViewGroup 都没有提供该方法的实现，而是交给具体的布局。</p><p>在 <strong>ViewRoot 和 DecorView</strong> 小节，提及了在 View 的 layout 之后通过<code>getWidth</code>、<code>getHeight</code>获得 View 的“最终宽高”，那么<code>getMeasuredWidth</code>和<code>getWidth</code>的区别到底是什么？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> mRight - mLeft;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> mBottom - mTop;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的代码可以看出，<code>getWidth</code>的返回值刚好就是 View 的测量宽度，也就是说，View 的测量宽高等于最终宽高，只不过测量宽高形成与 measure 过程，而最终宽高形成与 layout 过程 —— 赋值时机不同。但是如果重写 View 的<code>layout</code>方法，改变了<code>super</code>的参数值，比如</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.layout(l, t, r + <span class="number">100</span>, b + <span class="number">100</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>就会导致 View 的最终宽高总是比测量宽高大 100px。</p><h3 id="draw-过程"><a href="#draw-过程" class="headerlink" title="draw 过程"></a>draw 过程</h3><p>将 View 绘制到屏幕上，具体步骤</p><ul><li>绘制背景 background.draw(canvas)</li><li>绘制自身 onDraw</li><li>绘制子元素 dispatchDraw</li><li>绘制装饰 onDrawScrollBars</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Android 提供了一些 API 供开发调用，实现对 View 绘制过程的操纵</p><ul><li><p><code>requestLayout</code></p><p>调用此方法会导致 View 树调用 layout 和 measure 过程，但不会触发 draw 流程</p></li><li><p><code>invalidate</code></p><p>请求重绘 View 树，即 draw 过程。在子线程中可以通过<code>postInvalidate</code>实现</p></li></ul><p>当开发者调用 View 的<code>setVisibility</code>方法实现 VISIBLE / INVISIBLE -> GONE 时，相当于间接调用 <code>requestLayout</code> 和 <code>invalidate</code>。 </p><p>当开发者调用 View 的<code>setVisibility</code>方法实现  INVISIBLE -> VISIBLE 时，相当于间接调用 <code>invalidate</code>。 </p><hr><p><em>本文主要参考了《Android 开发艺术探索》——任玉刚 著</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android IPC 机制详解</title>
    <link href="http://yoursite.com/Android-IPC-%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Android-IPC-机制详解/</id>
    <published>2019-02-23T11:12:35.000Z</published>
    <updated>2019-03-23T04:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。<a id="more"></a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>只有在多进程场景下才需要 IPC 机制。</p><p>多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。</p><p>使用多进程会造成如下的问题：</p><ul><li>静态成员和单例模式完全失效</li><li>线程同步机制完全失效</li><li>SharedPreferences 可靠性下降</li><li>Application 会多次创建</li></ul><p>对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>Java 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个<code>seriaVersionUID</code>即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> seriaVersionUID = <span class="number">519067123721295773L</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">18</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>));</span><br><span class="line">User user = (User) in.readObject();</span><br><span class="line">in.close</span><br></pre></td></tr></tbody></table></figure><p>使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。</p><p>Java 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。</p><h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><p>Android 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。</p><p>其与 Serializable 的区别在于</p><ul><li>Parcelable 使用更复杂，后者如上面的代码，足够简洁。</li><li>使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。</li><li>使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。</li></ul><p>标准写法如下<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>{</span><br><span class="line">        name = in.readString();</span><br><span class="line">        id = in.readInt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实例化静态变量CREATOR</span></span><br><span class="line"><span class="comment">        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator<User> CREATOR = <span class="keyword">new</span> Creator<User>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>{</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过 Intent 传递和获取数据<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"Name"</span>, <span class="number">18</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"data"</span>, user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">User user = getIntent().getParcelableExtra(<span class="string">"data"</span>);</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>Binder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。</p><ul><li>从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。</li><li>从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。</li></ul><p>更多关于 Binder：<a href="https://www.cnblogs.com/samchen2009/p/3316001.html" target="_blank" rel="noopener">图解Android - Binder 和 Service</a></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>Bundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。</p><p>缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。</p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Android Interface Definition Language，Android 接口定义语言。</p><ul><li><p>数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下</p><blockquote><p>Java 中的八种基本数据类型、String、CharSequence。<br></p><p>List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br></p><p>Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br></p></blockquote></li><li><p>定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。</p><blockquote><p>in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</p></blockquote></li></ul><p>关于更多：<a href="https://blog.csdn.net/luoyanglizi/article/details/51958091" target="_blank" rel="noopener">你真的理解AIDL中的in，out，inout么?</a></p><ul><li>两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。<br>注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>第一类 AIDL 文件：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="comment">// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></span><br><span class="line"><span class="comment">// 注意：Book.aidl 与 Book.java的包名应当是一样的</span></span><br><span class="line"><span class="keyword">package</span> com.febers.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意parcelable是小写</span></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 <code>writeToParcel</code>方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现<code>readFromParcel</code>方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。</p></blockquote><p>第二类 AIDL 文件：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.lypeer.ipcclient;</span><br><span class="line"><span class="comment">//导入所需要使用的非默认支持数据类型的包</span></span><br><span class="line"><span class="keyword">import</span> com.febers.aidldemo.Book;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BookManager</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的返回值前都不需要加任何东西，不管是什么数据类型</span></span><br><span class="line">    <span class="function">List<Book> <span class="title">getBooks</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Book <span class="title">getBook</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBookCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传参时，Java基本数据类型、String 以及 CharSequence 之外的类型</span></span><br><span class="line">    <span class="comment">//都需要在前面加上定向tag，具体加什么量需而定</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBookPrice</span><span class="params">(in Book book , <span class="keyword">int</span> price)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(in Book book , String name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">addBookIn</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookOut</span><span class="params">(out Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookInout</span><span class="params">(inout Book book)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>完成上面的步骤之后，<code>build</code>项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。</p><p>服务端<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String TAG = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含Book对象的list</span></span><br><span class="line">    <span class="keyword">private</span> List<Book> mBooks = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由AIDL文件生成的BookManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BookManager.Stub mBookManager = <span class="keyword">new</span> BookManager.Stub() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List<Book> <span class="title">getBooks</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                Log.e(TAG, <span class="string">"invoking getBooks() method , now the list is : "</span> + mBooks.toString());</span><br><span class="line">                <span class="keyword">if</span> (mBooks != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span> mBooks;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                <span class="keyword">if</span> (mBooks == <span class="keyword">null</span>) {</span><br><span class="line">                    mBooks = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (book == <span class="keyword">null</span>) {</span><br><span class="line">                    Log.e(TAG, <span class="string">"Book is null in In"</span>);</span><br><span class="line">                    book = <span class="keyword">new</span> Book();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class="line">                book.setPrice(<span class="number">2333</span>);</span><br><span class="line">                <span class="keyword">if</span> (!mBooks.contains(book)) {</span><br><span class="line">                    mBooks.add(book);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//打印mBooks列表，观察客户端传过来的值</span></span><br><span class="line">                Log.e(TAG, <span class="string">"invoking addBooks() method , now the list is : "</span> + mBooks.toString());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"Android开发艺术探索"</span>);</span><br><span class="line">        book.setPrice(<span class="number">28</span>);</span><br><span class="line">        mBooks.add(book);   </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>{</span><br><span class="line">        Log.e(getClass().getSimpleName(), String.format(<span class="string">"on bind,intent = %s"</span>, intent.toString()));</span><br><span class="line">        <span class="keyword">return</span> mBookManager;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>客户端<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由AIDL文件生成的 Java 类</span></span><br><span class="line">    <span class="keyword">private</span> BookManager mBookManager = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标志当前与服务端连接状况的布尔值，false为未连接，true为连接中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含Book对象的list</span></span><br><span class="line">    <span class="keyword">private</span> List<Book> mBooks;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_aidl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按钮的点击事件，点击之后调用服务端的addBookIn方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(View view)</span> </span>{</span><br><span class="line">        <span class="comment">//如果与服务端的连接处于未连接状态，则尝试连接</span></span><br><span class="line">        <span class="keyword">if</span> (!mBound) {</span><br><span class="line">            attemptToBindService();</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"当前与服务端处于未连接状态，正在尝试重连，请稍后再试"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mBookManager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"APP研发录In"</span>);</span><br><span class="line">        book.setPrice(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            mBookManager.addBook(book);</span><br><span class="line">            Log.e(getLocalClassName(), book.toString());</span><br><span class="line">        } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试与服务端建立连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptToBindService</span><span class="params">()</span> </span>{</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(<span class="string">"com.febers.aidl"</span>);</span><br><span class="line">        intent.setPackage(<span class="string">"com.febers.aidldemo"</span>);</span><br><span class="line">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="keyword">if</span> (!mBound) {</span><br><span class="line">            attemptToBindService();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="keyword">if</span> (mBound) {</span><br><span class="line">            unbindService(mServiceConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>{</span><br><span class="line">            Log.e(getLocalClassName(), <span class="string">"service connected"</span>);</span><br><span class="line">            mBookManager = BookManager.Stub.asInterface(service);</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mBookManager != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    mBooks = mBookManager.getBooks();</span><br><span class="line">                    Log.e(getLocalClassName(), mBooks.toString());</span><br><span class="line">                } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>{</span><br><span class="line">            Log.e(getLocalClassName(), <span class="string">"service disconnected"</span>);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>当然不要忘记在 Manifest 文件中注册 Service。<br>控制台显示信息如下：</p><blockquote><p>//服务端的 log 信息<br><br>1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br><br>2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br><br>3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]</p></blockquote><blockquote><p>//客户端的 log 信息<br><br>1，service connected<br><br>2，[name : Android开发艺术探索 , price : 28]<br><br>3，name : APP研发录In , price : 2333</p></blockquote><h3 id="Messager"><a href="#Messager" class="headerlink" title="Messager"></a>Messager</h3><p>Messager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>Messenger 有两个构造函数，分贝以 Handler 和 Binder 为参数<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IMessenger mTarget;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>{</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>{</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);    <span class="comment">//和前面的 AIDL 很相似吧</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>Handler.getIMessenger</code>源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) {</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        }</span><br><span class="line">        mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>IMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法<code>send(android.os.Message msg)</code>。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>所以可以使用<code>Handler.handlerMessage</code>接收消息。Messenger 中对<code>send</code>的实现如下：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">    mTarget.send(message);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>Messenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部<code>send</code>方法实际上是调用 IMessenger 实现的<code>send</code>方法。</p><p>Messenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>服务端<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> && msg.arg1 == <span class="number">9527</span>) {</span><br><span class="line">                <span class="keyword">if</span> (msg.getData() == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                String content = (String) msg.getData().get(<span class="string">"MSG_CONTENT"</span>);  <span class="comment">//接收客户端的消息</span></span><br><span class="line">                Log.e(TAG, <span class="string">"Message from client: "</span> + content);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//回复消息给客户端</span></span><br><span class="line">                Message replyMsg = Message.obtain();</span><br><span class="line">                replyMsg.arg1 = <span class="number">9528</span>;</span><br><span class="line">                Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                bundle.putString(<span class="string">"MSG_CONTENT"</span>, <span class="string">"已收到消息"</span>);</span><br><span class="line">                replyMsg.setData(bundle);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    msg.replyTo.send(replyMsg);     <span class="comment">//回信</span></span><br><span class="line">                } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(<span class="keyword">final</span> Intent intent)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>客户端代码片段<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessagerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    Messenger mClientMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> && msg.arg1 == <span class="number">9528</span>){</span><br><span class="line">                <span class="keyword">if</span> (msg.getData() == <span class="keyword">null</span>){</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                String content = (String) msg.getData().get(<span class="string">"MSG_CONTENT"</span>);</span><br><span class="line">                Log.e(TAG, <span class="string">"Message from server: "</span> + content);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端的 Messenger</span></span><br><span class="line">    <span class="keyword">private</span> Messenger mServerMessenger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mMessengerConnection = <span class="keyword">new</span> ServiceConnection() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(<span class="keyword">final</span> ComponentName name, <span class="keyword">final</span> IBinder service)</span> </span>{</span><br><span class="line">            mServerMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(<span class="keyword">final</span> ComponentName name)</span> </span>{</span><br><span class="line">            mServerMessenger = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>{</span><br><span class="line">        String msgContent = <span class="string">"消息"</span>；</span><br><span class="line"></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.arg1 = <span class="number">9527</span>;</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(<span class="string">"MSG_CONTENT"</span>, msgContent);</span><br><span class="line">        message.setData(bundle);</span><br><span class="line">        message.replyTo = mClientMessenger;     <span class="comment">//指定回信人是客户端定义的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            mServerMessenger.send(message);</span><br><span class="line">        } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>主要用于不同的应用程序之间实现数据共享功能</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="多进程通信" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android 动画详解</title>
    <link href="http://yoursite.com/Android-%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/Android-动画详解/</id>
    <published>2019-02-18T11:12:22.000Z</published>
    <updated>2019-03-15T15:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。<a id="more"></a></p><h2 id="View-Animation"><a href="#View-Animation" class="headerlink" title="View Animation"></a>View Animation</h2><p>视图动画的作用对象是 View，可分为补间动画和帧动画。</p><h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><p>动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。</p><h4 id="XML-方式"><a href="#XML-方式" class="headerlink" title="XML 方式"></a>XML 方式</h4><p>创建一个 set.xml 文件，通过动画集合标签<code><set></code>将四种效果结合起来<br></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><?xml version="1.0" encoding="utf-8"?></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">--动画集合</span></span></span><br><span class="line"><span class="tag"><span class="attr">interpolator</span> 表示所采用的的差值器，其影响动画的速度，可以不指定</span></span><br><span class="line"><span class="tag"><span class="attr">shareInterpolator</span> 表示集合中的动画是否和集合共享同一个差值器<span class="attr">--</span>></span></span><br><span class="line"><span class="tag"><<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shareInterpolator</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:repeatMode</span>=<span class="string">"reverse"</span>></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"><!-- 缩放动画</span></span><br><span class="line"><span class="comment">    fromXScale 表示水平方向缩放的起始值</span></span><br><span class="line"><span class="comment">    toXScale 表示水平方向的结束值</span></span><br><span class="line"><span class="comment">    fillAfter 表示动画显示结束保持最后一帧--></span></span><br><span class="line">    <span class="tag"><<span class="name">scale</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXScale</span>=<span class="string">"0.5"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYScale</span>=<span class="string">"0.5"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXScale</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYScale</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:repeatCount</span>=<span class="string">"infinite"</span>/></span><span class="comment"><!--次数 ,infinite 为无线循环播放--></span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"><!-- 透明度动画</span></span><br><span class="line"><span class="comment">        fromAlpha 表示起始透明度</span></span><br><span class="line"><span class="comment">        toAlpha 表示结束透明度--></span></span><br><span class="line">    <span class="tag"><<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">"0.7"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">"1"</span>/></span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"><!--旋转动画</span></span><br><span class="line"><span class="comment">    fromDegrees 表示起始角度</span></span><br><span class="line"><span class="comment">    toDegrees 表示结束角度--></span></span><br><span class="line">    <span class="tag"><<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromDegrees</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toDegrees</span>=<span class="string">"90"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span>/></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"><!--平移动画--></span></span><br><span class="line">    <span class="tag"><<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"100%"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYDelta</span>=<span class="string">"-100%"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">        /></span></span><br><span class="line"><span class="tag"></<span class="name">set</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>使用以上动画的方式如下<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);</span><br><span class="line">view.startAnimation(anim);</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Java-代码方式"><a href="#Java-代码方式" class="headerlink" title="Java 代码方式"></a>Java 代码方式</h4><p>使用 Java 代码实现动画的方式如下<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimationSet</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//创建动画，参数表示他的子动画是否共用一个插值器</span></span><br><span class="line">    AnimationSet animationSet = <span class="keyword">new</span> AnimationSet(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//添加动画</span></span><br><span class="line">    animationSet.addAnimation(<span class="keyword">new</span> AlphaAnimation(<span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    <span class="comment">//设置插值器</span></span><br><span class="line">    animationSet.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">    <span class="comment">//设置动画持续时长</span></span><br><span class="line">    animationSet.setDuration(<span class="number">3000</span>);</span><br><span class="line">    <span class="comment">//设置动画结束之后是否保持动画的目标状态</span></span><br><span class="line">    animationSet.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置动画结束之后是否保持动画开始时的状态</span></span><br><span class="line">    animationSet.setFillBefore(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//设置重复模式</span></span><br><span class="line">    animationSet.setRepeatMode(AnimationSet.REVERSE);</span><br><span class="line">    <span class="comment">//设置重复次数</span></span><br><span class="line">    animationSet.setRepeatCount(AnimationSet.INFINITE);</span><br><span class="line">    <span class="comment">//设置动画延时时间</span></span><br><span class="line">    animationSet.setStartOffset(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">//取消动画</span></span><br><span class="line">    animationSet.cancel();</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    animationSet.reset();</span><br><span class="line">    <span class="comment">//开始动画</span></span><br><span class="line">    view.startAnimation(animationSet);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的<code>initialize</code>和<code>applyTransformation</code>方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 </p><h4 id="特殊使用"><a href="#特殊使用" class="headerlink" title="特殊使用"></a>特殊使用</h4><p>View 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。</p><h3 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h3><p>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。</p><p>首先需要定义一个 XML 文件<code>frame_animation.xml</code><br></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><?xml version="1.0" encoding="utf-8"?></span></span><br><span class="line"><span class="tag"><<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">"false"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@mipmap/image1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span> /></span></span><br><span class="line">    <span class="tag"><<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@mipmap/image2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span> /></span></span><br><span class="line">    <span class="tag"><<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@mipmap/iamge2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span> /></span></span><br><span class="line"><span class="tag"></<span class="name">animation-list</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setBackgroundResource(R.drawable.frame_animation)；</span><br><span class="line">AnimationDrawable drawable = (AnimationDrawable) view.getBackground();</span><br><span class="line">drawable.start();</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><p>属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：</p><ul><li>补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。</li><li>补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。</li></ul><p>与补间动画类似，属性动画也需要定义几个方面的属性：</p><ul><li>动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。</li><li>动画插值方式。通过 android:interploator 指定。</li><li>动画重复次数。通过 android:repeatCount 指定。</li><li>重复行为。通过 android:repeatMode 指定。</li><li>动画集。在属性资源文件中通过 <code><set></code> 来组合。</li><li>帧刷新率。指定多长时间播放一帧。默认为 10 ms。</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。</li><li>ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。</li><li>AnimatorSet：Animator 的子类，用于组合多个 Animator。</li></ul><p>属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。</p><ul><li>IntEvaluator：计算 int 类型属性值的计算器。</li><li>FloatEvaluator：用于计算 float 类型属性值的计算器。</li><li>ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。</li><li>TypeEvaluator：可以自定义计算器。</li></ul><h3 id="ValueAniamtor"><a href="#ValueAniamtor" class="headerlink" title="ValueAniamtor"></a>ValueAniamtor</h3><p>ValueAnimator 类中有3个重要方法：</p><blockquote><p>ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)</p></blockquote><h4 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt"></a>ofInt</h4><p>将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator</p><p>下面的代码将实现按钮的宽度从 150px 放大到 500px<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line">    <span class="comment">// 设置属性数值的初始值 & 结束值</span></span><br><span class="line">    <span class="comment">// ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500</span></span><br><span class="line">    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, <span class="number">500</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置动画的播放各种属性</span></span><br><span class="line">    valueAnimator.setDuration(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度</span></span><br><span class="line">    <span class="comment">// 设置更新监听器，数值每次变化更新都会调用该方法</span></span><br><span class="line">    valueAnimator.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener() {</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animator)</span> </span>{</span><br><span class="line">            <span class="comment">// 获得每次变化后的属性值</span></span><br><span class="line">            <span class="keyword">int</span> currentValue = (Integer) animator.getAnimatedValue();</span><br><span class="line">            <span class="comment">// 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化</span></span><br><span class="line">            mButton.getLayoutParams().width = currentValue;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 刷新视图，即重新绘制</span></span><br><span class="line">            mButton.requestLayout();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    valueAnimator.start();  <span class="comment">// 启动动画</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="ofFloat"><a href="#ofFloat" class="headerlink" title="ofFloat"></a>ofFloat</h4><p>其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span> </span>{  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写evaluate()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fraction 动画完成度（根据它来计算当前动画的值）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startValue 动画的初始值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endValue 动画的结束值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>{  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> startFloat = ((Number) startValue).floatValue();  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始值过渡到结束值的算法</span></span><br><span class="line">        <span class="comment">// 1. 用结束值减去初始值，算出它们之间的差值</span></span><br><span class="line">        <span class="comment">// 2. 用上述差值乘以 fraction 系数</span></span><br><span class="line">        <span class="comment">// 3. 加上初始值，得到当前动画的值</span></span><br><span class="line">        <span class="keyword">return</span> startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="ofObject"><a href="#ofObject" class="headerlink" title="ofObject"></a>ofObject</h4><p>对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。</p><p>但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。</p><p>自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象</span></span><br><span class="line">        Point startPoint = (Point) startValue;</span><br><span class="line">        Point endPoint = (Point) endValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据fraction来计算当前动画的x和y的值</span></span><br><span class="line">        <span class="keyword">float</span> x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());</span><br><span class="line">        <span class="keyword">float</span> y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将计算后的坐标封装到一个新的Point对象中并返回</span></span><br><span class="line">        Point point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将属性动画作用到自定义View当中<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> RADIUS = <span class="number">70f</span>;<span class="comment">// 圆的半径</span></span><br><span class="line">    <span class="keyword">private</span> Point currentPoint;<span class="comment">// 当前点坐标</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;<span class="comment">// 绘图画笔</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法，初始化画笔</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现绘制逻辑</span></span><br><span class="line">    <span class="comment">// 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>{</span><br><span class="line">        <span class="comment">// 如果当前点坐标为空(即第一次)</span></span><br><span class="line">        <span class="keyword">if</span> (currentPoint == <span class="keyword">null</span>) {</span><br><span class="line">            currentPoint = <span class="keyword">new</span> Point(RADIUS, RADIUS);  <span class="comment">// 创建一个点对象(坐标是(70,70))</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> x = currentPoint.getX();</span><br><span class="line">            <span class="keyword">float</span> y = currentPoint.getY();</span><br><span class="line">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将属性动画作用到View中</span></span><br><span class="line">            Point startPoint = <span class="keyword">new</span> Point(RADIUS, RADIUS);<span class="comment">// 初始点为圆心(70,70)</span></span><br><span class="line">            Point endPoint = <span class="keyword">new</span> Point(<span class="number">700</span>, <span class="number">1000</span>);<span class="comment">// 结束点为(700,1000)</span></span><br><span class="line"></span><br><span class="line">            ValueAnimator anim = ValueAnimator.ofObject(<span class="keyword">new</span> PointEvaluator(), startPoint, endPoint);</span><br><span class="line">            anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">            anim.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>{</span><br><span class="line">                    currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">                    <span class="comment">// 每次赋值后就重新绘制，从而实现动画效果</span></span><br><span class="line">                    <span class="comment">// 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次</span></span><br><span class="line">                    invalidate();  </span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            anim.start();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果坐标值不为0,则画圆</span></span><br><span class="line">            <span class="keyword">float</span> x = currentPoint.getX();</span><br><span class="line">            <span class="keyword">float</span> y = currentPoint.getY();</span><br><span class="line">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。<br>ObjectAnimator 与 ValueAnimator类的区别在于</p><ul><li>ValueAnimator 类是先改变值，然后<strong>手动赋值</strong>给对象的属性从而实现动画，属于<strong>间接</strong>对对象属性进行操作</li><li>ObjectAnimator 类是先改变值，然后<strong>自动赋值</strong>给对象的属性从而实现动画，属于<strong>直接</strong>对对象属性进行操作</li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>对于</p><blockquote><p>ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ….values); </p></blockquote><p>其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值</p><p>对 Button 进行变换<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  <span class="comment">// 效果:常规->全透明->常规</span></span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);</span><br><span class="line">......</span><br><span class="line">animator.setDuration(<span class="number">5000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h4><p>在上面的例子中，我们给<code>ObjectAnimator.ofFloat</code>的第二个参数<code>String property</code>传入<code>alpha</code>、<code>rotation</code>、<code>translationX</code> 和<code>scaleY</code>等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的<code>get/set</code>方法进行的。</p><p>所以自定义属性就可以通过为对象设置需要操作属性的<code>set/get</code>方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。</p><p>还是对一个球做变换<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView2</span> <span class="keyword">extends</span> <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> RADIUS = <span class="number">100f</span>;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;  <span class="comment">// 设置背景颜色属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置背景颜色的get() & set()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        mPaint.setColor(Color.parseColor(color));  <span class="comment">// 将画笔的颜色设置成方法参数传入的颜色</span></span><br><span class="line">        invalidate();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView2</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>{</span><br><span class="line">        canvas.drawCircle(<span class="number">500</span>, <span class="number">500</span>, RADIUS, mPaint);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>实现自定义估值器，完成颜色过渡的逻辑<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentRed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentGreen ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentBlue ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String startColor = (String) startValue;</span><br><span class="line">        String endColor = (String) endValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字</span></span><br><span class="line">        <span class="comment">// 那么每个颜色的取值范围是0-255</span></span><br><span class="line">        <span class="keyword">int</span> startRed = Integer.parseInt(startColor.substring(<span class="number">1</span>, <span class="number">3</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> startGreen = Integer.parseInt(startColor.substring(<span class="number">3</span>, <span class="number">5</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> startBlue = Integer.parseInt(startColor.substring(<span class="number">5</span>, <span class="number">7</span>), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> endRed = Integer.parseInt(endColor.substring(<span class="number">1</span>, <span class="number">3</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> endGreen = Integer.parseInt(endColor.substring(<span class="number">3</span>, <span class="number">5</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> endBlue = Integer.parseInt(endColor.substring(<span class="number">5</span>, <span class="number">7</span>), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将初始化颜色的值定义为当前需要操作的颜色值</span></span><br><span class="line">        mCurrentRed = startRed;</span><br><span class="line">        mCurrentGreen = startGreen;</span><br><span class="line">        mCurrentBlue = startBlue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算初始颜色和结束颜色之间的差值</span></span><br><span class="line">        <span class="comment">// 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢</span></span><br><span class="line">        <span class="keyword">int</span> redDiff = Math.abs(startRed - endRed);</span><br><span class="line">        <span class="keyword">int</span> greenDiff = Math.abs(startGreen - endGreen);</span><br><span class="line">        <span class="keyword">int</span> blueDiff = Math.abs(startBlue - endBlue);</span><br><span class="line">        <span class="keyword">int</span> colorDiff = redDiff + greenDiff + blueDiff;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mCurrentRed != endRed) {</span><br><span class="line">            <span class="comment">// getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1</span></span><br><span class="line">            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, <span class="number">0</span>, fraction);</span><br><span class="line">        </span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mCurrentGreen != endGreen) {</span><br><span class="line">            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mCurrentBlue != endBlue) {</span><br><span class="line">            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将计算出的当前颜色的值组装返回</span></span><br><span class="line">        String currentColor = <span class="string">"#"</span> + getHexString(mCurrentRed)</span><br><span class="line">                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);</span><br><span class="line">        <span class="keyword">return</span> currentColor;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据fraction值来计算当前的颜色。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCurrentColor</span><span class="params">(<span class="keyword">int</span> startColor, <span class="keyword">int</span> endColor, <span class="keyword">int</span> colorDiff,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> offset, <span class="keyword">float</span> fraction)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> currentColor;</span><br><span class="line">        <span class="keyword">if</span> (startColor > endColor) {</span><br><span class="line">            currentColor = (<span class="keyword">int</span>) (startColor - (fraction * colorDiff - offset));</span><br><span class="line">            <span class="keyword">if</span> (currentColor < endColor) {</span><br><span class="line">                currentColor = endColor;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            currentColor = (<span class="keyword">int</span>) (startColor + (fraction * colorDiff - offset));</span><br><span class="line">            <span class="keyword">if</span> (currentColor > endColor) {</span><br><span class="line">                currentColor = endColor;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> currentColor;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将10进制颜色值转换成16进制。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getHexString</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        String hexString = Integer.toHexString(value);</span><br><span class="line">        <span class="keyword">if</span> (hexString.length() == <span class="number">1</span>) {</span><br><span class="line">            hexString = <span class="string">"0"</span> + hexString;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> hexString;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>具体调用<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofObject(myView2, <span class="string">"color"</span>, <span class="keyword">new</span> ColorEvaluator(), <span class="string">"#0000FF"</span>, <span class="string">"#FF0000"</span>);</span><br><span class="line">anim.setDuration(<span class="number">2000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中<code>setWidth</code>并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过<code>get/set</code>无法改变控件的宽度，也就无法实现动画效果。</p><p>解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的<code>get/set</code>方法。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ButtonWrapper wrapper = <span class="keyword">new</span> ViewWrapper(button);</span><br><span class="line">ObjectAnimator.ofInt(wrapper, <span class="string">"width"</span>, <span class="number">500</span>)</span><br><span class="line">        .setDuration(<span class="number">3000</span>)</span><br><span class="line">        .start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewWrapper</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> View mTarget;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewWrapper</span><span class="params">(View target)</span> </span>{</span><br><span class="line">        mTarget = target;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为宽度设置get/set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> mTarget.getLayoutParams().width;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>{</span><br><span class="line">        mTarget.getLayoutParams().width = width;</span><br><span class="line">        mTarget.requestLayout();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h3><p>最后介绍组合动画类，仅展示用法<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, <span class="string">"translationX"</span>, curTranslationX, <span class="number">300</span>,curTranslationX);  </span><br><span class="line">ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);  </span><br><span class="line">ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  </span><br><span class="line"></span><br><span class="line">AnimatorSet animSet = <span class="keyword">new</span> AnimatorSet();  </span><br><span class="line"></span><br><span class="line">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class="line">animSet.setDuration(<span class="number">5000</span>);  </span><br><span class="line">animSet.start();</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Spring-Animation"><a href="#Spring-Animation" class="headerlink" title="Spring Animation"></a>Spring Animation</h2><p>SpringAnimation，弹簧动画，位于<code>android.support.animation</code>包中，属性动画位于<code>android.animation.Animator</code>包中，其实通过 <a href="https://developer.android.com/reference/android/view/animation/BounceInterpolator.html" target="_blank" rel="noopener">BounceInterpolator</a> 或者 <a href="https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html" target="_blank" rel="noopener">OvershootInterpolator</a> 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。</p><p>使用之前需要导入<code>com.android.support:support-dynamic-animation</code>包</p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringAnimation</span><span class="params">(View v, ViewProperty property)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringAnimation</span><span class="params">(View v, ViewProperty property, <span class="keyword">float</span> finalPosition)</span></span></span><br></pre></td></tr></tbody></table></figure><p>参数分别是操作对应的View，对应的变化属性及最终的位置。</p><p>ViewProperty 包括(Z轴支持需要API >= 21)：</p><blockquote><p>TRANSLATION_X<br>TRANSLATION_Y<br>TRANSLATION_Z<br>SCALE_X<br>SCALE_Y<br>ROTATION<br>ROTATION_X<br>ROTATION_Y<br>X<br>Y<br>Z<br>ALPHA<br>SCROLL_X<br>SCROLL_Y</p></blockquote><p>在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量</p><ul><li>Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快</li><li>DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ > 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 < ζ <1)。</li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SpringAnimation btnAnim = <span class="keyword">new</span> SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">btnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);</span><br><span class="line">btnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);</span><br><span class="line"></span><br><span class="line">btnAnim.setStartVelocity(<span class="number">10000</span>);  <span class="comment">//开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反</span></span><br><span class="line">btnAnim.start();</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="动画开发" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
