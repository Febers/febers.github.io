<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ReBE</title>
  
  <subtitle>Febers的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-12T10:28:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Febers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode：最长回文子串（Longest Palindromic Substring）的解法</title>
    <link href="http://yoursite.com/LeetCode%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88Longest-Palindromic-Substring%EF%BC%89%E7%9A%84%E8%A7%A3%E6%B3%95/"/>
    <id>http://yoursite.com/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/</id>
    <published>2019-01-12T06:32:23.000Z</published>
    <updated>2019-01-12T10:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babcd&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p>本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。</p><h2 id="O-n-3-算法"><a href="#O-n-3-算法" class="headerlink" title="O(n^3)算法"></a>O(n^3)算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>从最长的子串开始，遍历所有该原字符串的子串；</li><li>每找出一个字符串，就判断该字符串是否为回文；</li><li>子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>遍历字符串子串：嵌套一个循环：O(n^2)；   </li><li>判断是否为回文：再次嵌套一个循环：O(n^3)。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static String longestPalindrome(String s) &#123;</span><br><span class="line">    if(s.length() &lt;= 1)</span><br><span class="line">        return s;</span><br><span class="line">    for(int i = s.length();i &gt; 0; i--) &#123;//子串长度</span><br><span class="line">        for(int j = 0; j &lt;= s.length() - i; j++) &#123;</span><br><span class="line">            String sub = s.substring(j , i + j);//子串位置</span><br><span class="line">            int count = 0;//计数，用来判断是否对称</span><br><span class="line">            for (int k = 0; k &lt; sub.length() / 2; k++) &#123;//左右对称判断</span><br><span class="line">                if (sub.charAt(k) == sub.charAt(sub.length() - k - 1))</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (count == sub.length() / 2)</span><br><span class="line">                return sub;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;;//表示字符串中无回文子串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-n-2-算法"><a href="#O-n-2-算法" class="headerlink" title="O(n^2)算法"></a>O(n^2)算法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；</li><li>遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；</li><li>每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；</li><li>重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。</li></ul><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li><p>遍历字符：一层循环——O(n-1)；</p></li><li><p>找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)</p></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static int maxLen = 0;</span><br><span class="line"></span><br><span class="line">private static String sub = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">public static String longestPalindrome(String s) &#123;</span><br><span class="line">    if(s.length() &lt;= 1)</span><br><span class="line">        return s;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; s.length()-1;i++)&#123;</span><br><span class="line">        findLongestPalindrome(s,i,i);//单核回文</span><br><span class="line">        findLongestPalindrome(s,i,i+1);//双核回文</span><br><span class="line">    &#125;</span><br><span class="line">    return sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void findLongestPalindrome(String s,int low,int high) &#123;</span><br><span class="line">    while (low &gt;= 0 &amp;&amp; high &lt;= s.length()-1)&#123;</span><br><span class="line">        if(s.charAt(low) == s.charAt(high))&#123;</span><br><span class="line">            if(high - low + 1 &gt; maxLen)&#123;</span><br><span class="line">                maxLen = high - low + 1;</span><br><span class="line">                sub = s.substring(low , high+1);</span><br><span class="line">            &#125;</span><br><span class="line">            low --;//向两边扩散找当前字符为中心的最大回文子串</span><br><span class="line">            high ++;</span><br><span class="line">        &#125; else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-n-算法——Manacher算法"><a href="#O-n-算法——Manacher算法" class="headerlink" title="O(n)算法——Manacher算法"></a>O(n)算法——Manacher算法</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br><br>这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以<code>＃</code>号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; #a# </span><br><span class="line">abaf -&gt; #a#b#a#f#</span><br></pre></td></tr></table></figure></p><p>可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。</p><p>借助两个变量center、right分别记录回文子串对应的中心点和右端点</p><p><img src="/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png" alt="你想输入的替代文字"></p><p>可以直接看出，right就是<code>2*center-i</code>（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br><br>反之，就只能从1个长度开始匹配了，就是下面的这行代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1</span><br></pre></td></tr></table></figure><p>这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br><br>进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static String longestPalindrome(String s) &#123;</span><br><span class="line">if(s == null || s.length() &lt; 1) &#123;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder builder = new StringBuilder();</span><br><span class="line">// 防止左端点越界</span><br><span class="line">builder.append(&quot;&amp;#&quot;);</span><br><span class="line">char[] c = s.toCharArray();</span><br><span class="line">for (char a : c) &#123;</span><br><span class="line">builder.append(a).append(&quot;#&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String newStr = builder.toString();</span><br><span class="line">c = newStr.toCharArray();</span><br><span class="line">// 回文半径</span><br><span class="line">int[] r = new int[newStr.length()];</span><br><span class="line">// 回文子串最大右端点、中心点</span><br><span class="line">int right=0, center=0;</span><br><span class="line">// 最大回文半径、最大中心点</span><br><span class="line">int maxR=0, maxC=0;</span><br><span class="line">for (int i=1;i &lt; c.length;i++) &#123;</span><br><span class="line">// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径</span><br><span class="line">r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1;</span><br><span class="line">while (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123;</span><br><span class="line">++r[i];</span><br><span class="line">&#125;</span><br><span class="line">// 更新右端点和中心点</span><br><span class="line">if (right &lt; i+r[i]) &#123;</span><br><span class="line">right = i+r[i];</span><br><span class="line">center = i;</span><br><span class="line">&#125;</span><br><span class="line">// 更新最大半径和最大中心点</span><br><span class="line">if (maxR &lt; r[i]) &#123;</span><br><span class="line">maxR = r[i];</span><br><span class="line">maxC = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    // 计算在原字符串中的起始点</span><br><span class="line">int start = (maxC-maxR)/2;</span><br><span class="line">return s.substring(start, start+maxR-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;babcd&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: &amp;quot;bab&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Pages+Hexo搭建个人博客</title>
    <link href="http://yoursite.com/Github-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/Github-Pages-Hexo搭建个人博客/</id>
    <published>2019-01-11T15:22:07.000Z</published>
    <updated>2019-01-12T09:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<a id="more"></a></p><p>&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为<code>{账户名}.github.io</code>，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：<code>https://{账户名}.github.io</code>便可以看到缺省的界面。</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：</p><ul><li>安装Git客户端，前往Git主页下载，安装后登录帐号。</li><li>安装Node.js环境，前往Node主页下载。</li><li><p>安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>初始化Hexo，<code>projectname</code>省略时，要求当前文件夹为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [projectname]</span><br></pre></td></tr></table></figure></li></ul><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。<br>在博客的文件夹中有<code>_config.yml</code>文件，为Hexo的配置文件，打开并将相应位置设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">type: git</span><br><span class="line">repo: 该处填写仓库的完整路径</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p><p>该过程其实是给<code>hexo d</code>这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。<br>保存文件之后，安装Git部署插件，在Git Bash中键入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>接下来就是清除hexo缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>生成静态文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><p>部署网站，d的意思是deploy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>后两个命令可以合并为一条，关于Hexo的命令请访问：<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo指令</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入<code>https://{账户名}.github.io</code>，发现打开了一个使用Hexo搭建的Github Pages博客。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>&emsp;&emsp;博客文件夹下的<code>_config.yml</code>文件可以配置整个博客的名称、主题等基本功能，<code>/theme/</code>文件夹下的<code>_config.yml</code>文件则用于配置具体的主题配置。</p><h3 id="发表与删除"><a href="#发表与删除" class="headerlink" title="发表与删除"></a>发表与删除</h3><p>&emsp;&emsp;在博客文件夹打开Git Bash，键入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文章的标题&quot;</span><br></pre></td></tr></table></figure><p>之后便会生成一个md文件，在md文件中编辑文章保存，然后键入<code>hexo g -d</code>便会发布文章。</p><p>&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的 Hexo主题</a>。笔者使用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>。</p><p>&emsp;&emsp;在博客文件夹下的<code>_config.yml</code>文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客<code>_config.yml</code>文件的更改，保存片刻即生效。</p><h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>&emsp;&emsp;具体过程如下：</p><ul><li>需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，<code>{账户名}.github.io</code>的IP地址，还有一个的记录类型为<code>CNAME</code>，记录值为：<code>{账户名}.github.io</code>。</li><li>进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。</li><li>进入博客文件夹中的<code>/source/</code>，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为<strong>所有文件</strong>，名称为<strong>CNAME</strong>。</li></ul><h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p>&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:</p><ul><li>新建一个分支，如hexo，并将其设置为默认</li><li>本地clone你的Github Pages仓库，得到一个io文件夹：<code>{账户名}.github.io</code>的文件夹。</li><li>将原来博客文件夹中的<code>_config.yml，themes/，source/，scffolds/，package.json，.gitignore</code>复制到clone下来的文件夹，注意要将<code>theme/</code>主题的<code>.git/</code>删除。</li><li>在clone下的文件夹执行<code>npm install</code>，<code>npm install hexo-deployer-git</code>。</li></ul><p>此时<code>{账户名}.github.io</code>文件夹已经成为包含你博客所有文件的工作文件夹，在部署(<code>hexo g -d</code>)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;更新源文件&quot;</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:</p><ul><li>clone你的Github Pages仓库，得到一个io文件夹。</li><li>在文件夹中打开Git Bash，键入以下命令:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install </span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></li></ul><p>现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。</p><h2 id="Hexo各文件（夹）说明"><a href="#Hexo各文件（夹）说明" class="headerlink" title="Hexo各文件（夹）说明"></a>Hexo各文件（夹）说明</h2><ul><li>_config.yml：站点的配置文件，需要拷贝；</li><li>themes/：主题文件夹，需要拷贝；</li><li>source：博客文章的.md文件，需要拷贝；</li><li>scaffolds/：文章的模板，需要拷贝；</li><li>package.json：安装包的名称，需要拷贝；</li><li>.gitignore：限定在push时哪些文件可以忽略，需要拷贝；</li><li>.git/：主题和站点都有，标志这是一个git项目，不需要拷贝；</li><li>node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li><li>public：hexo g生成的静态网页，不需要拷贝；</li><li>.deploy_git：同上，hexo g也会生成，不需要拷贝；</li><li>db.json：文件，不需要拷贝。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="互联网" scheme="http://yoursite.com/categories/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>坐过山车的人</title>
    <link href="http://yoursite.com/%E5%9D%90%E8%BF%87%E5%B1%B1%E8%BD%A6%E7%9A%84%E4%BA%BA/"/>
    <id>http://yoursite.com/坐过山车的人/</id>
    <published>2019-01-10T09:57:55.000Z</published>
    <updated>2019-01-11T16:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<a id="more"></a><br>&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。</p><blockquote><p>我们乘坐过山车飞向未来，<br>他和我的手里各捏着一张票，<br>那是飞向未来的小舢板，<br>起伏的波浪是我无畏的想象力。<br>乘坐我的想象力，<br>他们尽情蹂躏<br>这些无辜的女孩和男孩，<br>这些无辜的小狗和小猫。<br>在波浪之下，在波浪的下面<br>一直匍匐着衰弱的故事人，<br>他曾经是最伟大的创造者，<br>匍匐在最下面的飞得最高，<br>全是痛苦，全部都是痛苦。<br>那些与我耳语者，个个聪明无比，<br>他们说智慧来自痛苦，他们说：<br>来，给你智慧之路。<br>哦，每一个坐过山车的人<br>都是过山车建造厂的工人，<br>每一双手都充满智慧，是痛苦的<br>工艺匠。他们也制造不同的心灵，<br>这些心灵里孕育着奖励，<br>那些渴望奖励的人，那些最智慧的人，<br>他们总在沉默，不停地被从过山车上<br>推下去，在空中飘荡，在飘荡中，<br>我们接吻，就像那些恋人，<br>那些被压缩在词典册页中的爱情故事，<br>还有家庭，人间的互相拯救。<br>如果存在一个空间，漂浮着<br>无数列过山车，痛苦的过山车…… </p><p>——马雁：《我们乘坐着过山车飞向未来》</p></blockquote><p>&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。<br>&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。<br>&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。<br>&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。<br>&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。<br>&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。<br>&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
