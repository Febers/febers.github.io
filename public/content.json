{"meta":{"title":"ReBE","subtitle":"Febers的博客","description":null,"author":"Febers","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2019-01-11T16:43:43.000Z","updated":"2019-01-11T16:44:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"翻越GFW记","slug":"翻越GFW记","date":"2019-01-12T15:31:31.000Z","updated":"2019-01-13T05:39:30.000Z","comments":true,"path":"翻越GFW记/","link":"","permalink":"http://yoursite.com/翻越GFW记/","excerpt":"前言GFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录GFW所为何物，以及翻的原理。","text":"前言GFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录GFW所为何物，以及翻的原理。 GFW所为何物GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 形象的描述，在没有 GFW 的时代，访问互联网的方式如下 GFW 出现之后，则变成 其内部构造如下 它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。 GFW的具体原理可以查看此文章：全面学习GFW 如何工作关键字过滤阻断关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。 IP地址封锁路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。 DNS污染、劫持DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 DNS劫持和污染的方式有两种： 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。 值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：中国防火长城-污染攻击大事记。 除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。 翻越记翻修改Hosts文件足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。 Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。 所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS 污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。 SSH TunnelSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1) 用户通过建立起的隧道进行代理，通过 SSH Server 向真实的服务发起请求 (2-3) 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5) 由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。 VPN对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。 VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。 VPN 的特点如下： VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。 VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。 ShadowsocksVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。 技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。 相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。 Shadowsocks-R虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。 作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。 v2rayv2ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。 记 1998年，公安部在全国公安机关开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。 2004年，维基百科遭遇网络封锁。 2008年，北京奥运会期间，中国政府放宽了GFW的封锁范围。 2010年，Google公司因内容审查问题与中国政府交涉无效后，退出中国。 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，删除代码，表示不再参与开发。 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。 结语从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。 翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。 本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。","categories":[{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/categories/互联网/"}],"tags":[]},{"title":"LeetCode：最长回文子串（Longest Palindromic Substring）的解法","slug":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法","date":"2019-01-12T06:32:23.000Z","updated":"2019-01-13T05:41:52.000Z","comments":true,"path":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/","link":"","permalink":"http://yoursite.com/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/","excerpt":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 Input: “babcd”Output: “bab”","text":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 Input: “babcd”Output: “bab” 本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。 O(n^3)算法思路 从最长的子串开始，遍历所有该原字符串的子串； 每找出一个字符串，就判断该字符串是否为回文； 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。 时间复杂度 遍历字符串子串：嵌套一个循环：O(n^2)； 判断是否为回文：再次嵌套一个循环：O(n^3)。 代码1234567891011121314151617public static String longestPalindrome(String s) &#123; if(s.length() &lt;= 1) return s; for(int i = s.length();i &gt; 0; i--) &#123;//子串长度 for(int j = 0; j &lt;= s.length() - i; j++) &#123; String sub = s.substring(j , i + j);//子串位置 int count = 0;//计数，用来判断是否对称 for (int k = 0; k &lt; sub.length() / 2; k++) &#123;//左右对称判断 if (sub.charAt(k) == sub.charAt(sub.length() - k - 1)) count++; &#125; if (count == sub.length() / 2) return sub; &#125; &#125; return \"\";//表示字符串中无回文子串&#125; O(n^2)算法思路 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数； 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）； 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的； 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。 时间复杂度 遍历字符：一层循环——O(n-1)； 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2) 代码12345678910111213141516171819202122232425262728private static int maxLen = 0;private static String sub = \"\";public static String longestPalindrome(String s) &#123; if(s.length() &lt;= 1) return s; for(int i = 0;i &lt; s.length()-1;i++)&#123; findLongestPalindrome(s,i,i);//单核回文 findLongestPalindrome(s,i,i+1);//双核回文 &#125; return sub;&#125;public static void findLongestPalindrome(String s,int low,int high) &#123; while (low &gt;= 0 &amp;&amp; high &lt;= s.length()-1)&#123; if(s.charAt(low) == s.charAt(high))&#123; if(high - low + 1 &gt; maxLen)&#123; maxLen = high - low + 1; sub = s.substring(low , high+1); &#125; low --;//向两边扩散找当前字符为中心的最大回文子串 high ++; &#125; else break; &#125;&#125; O(n)算法——Manacher算法思路Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以＃号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如： a -&gt; #a#abaf -&gt; #a#b#a#f# 可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。 借助两个变量center、right分别记录回文子串对应的中心点和右端点 可以直接看出，right就是2*center-i（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;反之，就只能从1个长度开始匹配了，就是下面的这行代码: 1r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1 这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。 时间复杂度只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。 代码12345678910111213141516171819202122232425262728293031323334353637383940public static String longestPalindrome(String s) &#123; if(s == null || s.length() &lt; 1) &#123; return s; &#125; StringBuilder builder = new StringBuilder(); // 防止左端点越界 builder.append(\"&amp;#\"); char[] c = s.toCharArray(); for (char a : c) &#123; builder.append(a).append(\"#\"); &#125; String newStr = builder.toString(); c = newStr.toCharArray(); // 回文半径 int[] r = new int[newStr.length()]; // 回文子串最大右端点、中心点 int right=0, center=0; // 最大回文半径、最大中心点 int maxR=0, maxC=0; for (int i=1;i &lt; c.length;i++) &#123; // 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径 r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1; while (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123; ++r[i]; &#125; // 更新右端点和中心点 if (right &lt; i+r[i]) &#123; right = i+r[i]; center = i; &#125; // 更新最大半径和最大中心点 if (maxR &lt; r[i]) &#123; maxR = r[i]; maxC = i; &#125; &#125; //计算在原字符串中的起始点 int start = (maxC-maxR)/2; return s.substring(start, start+maxR-1);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[]},{"title":"Github Pages+Hexo搭建个人博客","slug":"Github-Pages-Hexo搭建个人博客","date":"2019-01-11T15:22:07.000Z","updated":"2019-01-13T05:42:42.000Z","comments":true,"path":"Github-Pages-Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/Github-Pages-Hexo搭建个人博客/","excerpt":"引言&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。","text":"引言&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。 &emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。 准备工作Github Pages&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为{账户名}.github.io，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：https://{账户名}.github.io便可以看到缺省的界面。 Hexo&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下： 安装Git客户端，前往Git主页下载，安装后登录帐号。 安装Node.js环境，前往Node主页下载。 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令： 1npm install -g hexo-cli 初始化Hexo，projectname省略时，要求当前文件夹为空。 1hexo init [projectname] 关联&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。在博客的文件夹中有_config.yml文件，为Hexo的配置文件，打开并将相应位置设置为：1234deploy: type: gitrepo: 该处填写仓库的完整路径branch: master 该过程其实是给hexo d这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。保存文件之后，安装Git部署插件，在Git Bash中键入命令：1npm install hexo-deployer-git --save 接下来就是清除hexo缓存：1hexo clean 生成静态文件1hexo g 部署网站，d的意思是deploy 1hexo d 后两个命令可以合并为一条，关于Hexo的命令请访问：Hexo指令。 1hexo g -d &emsp;&emsp;至此，博客已经搭建完毕，浏览器键入https://{账户名}.github.io，发现打开了一个使用Hexo搭建的Github Pages博客。 配置&emsp;&emsp;博客文件夹下的_config.yml文件可以配置整个博客的名称、主题等基本功能，/theme/文件夹下的_config.yml文件则用于配置具体的主题配置。 发表与删除&emsp;&emsp;在博客文件夹打开Git Bash，键入 1hexo n &quot;文章的标题&quot; 之后便会生成一个md文件，在md文件中编辑文章保存，然后键入hexo g -d便会发布文章。 &emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。 主题&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：有哪些好看的 Hexo主题。笔者使用的是NexT。 &emsp;&emsp;在博客文件夹下的_config.yml文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客_config.yml文件的更改，保存片刻即生效。 域名绑定&emsp;&emsp;具体过程如下： 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，{账户名}.github.io的IP地址，还有一个的记录类型为CNAME，记录值为：{账户名}.github.io。 进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。 进入博客文件夹中的/source/，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为所有文件，名称为CNAME。 备份与恢复&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。 备份&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下: 新建一个分支，如hexo，并将其设置为默认 本地clone你的Github Pages仓库，得到一个io文件夹：{账户名}.github.io的文件夹。 将原来博客文件夹中的_config.yml，themes/，source/，scffolds/，package.json，.gitignore复制到clone下来的文件夹，注意要将theme/主题的.git/删除。 在clone下的文件夹执行npm install，npm install hexo-deployer-git。 此时{账户名}.github.io文件夹已经成为包含你博客所有文件的工作文件夹，在部署(hexo g -d)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:123git add .git commit -m &quot;更新源文件&quot;git push origin hexo 这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。 恢复&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下: clone你的Github Pages仓库，得到一个io文件夹。 在文件夹中打开Git Bash，键入以下命令:123npm install hexo-cli -gnpm install npm install hexo-deployer-git 现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。 Hexo各文件（夹）说明 _config.yml：站点的配置文件，备份过程中需要拷贝； themes/：主题文件夹，需要拷贝； source：博客文章的.md文件，需要拷贝； scaffolds/：文章的模板，需要拷贝； package.json：安装包的名称，需要拷贝； .gitignore：限定在push时哪些文件可以忽略，需要拷贝； .git/：主题和站点都有，标志这是一个git项目，不需要拷贝； node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； public：hexo g生成的静态网页，不需要拷贝； .deploy_git：同上，hexo g也会生成，不需要拷贝； db.json：文件，不需要拷贝。","categories":[{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/categories/互联网/"}],"tags":[]},{"title":"坐过山车的人","slug":"坐过山车的人","date":"2019-01-10T09:57:55.000Z","updated":"2019-01-11T16:31:30.000Z","comments":true,"path":"坐过山车的人/","link":"","permalink":"http://yoursite.com/坐过山车的人/","excerpt":"&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。","text":"&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。 我们乘坐过山车飞向未来，他和我的手里各捏着一张票，那是飞向未来的小舢板，起伏的波浪是我无畏的想象力。乘坐我的想象力，他们尽情蹂躏这些无辜的女孩和男孩，这些无辜的小狗和小猫。在波浪之下，在波浪的下面一直匍匐着衰弱的故事人，他曾经是最伟大的创造者，匍匐在最下面的飞得最高，全是痛苦，全部都是痛苦。那些与我耳语者，个个聪明无比，他们说智慧来自痛苦，他们说：来，给你智慧之路。哦，每一个坐过山车的人都是过山车建造厂的工人，每一双手都充满智慧，是痛苦的工艺匠。他们也制造不同的心灵，这些心灵里孕育着奖励，那些渴望奖励的人，那些最智慧的人，他们总在沉默，不停地被从过山车上推下去，在空中飘荡，在飘荡中，我们接吻，就像那些恋人，那些被压缩在词典册页中的爱情故事，还有家庭，人间的互相拯救。如果存在一个空间，漂浮着无数列过山车，痛苦的过山车…… ——马雁：《我们乘坐着过山车飞向未来》 &emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}