{"meta":{"title":"ReBE","subtitle":"Febers的博客","description":null,"author":"Febers","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2019-01-11T16:43:43.000Z","updated":"2019-01-11T16:44:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode：最长回文子串（Longest Palindromic Substring）的解法","slug":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法","date":"2019-01-12T06:32:23.000Z","updated":"2019-01-12T10:28:00.000Z","comments":true,"path":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/","link":"","permalink":"http://yoursite.com/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/","excerpt":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 12Input: &quot;babcd&quot;Output: &quot;bab&quot;","text":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 12Input: &quot;babcd&quot;Output: &quot;bab&quot; 本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。 O(n^3)算法思路 从最长的子串开始，遍历所有该原字符串的子串； 每找出一个字符串，就判断该字符串是否为回文； 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。 时间复杂度 遍历字符串子串：嵌套一个循环：O(n^2)； 判断是否为回文：再次嵌套一个循环：O(n^3)。 代码1234567891011121314151617public static String longestPalindrome(String s) &#123; if(s.length() &lt;= 1) return s; for(int i = s.length();i &gt; 0; i--) &#123;//子串长度 for(int j = 0; j &lt;= s.length() - i; j++) &#123; String sub = s.substring(j , i + j);//子串位置 int count = 0;//计数，用来判断是否对称 for (int k = 0; k &lt; sub.length() / 2; k++) &#123;//左右对称判断 if (sub.charAt(k) == sub.charAt(sub.length() - k - 1)) count++; &#125; if (count == sub.length() / 2) return sub; &#125; &#125; return &quot;&quot;;//表示字符串中无回文子串&#125; O(n^2)算法思路 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数； 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）； 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的； 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。 时间复杂度 遍历字符：一层循环——O(n-1)； 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2) 代码12345678910111213141516171819202122232425262728private static int maxLen = 0;private static String sub = &quot;&quot;;public static String longestPalindrome(String s) &#123; if(s.length() &lt;= 1) return s; for(int i = 0;i &lt; s.length()-1;i++)&#123; findLongestPalindrome(s,i,i);//单核回文 findLongestPalindrome(s,i,i+1);//双核回文 &#125; return sub;&#125;public static void findLongestPalindrome(String s,int low,int high) &#123; while (low &gt;= 0 &amp;&amp; high &lt;= s.length()-1)&#123; if(s.charAt(low) == s.charAt(high))&#123; if(high - low + 1 &gt; maxLen)&#123; maxLen = high - low + 1; sub = s.substring(low , high+1); &#125; low --;//向两边扩散找当前字符为中心的最大回文子串 high ++; &#125; else break; &#125;&#125; O(n)算法——Manacher算法思路Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以＃号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：12a -&gt; #a# abaf -&gt; #a#b#a#f# 可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。 借助两个变量center、right分别记录回文子串对应的中心点和右端点 可以直接看出，right就是2*center-i（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;反之，就只能从1个长度开始匹配了，就是下面的这行代码: 1r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1 这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。 时间复杂度只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。 代码12345678910111213141516171819202122232425262728293031323334353637383940public static String longestPalindrome(String s) &#123; if(s == null || s.length() &lt; 1) &#123; return s; &#125; StringBuilder builder = new StringBuilder(); // 防止左端点越界 builder.append(&quot;&amp;#&quot;); char[] c = s.toCharArray(); for (char a : c) &#123; builder.append(a).append(&quot;#&quot;); &#125; String newStr = builder.toString(); c = newStr.toCharArray(); // 回文半径 int[] r = new int[newStr.length()]; // 回文子串最大右端点、中心点 int right=0, center=0; // 最大回文半径、最大中心点 int maxR=0, maxC=0; for (int i=1;i &lt; c.length;i++) &#123; // 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径 r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1; while (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123; ++r[i]; &#125; // 更新右端点和中心点 if (right &lt; i+r[i]) &#123; right = i+r[i]; center = i; &#125; // 更新最大半径和最大中心点 if (maxR &lt; r[i]) &#123; maxR = r[i]; maxC = i; &#125; &#125; // 计算在原字符串中的起始点 int start = (maxC-maxR)/2; return s.substring(start, start+maxR-1);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[]},{"title":"Github Pages+Hexo搭建个人博客","slug":"Github-Pages-Hexo搭建个人博客","date":"2019-01-11T15:22:07.000Z","updated":"2019-01-12T09:14:36.000Z","comments":true,"path":"Github-Pages-Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/Github-Pages-Hexo搭建个人博客/","excerpt":"引言&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。","text":"引言&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。 &emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。 准备工作Github Pages&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为{账户名}.github.io，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：https://{账户名}.github.io便可以看到缺省的界面。 Hexo&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下： 安装Git客户端，前往Git主页下载，安装后登录帐号。 安装Node.js环境，前往Node主页下载。 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令： 1npm install -g hexo-cli 初始化Hexo，projectname省略时，要求当前文件夹为空。 1hexo init [projectname] 关联&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。在博客的文件夹中有_config.yml文件，为Hexo的配置文件，打开并将相应位置设置为：1234deploy: type: gitrepo: 该处填写仓库的完整路径branch: master 该过程其实是给hexo d这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。保存文件之后，安装Git部署插件，在Git Bash中键入命令：1npm install hexo-deployer-git --save 接下来就是清除hexo缓存：1hexo clean 生成静态文件1hexo g 部署网站，d的意思是deploy 1hexo d 后两个命令可以合并为一条，关于Hexo的命令请访问：Hexo指令。 1hexo g -d &emsp;&emsp;至此，博客已经搭建完毕，浏览器键入https://{账户名}.github.io，发现打开了一个使用Hexo搭建的Github Pages博客。 配置&emsp;&emsp;博客文件夹下的_config.yml文件可以配置整个博客的名称、主题等基本功能，/theme/文件夹下的_config.yml文件则用于配置具体的主题配置。 发表与删除&emsp;&emsp;在博客文件夹打开Git Bash，键入 1hexo n &quot;文章的标题&quot; 之后便会生成一个md文件，在md文件中编辑文章保存，然后键入hexo g -d便会发布文章。 &emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。 主题&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：有哪些好看的 Hexo主题。笔者使用的是NexT。 &emsp;&emsp;在博客文件夹下的_config.yml文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客_config.yml文件的更改，保存片刻即生效。 域名绑定&emsp;&emsp;具体过程如下： 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，{账户名}.github.io的IP地址，还有一个的记录类型为CNAME，记录值为：{账户名}.github.io。 进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。 进入博客文件夹中的/source/，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为所有文件，名称为CNAME。 备份与恢复&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。 备份&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下: 新建一个分支，如hexo，并将其设置为默认 本地clone你的Github Pages仓库，得到一个io文件夹：{账户名}.github.io的文件夹。 将原来博客文件夹中的_config.yml，themes/，source/，scffolds/，package.json，.gitignore复制到clone下来的文件夹，注意要将theme/主题的.git/删除。 在clone下的文件夹执行npm install，npm install hexo-deployer-git。 此时{账户名}.github.io文件夹已经成为包含你博客所有文件的工作文件夹，在部署(hexo g -d)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:123git add .git commit -m &quot;更新源文件&quot;git push origin hexo 这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。 恢复&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下: clone你的Github Pages仓库，得到一个io文件夹。 在文件夹中打开Git Bash，键入以下命令:123npm install hexo-cli -gnpm install npm install hexo-deployer-git 现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。 Hexo各文件（夹）说明 _config.yml：站点的配置文件，需要拷贝； themes/：主题文件夹，需要拷贝； source：博客文章的.md文件，需要拷贝； scaffolds/：文章的模板，需要拷贝； package.json：安装包的名称，需要拷贝； .gitignore：限定在push时哪些文件可以忽略，需要拷贝； .git/：主题和站点都有，标志这是一个git项目，不需要拷贝； node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； public：hexo g生成的静态网页，不需要拷贝； .deploy_git：同上，hexo g也会生成，不需要拷贝； db.json：文件，不需要拷贝。","categories":[{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/categories/互联网/"}],"tags":[]},{"title":"坐过山车的人","slug":"坐过山车的人","date":"2019-01-10T09:57:55.000Z","updated":"2019-01-11T16:31:30.000Z","comments":true,"path":"坐过山车的人/","link":"","permalink":"http://yoursite.com/坐过山车的人/","excerpt":"&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。","text":"&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。 我们乘坐过山车飞向未来，他和我的手里各捏着一张票，那是飞向未来的小舢板，起伏的波浪是我无畏的想象力。乘坐我的想象力，他们尽情蹂躏这些无辜的女孩和男孩，这些无辜的小狗和小猫。在波浪之下，在波浪的下面一直匍匐着衰弱的故事人，他曾经是最伟大的创造者，匍匐在最下面的飞得最高，全是痛苦，全部都是痛苦。那些与我耳语者，个个聪明无比，他们说智慧来自痛苦，他们说：来，给你智慧之路。哦，每一个坐过山车的人都是过山车建造厂的工人，每一双手都充满智慧，是痛苦的工艺匠。他们也制造不同的心灵，这些心灵里孕育着奖励，那些渴望奖励的人，那些最智慧的人，他们总在沉默，不停地被从过山车上推下去，在空中飘荡，在飘荡中，我们接吻，就像那些恋人，那些被压缩在词典册页中的爱情故事，还有家庭，人间的互相拯救。如果存在一个空间，漂浮着无数列过山车，痛苦的过山车…… ——马雁：《我们乘坐着过山车飞向未来》 &emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}