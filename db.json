{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1514806390000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1514806390000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1514806390000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1514806390000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1514806390000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1514806390000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1514806390000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1514806390000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1514806390000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1514806390000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1514806390000},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1514806390000},{"_id":"themes/next/_config.yml","hash":"a4d0ddcf7a1b470c2789edb60972c2a1ea74ef99","modified":1547224576000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1514806390000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1514806390000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1514806390000},{"_id":"source/_posts/Github-Pages-Hexo搭建个人博客.md","hash":"2cf61aff10c2954a2e614abe1b612668e403cb05","modified":1552354506000},{"_id":"source/_posts/Java设计模式：创建型模式.md","hash":"d9f703821440d54969cf0031a223ef64bf0f476a","modified":1552354506000},{"_id":"source/_posts/Java设计模式：结构型模式.md","hash":"d12b66af66841cf640bb09c1efe535ebcdc89cc5","modified":1552354506000},{"_id":"source/_posts/Java设计模式：行为型模式.md","hash":"56b06e68ea2ced452fc53ce19ad72344aba145e8","modified":1552401232000},{"_id":"source/_posts/LeakCanary源码解析.md","hash":"36e6e0dc58cdf67fac54ed407a58027cb381898d","modified":1552455254000},{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法.md","hash":"308102017258b14de6c045a132b213edab98ab27","modified":1547358112000},{"_id":"source/_posts/坐过山车的人.md","hash":"a8c6c5a5e228694f10e2ee5c3e7f831f52b6f776","modified":1547224290000},{"_id":"source/_posts/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》.md","hash":"c223dd8e407e2b1b91f0e7fb943e5585ba3ac37f","modified":1552354506000},{"_id":"source/_posts/翻越GFW记.md","hash":"d56c017ebb74613ae399f00402daed377e0e15b0","modified":1547358558000},{"_id":"source/categories/index.md","hash":"ec919064ec63dd78207bee18e4723073f9f0fb0f","modified":1547225098000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1514806390000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1514806390000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1514806390000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1514806390000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1514806390000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1514806390000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1514806390000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1514806390000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1514806390000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1514806390000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1514806390000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1514806390000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1514806390000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1514806390000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1514806390000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1514806390000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1514806390000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1514806390000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1514806390000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1514806390000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1514806390000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1514806390000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1514806390000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1514806390000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1514806390000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1514806390000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1514806390000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1514806390000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1514806390000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1514806390000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1514806390000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1514806390000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1514806390000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"source/_posts/Java设计模式：创建型模式/工厂方法.jpg","hash":"45d94d745f90e7cf75056fdd16728670d942a993","modified":1552354506000},{"_id":"source/_posts/Java设计模式：创建型模式/抽象工厂.jpg","hash":"e64d7c7297a60b86aa678a046f376e20f77a69cf","modified":1552354506000},{"_id":"source/_posts/Java设计模式：创建型模式/简单工厂.jpg","hash":"076bb6f2a96ac7086129a9f5f01a567b13cbe81c","modified":1552354506000},{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png","hash":"7008b7b5185e554ed4af858996d5a2c7f5433d5f","modified":1547287346000},{"_id":"source/_posts/翻越GFW记/GFW内部结构.jpg","hash":"1b4b3287216eb9d2d543b6075630482b2c14a789","modified":1547352958000},{"_id":"source/_posts/翻越GFW记/GFW存在后的连接方式.png","hash":"6062a7474e26fd92ad2bbbcfa854409c64c621b9","modified":1547352940000},{"_id":"source/_posts/翻越GFW记/SSH连接方式.png","hash":"4613fcc1932182816aa1734354cca2e2e2f87fc7","modified":1547352970000},{"_id":"source/_posts/翻越GFW记/SS连接方式.png","hash":"5189639e3bb1beaa834d1cd2a10a113858015410","modified":1547352980000},{"_id":"source/_posts/翻越GFW记/原始连接方式.png","hash":"a18e72d5ed67fbaddc9736039df9c7168fd98544","modified":1547352922000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806390000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806390000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1514806390000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1514806390000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1514806390000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1514806390000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1514806390000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1514806390000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1514806390000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1514806390000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1514806390000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1514806390000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1514806390000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1514806390000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1514806390000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1514806390000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1514806390000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1514806390000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1514806390000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1514806390000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1514806390000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1514806390000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1514806390000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1514806390000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1514806390000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1514806390000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1514806390000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1514806390000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1514806390000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1514806390000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1514806390000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1514806390000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1514806390000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1514806390000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1514806390000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514806390000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1514806390000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1514806390000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1514806390000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1514806390000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514806390000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514806390000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806390000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1514806390000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806390000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1514806390000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1514806390000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514806390000},{"_id":"source/_posts/Java设计模式：创建型模式/设计模式之间的关系.jpg","hash":"5533c4baa4a9ee3e2315d805f40f42fe7d4af6ce","modified":1552354506000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1514806390000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1514806390000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1514806390000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1514806390000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1514806390000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1514806390000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806390000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1514806390000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1514806390000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1514806390000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1514806390000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514806390000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514806390000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514806390000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514806390000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514806390000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514806390000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1514806390000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514806390000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514806390000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514806390000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1514806390000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514806390000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514806390000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1514806390000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514806390000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514806390000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514806390000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514806390000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514806390000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514806390000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514806390000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1514806390000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1514806390000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514806390000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514806390000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514806390000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514806390000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1514806390000},{"_id":"public/atom.xml","hash":"64ea39d0bfa0d56562addf89e2709bf57bc0b1a9","modified":1552455363250},{"_id":"public/content.json","hash":"023d4e5b456063dd889aeed9ba7e3c91e68c032a","modified":1552455363250},{"_id":"public/sitemap.xml","hash":"87652d001ef5a2248e956810c696828be9333413","modified":1552455363255},{"_id":"public/categories/index.html","hash":"2cbbc1f0400822084c607b613bb95e47a88841cf","modified":1552455363420},{"_id":"public/categories/互联网/index.html","hash":"bbcf3987ee3460ebbe1f0f2e133ec514cab12064","modified":1552455363420},{"_id":"public/categories/Java/index.html","hash":"82601f2a7f464d8fc38bdf0a3c964bcca51aeab6","modified":1552455363421},{"_id":"public/categories/随笔/index.html","hash":"956c65aabd90ae410dbdd2782c73a61a351a36e4","modified":1552455363421},{"_id":"public/categories/算法/index.html","hash":"5da2e21d2c020474015e7bdb1892d8cf6aa7a9c3","modified":1552455363421},{"_id":"public/categories/艺术/index.html","hash":"caa99ec6e2c2e4eece34d275a53c8714737a01f8","modified":1552455363421},{"_id":"public/archives/index.html","hash":"6586a79d7bc87811aba2cd2453816944763ee000","modified":1552455363421},{"_id":"public/archives/2019/index.html","hash":"3c8e397ea1a45c6d2dd0751303950cc0709eb946","modified":1552455363421},{"_id":"public/archives/2019/01/index.html","hash":"a7f45c1e8a87d292b88685058d293b8b84690af3","modified":1552455363421},{"_id":"public/Java设计模式：创建型模式/index.html","hash":"eccb19f15fb091d195c2ec1b530110561f053c3f","modified":1552455363421},{"_id":"public/Java设计模式：结构型模式/index.html","hash":"9aa3c1272715806378a645c0ffc61c606bee5be4","modified":1552455363421},{"_id":"public/Java设计模式：行为型模式/index.html","hash":"795f9b7904d15d0a9577a52b61d1464dbd2a23df","modified":1552455363422},{"_id":"public/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》/index.html","hash":"cef91c24c4d80549eb92d9d382d46555de0eedea","modified":1552455363422},{"_id":"public/翻越GFW记/index.html","hash":"79d7f84d61cc94e3cbc308cf073ddd6a1992c72f","modified":1552455363422},{"_id":"public/Github-Pages-Hexo搭建个人博客/index.html","hash":"e66f47d18118c1c37c8ee096494555cde89fcdef","modified":1552455363422},{"_id":"public/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/index.html","hash":"ce25a9a156847aa08e96f60cbf2d3d6d44540811","modified":1552455363422},{"_id":"public/坐过山车的人/index.html","hash":"2bddd433ba14dbbf4a5653f9ccb1ce1c1738b673","modified":1552455363422},{"_id":"public/index.html","hash":"f87c49ca31452427c6d0a00bd63aee80ceddd403","modified":1552455363422},{"_id":"public/categories/Android/index.html","hash":"315bca443cb015441b136deec2a7627b80718474","modified":1552455363427},{"_id":"public/archives/2019/03/index.html","hash":"3beb44cf37807fac74239671baa0541e8a02c74d","modified":1552455363427},{"_id":"public/LeakCanary源码解析/index.html","hash":"a80692a52000409ad5ed82a2878947923a070f5c","modified":1552455363427},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1552455363427},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1552455363427},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1552455363427},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1552455363427},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1552455363427},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1552455363427},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1552455363427},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1552455363427},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1552455363427},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1552455363427},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1552455363427},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1552455363428},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1552455363428},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1552455363428},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1552455363428},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1552455363428},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1552455363428},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1552455363428},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1552455363428},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1552455363428},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1552455363428},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1552455363428},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1552455363428},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1552455363429},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1552455363429},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1552455363429},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1552455363953},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1552455363957},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1552455363959},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1552455363959},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1552455363959},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1552455363959},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1552455363959},{"_id":"public/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png","hash":"7008b7b5185e554ed4af858996d5a2c7f5433d5f","modified":1552455363959},{"_id":"public/Java设计模式：创建型模式/抽象工厂.jpg","hash":"e64d7c7297a60b86aa678a046f376e20f77a69cf","modified":1552455363959},{"_id":"public/翻越GFW记/GFW存在后的连接方式.png","hash":"6062a7474e26fd92ad2bbbcfa854409c64c621b9","modified":1552455363960},{"_id":"public/翻越GFW记/GFW内部结构.jpg","hash":"1b4b3287216eb9d2d543b6075630482b2c14a789","modified":1552455363960},{"_id":"public/翻越GFW记/SSH连接方式.png","hash":"4613fcc1932182816aa1734354cca2e2e2f87fc7","modified":1552455363960},{"_id":"public/翻越GFW记/SS连接方式.png","hash":"5189639e3bb1beaa834d1cd2a10a113858015410","modified":1552455363960},{"_id":"public/翻越GFW记/原始连接方式.png","hash":"a18e72d5ed67fbaddc9736039df9c7168fd98544","modified":1552455363960},{"_id":"public/Java设计模式：创建型模式/简单工厂.jpg","hash":"076bb6f2a96ac7086129a9f5f01a567b13cbe81c","modified":1552455363960},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1552455363967},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1552455363967},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1552455363968},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1552455363968},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1552455363968},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1552455363968},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1552455363968},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1552455363968},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1552455363968},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1552455363968},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1552455363968},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1552455363968},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1552455363969},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1552455363969},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1552455363969},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1552455363969},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1552455363969},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1552455363969},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1552455363969},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1552455363969},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1552455363969},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1552455363969},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1552455363969},{"_id":"public/css/main.css","hash":"245d6d08ab0e6ee0ebaebd98e3a36e635c6511f9","modified":1552455363969},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1552455363969},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1552455363970},{"_id":"public/Java设计模式：创建型模式/工厂方法.jpg","hash":"45d94d745f90e7cf75056fdd16728670d942a993","modified":1552455363970},{"_id":"public/Java设计模式：创建型模式/设计模式之间的关系.jpg","hash":"5533c4baa4a9ee3e2315d805f40f42fe7d4af6ce","modified":1552455363970},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1552455363971},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1552455363971},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1552455363972},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1552455363972},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1552455363972},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1552455363972},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1552455363972},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1552455363972},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1552455363972},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1552455363972},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1552455363973},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1552455363973},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1552455363973},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1552455363973},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1552455363973},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1552455363974},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1552455363974},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1552455363974},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1552455363974},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1552455364000},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1552455364016},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1552455364016},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1552455364016},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1552455364016},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1552455364016},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1552455364016},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1552455364016},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1552455364016},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1552455364033},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1552455364033},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1552455364033},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1552455364043},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1552455364043},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1552455364047},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1552455364047},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1552455364047},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1552455364050},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1552455364055},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1552455364057}],"Category":[{"name":"互联网","_id":"cjt6ru73p0003f0u8ir1jx1qo"},{"name":"Java","_id":"cjt6ru73t0006f0u8yhbn6647"},{"name":"随笔","_id":"cjt6ru73u0008f0u8idkv16e6"},{"name":"算法","_id":"cjt6ru73v000af0u8asuebrg1"},{"name":"Android","_id":"cjt6ru78w000if0u8udsfh5un"},{"name":"艺术","_id":"cjt6ru78z000lf0u89j8njy64"}],"Data":[],"Page":[{"title":"categories","date":"2019-01-11T16:43:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-01-12 00:43:43\ntype: \"categories\"\n---\n","updated":"2019-01-11T16:44:58.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjt6ru73m0001f0u8jved8nfz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Github Pages+Hexo搭建个人博客","date":"2019-01-11T15:22:07.000Z","_content":"\n## 引言\n\n&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<!--more-->\n\n&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。\n\n## 准备工作\n\n### Github Pages\n\n&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为`{账户名}.github.io`，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：`https://{账户名}.github.io`便可以看到缺省的界面。\n\n### Hexo\n\n&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：\n- 安装Git客户端，前往Git主页下载，安装后登录帐号。\n- 安装Node.js环境，前往Node主页下载。\n- 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：\n```\nnpm install -g hexo-cli\n```\n\n- 初始化Hexo，`projectname`省略时，要求当前文件夹为空。\n```\nhexo init [projectname]\n```\n\n## 关联\n\n&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。\n在博客的文件夹中有`_config.yml`文件，为Hexo的配置文件，打开并将相应位置设置为：\n```\ndeploy: \ntype: git\nrepo: 该处填写仓库的完整路径\nbranch: master\n```\n该过程其实是给`hexo d`这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。\n保存文件之后，安装Git部署插件，在Git Bash中键入命令：\n```\nnpm install hexo-deployer-git --save\n```\n\n接下来就是清除hexo缓存：\n```\nhexo clean \n```\n\n生成静态文件\n```\nhexo g\n```\n\n部署网站，d的意思是deploy\n\n```\nhexo d\n```\n\n后两个命令可以合并为一条，关于Hexo的命令请访问：[Hexo指令](https://hexo.io/zh-cn/docs/commands.html)。\n\n```\nhexo g -d\n```\n\n&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入`https://{账户名}.github.io`，发现打开了一个使用Hexo搭建的Github Pages博客。\n\n## 配置\n\n&emsp;&emsp;博客文件夹下的`_config.yml`文件可以配置整个博客的名称、主题等基本功能，`/theme/`文件夹下的`_config.yml`文件则用于配置具体的主题配置。\n\n### 发表与删除\n\n&emsp;&emsp;在博客文件夹打开Git Bash，键入\n\n```\nhexo n \"文章的标题\"\n```\n\n之后便会生成一个md文件，在md文件中编辑文章保存，然后键入`hexo g -d`便会发布文章。\n\n&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。\n\n### 主题\n\n&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：[有哪些好看的 Hexo主题](https://www.zhihu.com/question/24422335)。笔者使用的是[NexT](https://github.com/iissnan/hexo-theme-next)。\n\n&emsp;&emsp;在博客文件夹下的`_config.yml`文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客`_config.yml`文件的更改，保存片刻即生效。\n\n### 域名绑定\n\n&emsp;&emsp;具体过程如下：\n- 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，`{账户名}.github.io`的IP地址，还有一个的记录类型为`CNAME`，记录值为：`{账户名}.github.io`。\n- 进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。\n- 进入博客文件夹中的`/source/`，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为**所有文件**，名称为**CNAME**。\n\n## 备份与恢复\n\n&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。\n\n### 备份\n\n&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:\n- 新建一个分支，如hexo，并将其设置为默认\n- 本地clone你的Github Pages仓库，得到一个io文件夹：`{账户名}.github.io`的文件夹。\n- 将原来博客文件夹中的`_config.yml，themes/，source/，scffolds/，package.json，.gitignore`复制到clone下来的文件夹，注意要将`theme/`主题的`.git/`删除。\n- 在clone下的文件夹执行`npm install`，`npm install hexo-deployer-git`。\n\n此时`{账户名}.github.io`文件夹已经成为包含你博客所有文件的工作文件夹，在部署(`hexo g -d`)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:\n```\ngit add .\ngit commit -m \"更新源文件\"\ngit push origin hexo\n```\n\n这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。\n\n### 恢复\n\n&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:\n- clone你的Github Pages仓库，得到一个io文件夹。\n- 在文件夹中打开Git Bash，键入以下命令:\n```\nnpm install hexo-cli -g\nnpm install \nnpm install hexo-deployer-git \n```\n现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。\n\n如果在拉取过程中提示本地分支与远程仓库冲突，可以使用`git reset --hard`命令重置之后再次pull。如果提示\n> The following untracked working tree files would be overwritten by merge\n\n可以使用`git clean -d -fx`，关于该命令\n\n> $ git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。\n$ git clean -f            //该命令会移除所有上一条命令中显示的文件。\n$ git clean -fd           //移除文件夹，使用选项-d。\n$ git clean -fX           //只想移除已被忽略的文件，使用选项-X。\n$ git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。\n\n## Hexo各文件（夹）说明\n\n- _config.yml：站点的配置文件，备份过程中需要拷贝；\n- themes/：主题文件夹，需要拷贝；\n- source：博客文章的.md文件，需要拷贝；\n- scaffolds/：文章的模板，需要拷贝；\n- package.json：安装包的名称，需要拷贝；\n-  .gitignore：限定在push时哪些文件可以忽略，需要拷贝；\n-  .git/：主题和站点都有，标志这是一个git项目，不需要拷贝；\n- node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；\n- public：hexo g生成的静态网页，不需要拷贝；\n-  .deploy_git：同上，hexo g也会生成，不需要拷贝；\n- db.json：文件，不需要拷贝。","source":"_posts/Github-Pages-Hexo搭建个人博客.md","raw":"---\ntitle: Github Pages+Hexo搭建个人博客\ndate: 2019-01-11 23:22:07\ncategories: \n- 互联网\n---\n\n## 引言\n\n&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<!--more-->\n\n&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。\n\n## 准备工作\n\n### Github Pages\n\n&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为`{账户名}.github.io`，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：`https://{账户名}.github.io`便可以看到缺省的界面。\n\n### Hexo\n\n&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：\n- 安装Git客户端，前往Git主页下载，安装后登录帐号。\n- 安装Node.js环境，前往Node主页下载。\n- 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：\n```\nnpm install -g hexo-cli\n```\n\n- 初始化Hexo，`projectname`省略时，要求当前文件夹为空。\n```\nhexo init [projectname]\n```\n\n## 关联\n\n&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。\n在博客的文件夹中有`_config.yml`文件，为Hexo的配置文件，打开并将相应位置设置为：\n```\ndeploy: \ntype: git\nrepo: 该处填写仓库的完整路径\nbranch: master\n```\n该过程其实是给`hexo d`这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。\n保存文件之后，安装Git部署插件，在Git Bash中键入命令：\n```\nnpm install hexo-deployer-git --save\n```\n\n接下来就是清除hexo缓存：\n```\nhexo clean \n```\n\n生成静态文件\n```\nhexo g\n```\n\n部署网站，d的意思是deploy\n\n```\nhexo d\n```\n\n后两个命令可以合并为一条，关于Hexo的命令请访问：[Hexo指令](https://hexo.io/zh-cn/docs/commands.html)。\n\n```\nhexo g -d\n```\n\n&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入`https://{账户名}.github.io`，发现打开了一个使用Hexo搭建的Github Pages博客。\n\n## 配置\n\n&emsp;&emsp;博客文件夹下的`_config.yml`文件可以配置整个博客的名称、主题等基本功能，`/theme/`文件夹下的`_config.yml`文件则用于配置具体的主题配置。\n\n### 发表与删除\n\n&emsp;&emsp;在博客文件夹打开Git Bash，键入\n\n```\nhexo n \"文章的标题\"\n```\n\n之后便会生成一个md文件，在md文件中编辑文章保存，然后键入`hexo g -d`便会发布文章。\n\n&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。\n\n### 主题\n\n&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：[有哪些好看的 Hexo主题](https://www.zhihu.com/question/24422335)。笔者使用的是[NexT](https://github.com/iissnan/hexo-theme-next)。\n\n&emsp;&emsp;在博客文件夹下的`_config.yml`文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客`_config.yml`文件的更改，保存片刻即生效。\n\n### 域名绑定\n\n&emsp;&emsp;具体过程如下：\n- 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，`{账户名}.github.io`的IP地址，还有一个的记录类型为`CNAME`，记录值为：`{账户名}.github.io`。\n- 进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。\n- 进入博客文件夹中的`/source/`，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为**所有文件**，名称为**CNAME**。\n\n## 备份与恢复\n\n&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。\n\n### 备份\n\n&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:\n- 新建一个分支，如hexo，并将其设置为默认\n- 本地clone你的Github Pages仓库，得到一个io文件夹：`{账户名}.github.io`的文件夹。\n- 将原来博客文件夹中的`_config.yml，themes/，source/，scffolds/，package.json，.gitignore`复制到clone下来的文件夹，注意要将`theme/`主题的`.git/`删除。\n- 在clone下的文件夹执行`npm install`，`npm install hexo-deployer-git`。\n\n此时`{账户名}.github.io`文件夹已经成为包含你博客所有文件的工作文件夹，在部署(`hexo g -d`)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:\n```\ngit add .\ngit commit -m \"更新源文件\"\ngit push origin hexo\n```\n\n这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。\n\n### 恢复\n\n&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:\n- clone你的Github Pages仓库，得到一个io文件夹。\n- 在文件夹中打开Git Bash，键入以下命令:\n```\nnpm install hexo-cli -g\nnpm install \nnpm install hexo-deployer-git \n```\n现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。\n\n如果在拉取过程中提示本地分支与远程仓库冲突，可以使用`git reset --hard`命令重置之后再次pull。如果提示\n> The following untracked working tree files would be overwritten by merge\n\n可以使用`git clean -d -fx`，关于该命令\n\n> $ git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。\n$ git clean -f            //该命令会移除所有上一条命令中显示的文件。\n$ git clean -fd           //移除文件夹，使用选项-d。\n$ git clean -fX           //只想移除已被忽略的文件，使用选项-X。\n$ git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。\n\n## Hexo各文件（夹）说明\n\n- _config.yml：站点的配置文件，备份过程中需要拷贝；\n- themes/：主题文件夹，需要拷贝；\n- source：博客文章的.md文件，需要拷贝；\n- scaffolds/：文章的模板，需要拷贝；\n- package.json：安装包的名称，需要拷贝；\n-  .gitignore：限定在push时哪些文件可以忽略，需要拷贝；\n-  .git/：主题和站点都有，标志这是一个git项目，不需要拷贝；\n- node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；\n- public：hexo g生成的静态网页，不需要拷贝；\n-  .deploy_git：同上，hexo g也会生成，不需要拷贝；\n- db.json：文件，不需要拷贝。","slug":"Github-Pages-Hexo搭建个人博客","published":1,"updated":"2019-03-12T01:35:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru73g0000f0u8ai6lqs2l","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<a id=\"more\"></a></p>\n<p>&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为<code>{账户名}.github.io</code>，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：<code>https://{账户名}.github.io</code>便可以看到缺省的界面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：</p>\n<ul>\n<li>安装Git客户端，前往Git主页下载，安装后登录帐号。</li>\n<li>安装Node.js环境，前往Node主页下载。</li>\n<li><p>安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化Hexo，<code>projectname</code>省略时，要求当前文件夹为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init [projectname]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h2><p>&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。<br>在博客的文件夹中有<code>_config.yml</code>文件，为Hexo的配置文件，打开并将相应位置设置为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy: </span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: 该处填写仓库的完整路径</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure></p>\n<p>该过程其实是给<code>hexo d</code>这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。<br>保存文件之后，安装Git部署插件，在Git Bash中键入命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>接下来就是清除hexo缓存：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure></p>\n<p>生成静态文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<p>部署网站，d的意思是deploy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>后两个命令可以合并为一条，关于Hexo的命令请访问：<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">Hexo指令</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入<code>https://{账户名}.github.io</code>，发现打开了一个使用Hexo搭建的Github Pages博客。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>&emsp;&emsp;博客文件夹下的<code>_config.yml</code>文件可以配置整个博客的名称、主题等基本功能，<code>/theme/</code>文件夹下的<code>_config.yml</code>文件则用于配置具体的主题配置。</p>\n<h3 id=\"发表与删除\"><a href=\"#发表与删除\" class=\"headerlink\" title=\"发表与删除\"></a>发表与删除</h3><p>&emsp;&emsp;在博客文件夹打开Git Bash，键入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n &quot;文章的标题&quot;</span><br></pre></td></tr></table></figure>\n<p>之后便会生成一个md文件，在md文件中编辑文章保存，然后键入<code>hexo g -d</code>便会发布文章。</p>\n<p>&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：<a href=\"https://www.zhihu.com/question/24422335\" target=\"_blank\" rel=\"noopener\">有哪些好看的 Hexo主题</a>。笔者使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>。</p>\n<p>&emsp;&emsp;在博客文件夹下的<code>_config.yml</code>文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客<code>_config.yml</code>文件的更改，保存片刻即生效。</p>\n<h3 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h3><p>&emsp;&emsp;具体过程如下：</p>\n<ul>\n<li>需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，<code>{账户名}.github.io</code>的IP地址，还有一个的记录类型为<code>CNAME</code>，记录值为：<code>{账户名}.github.io</code>。</li>\n<li>进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。</li>\n<li>进入博客文件夹中的<code>/source/</code>，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为<strong>所有文件</strong>，名称为<strong>CNAME</strong>。</li>\n</ul>\n<h2 id=\"备份与恢复\"><a href=\"#备份与恢复\" class=\"headerlink\" title=\"备份与恢复\"></a>备份与恢复</h2><p>&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:</p>\n<ul>\n<li>新建一个分支，如hexo，并将其设置为默认</li>\n<li>本地clone你的Github Pages仓库，得到一个io文件夹：<code>{账户名}.github.io</code>的文件夹。</li>\n<li>将原来博客文件夹中的<code>_config.yml，themes/，source/，scffolds/，package.json，.gitignore</code>复制到clone下来的文件夹，注意要将<code>theme/</code>主题的<code>.git/</code>删除。</li>\n<li>在clone下的文件夹执行<code>npm install</code>，<code>npm install hexo-deployer-git</code>。</li>\n</ul>\n<p>此时<code>{账户名}.github.io</code>文件夹已经成为包含你博客所有文件的工作文件夹，在部署(<code>hexo g -d</code>)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;更新源文件&quot;</span><br><span class=\"line\">git push origin hexo</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:</p>\n<ul>\n<li>clone你的Github Pages仓库，得到一个io文件夹。</li>\n<li>在文件夹中打开Git Bash，键入以下命令:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install </span><br><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。</p>\n<p>如果在拉取过程中提示本地分支与远程仓库冲突，可以使用<code>git reset --hard</code>命令重置之后再次pull。如果提示</p>\n<blockquote>\n<p>The following untracked working tree files would be overwritten by merge</p>\n</blockquote>\n<p>可以使用<code>git clean -d -fx</code>，关于该命令</p>\n<blockquote>\n<p>$ git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。<br>$ git clean -f            //该命令会移除所有上一条命令中显示的文件。<br>$ git clean -fd           //移除文件夹，使用选项-d。<br>$ git clean -fX           //只想移除已被忽略的文件，使用选项-X。<br>$ git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。</p>\n</blockquote>\n<h2 id=\"Hexo各文件（夹）说明\"><a href=\"#Hexo各文件（夹）说明\" class=\"headerlink\" title=\"Hexo各文件（夹）说明\"></a>Hexo各文件（夹）说明</h2><ul>\n<li>_config.yml：站点的配置文件，备份过程中需要拷贝；</li>\n<li>themes/：主题文件夹，需要拷贝；</li>\n<li>source：博客文章的.md文件，需要拷贝；</li>\n<li>scaffolds/：文章的模板，需要拷贝；</li>\n<li>package.json：安装包的名称，需要拷贝；</li>\n<li>.gitignore：限定在push时哪些文件可以忽略，需要拷贝；</li>\n<li>.git/：主题和站点都有，标志这是一个git项目，不需要拷贝；</li>\n<li>node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li>\n<li>public：hexo g生成的静态网页，不需要拷贝；</li>\n<li>.deploy_git：同上，hexo g也会生成，不需要拷贝；</li>\n<li>db.json：文件，不需要拷贝。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。</p>","more":"<p></p>\n<p>&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为<code>{账户名}.github.io</code>，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：<code>https://{账户名}.github.io</code>便可以看到缺省的界面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：</p>\n<ul>\n<li>安装Git客户端，前往Git主页下载，安装后登录帐号。</li>\n<li>安装Node.js环境，前往Node主页下载。</li>\n<li><p>安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化Hexo，<code>projectname</code>省略时，要求当前文件夹为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init [projectname]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h2><p>&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。<br>在博客的文件夹中有<code>_config.yml</code>文件，为Hexo的配置文件，打开并将相应位置设置为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy: </span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: 该处填写仓库的完整路径</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure></p>\n<p>该过程其实是给<code>hexo d</code>这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。<br>保存文件之后，安装Git部署插件，在Git Bash中键入命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>接下来就是清除hexo缓存：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure></p>\n<p>生成静态文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<p>部署网站，d的意思是deploy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>后两个命令可以合并为一条，关于Hexo的命令请访问：<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">Hexo指令</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入<code>https://{账户名}.github.io</code>，发现打开了一个使用Hexo搭建的Github Pages博客。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>&emsp;&emsp;博客文件夹下的<code>_config.yml</code>文件可以配置整个博客的名称、主题等基本功能，<code>/theme/</code>文件夹下的<code>_config.yml</code>文件则用于配置具体的主题配置。</p>\n<h3 id=\"发表与删除\"><a href=\"#发表与删除\" class=\"headerlink\" title=\"发表与删除\"></a>发表与删除</h3><p>&emsp;&emsp;在博客文件夹打开Git Bash，键入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n &quot;文章的标题&quot;</span><br></pre></td></tr></table></figure>\n<p>之后便会生成一个md文件，在md文件中编辑文章保存，然后键入<code>hexo g -d</code>便会发布文章。</p>\n<p>&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：<a href=\"https://www.zhihu.com/question/24422335\" target=\"_blank\" rel=\"noopener\">有哪些好看的 Hexo主题</a>。笔者使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>。</p>\n<p>&emsp;&emsp;在博客文件夹下的<code>_config.yml</code>文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客<code>_config.yml</code>文件的更改，保存片刻即生效。</p>\n<h3 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h3><p>&emsp;&emsp;具体过程如下：</p>\n<ul>\n<li>需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，<code>{账户名}.github.io</code>的IP地址，还有一个的记录类型为<code>CNAME</code>，记录值为：<code>{账户名}.github.io</code>。</li>\n<li>进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。</li>\n<li>进入博客文件夹中的<code>/source/</code>，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为<strong>所有文件</strong>，名称为<strong>CNAME</strong>。</li>\n</ul>\n<h2 id=\"备份与恢复\"><a href=\"#备份与恢复\" class=\"headerlink\" title=\"备份与恢复\"></a>备份与恢复</h2><p>&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:</p>\n<ul>\n<li>新建一个分支，如hexo，并将其设置为默认</li>\n<li>本地clone你的Github Pages仓库，得到一个io文件夹：<code>{账户名}.github.io</code>的文件夹。</li>\n<li>将原来博客文件夹中的<code>_config.yml，themes/，source/，scffolds/，package.json，.gitignore</code>复制到clone下来的文件夹，注意要将<code>theme/</code>主题的<code>.git/</code>删除。</li>\n<li>在clone下的文件夹执行<code>npm install</code>，<code>npm install hexo-deployer-git</code>。</li>\n</ul>\n<p>此时<code>{账户名}.github.io</code>文件夹已经成为包含你博客所有文件的工作文件夹，在部署(<code>hexo g -d</code>)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;更新源文件&quot;</span><br><span class=\"line\">git push origin hexo</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:</p>\n<ul>\n<li>clone你的Github Pages仓库，得到一个io文件夹。</li>\n<li>在文件夹中打开Git Bash，键入以下命令:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install </span><br><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。</p>\n<p>如果在拉取过程中提示本地分支与远程仓库冲突，可以使用<code>git reset --hard</code>命令重置之后再次pull。如果提示</p>\n<blockquote>\n<p>The following untracked working tree files would be overwritten by merge</p>\n</blockquote>\n<p>可以使用<code>git clean -d -fx</code>，关于该命令</p>\n<blockquote>\n<p>$ git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。<br>$ git clean -f            //该命令会移除所有上一条命令中显示的文件。<br>$ git clean -fd           //移除文件夹，使用选项-d。<br>$ git clean -fX           //只想移除已被忽略的文件，使用选项-X。<br>$ git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。</p>\n</blockquote>\n<h2 id=\"Hexo各文件（夹）说明\"><a href=\"#Hexo各文件（夹）说明\" class=\"headerlink\" title=\"Hexo各文件（夹）说明\"></a>Hexo各文件（夹）说明</h2><ul>\n<li>_config.yml：站点的配置文件，备份过程中需要拷贝；</li>\n<li>themes/：主题文件夹，需要拷贝；</li>\n<li>source：博客文章的.md文件，需要拷贝；</li>\n<li>scaffolds/：文章的模板，需要拷贝；</li>\n<li>package.json：安装包的名称，需要拷贝；</li>\n<li>.gitignore：限定在push时哪些文件可以忽略，需要拷贝；</li>\n<li>.git/：主题和站点都有，标志这是一个git项目，不需要拷贝；</li>\n<li>node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li>\n<li>public：hexo g生成的静态网页，不需要拷贝；</li>\n<li>.deploy_git：同上，hexo g也会生成，不需要拷贝；</li>\n<li>db.json：文件，不需要拷贝。</li>\n</ul>"},{"title":"Java设计模式：行为型模式","date":"2019-01-20T16:57:00.000Z","_content":"\n## 责任链模式\n责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<!--more-->\n\n创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。\n\n```Java\nabstract class AbstractLogger {\n    public static int INFO = 1;\n    public static int DEBUG = 2;\n    public static int ERROR = 3;\n\n    protected int level;\n\n    //责任链中的下一个元素\n    protected AbstractLogger nextLogger;\n\n    public void setNextLogger(AbstractLogger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    public void logMessage(int level, String message) {\n        if (this.level <= level) {\n            write(message);\n        }\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    abstract protected void write(String message);\n}\n```\n在 DebugLogger 中\n```Java\nclass DebugLogger extends AbstractLogger {\n\n    public DebugLogger() {\n        super();\n        level = 2;\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"DebugLogger: \" + message);\n    }\n}\n```\n调用\n```Java\n    static AbstractLogger getChainOfLogger() {\n        AbstractLogger infoLogger = new InfoLogger();\n        AbstractLogger debugLogger = new DebugLogger();\n        AbstractLogger errorLogger = new ErrorLogger();\n        \n        infoLogger.setNextLogger(debugLogger);\n        debugLogger.setNextLogger(errorLogger);\n        return infoLogger;\n    }\n    \n    public static void main(String[] args) {\n        AbstractLogger logger = getChainOfLogger();\n\n        logger.logMessage(AbstractLogger.INFO, \"an info msg\");\n        logger.logMessage(AbstractLogger.DEBUG, \"a debug msg\");\n        logger.logMessage(AbstractLogger.ERROR, \"an error msg\");\n    }\n```\n控制台输出结果为\n```\nInfoLogger: an info msg\nInfoLogger: a debug msg\nDebugLogger: a debug msg\nInfoLogger: an error msg\nDebugLogger: an error msg\nErrorLogger: an error msg\n```\n\n## 其他\n\n### 命令模式\n一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：[Java设计模式--命令模式（以管理智能家电为例）](http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&p=8b2a971c87dd11a05db0e63c49&newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&user=baidu&fm=sc&query=java%C3%FC%C1%EE%C4%A3%CA%BD&qid=c0e757ac00089354&p1=5)\n","source":"_posts/Java设计模式：行为型模式.md","raw":"---\ntitle: Java设计模式：行为型模式\ndate: 2019-01-21 00:57:00\ncategories:\n- Java\n---\n\n## 责任链模式\n责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<!--more-->\n\n创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。\n\n```Java\nabstract class AbstractLogger {\n    public static int INFO = 1;\n    public static int DEBUG = 2;\n    public static int ERROR = 3;\n\n    protected int level;\n\n    //责任链中的下一个元素\n    protected AbstractLogger nextLogger;\n\n    public void setNextLogger(AbstractLogger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    public void logMessage(int level, String message) {\n        if (this.level <= level) {\n            write(message);\n        }\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    abstract protected void write(String message);\n}\n```\n在 DebugLogger 中\n```Java\nclass DebugLogger extends AbstractLogger {\n\n    public DebugLogger() {\n        super();\n        level = 2;\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"DebugLogger: \" + message);\n    }\n}\n```\n调用\n```Java\n    static AbstractLogger getChainOfLogger() {\n        AbstractLogger infoLogger = new InfoLogger();\n        AbstractLogger debugLogger = new DebugLogger();\n        AbstractLogger errorLogger = new ErrorLogger();\n        \n        infoLogger.setNextLogger(debugLogger);\n        debugLogger.setNextLogger(errorLogger);\n        return infoLogger;\n    }\n    \n    public static void main(String[] args) {\n        AbstractLogger logger = getChainOfLogger();\n\n        logger.logMessage(AbstractLogger.INFO, \"an info msg\");\n        logger.logMessage(AbstractLogger.DEBUG, \"a debug msg\");\n        logger.logMessage(AbstractLogger.ERROR, \"an error msg\");\n    }\n```\n控制台输出结果为\n```\nInfoLogger: an info msg\nInfoLogger: a debug msg\nDebugLogger: a debug msg\nInfoLogger: an error msg\nDebugLogger: an error msg\nErrorLogger: an error msg\n```\n\n## 其他\n\n### 命令模式\n一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：[Java设计模式--命令模式（以管理智能家电为例）](http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&p=8b2a971c87dd11a05db0e63c49&newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&user=baidu&fm=sc&query=java%C3%FC%C1%EE%C4%A3%CA%BD&qid=c0e757ac00089354&p1=5)\n","slug":"Java设计模式：行为型模式","published":1,"updated":"2019-03-12T14:33:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru73n0002f0u8n5u42sa6","content":"<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<a id=\"more\"></a></p>\n<p>创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> INFO = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> DEBUG = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> ERROR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//责任链中的下一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AbstractLogger nextLogger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextLogger</span><span class=\"params\">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextLogger = nextLogger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.level &lt;= level) &#123;</span><br><span class=\"line\">            write(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLogger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nextLogger.logMessage(level, message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 DebugLogger 中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        level = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DebugLogger: \"</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> AbstractLogger <span class=\"title\">getChainOfLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger infoLogger = <span class=\"keyword\">new</span> InfoLogger();</span><br><span class=\"line\">    AbstractLogger debugLogger = <span class=\"keyword\">new</span> DebugLogger();</span><br><span class=\"line\">    AbstractLogger errorLogger = <span class=\"keyword\">new</span> ErrorLogger();</span><br><span class=\"line\">    </span><br><span class=\"line\">    infoLogger.setNextLogger(debugLogger);</span><br><span class=\"line\">    debugLogger.setNextLogger(errorLogger);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> infoLogger;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger logger = getChainOfLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.logMessage(AbstractLogger.INFO, <span class=\"string\">\"an info msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.DEBUG, <span class=\"string\">\"a debug msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.ERROR, <span class=\"string\">\"an error msg\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InfoLogger: an info msg</span><br><span class=\"line\">InfoLogger: a debug msg</span><br><span class=\"line\">DebugLogger: a debug msg</span><br><span class=\"line\">InfoLogger: an error msg</span><br><span class=\"line\">DebugLogger: an error msg</span><br><span class=\"line\">ErrorLogger: an error msg</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：<a href=\"http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&amp;p=8b2a971c87dd11a05db0e63c49&amp;newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&amp;user=baidu&amp;fm=sc&amp;query=java%C3%FC%C1%EE%C4%A3%CA%BD&amp;qid=c0e757ac00089354&amp;p1=5\" target=\"_blank\" rel=\"noopener\">Java设计模式–命令模式（以管理智能家电为例）</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。</p>","more":"<p></p>\n<p>创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> INFO = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> DEBUG = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> ERROR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//责任链中的下一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AbstractLogger nextLogger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextLogger</span><span class=\"params\">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextLogger = nextLogger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.level &lt;= level) &#123;</span><br><span class=\"line\">            write(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLogger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nextLogger.logMessage(level, message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 DebugLogger 中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        level = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DebugLogger: \"</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> AbstractLogger <span class=\"title\">getChainOfLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger infoLogger = <span class=\"keyword\">new</span> InfoLogger();</span><br><span class=\"line\">    AbstractLogger debugLogger = <span class=\"keyword\">new</span> DebugLogger();</span><br><span class=\"line\">    AbstractLogger errorLogger = <span class=\"keyword\">new</span> ErrorLogger();</span><br><span class=\"line\">    </span><br><span class=\"line\">    infoLogger.setNextLogger(debugLogger);</span><br><span class=\"line\">    debugLogger.setNextLogger(errorLogger);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> infoLogger;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger logger = getChainOfLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.logMessage(AbstractLogger.INFO, <span class=\"string\">\"an info msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.DEBUG, <span class=\"string\">\"a debug msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.ERROR, <span class=\"string\">\"an error msg\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InfoLogger: an info msg</span><br><span class=\"line\">InfoLogger: a debug msg</span><br><span class=\"line\">DebugLogger: a debug msg</span><br><span class=\"line\">InfoLogger: an error msg</span><br><span class=\"line\">DebugLogger: an error msg</span><br><span class=\"line\">ErrorLogger: an error msg</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：<a href=\"http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&amp;p=8b2a971c87dd11a05db0e63c49&amp;newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&amp;user=baidu&amp;fm=sc&amp;query=java%C3%FC%C1%EE%C4%A3%CA%BD&amp;qid=c0e757ac00089354&amp;p1=5\" target=\"_blank\" rel=\"noopener\">Java设计模式–命令模式（以管理智能家电为例）</a></p>"},{"title":"坐过山车的人","date":"2019-01-10T09:57:55.000Z","_content":"\n&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<!--more-->\n&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。\n\n> 我们乘坐过山车飞向未来，  \n> 他和我的手里各捏着一张票，  \n> 那是飞向未来的小舢板，  \n> 起伏的波浪是我无畏的想象力。  \n> 乘坐我的想象力，\n> 他们尽情蹂躏  \n> 这些无辜的女孩和男孩，  \n> 这些无辜的小狗和小猫。  \n> 在波浪之下，在波浪的下面  \n> 一直匍匐着衰弱的故事人， \n> 他曾经是最伟大的创造者，  \n> 匍匐在最下面的飞得最高，  \n> 全是痛苦，全部都是痛苦。  \n> 那些与我耳语者，个个聪明无比， \n> 他们说智慧来自痛苦，他们说：  \n> 来，给你智慧之路。  \n> 哦，每一个坐过山车的人  \n> 都是过山车建造厂的工人，  \n> 每一双手都充满智慧，是痛苦的 \n> 工艺匠。他们也制造不同的心灵，  \n> 这些心灵里孕育着奖励，  \n> 那些渴望奖励的人，那些最智慧的人，  \n> 他们总在沉默，不停地被从过山车上 \n> 推下去，在空中飘荡，在飘荡中，  \n> 我们接吻，就像那些恋人，  \n> 那些被压缩在词典册页中的爱情故事，  \n> 还有家庭，人间的互相拯救。 \n> 如果存在一个空间，漂浮着  \n> 无数列过山车，痛苦的过山车…… \n>\n> ——马雁：《我们乘坐着过山车飞向未来》\n\n&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。\n&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。\n&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。\n&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。\n&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。\n&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。\n&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","source":"_posts/坐过山车的人.md","raw":"---\ntitle: 坐过山车的人\ndate: 2019-01-10 17:57:55\ncategories: \n- 随笔\n---\n\n&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<!--more-->\n&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。\n\n> 我们乘坐过山车飞向未来，  \n> 他和我的手里各捏着一张票，  \n> 那是飞向未来的小舢板，  \n> 起伏的波浪是我无畏的想象力。  \n> 乘坐我的想象力，\n> 他们尽情蹂躏  \n> 这些无辜的女孩和男孩，  \n> 这些无辜的小狗和小猫。  \n> 在波浪之下，在波浪的下面  \n> 一直匍匐着衰弱的故事人， \n> 他曾经是最伟大的创造者，  \n> 匍匐在最下面的飞得最高，  \n> 全是痛苦，全部都是痛苦。  \n> 那些与我耳语者，个个聪明无比， \n> 他们说智慧来自痛苦，他们说：  \n> 来，给你智慧之路。  \n> 哦，每一个坐过山车的人  \n> 都是过山车建造厂的工人，  \n> 每一双手都充满智慧，是痛苦的 \n> 工艺匠。他们也制造不同的心灵，  \n> 这些心灵里孕育着奖励，  \n> 那些渴望奖励的人，那些最智慧的人，  \n> 他们总在沉默，不停地被从过山车上 \n> 推下去，在空中飘荡，在飘荡中，  \n> 我们接吻，就像那些恋人，  \n> 那些被压缩在词典册页中的爱情故事，  \n> 还有家庭，人间的互相拯救。 \n> 如果存在一个空间，漂浮着  \n> 无数列过山车，痛苦的过山车…… \n>\n> ——马雁：《我们乘坐着过山车飞向未来》\n\n&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。\n&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。\n&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。\n&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。\n&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。\n&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。\n&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","slug":"坐过山车的人","published":1,"updated":"2019-01-11T16:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru73q0004f0u8p7vmagkd","content":"<p>&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<a id=\"more\"></a><br>&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。</p>\n<blockquote>\n<p>我们乘坐过山车飞向未来，<br>他和我的手里各捏着一张票，<br>那是飞向未来的小舢板，<br>起伏的波浪是我无畏的想象力。<br>乘坐我的想象力，<br>他们尽情蹂躏<br>这些无辜的女孩和男孩，<br>这些无辜的小狗和小猫。<br>在波浪之下，在波浪的下面<br>一直匍匐着衰弱的故事人，<br>他曾经是最伟大的创造者，<br>匍匐在最下面的飞得最高，<br>全是痛苦，全部都是痛苦。<br>那些与我耳语者，个个聪明无比，<br>他们说智慧来自痛苦，他们说：<br>来，给你智慧之路。<br>哦，每一个坐过山车的人<br>都是过山车建造厂的工人，<br>每一双手都充满智慧，是痛苦的<br>工艺匠。他们也制造不同的心灵，<br>这些心灵里孕育着奖励，<br>那些渴望奖励的人，那些最智慧的人，<br>他们总在沉默，不停地被从过山车上<br>推下去，在空中飘荡，在飘荡中，<br>我们接吻，就像那些恋人，<br>那些被压缩在词典册页中的爱情故事，<br>还有家庭，人间的互相拯救。<br>如果存在一个空间，漂浮着<br>无数列过山车，痛苦的过山车…… </p>\n<p>——马雁：《我们乘坐着过山车飞向未来》</p>\n</blockquote>\n<p>&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。<br>&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。<br>&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。<br>&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。<br>&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。<br>&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。<br>&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。</p>","more":"<br>&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。<p></p>\n<blockquote>\n<p>我们乘坐过山车飞向未来，<br>他和我的手里各捏着一张票，<br>那是飞向未来的小舢板，<br>起伏的波浪是我无畏的想象力。<br>乘坐我的想象力，<br>他们尽情蹂躏<br>这些无辜的女孩和男孩，<br>这些无辜的小狗和小猫。<br>在波浪之下，在波浪的下面<br>一直匍匐着衰弱的故事人，<br>他曾经是最伟大的创造者，<br>匍匐在最下面的飞得最高，<br>全是痛苦，全部都是痛苦。<br>那些与我耳语者，个个聪明无比，<br>他们说智慧来自痛苦，他们说：<br>来，给你智慧之路。<br>哦，每一个坐过山车的人<br>都是过山车建造厂的工人，<br>每一双手都充满智慧，是痛苦的<br>工艺匠。他们也制造不同的心灵，<br>这些心灵里孕育着奖励，<br>那些渴望奖励的人，那些最智慧的人，<br>他们总在沉默，不停地被从过山车上<br>推下去，在空中飘荡，在飘荡中，<br>我们接吻，就像那些恋人，<br>那些被压缩在词典册页中的爱情故事，<br>还有家庭，人间的互相拯救。<br>如果存在一个空间，漂浮着<br>无数列过山车，痛苦的过山车…… </p>\n<p>——马雁：《我们乘坐着过山车飞向未来》</p>\n</blockquote>\n<p>&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。<br>&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。<br>&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。<br>&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。<br>&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。<br>&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。<br>&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。</p>"},{"title":"LeetCode：最长回文子串（Longest Palindromic Substring）的解法","date":"2019-01-12T06:32:23.000Z","_content":"\n## 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n\n> Input: \"babcd\"\nOutput: \"bab\"\n\n<!--more-->\n\n本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。\n\n## O(n^3)算法\n\n### 思路\n- 从最长的子串开始，遍历所有该原字符串的子串；\n- 每找出一个字符串，就判断该字符串是否为回文；\n- 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。\n\n### 时间复杂度\n- 遍历字符串子串：嵌套一个循环：O(n^2)；   \n- 判断是否为回文：再次嵌套一个循环：O(n^3)。\n\n### 代码\n\n```java\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n    for(int i = s.length();i > 0; i--) {//子串长度\n        for(int j = 0; j <= s.length() - i; j++) {\n            String sub = s.substring(j , i + j);//子串位置\n            int count = 0;//计数，用来判断是否对称\n            for (int k = 0; k < sub.length() / 2; k++) {//左右对称判断\n                if (sub.charAt(k) == sub.charAt(sub.length() - k - 1))\n                    count++;\n            }\n            if (count == sub.length() / 2)\n                return sub;\n        }\n    }\n    return \"\";//表示字符串中无回文子串\n}\n```\n\n## O(n^2)算法\n\n### 思路\n\n- 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；\n- 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；\n- 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；\n- 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。\n\n### 时间复杂度\n\n- 遍历字符：一层循环——O(n-1)；\n\n- 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)\n\n\n### 代码\n```java\nprivate static int maxLen = 0;\n\nprivate static String sub = \"\";\n\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n\n    for(int i = 0;i < s.length()-1;i++){\n        findLongestPalindrome(s,i,i);//单核回文\n        findLongestPalindrome(s,i,i+1);//双核回文\n    }\n    return sub;\n}\n\npublic static void findLongestPalindrome(String s,int low,int high) {\n    while (low >= 0 && high <= s.length()-1){\n        if(s.charAt(low) == s.charAt(high)){\n            if(high - low + 1 > maxLen){\n                maxLen = high - low + 1;\n                sub = s.substring(low , high+1);\n            }\n            low --;//向两边扩散找当前字符为中心的最大回文子串\n            high ++;\n        } else\n            break;\n    }\n}\n```\n\n## O(n)算法——Manacher算法\n\n### 思路\nManacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br>\n这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以`＃`号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：\n\n> a -> #a# \nabaf -> #a#b#a#f#\n\n可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。\n\n借助两个变量center、right分别记录回文子串对应的中心点和右端点\n\n![你想输入的替代文字](LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png)\n\n可以直接看出，right就是`2*center-i`（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br>\n反之，就只能从1个长度开始匹配了，就是下面的这行代码:\n\n```\nr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1\n```\n\n这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br>\n进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。\n\n### 时间复杂度\n只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。\n\n### 代码\n```java\npublic static String longestPalindrome(String s) {\n\tif(s == null || s.length() < 1) {\n\t\treturn s;\n\t}\n\tStringBuilder builder = new StringBuilder();\n\t// 防止左端点越界\n\tbuilder.append(\"&#\");\n\tchar[] c = s.toCharArray();\n\tfor (char a : c) {\n\t\tbuilder.append(a).append(\"#\");\n\t}\n\tString newStr = builder.toString();\n\tc = newStr.toCharArray();\n\t// 回文半径\n\tint[] r = new int[newStr.length()];\n\t// 回文子串最大右端点、中心点\n\tint right=0, center=0;\n\t// 最大回文半径、最大中心点\n\tint maxR=0, maxC=0;\n\tfor (int i=1;i < c.length;i++) {\n\t\t// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径\n\t\tr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1;\n\t\twhile (i+r[i]<c.length && c[i+r[i]]==c[i-r[i]]) {\n\t\t\t++r[i];\n\t\t}\n\t\t// 更新右端点和中心点\n\t\tif (right < i+r[i]) {\n\t\t\tright = i+r[i];\n\t\t\tcenter = i;\n\t\t}\n\t\t// 更新最大半径和最大中心点\n\t\tif (maxR < r[i]) {\n\t\t\tmaxR = r[i];\n\t\t\tmaxC = i;\n\t\t}\n\t}\n    //计算在原字符串中的起始点\n\tint start = (maxC-maxR)/2;\n\treturn s.substring(start, start+maxR-1);\n}\n```","source":"_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法.md","raw":"---\ntitle: LeetCode：最长回文子串（Longest Palindromic Substring）的解法\ndate: 2019-01-12 14:32:23\ncategories:\n- 算法\n---\n\n## 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n\n> Input: \"babcd\"\nOutput: \"bab\"\n\n<!--more-->\n\n本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。\n\n## O(n^3)算法\n\n### 思路\n- 从最长的子串开始，遍历所有该原字符串的子串；\n- 每找出一个字符串，就判断该字符串是否为回文；\n- 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。\n\n### 时间复杂度\n- 遍历字符串子串：嵌套一个循环：O(n^2)；   \n- 判断是否为回文：再次嵌套一个循环：O(n^3)。\n\n### 代码\n\n```java\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n    for(int i = s.length();i > 0; i--) {//子串长度\n        for(int j = 0; j <= s.length() - i; j++) {\n            String sub = s.substring(j , i + j);//子串位置\n            int count = 0;//计数，用来判断是否对称\n            for (int k = 0; k < sub.length() / 2; k++) {//左右对称判断\n                if (sub.charAt(k) == sub.charAt(sub.length() - k - 1))\n                    count++;\n            }\n            if (count == sub.length() / 2)\n                return sub;\n        }\n    }\n    return \"\";//表示字符串中无回文子串\n}\n```\n\n## O(n^2)算法\n\n### 思路\n\n- 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；\n- 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；\n- 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；\n- 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。\n\n### 时间复杂度\n\n- 遍历字符：一层循环——O(n-1)；\n\n- 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)\n\n\n### 代码\n```java\nprivate static int maxLen = 0;\n\nprivate static String sub = \"\";\n\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n\n    for(int i = 0;i < s.length()-1;i++){\n        findLongestPalindrome(s,i,i);//单核回文\n        findLongestPalindrome(s,i,i+1);//双核回文\n    }\n    return sub;\n}\n\npublic static void findLongestPalindrome(String s,int low,int high) {\n    while (low >= 0 && high <= s.length()-1){\n        if(s.charAt(low) == s.charAt(high)){\n            if(high - low + 1 > maxLen){\n                maxLen = high - low + 1;\n                sub = s.substring(low , high+1);\n            }\n            low --;//向两边扩散找当前字符为中心的最大回文子串\n            high ++;\n        } else\n            break;\n    }\n}\n```\n\n## O(n)算法——Manacher算法\n\n### 思路\nManacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br>\n这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以`＃`号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：\n\n> a -> #a# \nabaf -> #a#b#a#f#\n\n可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。\n\n借助两个变量center、right分别记录回文子串对应的中心点和右端点\n\n![你想输入的替代文字](LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png)\n\n可以直接看出，right就是`2*center-i`（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br>\n反之，就只能从1个长度开始匹配了，就是下面的这行代码:\n\n```\nr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1\n```\n\n这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br>\n进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。\n\n### 时间复杂度\n只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。\n\n### 代码\n```java\npublic static String longestPalindrome(String s) {\n\tif(s == null || s.length() < 1) {\n\t\treturn s;\n\t}\n\tStringBuilder builder = new StringBuilder();\n\t// 防止左端点越界\n\tbuilder.append(\"&#\");\n\tchar[] c = s.toCharArray();\n\tfor (char a : c) {\n\t\tbuilder.append(a).append(\"#\");\n\t}\n\tString newStr = builder.toString();\n\tc = newStr.toCharArray();\n\t// 回文半径\n\tint[] r = new int[newStr.length()];\n\t// 回文子串最大右端点、中心点\n\tint right=0, center=0;\n\t// 最大回文半径、最大中心点\n\tint maxR=0, maxC=0;\n\tfor (int i=1;i < c.length;i++) {\n\t\t// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径\n\t\tr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1;\n\t\twhile (i+r[i]<c.length && c[i+r[i]]==c[i-r[i]]) {\n\t\t\t++r[i];\n\t\t}\n\t\t// 更新右端点和中心点\n\t\tif (right < i+r[i]) {\n\t\t\tright = i+r[i];\n\t\t\tcenter = i;\n\t\t}\n\t\t// 更新最大半径和最大中心点\n\t\tif (maxR < r[i]) {\n\t\t\tmaxR = r[i];\n\t\t\tmaxC = i;\n\t\t}\n\t}\n    //计算在原字符串中的起始点\n\tint start = (maxC-maxR)/2;\n\treturn s.substring(start, start+maxR-1);\n}\n```","slug":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法","published":1,"updated":"2019-01-13T05:41:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru73s0005f0u88bmy3ngt","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>\n<blockquote>\n<p>Input: “babcd”<br>Output: “bab”</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。</p>\n<h2 id=\"O-n-3-算法\"><a href=\"#O-n-3-算法\" class=\"headerlink\" title=\"O(n^3)算法\"></a>O(n^3)算法</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>从最长的子串开始，遍历所有该原字符串的子串；</li>\n<li>每找出一个字符串，就判断该字符串是否为回文；</li>\n<li>子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li>遍历字符串子串：嵌套一个循环：O(n^2)；   </li>\n<li>判断是否为回文：再次嵌套一个循环：O(n^3)。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length();i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">//子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= s.length() - i; j++) &#123;</span><br><span class=\"line\">            String sub = s.substring(j , i + j);<span class=\"comment\">//子串位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//计数，用来判断是否对称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; sub.length() / <span class=\"number\">2</span>; k++) &#123;<span class=\"comment\">//左右对称判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sub.charAt(k) == sub.charAt(sub.length() - k - <span class=\"number\">1</span>))</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == sub.length() / <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;<span class=\"comment\">//表示字符串中无回文子串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-2-算法\"><a href=\"#O-n-2-算法\" class=\"headerlink\" title=\"O(n^2)算法\"></a>O(n^2)算法</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；</li>\n<li>遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；</li>\n<li>每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；</li>\n<li>重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。</li>\n</ul>\n<h3 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li><p>遍历字符：一层循环——O(n-1)；</p>\n</li>\n<li><p>找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)</p>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.length()-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">        findLongestPalindrome(s,i,i);<span class=\"comment\">//单核回文</span></span><br><span class=\"line\">        findLongestPalindrome(s,i,i+<span class=\"number\">1</span>);<span class=\"comment\">//双核回文</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">findLongestPalindrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &gt;= <span class=\"number\">0</span> &amp;&amp; high &lt;= s.length()-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(low) == s.charAt(high))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(high - low + <span class=\"number\">1</span> &gt; maxLen)&#123;</span><br><span class=\"line\">                maxLen = high - low + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub = s.substring(low , high+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            low --;<span class=\"comment\">//向两边扩散找当前字符为中心的最大回文子串</span></span><br><span class=\"line\">            high ++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-算法——Manacher算法\"><a href=\"#O-n-算法——Manacher算法\" class=\"headerlink\" title=\"O(n)算法——Manacher算法\"></a>O(n)算法——Manacher算法</h2><h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br><br>这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以<code>＃</code>号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：</p>\n<blockquote>\n<p>a -&gt; #a#<br>abaf -&gt; #a#b#a#f#</p>\n</blockquote>\n<p>可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。</p>\n<p>借助两个变量center、right分别记录回文子串对应的中心点和右端点</p>\n<p><img src=\"/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png\" alt=\"你想输入的替代文字\"></p>\n<p>可以直接看出，right就是<code>2*center-i</code>（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br><br>反之，就只能从1个长度开始匹配了，就是下面的这行代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1</span><br></pre></td></tr></table></figure>\n<p>这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br><br>进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。</p>\n<h3 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span> || s.length() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tStringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t<span class=\"comment\">// 防止左端点越界</span></span><br><span class=\"line\">\tbuilder.append(<span class=\"string\">\"&amp;#\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] c = s.toCharArray();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a : c) &#123;</span><br><span class=\"line\">\t\tbuilder.append(a).append(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tString newStr = builder.toString();</span><br><span class=\"line\">\tc = newStr.toCharArray();</span><br><span class=\"line\">\t<span class=\"comment\">// 回文半径</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[newStr.length()];</span><br><span class=\"line\">\t<span class=\"comment\">// 回文子串最大右端点、中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> right=<span class=\"number\">0</span>, center=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 最大回文半径、最大中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxR=<span class=\"number\">0</span>, maxC=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i &lt; c.length;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径</span></span><br><span class=\"line\">\t\tr[i] = right &gt; i ? (Math.min(r[<span class=\"number\">2</span>*center-i], right-i)) : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123;</span><br><span class=\"line\">\t\t\t++r[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新右端点和中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (right &lt; i+r[i]) &#123;</span><br><span class=\"line\">\t\t\tright = i+r[i];</span><br><span class=\"line\">\t\t\tcenter = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大半径和最大中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxR &lt; r[i]) &#123;</span><br><span class=\"line\">\t\t\tmaxR = r[i];</span><br><span class=\"line\">\t\t\tmaxC = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//计算在原字符串中的起始点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = (maxC-maxR)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.substring(start, start+maxR-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>\n<blockquote>\n<p>Input: “babcd”<br>Output: “bab”</p>\n</blockquote>","more":"<p>本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。</p>\n<h2 id=\"O-n-3-算法\"><a href=\"#O-n-3-算法\" class=\"headerlink\" title=\"O(n^3)算法\"></a>O(n^3)算法</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>从最长的子串开始，遍历所有该原字符串的子串；</li>\n<li>每找出一个字符串，就判断该字符串是否为回文；</li>\n<li>子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li>遍历字符串子串：嵌套一个循环：O(n^2)；   </li>\n<li>判断是否为回文：再次嵌套一个循环：O(n^3)。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length();i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">//子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= s.length() - i; j++) &#123;</span><br><span class=\"line\">            String sub = s.substring(j , i + j);<span class=\"comment\">//子串位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//计数，用来判断是否对称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; sub.length() / <span class=\"number\">2</span>; k++) &#123;<span class=\"comment\">//左右对称判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sub.charAt(k) == sub.charAt(sub.length() - k - <span class=\"number\">1</span>))</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == sub.length() / <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;<span class=\"comment\">//表示字符串中无回文子串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-2-算法\"><a href=\"#O-n-2-算法\" class=\"headerlink\" title=\"O(n^2)算法\"></a>O(n^2)算法</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；</li>\n<li>遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；</li>\n<li>每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；</li>\n<li>重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。</li>\n</ul>\n<h3 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li><p>遍历字符：一层循环——O(n-1)；</p>\n</li>\n<li><p>找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)</p>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.length()-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">        findLongestPalindrome(s,i,i);<span class=\"comment\">//单核回文</span></span><br><span class=\"line\">        findLongestPalindrome(s,i,i+<span class=\"number\">1</span>);<span class=\"comment\">//双核回文</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">findLongestPalindrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &gt;= <span class=\"number\">0</span> &amp;&amp; high &lt;= s.length()-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(low) == s.charAt(high))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(high - low + <span class=\"number\">1</span> &gt; maxLen)&#123;</span><br><span class=\"line\">                maxLen = high - low + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub = s.substring(low , high+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            low --;<span class=\"comment\">//向两边扩散找当前字符为中心的最大回文子串</span></span><br><span class=\"line\">            high ++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-算法——Manacher算法\"><a href=\"#O-n-算法——Manacher算法\" class=\"headerlink\" title=\"O(n)算法——Manacher算法\"></a>O(n)算法——Manacher算法</h2><h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br><br>这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以<code>＃</code>号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：</p>\n<blockquote>\n<p>a -&gt; #a#<br>abaf -&gt; #a#b#a#f#</p>\n</blockquote>\n<p>可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。</p>\n<p>借助两个变量center、right分别记录回文子串对应的中心点和右端点</p>\n<p><img src=\"/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png\" alt=\"你想输入的替代文字\"></p>\n<p>可以直接看出，right就是<code>2*center-i</code>（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br><br>反之，就只能从1个长度开始匹配了，就是下面的这行代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1</span><br></pre></td></tr></table></figure>\n<p>这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br><br>进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。</p>\n<h3 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span> || s.length() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tStringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t<span class=\"comment\">// 防止左端点越界</span></span><br><span class=\"line\">\tbuilder.append(<span class=\"string\">\"&amp;#\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] c = s.toCharArray();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a : c) &#123;</span><br><span class=\"line\">\t\tbuilder.append(a).append(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tString newStr = builder.toString();</span><br><span class=\"line\">\tc = newStr.toCharArray();</span><br><span class=\"line\">\t<span class=\"comment\">// 回文半径</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[newStr.length()];</span><br><span class=\"line\">\t<span class=\"comment\">// 回文子串最大右端点、中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> right=<span class=\"number\">0</span>, center=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 最大回文半径、最大中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxR=<span class=\"number\">0</span>, maxC=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i &lt; c.length;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径</span></span><br><span class=\"line\">\t\tr[i] = right &gt; i ? (Math.min(r[<span class=\"number\">2</span>*center-i], right-i)) : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123;</span><br><span class=\"line\">\t\t\t++r[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新右端点和中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (right &lt; i+r[i]) &#123;</span><br><span class=\"line\">\t\t\tright = i+r[i];</span><br><span class=\"line\">\t\t\tcenter = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大半径和最大中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxR &lt; r[i]) &#123;</span><br><span class=\"line\">\t\t\tmaxR = r[i];</span><br><span class=\"line\">\t\t\tmaxC = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//计算在原字符串中的起始点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = (maxC-maxR)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.substring(start, start+maxR-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java设计模式：创建型模式","date":"2019-01-20T16:58:21.000Z","_content":"## 设计模式及其分类\n\n### 设计模式\n设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<!--more-->\n\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n- 对接口编程而不是对实现编程。\n- 优先使用对象组合而不是继承。\n\n### 分类\n<html>\n<table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr>\n</table>\n</html>\n\n可以使用一张图来展示设计模式之间的关系：\n\n![设计模式之间的关系](Java设计模式：创建型模式/设计模式之间的关系.jpg)\n\n### 六个原则：\n\n- 开闭原则（Open Close Principle）\n> 对扩展开放，对修改关闭。\n\n\n- 里氏代换原则（Liskov Substitution Principle）\n> 基类可以出现的任何地方，子类一定可以出现。\n\n- 依赖倒转原则（Dependence Inversion Principle）\n> 针对接口编程，依赖于抽象而不依赖于具体。\n\n- 接口隔离原则（Interface Segregation Principle）\n> 降低类之间的耦合度。\n\n- 迪米特法则，又称最少知道原则（Demeter Principle）\n> 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。\n\n- 合成复用原则（Composite Reuse Principle）\n> 尽量使用合成/聚合的方式，而不是使用继承。\n\n三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。\n\n## 创建者模式\n\n### 工厂模式\n创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。\n\n工厂模式可分为简单工厂、工厂方法、抽象工厂。\n\n#### 简单工厂\n工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。\n\n![简单工厂](Java设计模式：创建型模式/简单工厂.jpg)\n\n简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。\n\n#### 工厂方法\n工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。\n\n![工厂方法](Java设计模式：创建型模式/工厂方法.jpg)\n\n从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。\n\n#### 抽象工厂\n工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。\n\n![抽象工厂](Java设计模式：创建型模式/抽象工厂.jpg)\n\n\n以上介绍的三种工厂方法各有优缺点\n>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  \n\n### 单例模式\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。\n\n单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。\n\n#### 懒汉式\n支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n要支持多线程，可以给`getInstance`方法加锁`synchronized`，但是效率会变得很低。\n\n#### 饿汉式\n不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}  \n```\n\n#### 双检式\n双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。`getInstance` 的性能对应用程序很关键。\n\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n\n该方法使用了关键字`volatile`，关于该关键字的分析：[Java并发编程：volatile关键字解析\n](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n> 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。\nvolatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。\n\n\n#### 静态内部类式\n能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n与双检式方式一样利用`ClassLoder`机制来保证初始化`instance`时只有一个线程。\n关于 ClassLoader：[一看你就懂，超详细java中的ClassLoader详解](https://blog.csdn.net/briblue/article/details/54973413)\n\n```Java\npublic class Singleton {  \n\n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n} \n```\n\n相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用`getInstance`之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。\n\n#### 枚举\n实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。\n\n```Java\npublic enum Singleton {  \n\n    INSTANCE;  \n    public void whateverMethod() {}  \n    \n}  \n```\n\n### 建造者模式\n使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。\n\n```Java\npublic class Human {\n\n    private final String name;\n    private final int height;\n    private final int weight;\n\n    public static class Builder {\n        // 必要参数\n        private final int name;\n\n        // 可选参数\n        private int height = 170;\n        private int weight = 60;\n\n        public Builder(String name) {\n            this.name = name\n        }\n\n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n\n        public Builder weight(int weight) {\n            this.weight = weight;\n            return this;\n        }\n\n        public Human build() {\n            return new Human(this);\n        }\n    }\n\n    private Human(Builder builder) {\n        name = builder.name;\n        height = builder.height;\n        weight = builder.weight;\n    }\n\n    public static void main(String[] args) {\n        Human human = new Human.Builder(\"Jack\")\n                    .height(175)\n                    .weight(60)\n                    .build();\n    }\n}\n```\n\n### 原型模式\n当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。\n\nJava的`clone`方法便是使用了这种方法，关于该方法：[java对象克隆以及深拷贝和浅拷贝](https://www.cnblogs.com/xuanxufeng/p/6558330.html)\n\n```Java\npublic inteface Prototype {\n    Prototype clone();\n}\n\npublic class ConcretePrototype implement Prototype {\n    \n    public override Prototype clone() {\n        Prototype prototype = new ConcretePrototype();\n        return prototype;\n    }\n    \n    public static void main(String[] args) {\n        Prototype p1 = new ConcretePrototype();\n        Prototype p2 = p1.clone();\n    }\n}\n```","source":"_posts/Java设计模式：创建型模式.md","raw":"---\ntitle: Java设计模式：创建型模式\ndate: 2019-01-21 00:58:21\ncategories: \n- Java\n---\n## 设计模式及其分类\n\n### 设计模式\n设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<!--more-->\n\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n- 对接口编程而不是对实现编程。\n- 优先使用对象组合而不是继承。\n\n### 分类\n<html>\n<table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr>\n</table>\n</html>\n\n可以使用一张图来展示设计模式之间的关系：\n\n![设计模式之间的关系](Java设计模式：创建型模式/设计模式之间的关系.jpg)\n\n### 六个原则：\n\n- 开闭原则（Open Close Principle）\n> 对扩展开放，对修改关闭。\n\n\n- 里氏代换原则（Liskov Substitution Principle）\n> 基类可以出现的任何地方，子类一定可以出现。\n\n- 依赖倒转原则（Dependence Inversion Principle）\n> 针对接口编程，依赖于抽象而不依赖于具体。\n\n- 接口隔离原则（Interface Segregation Principle）\n> 降低类之间的耦合度。\n\n- 迪米特法则，又称最少知道原则（Demeter Principle）\n> 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。\n\n- 合成复用原则（Composite Reuse Principle）\n> 尽量使用合成/聚合的方式，而不是使用继承。\n\n三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。\n\n## 创建者模式\n\n### 工厂模式\n创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。\n\n工厂模式可分为简单工厂、工厂方法、抽象工厂。\n\n#### 简单工厂\n工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。\n\n![简单工厂](Java设计模式：创建型模式/简单工厂.jpg)\n\n简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。\n\n#### 工厂方法\n工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。\n\n![工厂方法](Java设计模式：创建型模式/工厂方法.jpg)\n\n从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。\n\n#### 抽象工厂\n工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。\n\n![抽象工厂](Java设计模式：创建型模式/抽象工厂.jpg)\n\n\n以上介绍的三种工厂方法各有优缺点\n>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  \n\n### 单例模式\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。\n\n单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。\n\n#### 懒汉式\n支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n要支持多线程，可以给`getInstance`方法加锁`synchronized`，但是效率会变得很低。\n\n#### 饿汉式\n不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}  \n```\n\n#### 双检式\n双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。`getInstance` 的性能对应用程序很关键。\n\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n\n该方法使用了关键字`volatile`，关于该关键字的分析：[Java并发编程：volatile关键字解析\n](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n> 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。\nvolatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。\n\n\n#### 静态内部类式\n能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n与双检式方式一样利用`ClassLoder`机制来保证初始化`instance`时只有一个线程。\n关于 ClassLoader：[一看你就懂，超详细java中的ClassLoader详解](https://blog.csdn.net/briblue/article/details/54973413)\n\n```Java\npublic class Singleton {  \n\n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n} \n```\n\n相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用`getInstance`之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。\n\n#### 枚举\n实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。\n\n```Java\npublic enum Singleton {  \n\n    INSTANCE;  \n    public void whateverMethod() {}  \n    \n}  \n```\n\n### 建造者模式\n使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。\n\n```Java\npublic class Human {\n\n    private final String name;\n    private final int height;\n    private final int weight;\n\n    public static class Builder {\n        // 必要参数\n        private final int name;\n\n        // 可选参数\n        private int height = 170;\n        private int weight = 60;\n\n        public Builder(String name) {\n            this.name = name\n        }\n\n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n\n        public Builder weight(int weight) {\n            this.weight = weight;\n            return this;\n        }\n\n        public Human build() {\n            return new Human(this);\n        }\n    }\n\n    private Human(Builder builder) {\n        name = builder.name;\n        height = builder.height;\n        weight = builder.weight;\n    }\n\n    public static void main(String[] args) {\n        Human human = new Human.Builder(\"Jack\")\n                    .height(175)\n                    .weight(60)\n                    .build();\n    }\n}\n```\n\n### 原型模式\n当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。\n\nJava的`clone`方法便是使用了这种方法，关于该方法：[java对象克隆以及深拷贝和浅拷贝](https://www.cnblogs.com/xuanxufeng/p/6558330.html)\n\n```Java\npublic inteface Prototype {\n    Prototype clone();\n}\n\npublic class ConcretePrototype implement Prototype {\n    \n    public override Prototype clone() {\n        Prototype prototype = new ConcretePrototype();\n        return prototype;\n    }\n    \n    public static void main(String[] args) {\n        Prototype p1 = new ConcretePrototype();\n        Prototype p2 = p1.clone();\n    }\n}\n```","slug":"Java设计模式：创建型模式","published":1,"updated":"2019-03-12T01:35:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru78p000df0u8u955ox6e","content":"<h2 id=\"设计模式及其分类\"><a href=\"#设计模式及其分类\" class=\"headerlink\" title=\"设计模式及其分类\"></a>设计模式及其分类</h2><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p>设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n<p>1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<a id=\"more\"></a></p>\n<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>\n<ul>\n<li>对接口编程而不是对实现编程。</li>\n<li>优先使用对象组合而不是继承。</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><html><br><table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"></td><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><br></table><br></html>\n\n<p>可以使用一张图来展示设计模式之间的关系：</p>\n<p><img src=\"/Java设计模式：创建型模式/设计模式之间的关系.jpg\" alt=\"设计模式之间的关系\"></p>\n<h3 id=\"六个原则：\"><a href=\"#六个原则：\" class=\"headerlink\" title=\"六个原则：\"></a>六个原则：</h3><ul>\n<li>开闭原则（Open Close Principle）<blockquote>\n<p>对扩展开放，对修改关闭。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>里氏代换原则（Liskov Substitution Principle）</p>\n<blockquote>\n<p>基类可以出现的任何地方，子类一定可以出现。</p>\n</blockquote>\n</li>\n<li><p>依赖倒转原则（Dependence Inversion Principle）</p>\n<blockquote>\n<p>针对接口编程，依赖于抽象而不依赖于具体。</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则（Interface Segregation Principle）</p>\n<blockquote>\n<p>降低类之间的耦合度。</p>\n</blockquote>\n</li>\n<li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p>\n<blockquote>\n<p>实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。</p>\n</blockquote>\n</li>\n<li><p>合成复用原则（Composite Reuse Principle）</p>\n<blockquote>\n<p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n</blockquote>\n</li>\n</ul>\n<p>三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。</p>\n<h2 id=\"创建者模式\"><a href=\"#创建者模式\" class=\"headerlink\" title=\"创建者模式\"></a>创建者模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。</p>\n<p>工厂模式可分为简单工厂、工厂方法、抽象工厂。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。</p>\n<p><img src=\"/Java设计模式：创建型模式/简单工厂.jpg\" alt=\"简单工厂\"></p>\n<p>简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。</p>\n<p><img src=\"/Java设计模式：创建型模式/工厂方法.jpg\" alt=\"工厂方法\"></p>\n<p>从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。</p>\n<p><img src=\"/Java设计模式：创建型模式/抽象工厂.jpg\" alt=\"抽象工厂\"></p>\n<p>以上介绍的三种工厂方法各有优缺点</p>\n<blockquote>\n<p>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  </p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。</p>\n<p>单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要支持多线程，可以给<code>getInstance</code>方法加锁<code>synchronized</code>，但是效率会变得很低。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双检式\"><a href=\"#双检式\" class=\"headerlink\" title=\"双检式\"></a>双检式</h4><p>双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。<code>getInstance</code> 的性能对应用程序很关键。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法使用了关键字<code>volatile</code>，关于该关键字的分析：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：volatile关键字解析\n</a></p>\n<blockquote>\n<p>在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。<br>volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。</p>\n</blockquote>\n<h4 id=\"静态内部类式\"><a href=\"#静态内部类式\" class=\"headerlink\" title=\"静态内部类式\"></a>静态内部类式</h4><p>能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<p>与双检式方式一样利用<code>ClassLoder</code>机制来保证初始化<code>instance</code>时只有一个线程。<br>关于 ClassLoader：<a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener\">一看你就懂，超详细java中的ClassLoader详解</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用<code>getInstance</code>之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 必要参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height = <span class=\"number\">170</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> weight = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">weight</span><span class=\"params\">(<span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Human <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Human(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Human</span><span class=\"params\">(Builder builder)</span> </span>&#123;</span><br><span class=\"line\">        name = builder.name;</span><br><span class=\"line\">        height = builder.height;</span><br><span class=\"line\">        weight = builder.weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human human = <span class=\"keyword\">new</span> Human.Builder(<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">                    .height(<span class=\"number\">175</span>)</span><br><span class=\"line\">                    .weight(<span class=\"number\">60</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。</p>\n<p>Java的<code>clone</code>方法便是使用了这种方法，关于该方法：<a href=\"https://www.cnblogs.com/xuanxufeng/p/6558330.html\" target=\"_blank\" rel=\"noopener\">java对象克隆以及深拷贝和浅拷贝</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> inteface Prototype &#123;</span><br><span class=\"line\">    <span class=\"function\">Prototype <span class=\"title\">clone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"title\">implement</span> <span class=\"title\">Prototype</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override Prototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Prototype p1 = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        Prototype p2 = p1.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"设计模式及其分类\"><a href=\"#设计模式及其分类\" class=\"headerlink\" title=\"设计模式及其分类\"></a>设计模式及其分类</h2><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p>设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n<p>1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。</p>","more":"<p></p>\n<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>\n<ul>\n<li>对接口编程而不是对实现编程。</li>\n<li>优先使用对象组合而不是继承。</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><html><br><table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"></td><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><br></table><br></html>\n\n<p>可以使用一张图来展示设计模式之间的关系：</p>\n<p><img src=\"/Java设计模式：创建型模式/设计模式之间的关系.jpg\" alt=\"设计模式之间的关系\"></p>\n<h3 id=\"六个原则：\"><a href=\"#六个原则：\" class=\"headerlink\" title=\"六个原则：\"></a>六个原则：</h3><ul>\n<li>开闭原则（Open Close Principle）<blockquote>\n<p>对扩展开放，对修改关闭。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>里氏代换原则（Liskov Substitution Principle）</p>\n<blockquote>\n<p>基类可以出现的任何地方，子类一定可以出现。</p>\n</blockquote>\n</li>\n<li><p>依赖倒转原则（Dependence Inversion Principle）</p>\n<blockquote>\n<p>针对接口编程，依赖于抽象而不依赖于具体。</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则（Interface Segregation Principle）</p>\n<blockquote>\n<p>降低类之间的耦合度。</p>\n</blockquote>\n</li>\n<li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p>\n<blockquote>\n<p>实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。</p>\n</blockquote>\n</li>\n<li><p>合成复用原则（Composite Reuse Principle）</p>\n<blockquote>\n<p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n</blockquote>\n</li>\n</ul>\n<p>三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。</p>\n<h2 id=\"创建者模式\"><a href=\"#创建者模式\" class=\"headerlink\" title=\"创建者模式\"></a>创建者模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。</p>\n<p>工厂模式可分为简单工厂、工厂方法、抽象工厂。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。</p>\n<p><img src=\"/Java设计模式：创建型模式/简单工厂.jpg\" alt=\"简单工厂\"></p>\n<p>简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。</p>\n<p><img src=\"/Java设计模式：创建型模式/工厂方法.jpg\" alt=\"工厂方法\"></p>\n<p>从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。</p>\n<p><img src=\"/Java设计模式：创建型模式/抽象工厂.jpg\" alt=\"抽象工厂\"></p>\n<p>以上介绍的三种工厂方法各有优缺点</p>\n<blockquote>\n<p>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  </p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。</p>\n<p>单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要支持多线程，可以给<code>getInstance</code>方法加锁<code>synchronized</code>，但是效率会变得很低。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双检式\"><a href=\"#双检式\" class=\"headerlink\" title=\"双检式\"></a>双检式</h4><p>双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。<code>getInstance</code> 的性能对应用程序很关键。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法使用了关键字<code>volatile</code>，关于该关键字的分析：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：volatile关键字解析\n</a></p>\n<blockquote>\n<p>在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。<br>volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。</p>\n</blockquote>\n<h4 id=\"静态内部类式\"><a href=\"#静态内部类式\" class=\"headerlink\" title=\"静态内部类式\"></a>静态内部类式</h4><p>能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<p>与双检式方式一样利用<code>ClassLoder</code>机制来保证初始化<code>instance</code>时只有一个线程。<br>关于 ClassLoader：<a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener\">一看你就懂，超详细java中的ClassLoader详解</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用<code>getInstance</code>之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 必要参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height = <span class=\"number\">170</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> weight = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">weight</span><span class=\"params\">(<span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Human <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Human(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Human</span><span class=\"params\">(Builder builder)</span> </span>&#123;</span><br><span class=\"line\">        name = builder.name;</span><br><span class=\"line\">        height = builder.height;</span><br><span class=\"line\">        weight = builder.weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human human = <span class=\"keyword\">new</span> Human.Builder(<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">                    .height(<span class=\"number\">175</span>)</span><br><span class=\"line\">                    .weight(<span class=\"number\">60</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。</p>\n<p>Java的<code>clone</code>方法便是使用了这种方法，关于该方法：<a href=\"https://www.cnblogs.com/xuanxufeng/p/6558330.html\" target=\"_blank\" rel=\"noopener\">java对象克隆以及深拷贝和浅拷贝</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> inteface Prototype &#123;</span><br><span class=\"line\">    <span class=\"function\">Prototype <span class=\"title\">clone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"title\">implement</span> <span class=\"title\">Prototype</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override Prototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Prototype p1 = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        Prototype p2 = p1.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java设计模式：结构型模式","date":"2019-01-20T16:56:04.000Z","_content":"\n## 适配器模式\n在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<!--more-->\n\n用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此`Volt5V`称为`Target`，而不兼容的220V电压称之为`Adaptee`，我们的目的是适配设计一个`Adpater`，方法有两种。\n\n### 类适配器模式\n\n```Java\ninterface Volt5V {\n    int get5V();\n}\n\nclass Volt220V {\n    public int get220V() {\n        return 220;\n    }\n}\n\nclass Adapter extends Volt220V implements Volt5V {\n    @Override\n    public int get5V() {\n        return 5;\n    }\n}\n\npublic static void main(String[] args) {\n    Adapter adapter = new Adapter();\n    System.out.println(\"获取需要的5V电源：\" + adapter.get5V());\n}\n\n```\n\n### 对象适配器模式\n与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 \n　　 \n```Java\nclass ObjectAdapter implements Volt5V {\n\n    private Volt220V volt220V;\n\n    public ObjectAdapter(Volt220V adaptee) {\n        volt220V = adaptee;\n    }\n\n    @Override\n    public int get5V() {\n        return 5;\n    }\n        \n    public int get220V() {\n        return volt220V.get220V();\n    }  \n}\n```\n关于 Android 中 ListView 中的 Adapter，可以参考：[Android源码之ListView的适配器模式](https://blog.csdn.net/bboyfeiyu/article/details/43950185)\n\n## 组合模式\n将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。\n\n- 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。\n- 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。\n- 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。\n\n对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。\n\n```Java\n//抽象构件，声明一个接口用于访问和管理Component的子部件\nabstract class Component {\n\n    public Component() { }\n\n    public abstract void add(Component component);\n\n    public abstract void remove(Component component);\n\n    //显示层级结构\n    public abstract void Display(int level);\n}\n\n//叶子节点\nclass Leaf extends Component {\n\n    public Leaf() {\n        super();\n    }\n\n    //无意义的实现\n    @Override\n    public void add(Component component) { }\n\n    //无意义的实现\n    @Override\n    public void remove(Component component) { }\n\n    @Override\n    public void Display(int level) {\n        System.out.println(\"-\" + level);\n    }\n}\n\n//枝节点\nclass Composite extends Component {\n\n    public Composite() {\n        super();\n    }\n\n    private List<Component> children = new ArrayList<>();\n\n    @Override\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    @Override\n    public void Display(int level) {\n        children.forEach(\n                component -> component.Display(level + 2)\n        );\n    }\n}\n\n```\n对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。\n\n## 装饰器模式\n向一个现有的对象添加新的功能，同时又不改变其结构。<br>\n创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。\n\n```Java\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Draw a circle\");\n    }\n}\n\n//实现了 Shape 接口的抽象装饰类。\nabstract class ShapeDecorator implements Shape {\n\n    Shape decoratedShape;\n\n    public ShapeDecorator(Shape decoratedShape) {\n        this.decoratedShape = decoratedShape;\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n    }\n}\n\n//具体的装饰类\nclass RedShapeDecorator extends ShapeDecorator {\n\n    public RedShapeDecorator(Shape decoratedShape) {\n        super(decoratedShape);\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n        setRedBorder(decoratedShape);\n    }\n\n    private void setRedBorder(Shape decoratedShape) {\n        System.out.println(\"Border color: Red\");\n    }\n}\n```\n\n## 代理模式\n下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\n```Java\ninterface Image {\n    void display();\n}\n\nclass RealImage implements Image {\n\n    private String fileName;\n\n    public RealImage(String fileName){\n        this.fileName = fileName;\n        loadFromDisk(fileName);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Displaying \" + fileName);\n    }\n\n    private void loadFromDisk(String fileName){\n        System.out.println(\"Loading \" + fileName);\n    }\n}\n\nclass ProxyImage implements Image {\n\n    private RealImage realImage;\n    private String fileName;\n\n    public ProxyImage(String fileName){\n        this.fileName = fileName;\n    }\n\n    @Override\n    public void display() {\n        if(realImage == null){\n            realImage = new RealImage(fileName);\n        }\n        realImage.display();\n    }\n}\n```\n\n静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br>\nJava中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。\n\n```Java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DisplayHandler implements InvocationHandler {\n\n    //要代理的真实对象\n    private Object obj;\n\n    public DisplayHandler(Object obj) {\n        this.obj = obj;\n    }\n\n    /**\n     *\n     * @param proxy 代理类代理的真实代理对象\n     * @param method 所要调用某个对象真实的方法的Method对象\n     * @param args 指代代理对象方法传递的参数\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //真实的对象执行之前\n        System.out.println(\"Before invoke...\");\n\n        Object invoke = method.invoke(obj, args);\n\n        //真实的对象执行之后\n        System.out.println(\"After invoke...\");\n        return invoke;\n    }\n}\n\npublic static void main(String[] args) {\n    Image image = new RealImage(\"hello.jpg\");\n    InvocationHandler handler = new DisplayHandler(image);\n\n    /*\n     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象\n     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法\n     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上\n     */\n    Image proxy = (Image) Proxy.newProxyInstance(\n            handler.getClass().getClassLoader(),\n            image.getClass().getInterfaces(),\n            handler);\n    proxy.display();\n}\n```\n控制台输出结果为 \n```\nLoading hello.jpg\nBefore invoke...\nDisplaying hello.jpg\nAfter invoke...\n```\n\n代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。\n\n## 其他\n\n### 过滤器模式\n简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。\n\n### 桥接模式\n桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。\n\n举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。\n\n### 外观模式\n外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。\n\n简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。\n\n\n### 享元模式\n所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点\n\n```Java\npublic class FlyweightFactory{\n\n    static Map<String, Shape> shapes = new HashMap<String, Shape>();\n    \n    public static Shape getShape(String key){\n        Shape shape = shapes.get(key);\n        if(shape == null){\n            shape = new Circle(key);\n            shapes.put(key, shape);\n        }\n        return shape;\n    }\n    \n    public static int getSum(){\n        return shapes.size();\n    }\n}\n```\n\n### 补充\n从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是\"转换行为\"，外观模式是一种\"简化行为\"。","source":"_posts/Java设计模式：结构型模式.md","raw":"---\ntitle: Java设计模式：结构型模式\ndate: 2019-01-21 00:56:04\ncategories:\n- Java\n---\n\n## 适配器模式\n在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<!--more-->\n\n用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此`Volt5V`称为`Target`，而不兼容的220V电压称之为`Adaptee`，我们的目的是适配设计一个`Adpater`，方法有两种。\n\n### 类适配器模式\n\n```Java\ninterface Volt5V {\n    int get5V();\n}\n\nclass Volt220V {\n    public int get220V() {\n        return 220;\n    }\n}\n\nclass Adapter extends Volt220V implements Volt5V {\n    @Override\n    public int get5V() {\n        return 5;\n    }\n}\n\npublic static void main(String[] args) {\n    Adapter adapter = new Adapter();\n    System.out.println(\"获取需要的5V电源：\" + adapter.get5V());\n}\n\n```\n\n### 对象适配器模式\n与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 \n　　 \n```Java\nclass ObjectAdapter implements Volt5V {\n\n    private Volt220V volt220V;\n\n    public ObjectAdapter(Volt220V adaptee) {\n        volt220V = adaptee;\n    }\n\n    @Override\n    public int get5V() {\n        return 5;\n    }\n        \n    public int get220V() {\n        return volt220V.get220V();\n    }  \n}\n```\n关于 Android 中 ListView 中的 Adapter，可以参考：[Android源码之ListView的适配器模式](https://blog.csdn.net/bboyfeiyu/article/details/43950185)\n\n## 组合模式\n将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。\n\n- 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。\n- 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。\n- 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。\n\n对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。\n\n```Java\n//抽象构件，声明一个接口用于访问和管理Component的子部件\nabstract class Component {\n\n    public Component() { }\n\n    public abstract void add(Component component);\n\n    public abstract void remove(Component component);\n\n    //显示层级结构\n    public abstract void Display(int level);\n}\n\n//叶子节点\nclass Leaf extends Component {\n\n    public Leaf() {\n        super();\n    }\n\n    //无意义的实现\n    @Override\n    public void add(Component component) { }\n\n    //无意义的实现\n    @Override\n    public void remove(Component component) { }\n\n    @Override\n    public void Display(int level) {\n        System.out.println(\"-\" + level);\n    }\n}\n\n//枝节点\nclass Composite extends Component {\n\n    public Composite() {\n        super();\n    }\n\n    private List<Component> children = new ArrayList<>();\n\n    @Override\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    @Override\n    public void Display(int level) {\n        children.forEach(\n                component -> component.Display(level + 2)\n        );\n    }\n}\n\n```\n对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。\n\n## 装饰器模式\n向一个现有的对象添加新的功能，同时又不改变其结构。<br>\n创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。\n\n```Java\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Draw a circle\");\n    }\n}\n\n//实现了 Shape 接口的抽象装饰类。\nabstract class ShapeDecorator implements Shape {\n\n    Shape decoratedShape;\n\n    public ShapeDecorator(Shape decoratedShape) {\n        this.decoratedShape = decoratedShape;\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n    }\n}\n\n//具体的装饰类\nclass RedShapeDecorator extends ShapeDecorator {\n\n    public RedShapeDecorator(Shape decoratedShape) {\n        super(decoratedShape);\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n        setRedBorder(decoratedShape);\n    }\n\n    private void setRedBorder(Shape decoratedShape) {\n        System.out.println(\"Border color: Red\");\n    }\n}\n```\n\n## 代理模式\n下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\n```Java\ninterface Image {\n    void display();\n}\n\nclass RealImage implements Image {\n\n    private String fileName;\n\n    public RealImage(String fileName){\n        this.fileName = fileName;\n        loadFromDisk(fileName);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Displaying \" + fileName);\n    }\n\n    private void loadFromDisk(String fileName){\n        System.out.println(\"Loading \" + fileName);\n    }\n}\n\nclass ProxyImage implements Image {\n\n    private RealImage realImage;\n    private String fileName;\n\n    public ProxyImage(String fileName){\n        this.fileName = fileName;\n    }\n\n    @Override\n    public void display() {\n        if(realImage == null){\n            realImage = new RealImage(fileName);\n        }\n        realImage.display();\n    }\n}\n```\n\n静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br>\nJava中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。\n\n```Java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DisplayHandler implements InvocationHandler {\n\n    //要代理的真实对象\n    private Object obj;\n\n    public DisplayHandler(Object obj) {\n        this.obj = obj;\n    }\n\n    /**\n     *\n     * @param proxy 代理类代理的真实代理对象\n     * @param method 所要调用某个对象真实的方法的Method对象\n     * @param args 指代代理对象方法传递的参数\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //真实的对象执行之前\n        System.out.println(\"Before invoke...\");\n\n        Object invoke = method.invoke(obj, args);\n\n        //真实的对象执行之后\n        System.out.println(\"After invoke...\");\n        return invoke;\n    }\n}\n\npublic static void main(String[] args) {\n    Image image = new RealImage(\"hello.jpg\");\n    InvocationHandler handler = new DisplayHandler(image);\n\n    /*\n     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象\n     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法\n     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上\n     */\n    Image proxy = (Image) Proxy.newProxyInstance(\n            handler.getClass().getClassLoader(),\n            image.getClass().getInterfaces(),\n            handler);\n    proxy.display();\n}\n```\n控制台输出结果为 \n```\nLoading hello.jpg\nBefore invoke...\nDisplaying hello.jpg\nAfter invoke...\n```\n\n代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。\n\n## 其他\n\n### 过滤器模式\n简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。\n\n### 桥接模式\n桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。\n\n举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。\n\n### 外观模式\n外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。\n\n简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。\n\n\n### 享元模式\n所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点\n\n```Java\npublic class FlyweightFactory{\n\n    static Map<String, Shape> shapes = new HashMap<String, Shape>();\n    \n    public static Shape getShape(String key){\n        Shape shape = shapes.get(key);\n        if(shape == null){\n            shape = new Circle(key);\n            shapes.put(key, shape);\n        }\n        return shape;\n    }\n    \n    public static int getSum(){\n        return shapes.size();\n    }\n}\n```\n\n### 补充\n从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是\"转换行为\"，外观模式是一种\"简化行为\"。","slug":"Java设计模式：结构型模式","published":1,"updated":"2019-03-12T01:35:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru78r000ef0u8wgsbef0m","content":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<a id=\"more\"></a></p>\n<p>用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此<code>Volt5V</code>称为<code>Target</code>，而不兼容的220V电压称之为<code>Adaptee</code>，我们的目的是适配设计一个<code>Adpater</code>，方法有两种。</p>\n<h3 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volt220V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Volt220V</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Adapter adapter = <span class=\"keyword\">new</span> Adapter();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"获取需要的5V电源：\"</span> + adapter.get5V());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h3><p>与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。<br>　　<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Volt220V volt220V;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObjectAdapter</span><span class=\"params\">(Volt220V adaptee)</span> </span>&#123;</span><br><span class=\"line\">        volt220V = adaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> volt220V.get220V();</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 Android 中 ListView 中的 Adapter，可以参考：<a href=\"https://blog.csdn.net/bboyfeiyu/article/details/43950185\" target=\"_blank\" rel=\"noopener\">Android源码之ListView的适配器模式</a></p>\n<h2 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h2><p>将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。</p>\n<ul>\n<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>\n<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>\n<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。</li>\n</ul>\n<p>对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象构件，声明一个接口用于访问和管理Component的子部件</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示层级结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//叶子节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-\"</span> + level);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枝节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Component&gt; children = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.add(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.remove(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        children.forEach(</span><br><span class=\"line\">                component -&gt; component.Display(level + <span class=\"number\">2</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。</p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>向一个现有的对象添加新的功能，同时又不改变其结构。<br><br>创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Draw a circle\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现了 Shape 接口的抽象装饰类。</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeDecorator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Shape decoratedShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.decoratedShape = decoratedShape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//具体的装饰类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedShapeDecorator</span> <span class=\"keyword\">extends</span> <span class=\"title\">ShapeDecorator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">        setRedBorder(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedBorder</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Border color: Red\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RealImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">        loadFromDisk(fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Displaying \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromDisk</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Loading \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealImage realImage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(realImage == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            realImage = <span class=\"keyword\">new</span> RealImage(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        realImage.display();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br><br>Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisplayHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//要代理的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DisplayHandler</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类代理的真实代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 所要调用某个对象真实的方法的Method对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 指代代理对象方法传递的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Before invoke...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object invoke = method.invoke(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After invoke...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Image image = <span class=\"keyword\">new</span> RealImage(<span class=\"string\">\"hello.jpg\"</span>);</span><br><span class=\"line\">    InvocationHandler handler = <span class=\"keyword\">new</span> DisplayHandler(image);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Image proxy = (Image) Proxy.newProxyInstance(</span><br><span class=\"line\">            handler.getClass().getClassLoader(),</span><br><span class=\"line\">            image.getClass().getInterfaces(),</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    proxy.display();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Loading hello.jpg</span><br><span class=\"line\">Before invoke...</span><br><span class=\"line\">Displaying hello.jpg</span><br><span class=\"line\">After invoke...</span><br></pre></td></tr></table></figure></p>\n<p>代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"过滤器模式\"><a href=\"#过滤器模式\" class=\"headerlink\" title=\"过滤器模式\"></a>过滤器模式</h3><p>简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。</p>\n<h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。</p>\n<p>举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。</p>\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>\n<p>简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。</p>\n<h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><p>所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlyweightFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;String, Shape&gt; shapes = <span class=\"keyword\">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">getShape</span><span class=\"params\">(String key)</span></span>&#123;</span><br><span class=\"line\">        Shape shape = shapes.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shape == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            shape = <span class=\"keyword\">new</span> Circle(key);</span><br><span class=\"line\">            shapes.put(key, shape);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shapes.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>","more":"<p></p>\n<p>用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此<code>Volt5V</code>称为<code>Target</code>，而不兼容的220V电压称之为<code>Adaptee</code>，我们的目的是适配设计一个<code>Adpater</code>，方法有两种。</p>\n<h3 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volt220V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Volt220V</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Adapter adapter = <span class=\"keyword\">new</span> Adapter();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"获取需要的5V电源：\"</span> + adapter.get5V());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h3><p>与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。<br>　　<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Volt220V volt220V;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObjectAdapter</span><span class=\"params\">(Volt220V adaptee)</span> </span>&#123;</span><br><span class=\"line\">        volt220V = adaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> volt220V.get220V();</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 Android 中 ListView 中的 Adapter，可以参考：<a href=\"https://blog.csdn.net/bboyfeiyu/article/details/43950185\" target=\"_blank\" rel=\"noopener\">Android源码之ListView的适配器模式</a></p>\n<h2 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h2><p>将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。</p>\n<ul>\n<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>\n<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>\n<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。</li>\n</ul>\n<p>对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象构件，声明一个接口用于访问和管理Component的子部件</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示层级结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//叶子节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-\"</span> + level);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枝节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Component&gt; children = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.add(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.remove(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        children.forEach(</span><br><span class=\"line\">                component -&gt; component.Display(level + <span class=\"number\">2</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。</p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>向一个现有的对象添加新的功能，同时又不改变其结构。<br><br>创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Draw a circle\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现了 Shape 接口的抽象装饰类。</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeDecorator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Shape decoratedShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.decoratedShape = decoratedShape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//具体的装饰类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedShapeDecorator</span> <span class=\"keyword\">extends</span> <span class=\"title\">ShapeDecorator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">        setRedBorder(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedBorder</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Border color: Red\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RealImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">        loadFromDisk(fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Displaying \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromDisk</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Loading \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealImage realImage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(realImage == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            realImage = <span class=\"keyword\">new</span> RealImage(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        realImage.display();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br><br>Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisplayHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//要代理的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DisplayHandler</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类代理的真实代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 所要调用某个对象真实的方法的Method对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 指代代理对象方法传递的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Before invoke...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object invoke = method.invoke(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After invoke...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Image image = <span class=\"keyword\">new</span> RealImage(<span class=\"string\">\"hello.jpg\"</span>);</span><br><span class=\"line\">    InvocationHandler handler = <span class=\"keyword\">new</span> DisplayHandler(image);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Image proxy = (Image) Proxy.newProxyInstance(</span><br><span class=\"line\">            handler.getClass().getClassLoader(),</span><br><span class=\"line\">            image.getClass().getInterfaces(),</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    proxy.display();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Loading hello.jpg</span><br><span class=\"line\">Before invoke...</span><br><span class=\"line\">Displaying hello.jpg</span><br><span class=\"line\">After invoke...</span><br></pre></td></tr></table></figure></p>\n<p>代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"过滤器模式\"><a href=\"#过滤器模式\" class=\"headerlink\" title=\"过滤器模式\"></a>过滤器模式</h3><p>简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。</p>\n<h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。</p>\n<p>举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。</p>\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>\n<p>简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。</p>\n<h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><p>所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlyweightFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;String, Shape&gt; shapes = <span class=\"keyword\">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">getShape</span><span class=\"params\">(String key)</span></span>&#123;</span><br><span class=\"line\">        Shape shape = shapes.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shape == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            shape = <span class=\"keyword\">new</span> Circle(key);</span><br><span class=\"line\">            shapes.put(key, shape);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shapes.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。</p>"},{"title":"LeakCanary源码解析","date":"2019-03-13T05:28:31.000Z","_content":"\n## 引言\n内存泄漏是 Android 开发中无法避免的问题，[LeakCanary](https://github.com/square/leakcanary) 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<!--more-->\n\n## ActivityLifecycleCallbacks\nLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。\n\n### 接口方法\n可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。\n\n```Java\n    public interface ActivityLifecycleCallbacks {\n        void onActivityCreated(Activity activity, Bundle savedInstanceState);\n        void onActivityStarted(Activity activity);\n        void onActivityResumed(Activity activity);\n        void onActivityPaused(Activity activity);\n        void onActivityStopped(Activity activity);\n        void onActivitySaveInstanceState(Activity activity, Bundle outState);\n        void onActivityDestroyed(Activity activity);\n    }\n```\n\n### 简单用法\n开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。\n```Java\npublic class MyApplication extends Application {\n\n    public static List<Activity> activityList;\n    public static final int ACTIVITY_MAX_NUM = 10;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        activityList = new LinkedList<>();\n        registerActivityLifecycleCallbacks(new MyActivityCallbacks());\n    }\n\n    class MyActivityCallbacks implements ActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            if (activityList.size() >= ACTIVITY_MAX_NUM) {\n                activityList.remove(activityList.size()-1).finish();\n            }\n            activityList.add(activity);\n        }\n\n        @Override\n        public void onActivityStarted(Activity activity) { }\n\n        @Override\n        public void onActivityResumed(Activity activity) { }\n\n        @Override\n        public void onActivityPaused(Activity activity) { }\n\n        @Override\n        public void onActivityStopped(Activity activity) { }\n\n        @Override\n        public void onActivitySaveInstanceState(Activity activity, Bundle outState) { }\n\n        @Override\n        public void onActivityDestroyed(Activity activity) {\n            activityList.remove(activity);\n        }\n    }\n    \n    public static Activity getCurrentActivity() {\n        return activityList.get(0);\n    }\n}\n```\n\n## 引用类型\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。\n\n### 强引用\n强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的`A a = new A()`中的引用a。\n\n### 软引用\n软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。\n```Java\nSoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));\nSystem.out.println(sr.get());\n```\n\n### 弱引用\n弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n```Java\nWeakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n         \nSystem.out.println(sr.get());\nSystem.gc();                //通知JVM的gc进行垃圾回收\nSystem.out.println(sr.get());\n```\n打印的结果为\n> hello\n<br>null\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n```Java\nReferenceQueue queue = new ReferenceQueue();\nWeakReference pr = new WeakReference(object, queue);\n```\n\n### 虚引用\nPhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其`get()`永远返回`null`\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n```Java\npublic class PhantomReference<T> extends Reference<T> {\n\n    public T get() {\n        return null;\n    }\n\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n## LeakCanary源码\n实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。\n\n### 执行流程\n跟踪调用的入口方法`install`\n```Java\npublic static @NonNull RefWatcher install(@NonNull Application application) {\n    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n}\n```\n\n`listenerServiceClass`方法位于 AndroidRefWatcherBuilder\n\n```Java\npublic @NonNull AndroidRefWatcherBuilder listenerServiceClass(\n      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {\n      \n    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);\n    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));\n}\n```\n该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和`excludedRefs`方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：\n\n```Java\npublic @NonNull RefWatcher buildAndInstall() {\n    if (LeakCanaryInternals.installedRefWatcher != null) {\n        throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\");\n    }\n    RefWatcher refWatcher = build();\n    if (refWatcher != DISABLED) {\n        if (enableDisplayLeakActivity) {\n            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);\n        }\n        if (watchActivities) {\n            ActivityRefWatcher.install(context, refWatcher);\n        }\n        if (watchFragments) {\n            FragmentRefWatcher.Helper.install(context, refWatcher);\n        }\n    }\n    LeakCanaryInternals.installedRefWatcher = refWatcher;\n    return refWatcher;\n}\n```\n该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪`install`方法\n\n```Java\npublic static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {\n    Application application = (Application) context.getApplicationContext();\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n\n    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);\n}\n\n//成员变量 lifecycleCallbacks\nprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n    new ActivityLifecycleCallbacksAdapter  {\n        @Override public void onActivityDestroyed(Activity activity) {\n            refWatcher.watch(activity);\n        }\n    };\n```\n\n由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。\n\n`watch`方法由 RefWatcher 默认实现：\n\n```Java\npublic void watch(Object watchedReference, String referenceName) {\n    ......  \n    retainedKeys.add(key);\n    final KeyedWeakReference reference =\n            new KeyedWeakReference(watchedReference, key, referenceName, queue);\n\n    ensureGoneAsync(watchStartNanoTime, reference);\n}\n```\n\n其中 retainedKeys 是一个 Set<String> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。 \nKeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。\n\n```Java\nprivate void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {\n    watchExecutor.execute(new Retryable() {\n        @Override public Retryable.Result run() {\n            return ensureGone(reference, watchStartNanoTime);\n        }\n    });\n}\n```\n\nwatchExecutor 为 AndroidWatchExecutor 对象\n```\npublic AndroidWatchExecutor(long initialDelayMillis) {\n    mainHandler = new Handler(Looper.getMainLooper());\n    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);\n    handlerThread.start();\n    backgroundHandler = new Handler(handlerThread.getLooper());\n    this.initialDelayMillis = initialDelayMillis;\n    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;\n}\n\n@Override public void execute(@NonNull Retryable retryable) {\n    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\n        waitForIdle(retryable, 0);\n    } else {\n        postWaitForIdle(retryable, 0);\n    }\n}\n```\n在`execute`中，不管是`waitForIdle`还是`postWaitForIdle`都会切换到主线程执行，最终会调用以下代码：\n```Java\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        postToBackgroundWithDelay(retryable, failedAttempts);\n        return false;\n      }\n    });\n```\n那么 IdleHandler 到底是什么呢？\n\n我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。\n\n`ensureGoneAsync`方法最终会调用`ensureGone`\n\n```Java\nRetryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {\n    ......\n    removeWeaklyReachableReferences();\n    ......\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n        ......\n        File heapDumpFile = heapDumper.dumpHeap();\n        ......\n        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)\n            .referenceName(reference.name)\n            .watchDurationMs(watchDurationMs)\n            .gcDurationMs(gcDurationMs)\n            .heapDumpDurationMs(heapDumpDurationMs)\n            .build();\n\n        heapdumpListener.analyze(heapDump);\n    }\n    return DONE;\n}\n```\n\n- `removeWeaklyReachableReferences`遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。\n- 调用`gcTrigger.runGc`去进行内存回收，这里没有使用`System.gc`，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。\n- 主动进行 GC 之后会再次调用`removeWeaklyReachableReferences`清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。\n- 生成性能统计文件.hprof，进行内存泄漏的分析。\n\n那么 hprof 文件是被解析成信息的呢\n\n```Java\nAnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);\n```\n\n```Java\npublic AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {\n    ......\n    MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile);\n    HprofParser parser = new HprofParser(e);\n    Snapshot snapshot = parser.parse();\n    this.deduplicateGcRoots(snapshot);\n    Instance leakingRef = this.findLeakingReference(referenceKey, snapshot);\n    return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ：\n        this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);\n}\n```\n\n`checkForLeak`方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的`parse`方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。\n\n得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。\n\n### 总结\nLeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。\n","source":"_posts/LeakCanary源码解析.md","raw":"---\ntitle: LeakCanary源码解析\ndate: 2019-03-13 13:28:31\ncategories:\n- Android\n---\n\n## 引言\n内存泄漏是 Android 开发中无法避免的问题，[LeakCanary](https://github.com/square/leakcanary) 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<!--more-->\n\n## ActivityLifecycleCallbacks\nLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。\n\n### 接口方法\n可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。\n\n```Java\n    public interface ActivityLifecycleCallbacks {\n        void onActivityCreated(Activity activity, Bundle savedInstanceState);\n        void onActivityStarted(Activity activity);\n        void onActivityResumed(Activity activity);\n        void onActivityPaused(Activity activity);\n        void onActivityStopped(Activity activity);\n        void onActivitySaveInstanceState(Activity activity, Bundle outState);\n        void onActivityDestroyed(Activity activity);\n    }\n```\n\n### 简单用法\n开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。\n```Java\npublic class MyApplication extends Application {\n\n    public static List<Activity> activityList;\n    public static final int ACTIVITY_MAX_NUM = 10;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        activityList = new LinkedList<>();\n        registerActivityLifecycleCallbacks(new MyActivityCallbacks());\n    }\n\n    class MyActivityCallbacks implements ActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            if (activityList.size() >= ACTIVITY_MAX_NUM) {\n                activityList.remove(activityList.size()-1).finish();\n            }\n            activityList.add(activity);\n        }\n\n        @Override\n        public void onActivityStarted(Activity activity) { }\n\n        @Override\n        public void onActivityResumed(Activity activity) { }\n\n        @Override\n        public void onActivityPaused(Activity activity) { }\n\n        @Override\n        public void onActivityStopped(Activity activity) { }\n\n        @Override\n        public void onActivitySaveInstanceState(Activity activity, Bundle outState) { }\n\n        @Override\n        public void onActivityDestroyed(Activity activity) {\n            activityList.remove(activity);\n        }\n    }\n    \n    public static Activity getCurrentActivity() {\n        return activityList.get(0);\n    }\n}\n```\n\n## 引用类型\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。\n\n### 强引用\n强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的`A a = new A()`中的引用a。\n\n### 软引用\n软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。\n```Java\nSoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));\nSystem.out.println(sr.get());\n```\n\n### 弱引用\n弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n```Java\nWeakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n         \nSystem.out.println(sr.get());\nSystem.gc();                //通知JVM的gc进行垃圾回收\nSystem.out.println(sr.get());\n```\n打印的结果为\n> hello\n<br>null\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n```Java\nReferenceQueue queue = new ReferenceQueue();\nWeakReference pr = new WeakReference(object, queue);\n```\n\n### 虚引用\nPhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其`get()`永远返回`null`\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n```Java\npublic class PhantomReference<T> extends Reference<T> {\n\n    public T get() {\n        return null;\n    }\n\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n## LeakCanary源码\n实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。\n\n### 执行流程\n跟踪调用的入口方法`install`\n```Java\npublic static @NonNull RefWatcher install(@NonNull Application application) {\n    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n}\n```\n\n`listenerServiceClass`方法位于 AndroidRefWatcherBuilder\n\n```Java\npublic @NonNull AndroidRefWatcherBuilder listenerServiceClass(\n      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {\n      \n    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);\n    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));\n}\n```\n该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和`excludedRefs`方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：\n\n```Java\npublic @NonNull RefWatcher buildAndInstall() {\n    if (LeakCanaryInternals.installedRefWatcher != null) {\n        throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\");\n    }\n    RefWatcher refWatcher = build();\n    if (refWatcher != DISABLED) {\n        if (enableDisplayLeakActivity) {\n            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);\n        }\n        if (watchActivities) {\n            ActivityRefWatcher.install(context, refWatcher);\n        }\n        if (watchFragments) {\n            FragmentRefWatcher.Helper.install(context, refWatcher);\n        }\n    }\n    LeakCanaryInternals.installedRefWatcher = refWatcher;\n    return refWatcher;\n}\n```\n该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪`install`方法\n\n```Java\npublic static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {\n    Application application = (Application) context.getApplicationContext();\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n\n    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);\n}\n\n//成员变量 lifecycleCallbacks\nprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n    new ActivityLifecycleCallbacksAdapter  {\n        @Override public void onActivityDestroyed(Activity activity) {\n            refWatcher.watch(activity);\n        }\n    };\n```\n\n由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。\n\n`watch`方法由 RefWatcher 默认实现：\n\n```Java\npublic void watch(Object watchedReference, String referenceName) {\n    ......  \n    retainedKeys.add(key);\n    final KeyedWeakReference reference =\n            new KeyedWeakReference(watchedReference, key, referenceName, queue);\n\n    ensureGoneAsync(watchStartNanoTime, reference);\n}\n```\n\n其中 retainedKeys 是一个 Set<String> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。 \nKeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。\n\n```Java\nprivate void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {\n    watchExecutor.execute(new Retryable() {\n        @Override public Retryable.Result run() {\n            return ensureGone(reference, watchStartNanoTime);\n        }\n    });\n}\n```\n\nwatchExecutor 为 AndroidWatchExecutor 对象\n```\npublic AndroidWatchExecutor(long initialDelayMillis) {\n    mainHandler = new Handler(Looper.getMainLooper());\n    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);\n    handlerThread.start();\n    backgroundHandler = new Handler(handlerThread.getLooper());\n    this.initialDelayMillis = initialDelayMillis;\n    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;\n}\n\n@Override public void execute(@NonNull Retryable retryable) {\n    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\n        waitForIdle(retryable, 0);\n    } else {\n        postWaitForIdle(retryable, 0);\n    }\n}\n```\n在`execute`中，不管是`waitForIdle`还是`postWaitForIdle`都会切换到主线程执行，最终会调用以下代码：\n```Java\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        postToBackgroundWithDelay(retryable, failedAttempts);\n        return false;\n      }\n    });\n```\n那么 IdleHandler 到底是什么呢？\n\n我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。\n\n`ensureGoneAsync`方法最终会调用`ensureGone`\n\n```Java\nRetryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {\n    ......\n    removeWeaklyReachableReferences();\n    ......\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n        ......\n        File heapDumpFile = heapDumper.dumpHeap();\n        ......\n        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)\n            .referenceName(reference.name)\n            .watchDurationMs(watchDurationMs)\n            .gcDurationMs(gcDurationMs)\n            .heapDumpDurationMs(heapDumpDurationMs)\n            .build();\n\n        heapdumpListener.analyze(heapDump);\n    }\n    return DONE;\n}\n```\n\n- `removeWeaklyReachableReferences`遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。\n- 调用`gcTrigger.runGc`去进行内存回收，这里没有使用`System.gc`，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。\n- 主动进行 GC 之后会再次调用`removeWeaklyReachableReferences`清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。\n- 生成性能统计文件.hprof，进行内存泄漏的分析。\n\n那么 hprof 文件是被解析成信息的呢\n\n```Java\nAnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);\n```\n\n```Java\npublic AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {\n    ......\n    MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile);\n    HprofParser parser = new HprofParser(e);\n    Snapshot snapshot = parser.parse();\n    this.deduplicateGcRoots(snapshot);\n    Instance leakingRef = this.findLeakingReference(referenceKey, snapshot);\n    return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ：\n        this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);\n}\n```\n\n`checkForLeak`方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的`parse`方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。\n\n得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。\n\n### 总结\nLeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。\n","slug":"LeakCanary源码解析","published":1,"updated":"2019-03-13T05:34:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru78t000ff0u8b93mk72j","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>内存泄漏是 Android 开发中无法避免的问题，<a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"noopener\">LeakCanary</a> 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<a id=\"more\"></a></p>\n<h2 id=\"ActivityLifecycleCallbacks\"><a href=\"#ActivityLifecycleCallbacks\" class=\"headerlink\" title=\"ActivityLifecycleCallbacks\"></a>ActivityLifecycleCallbacks</h2><p>LeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。</p>\n<h3 id=\"接口方法\"><a href=\"#接口方法\" class=\"headerlink\" title=\"接口方法\"></a>接口方法</h3><p>可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h3><p>开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Activity&gt; activityList;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_MAX_NUM = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        activityList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> MyActivityCallbacks());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivityCallbacks</span> <span class=\"keyword\">implements</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activityList.size() &gt;= ACTIVITY_MAX_NUM) &#123;</span><br><span class=\"line\">                activityList.remove(activityList.size()-<span class=\"number\">1</span>).finish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            activityList.remove(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity <span class=\"title\">getCurrentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activityList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的<code>A a = new A()</code>中的引用a。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;String&gt; sr = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">         </span><br><span class=\"line\">System.out.println(sr.get());</span><br><span class=\"line\">System.gc();                <span class=\"comment\">//通知JVM的gc进行垃圾回收</span></span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<p>打印的结果为</p>\n<blockquote>\n<p>hello<br><br>null</p>\n</blockquote>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">WeakReference pr = <span class=\"keyword\">new</span> WeakReference(object, queue);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其<code>get()</code>永远返回<code>null</code></p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LeakCanary源码\"><a href=\"#LeakCanary源码\" class=\"headerlink\" title=\"LeakCanary源码\"></a>LeakCanary源码</h2><p>实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>跟踪调用的入口方法<code>install</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">install</span><span class=\"params\">(@NonNull Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class=\"line\">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class=\"line\">        .buildAndInstall();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>listenerServiceClass</code>方法位于 AndroidRefWatcherBuilder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">AndroidRefWatcherBuilder <span class=\"title\">listenerServiceClass</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heapDumpListener(<span class=\"keyword\">new</span> ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和<code>excludedRefs</code>方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">buildAndInstall</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LeakCanaryInternals.installedRefWatcher != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"buildAndInstall() should only be called once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RefWatcher refWatcher = build();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refWatcher != DISABLED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class=\"line\">            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchActivities) &#123;</span><br><span class=\"line\">            ActivityRefWatcher.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchFragments) &#123;</span><br><span class=\"line\">            FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪<code>install</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class=\"line\">    Application application = (Application) context.getApplicationContext();</span><br><span class=\"line\">    ActivityRefWatcher activityRefWatcher = <span class=\"keyword\">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//成员变量 lifecycleCallbacks</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ActivityLifecycleCallbacksAdapter  &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            refWatcher.watch(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。</p>\n<p><code>watch</code>方法由 RefWatcher 默认实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">watch</span><span class=\"params\">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">    retainedKeys.add(key);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> KeyedWeakReference reference =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 retainedKeys 是一个 Set<string> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。<br>KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。</string></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureGoneAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime, <span class=\"keyword\">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class=\"line\">    watchExecutor.execute(<span class=\"keyword\">new</span> Retryable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> Retryable.<span class=\"function\">Result <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>watchExecutor 为 AndroidWatchExecutor 对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AndroidWatchExecutor(long initialDelayMillis) &#123;</span><br><span class=\"line\">    mainHandler = new Handler(Looper.getMainLooper());</span><br><span class=\"line\">    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    backgroundHandler = new Handler(handlerThread.getLooper());</span><br><span class=\"line\">    this.initialDelayMillis = initialDelayMillis;</span><br><span class=\"line\">    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override public void execute(@NonNull Retryable retryable) &#123;</span><br><span class=\"line\">    if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class=\"line\">        waitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        postWaitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>execute</code>中，不管是<code>waitForIdle</code>还是<code>postWaitForIdle</code>都会切换到主线程执行，最终会调用以下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>那么 IdleHandler 到底是什么呢？</p>\n<p>我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。</p>\n<p><code>ensureGoneAsync</code>方法最终会调用<code>ensureGone</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retryable.<span class=\"function\">Result <span class=\"title\">ensureGone</span><span class=\"params\">(<span class=\"keyword\">final</span> KeyedWeakReference reference, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    gcTrigger.runGc();</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gone(reference)) &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        File heapDumpFile = heapDumper.dumpHeap();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class=\"line\">            .referenceName(reference.name)</span><br><span class=\"line\">            .watchDurationMs(watchDurationMs)</span><br><span class=\"line\">            .gcDurationMs(gcDurationMs)</span><br><span class=\"line\">            .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        heapdumpListener.analyze(heapDump);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DONE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>removeWeaklyReachableReferences</code>遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。</li>\n<li>调用<code>gcTrigger.runGc</code>去进行内存回收，这里没有使用<code>System.gc</code>，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。</li>\n<li>主动进行 GC 之后会再次调用<code>removeWeaklyReachableReferences</code>清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。</li>\n<li>生成性能统计文件.hprof，进行内存泄漏的分析。</li>\n</ul>\n<p>那么 hprof 文件是被解析成信息的呢</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AnalysisResult <span class=\"title\">checkForLeak</span><span class=\"params\">(File heapDumpFile, String referenceKey)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    MemoryMappedFileBuffer e = <span class=\"keyword\">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class=\"line\">    HprofParser parser = <span class=\"keyword\">new</span> HprofParser(e);</span><br><span class=\"line\">    Snapshot snapshot = parser.parse();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deduplicateGcRoots(snapshot);</span><br><span class=\"line\">    Instance leakingRef = <span class=\"keyword\">this</span>.findLeakingReference(referenceKey, snapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leakingRef == <span class=\"keyword\">null</span> ? AnalysisResult.noLeak(<span class=\"keyword\">this</span>.since(analysisStartNanoTime)) ：</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>checkForLeak</code>方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的<code>parse</code>方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。</p>\n<p>得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>内存泄漏是 Android 开发中无法避免的问题，<a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"noopener\">LeakCanary</a> 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。</p>","more":"<p></p>\n<h2 id=\"ActivityLifecycleCallbacks\"><a href=\"#ActivityLifecycleCallbacks\" class=\"headerlink\" title=\"ActivityLifecycleCallbacks\"></a>ActivityLifecycleCallbacks</h2><p>LeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。</p>\n<h3 id=\"接口方法\"><a href=\"#接口方法\" class=\"headerlink\" title=\"接口方法\"></a>接口方法</h3><p>可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h3><p>开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Activity&gt; activityList;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_MAX_NUM = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        activityList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> MyActivityCallbacks());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivityCallbacks</span> <span class=\"keyword\">implements</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activityList.size() &gt;= ACTIVITY_MAX_NUM) &#123;</span><br><span class=\"line\">                activityList.remove(activityList.size()-<span class=\"number\">1</span>).finish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            activityList.remove(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity <span class=\"title\">getCurrentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activityList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的<code>A a = new A()</code>中的引用a。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;String&gt; sr = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">         </span><br><span class=\"line\">System.out.println(sr.get());</span><br><span class=\"line\">System.gc();                <span class=\"comment\">//通知JVM的gc进行垃圾回收</span></span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<p>打印的结果为</p>\n<blockquote>\n<p>hello<br><br>null</p>\n</blockquote>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">WeakReference pr = <span class=\"keyword\">new</span> WeakReference(object, queue);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其<code>get()</code>永远返回<code>null</code></p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LeakCanary源码\"><a href=\"#LeakCanary源码\" class=\"headerlink\" title=\"LeakCanary源码\"></a>LeakCanary源码</h2><p>实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>跟踪调用的入口方法<code>install</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">install</span><span class=\"params\">(@NonNull Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class=\"line\">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class=\"line\">        .buildAndInstall();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>listenerServiceClass</code>方法位于 AndroidRefWatcherBuilder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">AndroidRefWatcherBuilder <span class=\"title\">listenerServiceClass</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heapDumpListener(<span class=\"keyword\">new</span> ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和<code>excludedRefs</code>方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">buildAndInstall</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LeakCanaryInternals.installedRefWatcher != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"buildAndInstall() should only be called once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RefWatcher refWatcher = build();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refWatcher != DISABLED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class=\"line\">            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchActivities) &#123;</span><br><span class=\"line\">            ActivityRefWatcher.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchFragments) &#123;</span><br><span class=\"line\">            FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪<code>install</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class=\"line\">    Application application = (Application) context.getApplicationContext();</span><br><span class=\"line\">    ActivityRefWatcher activityRefWatcher = <span class=\"keyword\">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//成员变量 lifecycleCallbacks</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ActivityLifecycleCallbacksAdapter  &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            refWatcher.watch(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。</p>\n<p><code>watch</code>方法由 RefWatcher 默认实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">watch</span><span class=\"params\">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">    retainedKeys.add(key);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> KeyedWeakReference reference =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 retainedKeys 是一个 Set<string> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。<br>KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。</string></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureGoneAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime, <span class=\"keyword\">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class=\"line\">    watchExecutor.execute(<span class=\"keyword\">new</span> Retryable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> Retryable.<span class=\"function\">Result <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>watchExecutor 为 AndroidWatchExecutor 对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AndroidWatchExecutor(long initialDelayMillis) &#123;</span><br><span class=\"line\">    mainHandler = new Handler(Looper.getMainLooper());</span><br><span class=\"line\">    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    backgroundHandler = new Handler(handlerThread.getLooper());</span><br><span class=\"line\">    this.initialDelayMillis = initialDelayMillis;</span><br><span class=\"line\">    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override public void execute(@NonNull Retryable retryable) &#123;</span><br><span class=\"line\">    if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class=\"line\">        waitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        postWaitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>execute</code>中，不管是<code>waitForIdle</code>还是<code>postWaitForIdle</code>都会切换到主线程执行，最终会调用以下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>那么 IdleHandler 到底是什么呢？</p>\n<p>我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。</p>\n<p><code>ensureGoneAsync</code>方法最终会调用<code>ensureGone</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retryable.<span class=\"function\">Result <span class=\"title\">ensureGone</span><span class=\"params\">(<span class=\"keyword\">final</span> KeyedWeakReference reference, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    gcTrigger.runGc();</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gone(reference)) &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        File heapDumpFile = heapDumper.dumpHeap();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class=\"line\">            .referenceName(reference.name)</span><br><span class=\"line\">            .watchDurationMs(watchDurationMs)</span><br><span class=\"line\">            .gcDurationMs(gcDurationMs)</span><br><span class=\"line\">            .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        heapdumpListener.analyze(heapDump);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DONE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>removeWeaklyReachableReferences</code>遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。</li>\n<li>调用<code>gcTrigger.runGc</code>去进行内存回收，这里没有使用<code>System.gc</code>，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。</li>\n<li>主动进行 GC 之后会再次调用<code>removeWeaklyReachableReferences</code>清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。</li>\n<li>生成性能统计文件.hprof，进行内存泄漏的分析。</li>\n</ul>\n<p>那么 hprof 文件是被解析成信息的呢</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AnalysisResult <span class=\"title\">checkForLeak</span><span class=\"params\">(File heapDumpFile, String referenceKey)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    MemoryMappedFileBuffer e = <span class=\"keyword\">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class=\"line\">    HprofParser parser = <span class=\"keyword\">new</span> HprofParser(e);</span><br><span class=\"line\">    Snapshot snapshot = parser.parse();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deduplicateGcRoots(snapshot);</span><br><span class=\"line\">    Instance leakingRef = <span class=\"keyword\">this</span>.findLeakingReference(referenceKey, snapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leakingRef == <span class=\"keyword\">null</span> ? AnalysisResult.noLeak(<span class=\"keyword\">this</span>.since(analysisStartNanoTime)) ：</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>checkForLeak</code>方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的<code>parse</code>方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。</p>\n<p>得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。</p>"},{"title":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","date":"2019-01-13T15:09:12.000Z","_content":"\n## 引言\n 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<!--more-->\n\n “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。\n\n 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。\n\n 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：[巴赫《六首无伴奏大提琴组曲》斯塔克](https://music.163.com/#/playlist?id=596314970)\n\n\n ## 正文\n 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。\n\n如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。\n那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。\n\n回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。\n\n探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。\n\n如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。\n\n应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。\n\n12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。\n\n马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。\n\n在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。\n\n在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。\n\n最感人的还是大师们晚年的演奏，情感饱足，回归天真。\n\n罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。\n\n罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。\n\n俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。\n\n法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。\n\n只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜","source":"_posts/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》.md","raw":"---\ntitle: 巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》\ndate: 2019-01-13 23:09:12\ncategories:\n- 艺术\n---\n\n## 引言\n 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<!--more-->\n\n “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。\n\n 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。\n\n 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：[巴赫《六首无伴奏大提琴组曲》斯塔克](https://music.163.com/#/playlist?id=596314970)\n\n\n ## 正文\n 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。\n\n如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。\n那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。\n\n回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。\n\n探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。\n\n如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。\n\n应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。\n\n12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。\n\n马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。\n\n在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。\n\n在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。\n\n最感人的还是大师们晚年的演奏，情感饱足，回归天真。\n\n罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。\n\n罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。\n\n俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。\n\n法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。\n\n只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜","slug":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","published":1,"updated":"2019-03-12T01:35:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru78u000gf0u8r86vygvs","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p> 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<a id=\"more\"></a></p>\n<p> “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。</p>\n<p> 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。</p>\n<p> 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：<a href=\"https://music.163.com/#/playlist?id=596314970\" target=\"_blank\" rel=\"noopener\">巴赫《六首无伴奏大提琴组曲》斯塔克</a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p> 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。</p>\n<p>如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。<br>那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。</p>\n<p>回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。</p>\n<p>探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。</p>\n<p>如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。</p>\n<p>应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。</p>\n<p>12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。</p>\n<p>马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。</p>\n<p>在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。</p>\n<p>在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。</p>\n<p>最感人的还是大师们晚年的演奏，情感饱足，回归天真。</p>\n<p>罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。</p>\n<p>罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。</p>\n<p>俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。</p>\n<p>法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。</p>\n<p>只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p> 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。</p>","more":"<p></p>\n<p> “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。</p>\n<p> 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。</p>\n<p> 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：<a href=\"https://music.163.com/#/playlist?id=596314970\" target=\"_blank\" rel=\"noopener\">巴赫《六首无伴奏大提琴组曲》斯塔克</a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p> 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。</p>\n<p>如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。<br>那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。</p>\n<p>回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。</p>\n<p>探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。</p>\n<p>如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。</p>\n<p>应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。</p>\n<p>12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。</p>\n<p>马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。</p>\n<p>在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。</p>\n<p>在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。</p>\n<p>最感人的还是大师们晚年的演奏，情感饱足，回归天真。</p>\n<p>罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。</p>\n<p>罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。</p>\n<p>俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。</p>\n<p>法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。</p>\n<p>只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜</p>"},{"title":"翻越GFW记","date":"2019-01-12T15:31:31.000Z","_content":"\n## 前言\nGFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录`GFW`所为何物，以及`翻`的原理。<!--more-->\n## GFW\n\n### 所为何物\nGFW：Great Firewall (of the People's Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 \n\n\n形象的描述，在没有 GFW 的时代，访问互联网的方式如下\n\n![原始连接方式](翻越GFW记/原始连接方式.png)\n\nGFW 出现之后，则变成\n\n![GFW存在后的连接方式](翻越GFW记/GFW存在后的连接方式.png)\n\n其内部构造如下\n\n![翻越GFW记/GFW内部结构](翻越GFW记/GFW内部结构.jpg)\n\n它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。\n\nGFW的具体原理可以查看此文章：[全面学习GFW](https://cokebar.info/archives/253)\n\n### 如何工作\n#### 关键字过滤阻断\n关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。\n\n#### IP地址封锁\n路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br> \nGFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。\n\n#### DNS污染、劫持\nDNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br>\n\nDNS劫持和污染的方式有两种： \n\n- 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 \n- 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。\n\n值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：[中国防火长城-污染攻击大事记](https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记)。 \n\n**除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。**\n\n## 翻越记\n\n### 翻\n\n#### 修改Hosts文件\n足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。\n\nHosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。\n\n所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。\n\n#### SSH Tunnel\nSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br>\n\n![SSH连接方式](翻越GFW记/SSH连接方式.png)\n1. 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)\n2. 用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)\n3. 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)\n\n由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。\n\n#### VPN\n对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。\n\nVPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。\n\nVPN 的特点如下：\n- VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。\n- 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。\n- VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。\n\n#### Shadowsocks\nVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。\n\n技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下\n\n![SS连接方式](翻越GFW记/SS连接方式.png)\n\n- 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题\n- 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密\n- 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。\n\n相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。\n\n##### Shadowsocks-R\n虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。\n\n作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。\n\n##### V2Ray\nV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。\n\n### 记\n\n- 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。\n- 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。\n- 2004年，维基百科遭遇网络封锁，至今未解封。\n- 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。\n- 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。\n- 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。\n- 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。\n- 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。\n\n## 结语\n从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。\n\n翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。\n\n本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。","source":"_posts/翻越GFW记.md","raw":"---\ntitle: 翻越GFW记\ndate: 2019-01-12 23:31:31\ncategories:\n- 互联网\n---\n\n## 前言\nGFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录`GFW`所为何物，以及`翻`的原理。<!--more-->\n## GFW\n\n### 所为何物\nGFW：Great Firewall (of the People's Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 \n\n\n形象的描述，在没有 GFW 的时代，访问互联网的方式如下\n\n![原始连接方式](翻越GFW记/原始连接方式.png)\n\nGFW 出现之后，则变成\n\n![GFW存在后的连接方式](翻越GFW记/GFW存在后的连接方式.png)\n\n其内部构造如下\n\n![翻越GFW记/GFW内部结构](翻越GFW记/GFW内部结构.jpg)\n\n它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。\n\nGFW的具体原理可以查看此文章：[全面学习GFW](https://cokebar.info/archives/253)\n\n### 如何工作\n#### 关键字过滤阻断\n关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。\n\n#### IP地址封锁\n路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br> \nGFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。\n\n#### DNS污染、劫持\nDNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br>\n\nDNS劫持和污染的方式有两种： \n\n- 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 \n- 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。\n\n值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：[中国防火长城-污染攻击大事记](https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记)。 \n\n**除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。**\n\n## 翻越记\n\n### 翻\n\n#### 修改Hosts文件\n足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。\n\nHosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。\n\n所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。\n\n#### SSH Tunnel\nSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br>\n\n![SSH连接方式](翻越GFW记/SSH连接方式.png)\n1. 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)\n2. 用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)\n3. 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)\n\n由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。\n\n#### VPN\n对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。\n\nVPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。\n\nVPN 的特点如下：\n- VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。\n- 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。\n- VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。\n\n#### Shadowsocks\nVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。\n\n技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下\n\n![SS连接方式](翻越GFW记/SS连接方式.png)\n\n- 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题\n- 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密\n- 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。\n\n相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。\n\n##### Shadowsocks-R\n虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。\n\n作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。\n\n##### V2Ray\nV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。\n\n### 记\n\n- 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。\n- 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。\n- 2004年，维基百科遭遇网络封锁，至今未解封。\n- 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。\n- 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。\n- 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。\n- 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。\n- 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。\n\n## 结语\n从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。\n\n翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。\n\n本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。","slug":"翻越GFW记","published":1,"updated":"2019-01-13T05:49:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt6ru78w000jf0u8bkc2yr2z","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录<code>GFW</code>所为何物，以及<code>翻</code>的原理。<a id=\"more\"></a></p>\n<h2 id=\"GFW\"><a href=\"#GFW\" class=\"headerlink\" title=\"GFW\"></a>GFW</h2><h3 id=\"所为何物\"><a href=\"#所为何物\" class=\"headerlink\" title=\"所为何物\"></a>所为何物</h3><p>GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 </p>\n<p>形象的描述，在没有 GFW 的时代，访问互联网的方式如下</p>\n<p><img src=\"/翻越GFW记/原始连接方式.png\" alt=\"原始连接方式\"></p>\n<p>GFW 出现之后，则变成</p>\n<p><img src=\"/翻越GFW记/GFW存在后的连接方式.png\" alt=\"GFW存在后的连接方式\"></p>\n<p>其内部构造如下</p>\n<p><img src=\"/翻越GFW记/GFW内部结构.jpg\" alt=\"翻越GFW记/GFW内部结构\"></p>\n<p>它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。</p>\n<p>GFW的具体原理可以查看此文章：<a href=\"https://cokebar.info/archives/253\" target=\"_blank\" rel=\"noopener\">全面学习GFW</a></p>\n<h3 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h3><h4 id=\"关键字过滤阻断\"><a href=\"#关键字过滤阻断\" class=\"headerlink\" title=\"关键字过滤阻断\"></a>关键字过滤阻断</h4><p>关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: <a href=\"http://www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送\" target=\"_blank\" rel=\"noopener\">www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送</a> RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。</p>\n<h4 id=\"IP地址封锁\"><a href=\"#IP地址封锁\" class=\"headerlink\" title=\"IP地址封锁\"></a>IP地址封锁</h4><p>路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br><br>GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。</p>\n<h4 id=\"DNS污染、劫持\"><a href=\"#DNS污染、劫持\" class=\"headerlink\" title=\"DNS污染、劫持\"></a>DNS污染、劫持</h4><p>DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br></p>\n<p>DNS劫持和污染的方式有两种： </p>\n<ul>\n<li>一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 </li>\n<li>另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。</li>\n</ul>\n<p>值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记\" target=\"_blank\" rel=\"noopener\">中国防火长城-污染攻击大事记</a>。 </p>\n<p><strong>除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。</strong></p>\n<h2 id=\"翻越记\"><a href=\"#翻越记\" class=\"headerlink\" title=\"翻越记\"></a>翻越记</h2><h3 id=\"翻\"><a href=\"#翻\" class=\"headerlink\" title=\"翻\"></a>翻</h3><h4 id=\"修改Hosts文件\"><a href=\"#修改Hosts文件\" class=\"headerlink\" title=\"修改Hosts文件\"></a>修改Hosts文件</h4><p>足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。</p>\n<p>Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。</p>\n<p>所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。</p>\n<h4 id=\"SSH-Tunnel\"><a href=\"#SSH-Tunnel\" class=\"headerlink\" title=\"SSH Tunnel\"></a>SSH Tunnel</h4><p>SSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br></p>\n<p><img src=\"/翻越GFW记/SSH连接方式.png\" alt=\"SSH连接方式\"></p>\n<ol>\n<li>首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)</li>\n<li>用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)</li>\n<li>服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)</li>\n</ol>\n<p>由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。</p>\n<h4 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h4><p>对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。</p>\n<p>VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。</p>\n<p>VPN 的特点如下：</p>\n<ul>\n<li>VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。</li>\n<li>商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。</li>\n<li>VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。</li>\n</ul>\n<h4 id=\"Shadowsocks\"><a href=\"#Shadowsocks\" class=\"headerlink\" title=\"Shadowsocks\"></a>Shadowsocks</h4><p>VPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。</p>\n<p>技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下</p>\n<p><img src=\"/翻越GFW记/SS连接方式.png\" alt=\"SS连接方式\"></p>\n<ul>\n<li>1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题</li>\n<li>2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密</li>\n<li>3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。</li>\n</ul>\n<p>相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。</p>\n<h5 id=\"Shadowsocks-R\"><a href=\"#Shadowsocks-R\" class=\"headerlink\" title=\"Shadowsocks-R\"></a>Shadowsocks-R</h5><p>虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。</p>\n<p>作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。</p>\n<h5 id=\"V2Ray\"><a href=\"#V2Ray\" class=\"headerlink\" title=\"V2Ray\"></a>V2Ray</h5><p>V2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。</p>\n<h3 id=\"记\"><a href=\"#记\" class=\"headerlink\" title=\"记\"></a>记</h3><ul>\n<li>1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。</li>\n<li>2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。</li>\n<li>2004年，维基百科遭遇网络封锁，至今未解封。</li>\n<li>2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。</li>\n<li>2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。</li>\n<li>2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。</li>\n<li>2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。</li>\n<li>2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。</p>\n<p>翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。</p>\n<p>本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录<code>GFW</code>所为何物，以及<code>翻</code>的原理。</p>","more":"<p></p>\n<h2 id=\"GFW\"><a href=\"#GFW\" class=\"headerlink\" title=\"GFW\"></a>GFW</h2><h3 id=\"所为何物\"><a href=\"#所为何物\" class=\"headerlink\" title=\"所为何物\"></a>所为何物</h3><p>GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 </p>\n<p>形象的描述，在没有 GFW 的时代，访问互联网的方式如下</p>\n<p><img src=\"/翻越GFW记/原始连接方式.png\" alt=\"原始连接方式\"></p>\n<p>GFW 出现之后，则变成</p>\n<p><img src=\"/翻越GFW记/GFW存在后的连接方式.png\" alt=\"GFW存在后的连接方式\"></p>\n<p>其内部构造如下</p>\n<p><img src=\"/翻越GFW记/GFW内部结构.jpg\" alt=\"翻越GFW记/GFW内部结构\"></p>\n<p>它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。</p>\n<p>GFW的具体原理可以查看此文章：<a href=\"https://cokebar.info/archives/253\" target=\"_blank\" rel=\"noopener\">全面学习GFW</a></p>\n<h3 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h3><h4 id=\"关键字过滤阻断\"><a href=\"#关键字过滤阻断\" class=\"headerlink\" title=\"关键字过滤阻断\"></a>关键字过滤阻断</h4><p>关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: <a href=\"http://www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送\" target=\"_blank\" rel=\"noopener\">www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送</a> RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。</p>\n<h4 id=\"IP地址封锁\"><a href=\"#IP地址封锁\" class=\"headerlink\" title=\"IP地址封锁\"></a>IP地址封锁</h4><p>路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br><br>GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。</p>\n<h4 id=\"DNS污染、劫持\"><a href=\"#DNS污染、劫持\" class=\"headerlink\" title=\"DNS污染、劫持\"></a>DNS污染、劫持</h4><p>DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br></p>\n<p>DNS劫持和污染的方式有两种： </p>\n<ul>\n<li>一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 </li>\n<li>另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。</li>\n</ul>\n<p>值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记\" target=\"_blank\" rel=\"noopener\">中国防火长城-污染攻击大事记</a>。 </p>\n<p><strong>除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。</strong></p>\n<h2 id=\"翻越记\"><a href=\"#翻越记\" class=\"headerlink\" title=\"翻越记\"></a>翻越记</h2><h3 id=\"翻\"><a href=\"#翻\" class=\"headerlink\" title=\"翻\"></a>翻</h3><h4 id=\"修改Hosts文件\"><a href=\"#修改Hosts文件\" class=\"headerlink\" title=\"修改Hosts文件\"></a>修改Hosts文件</h4><p>足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。</p>\n<p>Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。</p>\n<p>所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。</p>\n<h4 id=\"SSH-Tunnel\"><a href=\"#SSH-Tunnel\" class=\"headerlink\" title=\"SSH Tunnel\"></a>SSH Tunnel</h4><p>SSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br></p>\n<p><img src=\"/翻越GFW记/SSH连接方式.png\" alt=\"SSH连接方式\"></p>\n<ol>\n<li>首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)</li>\n<li>用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)</li>\n<li>服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)</li>\n</ol>\n<p>由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。</p>\n<h4 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h4><p>对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。</p>\n<p>VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。</p>\n<p>VPN 的特点如下：</p>\n<ul>\n<li>VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。</li>\n<li>商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。</li>\n<li>VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。</li>\n</ul>\n<h4 id=\"Shadowsocks\"><a href=\"#Shadowsocks\" class=\"headerlink\" title=\"Shadowsocks\"></a>Shadowsocks</h4><p>VPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。</p>\n<p>技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下</p>\n<p><img src=\"/翻越GFW记/SS连接方式.png\" alt=\"SS连接方式\"></p>\n<ul>\n<li>1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题</li>\n<li>2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密</li>\n<li>3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。</li>\n</ul>\n<p>相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。</p>\n<h5 id=\"Shadowsocks-R\"><a href=\"#Shadowsocks-R\" class=\"headerlink\" title=\"Shadowsocks-R\"></a>Shadowsocks-R</h5><p>虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。</p>\n<p>作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。</p>\n<h5 id=\"V2Ray\"><a href=\"#V2Ray\" class=\"headerlink\" title=\"V2Ray\"></a>V2Ray</h5><p>V2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。</p>\n<h3 id=\"记\"><a href=\"#记\" class=\"headerlink\" title=\"记\"></a>记</h3><ul>\n<li>1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。</li>\n<li>2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。</li>\n<li>2004年，维基百科遭遇网络封锁，至今未解封。</li>\n<li>2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。</li>\n<li>2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。</li>\n<li>2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。</li>\n<li>2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。</li>\n<li>2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。</p>\n<p>翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。</p>\n<p>本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。</p>"}],"PostAsset":[{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png","post":"cjt6ru73s0005f0u88bmy3ngt","slug":"i-center-right.png","modified":1,"renderable":1},{"_id":"source/_posts/Java设计模式：创建型模式/工厂方法.jpg","post":"cjt6ru78p000df0u8u955ox6e","slug":"工厂方法.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java设计模式：创建型模式/抽象工厂.jpg","post":"cjt6ru78p000df0u8u955ox6e","slug":"抽象工厂.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java设计模式：创建型模式/简单工厂.jpg","post":"cjt6ru78p000df0u8u955ox6e","slug":"简单工厂.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java设计模式：创建型模式/设计模式之间的关系.jpg","post":"cjt6ru78p000df0u8u955ox6e","slug":"设计模式之间的关系.jpg","modified":1,"renderable":1},{"_id":"source/_posts/翻越GFW记/GFW内部结构.jpg","post":"cjt6ru78w000jf0u8bkc2yr2z","slug":"GFW内部结构.jpg","modified":1,"renderable":1},{"_id":"source/_posts/翻越GFW记/GFW存在后的连接方式.png","post":"cjt6ru78w000jf0u8bkc2yr2z","slug":"GFW存在后的连接方式.png","modified":1,"renderable":1},{"_id":"source/_posts/翻越GFW记/SSH连接方式.png","post":"cjt6ru78w000jf0u8bkc2yr2z","slug":"SSH连接方式.png","modified":1,"renderable":1},{"_id":"source/_posts/翻越GFW记/SS连接方式.png","post":"cjt6ru78w000jf0u8bkc2yr2z","slug":"SS连接方式.png","modified":1,"renderable":1},{"_id":"source/_posts/翻越GFW记/原始连接方式.png","post":"cjt6ru78w000jf0u8bkc2yr2z","slug":"原始连接方式.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjt6ru73g0000f0u8ai6lqs2l","category_id":"cjt6ru73p0003f0u8ir1jx1qo","_id":"cjt6ru73u0007f0u81l2zszq2"},{"post_id":"cjt6ru73n0002f0u8n5u42sa6","category_id":"cjt6ru73t0006f0u8yhbn6647","_id":"cjt6ru73v0009f0u8au2isjof"},{"post_id":"cjt6ru73q0004f0u8p7vmagkd","category_id":"cjt6ru73u0008f0u8idkv16e6","_id":"cjt6ru73v000bf0u8x2y3a9he"},{"post_id":"cjt6ru73s0005f0u88bmy3ngt","category_id":"cjt6ru73v000af0u8asuebrg1","_id":"cjt6ru73w000cf0u88s6rpw0x"},{"post_id":"cjt6ru78p000df0u8u955ox6e","category_id":"cjt6ru73t0006f0u8yhbn6647","_id":"cjt6ru78w000hf0u8nmt6w48v"},{"post_id":"cjt6ru78r000ef0u8wgsbef0m","category_id":"cjt6ru73t0006f0u8yhbn6647","_id":"cjt6ru78y000kf0u8i2f98ukh"},{"post_id":"cjt6ru78w000jf0u8bkc2yr2z","category_id":"cjt6ru73p0003f0u8ir1jx1qo","_id":"cjt6ru78z000mf0u8kdfi698t"},{"post_id":"cjt6ru78t000ff0u8b93mk72j","category_id":"cjt6ru78w000if0u8udsfh5un","_id":"cjt6ru78z000nf0u89pt0gzkf"},{"post_id":"cjt6ru78u000gf0u8r86vygvs","category_id":"cjt6ru78z000lf0u89j8njy64","_id":"cjt6ru790000of0u8dheud5yo"}],"PostTag":[],"Tag":[]}}