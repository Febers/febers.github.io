{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":0,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/fexo/.csscomb.json","hash":"1705fe6d52603391eb303751f559eff72170a2a8","modified":1559454818000},{"_id":"themes/fexo/LICENSE","hash":"254873dd0da3d669426d67f255854b3d09f4cd24","modified":1559454818000},{"_id":"themes/fexo/README.md","hash":"1c6a9a4676a3e9c66c47ad772c45c9cb435f9d25","modified":1559454818000},{"_id":"themes/fexo/_config.yml","hash":"0b1e93b941460fc4149d693399f2a1fe0ecb5f1d","modified":1559543584000},{"_id":"themes/fexo/gulpfile.js","hash":"63b37775d9f1c45c12cc35c02e25488b8a5cedc4","modified":1559454818000},{"_id":"themes/fexo/package.json","hash":"8207cbb809c18d514c700338bbb3eb983092a001","modified":1559454818000},{"_id":"source/about/index.md","hash":"bc1e33abe97db8273e6b12f35bb578534dde20a2","modified":1559457084000},{"_id":"source/categories/index.md","hash":"ec919064ec63dd78207bee18e4723073f9f0fb0f","modified":1559456356000},{"_id":"source/_posts/Android-Binder-源码解析.md","hash":"e90e679e212ae40e56f83a5e2a59f476628695f0","modified":1556083912000},{"_id":"source/_posts/Android-IPC-机制详解.md","hash":"b86e3d0877a7ad225a3f72e5d7cf65e62cdd230e","modified":1559451238000},{"_id":"source/_posts/Android-LruCache-缓存详解.md","hash":"275c1982149a408e32ded547031ec1a174bc1dd6","modified":1556883284000},{"_id":"source/_posts/Android-View-的工作原理.md","hash":"eee84230c26d3a342b0f33c88faa0047ee29169e","modified":1559451256000},{"_id":"source/_posts/Android-动画详解.md","hash":"30bb90ace1e80161590e8fed9548f1afbf3383a6","modified":1559451268000},{"_id":"source/_posts/Android-多线程技术.md","hash":"b836f29fe5da6f7e2c0ed43ff1cacd0f370ccc15","modified":1552797826000},{"_id":"source/_posts/Android-消息机制详解.md","hash":"f5a097da1dbe74b0ea7afca20545d8193498df2a","modified":1559451288000},{"_id":"source/_posts/Android-自定义-View-详解.md","hash":"b3ef9cc7a8fc9e8642b5f61677bf975b6022c08a","modified":1559451296000},{"_id":"source/_posts/Dart 基础入门.md","hash":"02ccd7038e43636350555bb376e06b250a16252d","modified":1559451308000},{"_id":"source/_posts/Dart-反射初识.md","hash":"a7ea4600d0730caef2983e1025916c39311b5b16","modified":1559451316000},{"_id":"source/_posts/Dart-异步编程.md","hash":"a667bf6d4d66beb2e564006264e447a1bb7ee29b","modified":1559451330000},{"_id":"source/_posts/Dart-面向对象.md","hash":"372f991a64d4bccc01e52d0238b25da112fba20f","modified":1559451322000},{"_id":"source/_posts/Java-反射详解.md","hash":"4aff185c2643b0943c5b21326c2d82de4211dbda","modified":1559451654000},{"_id":"source/_posts/Java-排序算法.md","hash":"e465849a1f61b230dd9863e11f34272926030abe","modified":1559451662000},{"_id":"source/_posts/Java-数据库知识整理.md","hash":"5a2886478c2dcd5e0f8af5b98fd4628c84c85072","modified":1556083966000},{"_id":"source/_posts/Java-线程和线程池详解.md","hash":"f20407b4547ff43b388ebd6c5f43243ed10e8ec1","modified":1559451738000},{"_id":"source/_posts/Java设计模式：创建型模式.md","hash":"30634f1895fd6a78f837509544a22fb8e3256e32","modified":1552663676000},{"_id":"source/_posts/Java设计模式：结构型模式.md","hash":"996d65a0e4736c5bbb783216335146f5aefedc7f","modified":1552663652000},{"_id":"source/_posts/Java设计模式：行为型模式.md","hash":"2e9aef0d23cedf22dc9baa3202ca1d41de2b53e3","modified":1552663666000},{"_id":"source/_posts/Github-Pages-Hexo搭建个人博客.md","hash":"b65c64ebcc430c4f705c1fb2942dbb4ec8457e30","modified":1559451636000},{"_id":"source/_posts/Kotlin-委托属性详解.md","hash":"91372b6e2e8cb9d841b148f3b3a6d27aba957359","modified":1559451748000},{"_id":"source/_posts/Gradle-构建工具详解.md","hash":"616c5b4093d44b5011d3d723f899474ab68e404c","modified":1559451646000},{"_id":"source/_posts/LeakCanary源码解析.md","hash":"e93db1b595e2869425b20f3213bee7be0ba82239","modified":1559451762000},{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法.md","hash":"9ea33c7070a7884af1a3d948e3b8e39ee7eac400","modified":1552663600000},{"_id":"source/_posts/Markdown-语法详解.md","hash":"c1022e4bfa313add92e7775a5a50cfa0d0daa2cd","modified":1559459448000},{"_id":"source/_posts/Spring-学习笔记（一）：基本理念和-Bean-装配.md","hash":"885e96aee1fc21048b968af0341217d417435cb6","modified":1559391384000},{"_id":"source/_posts/Spring-学习笔记（三）：面向切面.md","hash":"4d1fc7e341c2eaa0ea1a37a12a9fe4ab152ddc87","modified":1559535484000},{"_id":"source/_posts/Spring-学习笔记（二）：高级装配.md","hash":"81627c2167f8b932dee244b0f2dd4c6cb981afb9","modified":1559451828000},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序.md","hash":"33753607c5fe5df95b8cbac7b161db91d7dc613b","modified":1559579084000},{"_id":"source/_posts/《剑指offer》题目-Java-实现.md","hash":"4b63457e80bf290463bd1b63de04a98d261d4c88","modified":1553505426000},{"_id":"source/_posts/《红楼梦》读书笔记.md","hash":"2adfb2191aa1417f7fd18faedf9035476e2ae169","modified":1559483152000},{"_id":"source/_posts/利用反射实现-DrawerLayout-全屏滑动.md","hash":"cea8cb91fac6484c4d074fcfd562bb25f5a5a4db","modified":1559451894000},{"_id":"source/_posts/坐过山车的人.md","hash":"38bc1e373d7ad969f536a27c9645c0457c5c436f","modified":1559451960000},{"_id":"source/_posts/基本数据结构的简单Java实现.md","hash":"a68aece0bd2c5bc81e93dfe20cf071921af0a242","modified":1559451888000},{"_id":"source/_posts/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》.md","hash":"629e1bd3e1f922353377bf731a40b2fefbc17ce7","modified":1559451850000},{"_id":"source/_posts/翻越GFW记.md","hash":"6e0e82b2ac4b0f327e51c551c885e0faf86e709a","modified":1559451876000},{"_id":"source/category/index.md","hash":"7f7244fded59157de316a6b1ba4dbb6fc08a2a5c","modified":1559456374000},{"_id":"source/search/index.md","hash":"50c12c2a6300c2d6355834fda046593a02bd9be0","modified":1559456756000},{"_id":"source/tag/index.md","hash":"34c7b76f347ad9f82a1b085bc6691d24c8fb126b","modified":1559456580000},{"_id":"source/tags/index.md","hash":"f852c5b4f0b945cd2fc74d3bdb87cb37964d6a03","modified":1552664794000},{"_id":"themes/fexo/languages/default.yml","hash":"8024ae389a371b88ba2200199d148cb85441e22b","modified":1559454818000},{"_id":"themes/fexo/languages/en.yml","hash":"46409ca1352107db0d12e3620649f50dab89c1f9","modified":1559454818000},{"_id":"themes/fexo/languages/no.yml","hash":"d9a1b34d590f94ab5c03809754e62bc4cf0e8d0f","modified":1559454818000},{"_id":"themes/fexo/languages/zh-CN.yml","hash":"8024ae389a371b88ba2200199d148cb85441e22b","modified":1559454818000},{"_id":"themes/fexo/languages/zh-TW.yml","hash":"b2474b775a8fa0fa3e9e3c58ddb11b20cf65dbc5","modified":1559454818000},{"_id":"themes/fexo/layout/about.ejs","hash":"2da014491a3d4c99f0d1f8d4234792bdbdaeb0a8","modified":1559454818000},{"_id":"themes/fexo/layout/category.ejs","hash":"a9216a0229dadfef656bb0c91fa7abba72865d5f","modified":1559454818000},{"_id":"themes/fexo/layout/archive.ejs","hash":"1c841544a653ca622f2a4c694f9d6cff75df94a4","modified":1559454818000},{"_id":"themes/fexo/layout/index.ejs","hash":"ee3fbfb2f560b3fb1ef074fd2912d759702e4e0f","modified":1559454818000},{"_id":"themes/fexo/layout/post.ejs","hash":"c151be598d176a8a25d1f9987a0c1bbb443a851b","modified":1559454818000},{"_id":"themes/fexo/layout/link.ejs","hash":"f6f3ef389fee05013e77c0acef71ac3fa3cc7103","modified":1559454818000},{"_id":"themes/fexo/yarn.lock","hash":"241b66962a690830817bdffd9759b8a570da9f5d","modified":1559454818000},{"_id":"themes/fexo/layout/layout.ejs","hash":"55bb1a65cca87379c306113b481c7cc5a1e48525","modified":1559454818000},{"_id":"themes/fexo/layout/project.ejs","hash":"515621da8d0be8c2de4ea34e63b583f14bc6c6e0","modified":1559454818000},{"_id":"themes/fexo/layout/search.ejs","hash":"9f52f953d161cb1ea3fd9f8a502c74e0ad5a57bd","modified":1559454818000},{"_id":"themes/fexo/layout/tag.ejs","hash":"1fb070d4fedc855c7931889b40bff95b5d95286a","modified":1559454818000},{"_id":"source/_posts/Android-LruCache-缓存详解/LruCache.png","hash":"1010fbae3548b8871d6580b1230e7dfa0447d35b","modified":1555934794000},{"_id":"source/_posts/Android-View-的工作原理/MeasureSpec创建规则.png","hash":"ea2924048d93219f071310d58e41faa914404002","modified":1556696206000},{"_id":"source/_posts/Android-View-的工作原理/performTraversals.png","hash":"fa8cc199c3ac68e7381b330c6f573f34658a0aea","modified":1556684660000},{"_id":"source/_posts/Android-消息机制详解/消息流程图.jpg","hash":"f9d3d2d0f3db61e333627904b0ff271c3101f69c","modified":1552713678000},{"_id":"source/_posts/Dart 基础入门/dart_core.png","hash":"4a35f81f0ba0d0f745140191d0bc0dc5113be823","modified":1555916080000},{"_id":"source/_posts/Dart 基础入门/idea_category.png","hash":"d831a1565d741a9e1025ffc4a3160f495f9e219e","modified":1555915508000},{"_id":"source/_posts/Dart 基础入门/idea_create.png","hash":"728ab0225ad56c3c89550fe6d2b47474d8e5e35f","modified":1555915472000},{"_id":"source/_posts/Dart-异步编程/事件循环.png.jpg","hash":"f178fb88648f615c45f36ae1271435dfc041edf5","modified":1556585056000},{"_id":"source/_posts/Dart-面向对象/ABP继承图.png","hash":"ef65cf4e08f8d07f8589f8fb23bd196b501d3be3","modified":1556082156000},{"_id":"source/_posts/Dart-面向对象/继承歧义.png","hash":"290faaa63913285f395ec07237d4038b3fe2b6b8","modified":1556011730000},{"_id":"source/_posts/Gradle-构建工具详解/项目结构.png","hash":"4bdb501eb2fe05e2654faaffed79ac4ab54f4bf6","modified":1558852270000},{"_id":"source/_posts/Java-线程和线程池详解/线程池流程.png","hash":"69fd1b5147720b08181d86c974a6665291a9d955","modified":1553161474000},{"_id":"source/_posts/Java-线程和线程池详解/线程状态1.png","hash":"800238efba01bcddd8c73f7dea2aea47c2c7598a","modified":1553161040000},{"_id":"source/_posts/Java-线程和线程池详解/继承图.png","hash":"27658f399a862ef867bc1cc81def896bf3840614","modified":1553071334000},{"_id":"source/_posts/Java设计模式：创建型模式/工厂方法.jpg","hash":"45d94d745f90e7cf75056fdd16728670d942a993","modified":1552354506000},{"_id":"source/_posts/Java设计模式：创建型模式/抽象工厂.jpg","hash":"e64d7c7297a60b86aa678a046f376e20f77a69cf","modified":1552354506000},{"_id":"source/_posts/Java设计模式：创建型模式/简单工厂.jpg","hash":"076bb6f2a96ac7086129a9f5f01a567b13cbe81c","modified":1552354506000},{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png","hash":"7008b7b5185e554ed4af858996d5a2c7f5433d5f","modified":1547287346000},{"_id":"source/_posts/Markdown-语法详解/markdown.png","hash":"1414644bf42de09d8d43b2f687c25a4b7b9599bc","modified":1558255648000},{"_id":"source/_posts/Markdown-语法详解/kotlin.png","hash":"6ed77ee8cbebf29b42a4e15dc71305b8d065dd10","modified":1558282772000},{"_id":"source/_posts/Markdown-语法详解/todo-list.png","hash":"12858594561e3474c50f442b5d9f68996618e3ab","modified":1558270596000},{"_id":"source/_posts/Spring-学习笔记（三）：面向切面/Compiler.png","hash":"b4c05fb6df5791ab7804ecc0d415bfeeb9ab1276","modified":1559534924000},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/spring-mvc-request.jpeg","hash":"b374ddd19d6d8a42313c2b772313b5a63a5420df","modified":1559560032000},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_deploy.png","hash":"81aef7e20c56ea291b0743b285e631502b6e75d4","modified":1559565384000},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_put.jpg","hash":"0a0f8d1a1b0426ed2c69a6ebb786ca90f70ada23","modified":1559574970000},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_server.png","hash":"f3e31e45fb488937dc5b299d3b368b3230c67b9f","modified":1559565316000},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/项目结构.png","hash":"2a418f63c874572375fe583eff33ff05a8c1a88e","modified":1559576030000},{"_id":"source/_posts/《剑指offer》题目-Java-实现/rebt.png","hash":"45137b4701b658acb58103aa7539913bf517c753","modified":1552894066000},{"_id":"source/_posts/《剑指offer》题目-Java-实现/翻转链表.png","hash":"4bca505073c7d4fd05511298f61ddf917b0a38d6","modified":1553483904000},{"_id":"source/_posts/基本数据结构的简单Java实现/二叉搜索树.png","hash":"a86203a32532d499793f076453363c16efc424ff","modified":1552747382000},{"_id":"source/_posts/翻越GFW记/GFW存在后的连接方式.png","hash":"6062a7474e26fd92ad2bbbcfa854409c64c621b9","modified":1547352940000},{"_id":"source/_posts/翻越GFW记/SSH连接方式.png","hash":"4613fcc1932182816aa1734354cca2e2e2f87fc7","modified":1547352970000},{"_id":"source/_posts/翻越GFW记/SS连接方式.png","hash":"5189639e3bb1beaa834d1cd2a10a113858015410","modified":1547352980000},{"_id":"source/_posts/翻越GFW记/GFW内部结构.jpg","hash":"1b4b3287216eb9d2d543b6075630482b2c14a789","modified":1547352958000},{"_id":"source/_posts/翻越GFW记/原始连接方式.png","hash":"a18e72d5ed67fbaddc9736039df9c7168fd98544","modified":1547352922000},{"_id":"themes/fexo/layout/_partial/article.ejs","hash":"f75505424d4f3b6bcf49624b2fbeeaa2aff6db42","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","hash":"3801a22d0bfe46c118a4ce5187e22121ba02ff7f","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","hash":"19a0ae26e336a0f5f475d231e4984eb891bd1022","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/head.ejs","hash":"f442f9d25b342812e7ac70bc850b6cf3ac899e93","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/home.ejs","hash":"00282a39ed0f22a38b55cedc443bd57c8fa3aceb","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/load-script.ejs","hash":"df9630121a1354e864d3f305744a85c8e4941517","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/style.ejs","hash":"7a9211cc0a45bd2c2861043c7e4e191706cf5214","modified":1559454818000},{"_id":"themes/fexo/source/css/styles.css","hash":"27a7fa2784b509de3c5329feab293321c6197024","modified":1559454818000},{"_id":"themes/fexo/source/images/avatar.jpg","hash":"06b315b1cde634d2313044a83c40b1ac10961134","modified":1559454818000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1559454818000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1559454818000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1559454818000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1559454818000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1559454818000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1559454818000},{"_id":"themes/fexo/source/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1559454818000},{"_id":"themes/fexo/source/fonts/fontello.svg","hash":"c32ea33c25a9aee152a27ea90eafb237cbdac0ca","modified":1559454818000},{"_id":"themes/fexo/source/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1559454818000},{"_id":"themes/fexo/source/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1559454818000},{"_id":"themes/fexo/source/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1559454818000},{"_id":"themes/fexo/source/js/app.js","hash":"79db95e0422d48aa3fdddc33b3140e07514c07db","modified":1559538402000},{"_id":"themes/fexo/source/js/bundle.js","hash":"8b64dd44eec4521f554323fc0a1dbb07f61dc678","modified":1559454818000},{"_id":"themes/fexo/source/js/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1559454818000},{"_id":"themes/fexo/source/js/scroll-spy.js","hash":"5ae67d88f0147937c847bb205acae060c4f24de5","modified":1559454818000},{"_id":"themes/fexo/source/js/util.js","hash":"a7159ca12fe86bbd41b95aed2021c42884aa4676","modified":1559454818000},{"_id":"themes/fexo/source/js/zenscroll.js","hash":"51e88227a98123246f35a49ec22263973cec8d78","modified":1559454818000},{"_id":"themes/fexo/source/sass/_animate.scss","hash":"7d7653e77750645a424d5a7ecbe59f9f7457287b","modified":1559454818000},{"_id":"themes/fexo/source/sass/_base.scss","hash":"e2597f745ee5d92ba4ef1d98cf720d7f28588428","modified":1559454818000},{"_id":"themes/fexo/source/sass/_common.scss","hash":"2b2eb1f34d839b8a75ed3c4360fa0c7776917653","modified":1559454818000},{"_id":"themes/fexo/source/sass/_fontello.scss","hash":"0a9332dd83ab64487846f7749801c8d6e104d014","modified":1559454818000},{"_id":"themes/fexo/source/sass/_fonts.scss","hash":"74a9e7653ad628199349d7cc0ec9315194ac3691","modified":1559454818000},{"_id":"themes/fexo/source/sass/_highlight-js.scss","hash":"4b6cf6478cdfeb4baa5def1f2116d36ac7100cad","modified":1559454818000},{"_id":"themes/fexo/source/sass/_normalize.scss","hash":"f466245d5ad990c1062481c0e1f8741fb4bfa00e","modified":1559454818000},{"_id":"themes/fexo/source/sass/_type.scss","hash":"f78d73bed280361c527e6111fcd0734431a60031","modified":1559454818000},{"_id":"themes/fexo/source/sass/_variable.scss","hash":"d16ea71577be84049c3cf006818edb94e3e1e0c5","modified":1559454818000},{"_id":"themes/fexo/source/sass/styles.scss","hash":"7d890fc68d4e7d8fa9bb402d7b9ad9f8bbe21460","modified":1559454818000},{"_id":"source/_posts/Android-View-的工作原理/整体布局.webp.jpg","hash":"3adefde2fefdd06e5fa9a0a996a06228e97ea4e6","modified":1556685482000},{"_id":"source/_posts/Gradle-构建工具详解/groovy.png","hash":"df6d9e347a61aa45cbe7b889074359e94ce39764","modified":1558795778000},{"_id":"source/_posts/Java-线程和线程池详解/线程状态2.png","hash":"28e11bf820c48dba6211483af7822d2f7028847c","modified":1553161052000},{"_id":"source/_posts/Java设计模式：创建型模式/设计模式之间的关系.jpg","hash":"5533c4baa4a9ee3e2315d805f40f42fe7d4af6ce","modified":1552354506000},{"_id":"source/_posts/Spring-学习笔记（三）：面向切面/AOP_1.jpg","hash":"7bc0329497f4fe0afd2144a4d82307e7ce443f16","modified":1559475468000},{"_id":"source/_posts/Spring-学习笔记（三）：面向切面/AOP_2.jpg","hash":"99ec0e216aef1ee267aa7c6832c82f39a1af35a0","modified":1559481772000},{"_id":"source/_posts/基本数据结构的简单Java实现/HashMap.png","hash":"5a39016f1245a3bbe61f00728f4d289055751318","modified":1552745558000},{"_id":"themes/fexo/source/css/styles.css.map","hash":"9672a4e5f8c6e9742095c1ca33f1c68b3145a7e3","modified":1559454818000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_tag.scss","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1559454816810},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","hash":"fa891596043765893fceb83978e5f85e01e6a8c4","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","hash":"8dfc6eb4b1da4f3375b6d6cf7806dd10bc86baf3","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/category.ejs","hash":"75434cd1cdf23fce3013e1649df684815f8f7e83","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/changyan.ejs","hash":"c3a8bfce7fe3b3df8a3b502fcd5bf1c8e75b401f","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","hash":"5301724e992579dd2afffd5ea07071bbe2b4ce14","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/date.ejs","hash":"517719b3c97d470c2b9211f757fc50384b21dfd3","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","hash":"42c1359fb919518deaa6421eb03f979258e59262","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","hash":"1c9cf3fd62911404694704fe810684c797dfb64c","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","hash":"10565634d704f797726afca1aafd04c7ebdfe44d","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/gitalk.ejs","hash":"8093404816456a49d992298262e4a4edbeda9220","modified":1559461972000},{"_id":"themes/fexo/layout/_partial/component/gitment.ejs","hash":"79252b25c2be88219037b255c1fc90f6f46966f5","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/hypercomments.ejs","hash":"872a23d69cbe8f469dc3371bdbc28f3af40f12cb","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","hash":"a17a7a8d37f57d62d85c31e364090853e661a1ba","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","hash":"8940e9542f5b9fe599a31b0f20d3f6987928672b","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","hash":"fb7bb83bb70e8fdba4ff94bc413c641196f474f9","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","hash":"f4f5004dbd9760729380740c06028df11d995d71","modified":1559539380000},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","hash":"292a11a47e751b8cfdb9ff85fd23ceb3b75fd30e","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","hash":"366edcd8af0c1449fb6a57aea1f81111752e1f41","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","hash":"c779f82f764d6ce2285043e9797992ebb7160cd1","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","hash":"64c9292926391920901cf04f4f1f5aa41fb872d7","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","hash":"3441860e795b275804bd109615d79d52ce0415f7","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","hash":"05d0e5182f5b622393d408fc85c64c886999eb36","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/title.ejs","hash":"713cb479e20e6843095fb23db5213c66d2259a84","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","hash":"cad46d32d7167a4e2e6231567d5fa7668658ee65","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","hash":"9c5de565ca94666126fc88fc52fc24f5eb4654c7","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/uyan.ejs","hash":"afe757c6f45d24640b22d90db6f2799000c6f994","modified":1559454818000},{"_id":"themes/fexo/layout/_partial/component/valine.ejs","hash":"19f3cdc85cd44652be41ef9b1fcd6956230d9d14","modified":1559454818000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_category-box.scss","hash":"50825816e002fcbbfcea4788045ecf655070f1cf","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_back-top.scss","hash":"fadf3d3987eeee78b5c9ebbad00e6bb056429563","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_comments.scss","hash":"3e1161b25336bf974e22df15c4e574e3ac1960f6","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_donation.scss","hash":"e2be24eccf94dfed2b2bd7da6c8fbeb5475c8116","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_hint.scss","hash":"dd8e7ac2f17a44c7dff4347290235c621d5b0776","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_index.scss","hash":"96b7fc78bf9ca5397dd73ab1351823df605a92c7","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","hash":"0422c181d03081c9bd870756f78c1dc97a77bd09","modified":1559540564000},{"_id":"themes/fexo/source/sass/component/_item-post.scss","hash":"5ffda36360fd42c85806131f6f8bcb7b701b701c","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_item-title.scss","hash":"cae94fbf485b6570a5cb7821da0e296d29b5919c","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_item-year.scss","hash":"437c9551eff71e1087c6b55effcf16d4199a579c","modified":1559541314000},{"_id":"themes/fexo/source/sass/component/_list-post.scss","hash":"97f153db29496f6c3c8853e522a7bd3d4c0d34a7","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_modal.scss","hash":"7d4463b9d28525455aa09064d2e95b6ec6b38762","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_page-header.scss","hash":"5ecd7e742109acebc84e0bf612d890ff7198b4c9","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_pagination.scss","hash":"cb536172bf9f5d3dfbff71bf3ec35521a04e3058","modified":1559540584000},{"_id":"themes/fexo/source/sass/component/_prev-net.scss","hash":"a510a5220205904f74865e297327fa4770427db7","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_table.scss","hash":"ae548d0a21c5358607f3bf187c01d48c7d08531e","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","hash":"2f033e2b35c96adda32bce15b6c33f9eebcaa847","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_toc.scss","hash":"16ebf02f4b371d9a833dc002e9354a40980e6b39","modified":1559454818000},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","hash":"b59636ae0f5ac6d4a0fc95f5140ab7cc69b8eff5","modified":1559541098000},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","hash":"21665610ca4212def73b767f4efbe2ff48dd491e","modified":1559541104000},{"_id":"themes/fexo/source/sass/pages/_about.scss","hash":"47f3bf8f2c7b690f343d13dfdb6d0a1797d77833","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_category.scss","hash":"3b2c188c43fd4b908e0905f5ea9b6fef9edf598e","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_archive.scss","hash":"723062e099a67565c87c54e912cff1102d453d0b","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_home.scss","hash":"32b68b8779e7a010051a631aebbd92b1c86bfc6d","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_index.scss","hash":"fe46ce0d24d17aa5ac39997b9bbef5324eac9aee","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_post.scss","hash":"17190026311a972f34847877212577e9af90aad6","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_link.scss","hash":"3a29191bed2c471e05e6ef21d74f769e23192cd1","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_project.scss","hash":"6b602e0fc5fff2e4b295eca9fd5c82794733cf3f","modified":1559454818000},{"_id":"themes/fexo/source/sass/pages/_search.scss","hash":"fd477d09e9eca14416cd03e6312ddccaa4c46689","modified":1559454818000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","hash":"3f1f4e7974e2cff38f52daf44697048c3c4492fe","modified":1559454818000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1559454818000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1559454818000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1559454818000},{"_id":"source/_posts/Markdown-语法详解/编辑器.png","hash":"d6355514a0cfc38cf0c918e8575aa8b633115919","modified":1558255526000},{"_id":"source/_posts/Spring-学习笔记（一）：基本理念和-Bean-装配/生命周期.png","hash":"890eb9070156c972a4497d3112520942a74fa38e","modified":1559106468000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1559454818000},{"_id":"public/content.json","hash":"0b2f74f60fd440fa362c3f835d5889d81be8e2d5","modified":1559579555486},{"_id":"public/sitemap.xml","hash":"54a0999a3ac2168cc3c1847e2d6e0bf07e403d32","modified":1559579555551},{"_id":"public/atom.xml","hash":"d8361d5f91f3ee47be06932a2346c70f61dfd695","modified":1559579556208},{"_id":"public/search.json","hash":"e8331f35ad621443265b6399c64f8bf93c53aab1","modified":1559579556833},{"_id":"public/about/index.html","hash":"d9c38300e665b248c8e35ad8d2354c4c4af41a7b","modified":1559579557075},{"_id":"public/categories/index.html","hash":"afe8c2f0bd63c3a8b63aef5c8dffffbd3d39fc97","modified":1559579557076},{"_id":"public/search/index.html","hash":"bf001122465cc9b73a6fd3968c107c6abec0101a","modified":1559579557092},{"_id":"public/tags/index.html","hash":"11fec9f106be14a03c44af92434fca4e2ee8b3d4","modified":1559579557103},{"_id":"public/Android-自定义-View-详解/index.html","hash":"45c2e4e728b3278ee0696fd4cbec3d4e223c64de","modified":1559579557104},{"_id":"public/Android-Binder-源码解析/index.html","hash":"55433104f931aa690c549555d7f66f9cabc15dad","modified":1559579557104},{"_id":"public/Java-数据库知识整理/index.html","hash":"af1eea8898f71e616e9a672b7962434b7cd3e97e","modified":1559579557104},{"_id":"public/Android-多线程技术/index.html","hash":"3ee384ef185601d7b073583a440072b15be75a91","modified":1559579557104},{"_id":"public/坐过山车的人/index.html","hash":"c4ea17228bbc622e9c2a48301bb0c9951ec6fd01","modified":1559579557105},{"_id":"public/archives/page/3/index.html","hash":"9baee742807e15893ba5d9ae8382e9c1a42633f2","modified":1559579557105},{"_id":"public/archives/index.html","hash":"73548e8b1f96ec8980a14b0bcfcb0b222c9b7298","modified":1559579557105},{"_id":"public/archives/page/2/index.html","hash":"bfc01091f92e54a3b42ac63301333538df7e0d89","modified":1559579557105},{"_id":"public/archives/2019/index.html","hash":"709794c35b35c228863a56108c9cf5c978633fdb","modified":1559579557105},{"_id":"public/archives/2019/page/2/index.html","hash":"95f177e5308e85bf82234a70a30d1008dada2b44","modified":1559579557105},{"_id":"public/archives/2019/page/3/index.html","hash":"431d2ce5d98e8bc3179fc19dba4a7b9518666711","modified":1559579557105},{"_id":"public/archives/2019/02/index.html","hash":"cbc6f2d800d97dd0d67f44e747c9364577e76240","modified":1559579557105},{"_id":"public/archives/2019/01/index.html","hash":"27d8389756334dd39e6ccaa08a5e790b95f00897","modified":1559579557105},{"_id":"public/archives/2019/03/index.html","hash":"1ab40bb05311a94403d70be945ba4c1cc249d22e","modified":1559579557105},{"_id":"public/archives/2019/04/index.html","hash":"a5057519de7aa1cee064dc98f5e5de5277931473","modified":1559579557105},{"_id":"public/archives/2019/05/index.html","hash":"b723fc0c27fc278309c3ea38027d3d69cd9c5ad1","modified":1559579557105},{"_id":"public/archives/2019/06/index.html","hash":"a1bf23f15c93023b603d3a656b7ddb7e6853fdbc","modified":1559579557105},{"_id":"public/index.html","hash":"c42d1bed50d6c2a6d9bb453e56fa08183cf47e95","modified":1559579557105},{"_id":"public/page/2/index.html","hash":"f06974fde491ce0461f3ba79ea4865ec47033fd6","modified":1559579557105},{"_id":"public/category/index.html","hash":"71bc3b686ef636adfb2aeb2088d60abb80441c49","modified":1559579557106},{"_id":"public/tag/index.html","hash":"dc970f76cdc18a3157deb3ef76aaa068253b109a","modified":1559579557106},{"_id":"public/Spring-学习笔记（三）：面向切面/index.html","hash":"1a63712cc0633e6e31266f8e78552bf8b3c880da","modified":1559579557106},{"_id":"public/Spring-学习笔记（二）：高级装配/index.html","hash":"2e7b76cc7d59583e693f1fc83dc2d021d2887af9","modified":1559579557106},{"_id":"public/Spring-学习笔记（一）：基本理念和-Bean-装配/index.html","hash":"f24dd02a25478b3bc9020f1b2a6e72b6c4ba2f46","modified":1559579557106},{"_id":"public/Gradle-构建工具详解/index.html","hash":"a655a8a824dac5290a41be3bd72d3b1409472ff1","modified":1559579557106},{"_id":"public/Kotlin-委托属性详解/index.html","hash":"bd77c1c88b516667c3936d6a8ed251e39631dd7d","modified":1559579557106},{"_id":"public/Markdown-语法详解/index.html","hash":"3a288c9a0559cf7b572c937f95621d2ec2d323cd","modified":1559579557106},{"_id":"public/Dart-反射初识/index.html","hash":"1388100eed05fcc4c384a7df036c4b77974d211e","modified":1559579557106},{"_id":"public/利用反射实现-DrawerLayout-全屏滑动/index.html","hash":"4742c5ac4ed5528f7ab3cdb59f92b6e80f31dba1","modified":1559579557106},{"_id":"public/Dart-异步编程/index.html","hash":"f9ba38fd67bf56c06cf18f83532bd74ea8e7a082","modified":1559579557106},{"_id":"public/《红楼梦》读书笔记/index.html","hash":"a0f3c4f18fcd51a4e0f4442b7506d4f7774ed774","modified":1559579557106},{"_id":"public/Dart-面向对象/index.html","hash":"2fd14b271eee35eb7b647318f58ecf4d07642ad8","modified":1559579557106},{"_id":"public/Dart 基础入门/index.html","hash":"58c7863415bf5ee305c3d8113443b685fcac8c22","modified":1559579557106},{"_id":"public/Java-线程和线程池详解/index.html","hash":"c9dde894399ecdcd315ff23c6f5bfa693c0aa4cd","modified":1559579557106},{"_id":"public/《剑指offer》题目-Java-实现/index.html","hash":"6d4fb7e2de9d770db183d15568dc116939ae1e8c","modified":1559579557106},{"_id":"public/Android-LruCache-缓存详解/index.html","hash":"4c85a75e793aa0dc1bbbf5388b92668886d41d63","modified":1559579557106},{"_id":"public/Java-反射详解/index.html","hash":"4e95db01e0aadd139f1230962d2fac966964f9f3","modified":1559579557107},{"_id":"public/基本数据结构的简单Java实现/index.html","hash":"60fd82653bf99c0a482357ca4e1acbfa31eabfd3","modified":1559579557107},{"_id":"public/Android-消息机制详解/index.html","hash":"8cbf3e7862ca9735e4dce4a4d4a74d693bb2fd01","modified":1559579557107},{"_id":"public/Java-排序算法/index.html","hash":"eda79601ebd68e6c4528cb59ddec48f2937db9d4","modified":1559579557107},{"_id":"public/Android-View-的工作原理/index.html","hash":"1816afd948e960f27d96d7f1d2a98d7fea61ca5d","modified":1559579557107},{"_id":"public/Android-IPC-机制详解/index.html","hash":"9b5e60226444be7806a55400fe38d8aaab3a2fee","modified":1559579557107},{"_id":"public/Android-动画详解/index.html","hash":"2b65b77385ca22efbb2ccf17da65369dcc391bbb","modified":1559579557107},{"_id":"public/LeakCanary源码解析/index.html","hash":"61af5ff6cae278f2680ad59d28f30399c715a80b","modified":1559579557107},{"_id":"public/Java设计模式：创建型模式/index.html","hash":"584091288eb49d3d6e7def8a53f6d3e916a17b97","modified":1559579557108},{"_id":"public/Java设计模式：行为型模式/index.html","hash":"192fbdf74e208549da176d7a8fdaa88f6624e37f","modified":1559579557108},{"_id":"public/Java设计模式：结构型模式/index.html","hash":"97964a3cb7bfcac2fbaf0aee3c5adc63cc3f8653","modified":1559579557108},{"_id":"public/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》/index.html","hash":"9072aecc504d1e7761be67834ebcb9067a20cdd1","modified":1559579557108},{"_id":"public/翻越GFW记/index.html","hash":"aaa2bd60a65055023759318b7c642c90a7cc2151","modified":1559579557108},{"_id":"public/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/index.html","hash":"0c7f3e7c165da985a1f582631d0a3dce7836af1e","modified":1559579557109},{"_id":"public/Github-Pages-Hexo搭建个人博客/index.html","hash":"71e6a1c9ad280ad020ea1cd4501d80b99be6e302","modified":1559579557109},{"_id":"public/categories/Android/index.html","hash":"5fff9b4ebc631ae42370fa5dac343f2e8d3a5670","modified":1559579557109},{"_id":"public/categories/Dart/index.html","hash":"c75e197c99292cf40184b75e02cf3d8dff8393f0","modified":1559579557109},{"_id":"public/categories/Java/index.html","hash":"57f9c03da2527d3c6e1131d1624ece59b7f420c0","modified":1559579557109},{"_id":"public/categories/算法/index.html","hash":"76d7867089bea074e10cc692b5e790501c2a0a41","modified":1559579557109},{"_id":"public/categories/互联网/index.html","hash":"755731fb6676d32153916b26fb89677e611e4c63","modified":1559579557110},{"_id":"public/categories/Spring/index.html","hash":"1025aa6641394f7507d8de0c2f4b316fbda8da56","modified":1559579557110},{"_id":"public/categories/随笔/index.html","hash":"b49863d66e8170aa4dc17301d6a299766b62d77c","modified":1559579557110},{"_id":"public/categories/Kotlin/index.html","hash":"45cb79d93af6c1f143b62cd4b5a2e734ac052a8f","modified":1559579557110},{"_id":"public/categories/Markdown/index.html","hash":"c77d9eb1f64250efa692e1f0519ad738a4613bc8","modified":1559579557110},{"_id":"public/categories/文学/index.html","hash":"f3734195c6a1a5a5f57c7f3f2b8061c22344f2fc","modified":1559579557110},{"_id":"public/categories/艺术/index.html","hash":"9d72ef805b3871ab1e9f84b1b7494a4bab92bcbc","modified":1559579557110},{"_id":"public/categories/Gradle/index.html","hash":"1b0eea25334ea0f2ac3f17c4eb7c0252ce176266","modified":1559579557110},{"_id":"public/tags/Android/index.html","hash":"db9e93def0ccb233ea233d698519060d22244c30","modified":1559579557110},{"_id":"public/tags/Binder/index.html","hash":"441792f92275196e3068c9fbd9c1a72054b84ed0","modified":1559579557110},{"_id":"public/tags/Java/index.html","hash":"5d495255bec13637da856b928c5e96e3a06288bb","modified":1559579557111},{"_id":"public/tags/多线程/index.html","hash":"9ca0b1ddaad5b0b00a4d4c412f5aa489fa53d2b1","modified":1559579557111},{"_id":"public/tags/View/index.html","hash":"36c9945cfe112e6f03e9fd18994833548561d1d0","modified":1559579557111},{"_id":"public/tags/Dart/index.html","hash":"6d8ade6f802011b8254f0c8627dc926158afc0a6","modified":1559579557111},{"_id":"public/tags/反射/index.html","hash":"f9ba65738ee007442402b1ad99f2ab526f16bcec","modified":1559579557111},{"_id":"public/tags/数据库/index.html","hash":"9cff221fd5862625098bc76fa9452e60fe2a30e7","modified":1559579557111},{"_id":"public/tags/LRU/index.html","hash":"f362b9d13ed581767e0e4e4bca5f8f89f3366488","modified":1559579557111},{"_id":"public/tags/缓存/index.html","hash":"3b5d054393711df1c90c787d3821de422d431ef8","modified":1559579557111},{"_id":"public/tags/Handler/index.html","hash":"72d148b6da550780a2454d86fc518f9f35257447","modified":1559579557111},{"_id":"public/tags/异步/index.html","hash":"96cdd3ef219c532dbc6ce85fca8751a66406bca3","modified":1559579557111},{"_id":"public/tags/算法/index.html","hash":"700fd8fa28efdc680f56b60e4f2b256cddd050ba","modified":1559579557111},{"_id":"public/tags/设计模式/index.html","hash":"835b4b1e3e30037b8faf443f5b2d474d1cfbf8f4","modified":1559579557111},{"_id":"public/tags/GitHub/index.html","hash":"a17f8f3ea0761865533663582cdf99b9c7144752","modified":1559579557111},{"_id":"public/tags/Hexo/index.html","hash":"b56e7929bca06d5c4c80f8e6d2f5c48cacd55723","modified":1559579557111},{"_id":"public/tags/LeetCode/index.html","hash":"5e2d68fb4b040d08fee59753defcce28332da032","modified":1559579557112},{"_id":"public/tags/Spring/index.html","hash":"03a597520f353410351e9bc4404daa06f1405a38","modified":1559579557112},{"_id":"public/tags/随笔/index.html","hash":"151e21571b277eceb2314bd43a88bfbd554ac6e1","modified":1559579557112},{"_id":"public/tags/诗歌/index.html","hash":"2276a469d3d7f607023e5831f2ec4fa426d98944","modified":1559579557112},{"_id":"public/tags/多进程通信/index.html","hash":"d7a16e548dce235830b976c03fce107847049714","modified":1559579557112},{"_id":"public/tags/动画开发/index.html","hash":"3b8370d184d1ba01dd09c78e7b4b5e2083e30211","modified":1559579557112},{"_id":"public/tags/Kotlin/index.html","hash":"0e0e931d6d236d560d7fd8ffa188edfc50698bbe","modified":1559579557112},{"_id":"public/tags/委托属性/index.html","hash":"dc485803991e134ede962daae66ea45e339d5eb7","modified":1559579557112},{"_id":"public/tags/内存泄漏/index.html","hash":"dfd9396050877d5d4de03c7c0a00841803b432d7","modified":1559579557112},{"_id":"public/tags/源码/index.html","hash":"381d46f2153bc1cb6fc7ed77fc49eea1d03e9b55","modified":1559579557112},{"_id":"public/tags/Markdown/index.html","hash":"3a766ca4251cc6afcbd1f3fce1caf26fa8214c0e","modified":1559579557112},{"_id":"public/tags/AOP/index.html","hash":"2ab542ea385471aa105f16c7cafb22019bf68e28","modified":1559579557112},{"_id":"public/tags/文学/index.html","hash":"74398605aaaff0f9606ee385f40a760737c1e4b7","modified":1559579557112},{"_id":"public/tags/笔记/index.html","hash":"263bb28fceab06f5619e2c8d081854a532267936","modified":1559579557113},{"_id":"public/tags/红楼梦/index.html","hash":"239ab81b9ed85f2d40ba231b07426152e27afe9e","modified":1559579557113},{"_id":"public/tags/数据结构/index.html","hash":"4239ba2b0d830a565c628ce0ef900495258b5e93","modified":1559579557113},{"_id":"public/tags/音乐/index.html","hash":"b869af94032bb83645a9caadf1d123f64e6b178e","modified":1559579557113},{"_id":"public/tags/巴洛克/index.html","hash":"511121c72202ceded917f2f4e613ce9abde4d158","modified":1559579557113},{"_id":"public/tags/巴赫/index.html","hash":"dcecb5531e734c5faee580ae9a885888705bf2b7","modified":1559579557113},{"_id":"public/tags/翻墙/index.html","hash":"d19c8e285856e7824e52cdddcd602d49d9093a6f","modified":1559579557113},{"_id":"public/tags/互联网/index.html","hash":"24c786be96accf4a8cbc61e0b347e7e63309b60f","modified":1559579557113},{"_id":"public/tags/线程池/index.html","hash":"5f55afdab13fd4e9b115705ee7de3a19fbdb2922","modified":1559579557113},{"_id":"public/tags/Gradle/index.html","hash":"b08cb850d2e61342811b577572095ce2d51d0f29","modified":1559579557113},{"_id":"public/tags/构建工具/index.html","hash":"5f57cb6c4e680338cc24525fb38bf331bf7ed877","modified":1559579557113},{"_id":"public/tags/Groovy/index.html","hash":"97d538fce3cf97550301739604035da26d2e3203","modified":1559579557113},{"_id":"public/tags/DI/index.html","hash":"062f427d9def30896c44d8f04bae0354035267a8","modified":1559579557113},{"_id":"public/tags/Java-EE/index.html","hash":"cbda54b2dd0427894296af9e4023d6e517d58fd3","modified":1559579557113},{"_id":"public/Spring-学习笔记（四）：构建-Web-应用程序/index.html","hash":"5dc09d0eb9b64e74569860083eee5efcfe3231d3","modified":1559579557122},{"_id":"public/tags/Web/index.html","hash":"a00185c67a23324088eeec155ad0f1fdf793e047","modified":1559579557123},{"_id":"public/Spring-学习笔记（四）：构建-Web-应用程序/项目结构.png","hash":"2a418f63c874572375fe583eff33ff05a8c1a88e","modified":1559579557132},{"_id":"public/Spring-学习笔记（四）：构建-Web-应用程序/spring-mvc-request.jpeg","hash":"b374ddd19d6d8a42313c2b772313b5a63a5420df","modified":1559579557135},{"_id":"public/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_deploy.png","hash":"81aef7e20c56ea291b0743b285e631502b6e75d4","modified":1559579557135},{"_id":"public/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_put.jpg","hash":"0a0f8d1a1b0426ed2c69a6ebb786ca90f70ada23","modified":1559579557144},{"_id":"public/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_server.png","hash":"f3e31e45fb488937dc5b299d3b368b3230c67b9f","modified":1559579557144}],"Category":[{"name":"Android","_id":"cjwgkzqur0004y4upfsidwc6g"},{"name":"Dart","_id":"cjwgkzqva000hy4uphwzfh0dl"},{"name":"Java","_id":"cjwgkzqvd000oy4up7j3pnk1o"},{"name":"算法","_id":"cjwgkzqwk001vy4upc2ez5i7d"},{"name":"互联网","_id":"cjwgkzqwp0025y4upf4qmfdro"},{"name":"Spring","_id":"cjwgkzqwv002dy4upxb2m863b"},{"name":"随笔","_id":"cjwgkzqwx002ky4upwbmklezj"},{"name":"Kotlin","_id":"cjwgkzqxu003py4up8gimzk40"},{"name":"Markdown","_id":"cjwgkzqxz003yy4upmbg71mgo"},{"name":"文学","_id":"cjwgkzqy30046y4up7551bidq"},{"name":"艺术","_id":"cjwgkzqya004gy4up8dgltsl9"},{"name":"Gradle","_id":"cjwgkzqz0005ky4upcrvzz2sj"}],"Data":[],"Page":[{"title":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---\n","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:31:24.000Z","path":"about/index.html","_id":"cjwgkzqui0000y4up5ki0nntm","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"categories","date":"2019-01-11T16:43:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-01-12 00:43:43\ntype: \"categories\"\n---\n","updated":"2019-06-02T06:19:16.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjwgkzquo0002y4upixlbqa50","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"category","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\ncomments: false\n---\n","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:19:34.000Z","path":"category/index.html","_id":"cjwgkzqw6001gy4up9jjmxf9v","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"search","layout":"search","comments":0,"_content":"","source":"search/index.md","raw":"---\ntitle: search\nlayout: search\ncomments: false\n---\n","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:25:56.000Z","path":"search/index.html","_id":"cjwgkzqw8001iy4upzmjaxmwx","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"tag","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---\n","date":"2076-11-29T08:54:34.955Z","updated":"2019-06-02T06:23:00.000Z","path":"tag/index.html","_id":"cjwgkzqwa001ly4upj63zao86","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"tags","type":"tags","date":"2019-03-15T15:33:56.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ndate: 2019-03-15 23:33:56\n---\n","updated":"2019-03-15T15:46:34.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjwgkzqwc001oy4upkpsn1xzw","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"Android Binder 源码解析","date":"2019-03-23T04:18:53.000Z","_content":"\nTODO","source":"_posts/Android-Binder-源码解析.md","raw":"---\ntitle: Android Binder 源码解析\ndate: 2019-03-23 12:18:53\ntags:\n- Android\n- Binder \ncategories:\n- Android\n---\n\nTODO","slug":"Android-Binder-源码解析","published":1,"updated":"2019-04-24T05:31:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzquj0001y4up8iprhb2p","content":"<p>TODO</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":5,"excerpt":"","more":"<p>TODO</p>\n"},{"title":"Android 多线程技术","date":"2019-03-17T03:56:59.000Z","_content":"\n多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。<!--more--> \n\n","source":"_posts/Android-多线程技术.md","raw":"---\ntitle: Android 多线程技术\ndate: 2019-03-17 11:56:59\ntags:\n- Android\n- Java \n- 多线程\ncategories:\n- Android\n---\n\n多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。<!--more--> \n\n","slug":"Android-多线程技术","published":1,"updated":"2019-03-17T04:43:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqup0003y4upjwhs1x46","content":"<p>多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。<a id=\"more\"></a> </p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":112,"excerpt":"<p>多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。</p>","more":"<p></p>"},{"title":"Android 自定义 View 详解","date":"2019-05-03T10:34:00.000Z","_content":"\n开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。\n\n<!--more-->\n\n## Canvas\n\n## Paint\n\n## 自定义 View\n\n## 自定义 ViewGroup \n\n","source":"_posts/Android-自定义-View-详解.md","raw":"---\ntitle: Android 自定义 View 详解\ndate: 2019-05-03 18:34:00\ntags:\n- Android\n- View\ncategories:\n- Android  \n---\n\n开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。\n\n<!--more-->\n\n## Canvas\n\n## Paint\n\n## 自定义 View\n\n## 自定义 ViewGroup \n\n","slug":"Android-自定义-View-详解","published":1,"updated":"2019-06-02T04:54:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzquu0006y4uppc9t873x","content":"<p>开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。</p>\n<a id=\"more\"></a>\n<h2 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h2><h2 id=\"Paint\"><a href=\"#Paint\" class=\"headerlink\" title=\"Paint\"></a>Paint</h2><h2 id=\"自定义-View\"><a href=\"#自定义-View\" class=\"headerlink\" title=\"自定义 View\"></a>自定义 View</h2><h2 id=\"自定义-ViewGroup\"><a href=\"#自定义-ViewGroup\" class=\"headerlink\" title=\"自定义 ViewGroup\"></a>自定义 ViewGroup</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":129,"excerpt":"<p>开发者可以通过自定义 View 实现炫酷的效果，其过程涉及到 View 的层次结构、事件分发机制和 View 的工作原理等技术细节。本文将串联个知识点，通过代码揭开自定义 View 的面纱。</p>","more":"<h2 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h2><h2 id=\"Paint\"><a href=\"#Paint\" class=\"headerlink\" title=\"Paint\"></a>Paint</h2><h2 id=\"自定义-View\"><a href=\"#自定义-View\" class=\"headerlink\" title=\"自定义 View\"></a>自定义 View</h2><h2 id=\"自定义-ViewGroup\"><a href=\"#自定义-ViewGroup\" class=\"headerlink\" title=\"自定义 ViewGroup\"></a>自定义 ViewGroup</h2>"},{"title":"Dart 基础入门","date":"2019-04-22T06:27:18.000Z","_content":"\n终于开始 Flutter 的具体学习，一切从 Dart 语言开始。\n\n```\nvoid main() {\n    print('hello world');\n}\n```\n\n<!--more-->\n\n## 环境搭建\n\nDart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。\n\n![](Dart 基础入门\\idea_create.png)\n\n\n\n创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的`main`函数作为运行的入口。在`run`之前需要`edit configuration`，很简单，只要指定对应的文件即可。\n\n![](Dart 基础入门\\idea_category.png)\n\n\n\n## 声明变量\n\nDart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为`null`。可以使用具体的类型声明，也可以使用`var`、`dynamic`、`const`、`final`等关键字\n\n```\nvoid main() {\n  var i = 0;\n  var d = 2.0;\n  var s = 'hello';\n  var b = true;\n  var l = [1, 2, 3];\n  var m = {0: 'a', 1: 'b'};\n  \n  print(main is Function);  //true\n}\n```\n\n通过查看官方库的`core`包，可以大概看出其结构\n\n![dart_core](Dart 基础入门\\dart_core.png)\n\n## 数据类型\n\n### Numbers\n\n包括 int 和 double，分别代表整形和浮点型。\n\nint 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。\n\n### String\n\n在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码\n\n```dart\nvar s1 = \"hello\";\nvar s2 = 'world';\nvar s3 = 'hello' + 'world';\nvar s4 = 'hello' 'world';\nvar s5 = \"\"\"hello \n              world\"\"\";\n```\n\n如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。\n\n```dart\nvar clapping = '\\u{1f44f}';\nprint(clapping);\n\nRunes runes = new Runes('\\u{1f44d}');\nprint(new String.fromCharCode(runes.first));\n```\n\n\n\n上面的输出为\n\n```\n👏\n👍\n```\n\n### Boolean\n\n提供 bool 用来声明布尔型变量，默认为 false。\n\n### List 和 Map\n\n```dart\nList<int> l = [1,2,3];\nl.forEach((x) => print(x)); //forEach的参数为 Function\nfor(var x in l) { //使用for-in\n  print(x);\n}\n\nMap<int, String> map = {0: \"a\", 1: \"b\"};\nmap[0] = \"c\";\n```\n\n## Function\n\n### 普通Function\n\n函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。\n\n```dart\nvoid main() {\n  single1('Tom', 20);\n  single2('Tom', 20);\n  single3('Tom', 20, weight: 30); //由于没有位置约束，必须指定形参名称\n  single4('Tom', 20, 20, 30);\n}\n\nbool single1(String name, int age) {\n  return true;\n}\n\n//返回类型和参数类型可省略，支持返回表达式\nsingle2(name, age) => true;\n\n//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值\nbool single3(String name, int age, {int weight = 60, int height}) => true;\n\n//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight\nbool single4(String name, int age, [int weight, int height]) => true;\n```\n\n对于`main`方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：\n\n```dart\nvoid main() => runApp(MyApp());\n```\n\n### Lambda表达式\n\n在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量\n\n```dart\nvar f = (c) {\n  print(c);\n};\n\nf('hello');\n\nvar list = [1, 2, 3];\nprintElement(x) {\t//方法签名写成 void printElement(int x) 更直观\n  print(x);\n}\n\nlist.forEach(printElement);\n\n```\n\n`forEach`的函数定义如下\n\n```dart\nvoid forEach(void f(E element)) {\n  for (E element in this) f(element);\n}\n\n```\n\n下面的例子直观展示将函数作为变量传递的思想\n\n```dart\nFunction makeAdder(num n) {\n  return (num i) => n + i;\n}\n  \n//更明晰的写法\nFunction makeAdder_(num n) {\n  Function add = (num i) {\n    return i + n;\n  };\n  return add;\n}\n\nvar adder2 = makeAdder(2);\nprint(adder2(3));\n\n```\n\n控制台将输出 5\n\n## 运算符\n\n### 赋值操作符\n\n除了`=`，还有`??=`，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。\n\n### 相等\n\n`==`将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的`identical`方法\n\n```dart\nexternal bool identical(Object a, Object b);\n\n```\n\n### 除法\n\n| 操作符 | 含义               |\n| :----: | ------------------ |\n|   /    | 除，比如 5/2 = 2.5 |\n|   ~/   | 整除， 5/2 = 2     |\n\n### 类型判断\n\n| 操作符 | 含义                       |\n| :----: | -------------------------- |\n|   is   | 对象属于指定类型则返回true |\n|  is!   | 对象不属于指定类型返回true |\n|   as   | 类型转换                   |\n\n### 条件表达式\n\n分为两种\n\n```dart\ncondition ? expr1 : expr2\t//通用表达式\nexpr1 ?? expr2\t//如果 expr1 非空，返回其值，否则返回 expr2\n```\n\n### 级联调用与非空调用\n\n```dart\n//常规写法\nvar button = querySelector('#button');\nbutton.text = 'Confirm';\nbutton.classes.add('important');\nbutton.onClick.listen((e) => window.alert('Confirmed!'));\n\n//使用级联表达式\nquerySelector('#button') // Get an object.\n  ..text = 'Confirm'   // Use its members.\n  ..classes.add('important')\n  ..onClick.listen((e) => window.alert('Confirmed!'));\n\n//非空调用\nprint(button?.text);\n```\n\n## 其他\n\nDart 语言在比如 `if/else`、`[do、]while`、`for`、`switch/case`等语句上跟 Java 类似，不再赘述。\n\n异常处理的做法如下\n\n```dart\n//抛出异常\nthrow 'x should be less than 10';\t\nthrow new FormatException('Expected at least 1 section');\n\n//捕获异常\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlamas();\n}\n\ntry {\n //...\n} on Exception catch (e) {\n  print('Unknown exception: $e');\n} catch (e, s) {\t\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```","source":"_posts/Dart 基础入门.md","raw":"---\ntitle: Dart 基础入门\ndate: 2019-04-22 14:27:18\ncategories:\n- Dart\ntags: \n- Dart\n\n---\n\n终于开始 Flutter 的具体学习，一切从 Dart 语言开始。\n\n```\nvoid main() {\n    print('hello world');\n}\n```\n\n<!--more-->\n\n## 环境搭建\n\nDart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。\n\n![](Dart 基础入门\\idea_create.png)\n\n\n\n创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的`main`函数作为运行的入口。在`run`之前需要`edit configuration`，很简单，只要指定对应的文件即可。\n\n![](Dart 基础入门\\idea_category.png)\n\n\n\n## 声明变量\n\nDart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为`null`。可以使用具体的类型声明，也可以使用`var`、`dynamic`、`const`、`final`等关键字\n\n```\nvoid main() {\n  var i = 0;\n  var d = 2.0;\n  var s = 'hello';\n  var b = true;\n  var l = [1, 2, 3];\n  var m = {0: 'a', 1: 'b'};\n  \n  print(main is Function);  //true\n}\n```\n\n通过查看官方库的`core`包，可以大概看出其结构\n\n![dart_core](Dart 基础入门\\dart_core.png)\n\n## 数据类型\n\n### Numbers\n\n包括 int 和 double，分别代表整形和浮点型。\n\nint 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。\n\n### String\n\n在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码\n\n```dart\nvar s1 = \"hello\";\nvar s2 = 'world';\nvar s3 = 'hello' + 'world';\nvar s4 = 'hello' 'world';\nvar s5 = \"\"\"hello \n              world\"\"\";\n```\n\n如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。\n\n```dart\nvar clapping = '\\u{1f44f}';\nprint(clapping);\n\nRunes runes = new Runes('\\u{1f44d}');\nprint(new String.fromCharCode(runes.first));\n```\n\n\n\n上面的输出为\n\n```\n👏\n👍\n```\n\n### Boolean\n\n提供 bool 用来声明布尔型变量，默认为 false。\n\n### List 和 Map\n\n```dart\nList<int> l = [1,2,3];\nl.forEach((x) => print(x)); //forEach的参数为 Function\nfor(var x in l) { //使用for-in\n  print(x);\n}\n\nMap<int, String> map = {0: \"a\", 1: \"b\"};\nmap[0] = \"c\";\n```\n\n## Function\n\n### 普通Function\n\n函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。\n\n```dart\nvoid main() {\n  single1('Tom', 20);\n  single2('Tom', 20);\n  single3('Tom', 20, weight: 30); //由于没有位置约束，必须指定形参名称\n  single4('Tom', 20, 20, 30);\n}\n\nbool single1(String name, int age) {\n  return true;\n}\n\n//返回类型和参数类型可省略，支持返回表达式\nsingle2(name, age) => true;\n\n//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值\nbool single3(String name, int age, {int weight = 60, int height}) => true;\n\n//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight\nbool single4(String name, int age, [int weight, int height]) => true;\n```\n\n对于`main`方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：\n\n```dart\nvoid main() => runApp(MyApp());\n```\n\n### Lambda表达式\n\n在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量\n\n```dart\nvar f = (c) {\n  print(c);\n};\n\nf('hello');\n\nvar list = [1, 2, 3];\nprintElement(x) {\t//方法签名写成 void printElement(int x) 更直观\n  print(x);\n}\n\nlist.forEach(printElement);\n\n```\n\n`forEach`的函数定义如下\n\n```dart\nvoid forEach(void f(E element)) {\n  for (E element in this) f(element);\n}\n\n```\n\n下面的例子直观展示将函数作为变量传递的思想\n\n```dart\nFunction makeAdder(num n) {\n  return (num i) => n + i;\n}\n  \n//更明晰的写法\nFunction makeAdder_(num n) {\n  Function add = (num i) {\n    return i + n;\n  };\n  return add;\n}\n\nvar adder2 = makeAdder(2);\nprint(adder2(3));\n\n```\n\n控制台将输出 5\n\n## 运算符\n\n### 赋值操作符\n\n除了`=`，还有`??=`，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。\n\n### 相等\n\n`==`将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的`identical`方法\n\n```dart\nexternal bool identical(Object a, Object b);\n\n```\n\n### 除法\n\n| 操作符 | 含义               |\n| :----: | ------------------ |\n|   /    | 除，比如 5/2 = 2.5 |\n|   ~/   | 整除， 5/2 = 2     |\n\n### 类型判断\n\n| 操作符 | 含义                       |\n| :----: | -------------------------- |\n|   is   | 对象属于指定类型则返回true |\n|  is!   | 对象不属于指定类型返回true |\n|   as   | 类型转换                   |\n\n### 条件表达式\n\n分为两种\n\n```dart\ncondition ? expr1 : expr2\t//通用表达式\nexpr1 ?? expr2\t//如果 expr1 非空，返回其值，否则返回 expr2\n```\n\n### 级联调用与非空调用\n\n```dart\n//常规写法\nvar button = querySelector('#button');\nbutton.text = 'Confirm';\nbutton.classes.add('important');\nbutton.onClick.listen((e) => window.alert('Confirmed!'));\n\n//使用级联表达式\nquerySelector('#button') // Get an object.\n  ..text = 'Confirm'   // Use its members.\n  ..classes.add('important')\n  ..onClick.listen((e) => window.alert('Confirmed!'));\n\n//非空调用\nprint(button?.text);\n```\n\n## 其他\n\nDart 语言在比如 `if/else`、`[do、]while`、`for`、`switch/case`等语句上跟 Java 类似，不再赘述。\n\n异常处理的做法如下\n\n```dart\n//抛出异常\nthrow 'x should be less than 10';\t\nthrow new FormatException('Expected at least 1 section');\n\n//捕获异常\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlamas();\n}\n\ntry {\n //...\n} on Exception catch (e) {\n  print('Unknown exception: $e');\n} catch (e, s) {\t\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```","slug":"Dart 基础入门","published":1,"updated":"2019-06-02T04:55:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzquw0007y4upvxnjqttm","content":"<p>终于开始 Flutter 的具体学习，一切从 Dart 语言开始。</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">void main() {</span><br><span class=\"line\">    print('hello world');</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。</p>\n<p><img src=\"/Dart 基础入门/idea_create.png\" alt></p>\n<p>创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的<code>main</code>函数作为运行的入口。在<code>run</code>之前需要<code>edit configuration</code>，很简单，只要指定对应的文件即可。</p>\n<p><img src=\"/Dart 基础入门/idea_category.png\" alt></p>\n<h2 id=\"声明变量\"><a href=\"#声明变量\" class=\"headerlink\" title=\"声明变量\"></a>声明变量</h2><p>Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为<code>null</code>。可以使用具体的类型声明，也可以使用<code>var</code>、<code>dynamic</code>、<code>const</code>、<code>final</code>等关键字</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">void main() {</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  var d = 2.0;</span><br><span class=\"line\">  var s = 'hello';</span><br><span class=\"line\">  var b = true;</span><br><span class=\"line\">  var l = [1, 2, 3];</span><br><span class=\"line\">  var m = {0: 'a', 1: 'b'};</span><br><span class=\"line\">  </span><br><span class=\"line\">  print(main is Function);  //true</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>通过查看官方库的<code>core</code>包，可以大概看出其结构</p>\n<p><img src=\"/Dart 基础入门/dart_core.png\" alt=\"dart_core\"></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>包括 int 和 double，分别代表整形和浮点型。</p>\n<p>int 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"string\">'hello'</span> + <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"string\">'hello'</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s5 = <span class=\"string\">\"\"\"hello </span></span><br><span class=\"line\"><span class=\"string\">              world\"\"\"</span>;</span><br></pre></td></tr></tbody></table></figure>\n<p>如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u{1f44f}'</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\"></span><br><span class=\"line\">Runes runes = <span class=\"keyword\">new</span> Runes(<span class=\"string\">'\\u{1f44d}'</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCode(runes.first));</span><br></pre></td></tr></tbody></table></figure>\n<p>上面的输出为</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">👏</span><br><span class=\"line\">👍</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><p>提供 bool 用来声明布尔型变量，默认为 false。</p>\n<h3 id=\"List-和-Map\"><a href=\"#List-和-Map\" class=\"headerlink\" title=\"List 和 Map\"></a>List 和 Map</h3><figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span><<span class=\"built_in\">int</span>> l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">l.forEach((x) => <span class=\"built_in\">print</span>(x)); <span class=\"comment\">//forEach的参数为 Function</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x <span class=\"keyword\">in</span> l) { <span class=\"comment\">//使用for-in</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Map</span><<span class=\"built_in\">int</span>, <span class=\"built_in\">String</span>> map = {<span class=\"number\">0</span>: <span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"b\"</span>};</span><br><span class=\"line\">map[<span class=\"number\">0</span>] = <span class=\"string\">\"c\"</span>;</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><h3 id=\"普通Function\"><a href=\"#普通Function\" class=\"headerlink\" title=\"普通Function\"></a>普通Function</h3><p>函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  single1(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single2(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single3(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, weight: <span class=\"number\">30</span>); <span class=\"comment\">//由于没有位置约束，必须指定形参名称</span></span><br><span class=\"line\">  single4(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single1(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类型和参数类型可省略，支持返回表达式</span></span><br><span class=\"line\">single2(name, age) => <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single3(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, {<span class=\"built_in\">int</span> weight = <span class=\"number\">60</span>, <span class=\"built_in\">int</span> height}) => <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single4(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, [<span class=\"built_in\">int</span> weight, <span class=\"built_in\">int</span> height]) => <span class=\"keyword\">true</span>;</span><br></pre></td></tr></tbody></table></figure>\n<p>对于<code>main</code>方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() => runApp(MyApp());</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h3><p>在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (c) {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(c);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">printElement(x) {\t<span class=\"comment\">//方法签名写成 void printElement(int x) 更直观</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">list.forEach(printElement);</span><br></pre></td></tr></tbody></table></figure>\n<p><code>forEach</code>的函数定义如下</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> forEach(<span class=\"keyword\">void</span> f(E element)) {</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (E element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) f(element);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>下面的例子直观展示将函数作为变量传递的思想</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder(<span class=\"built_in\">num</span> n) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) => n + i;</span><br><span class=\"line\">}</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//更明晰的写法</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder_(<span class=\"built_in\">num</span> n) {</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> add = (<span class=\"built_in\">num</span> i) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + n;</span><br><span class=\"line\">  };</span><br><span class=\"line\">  <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> adder2 = makeAdder(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adder2(<span class=\"number\">3</span>));</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台将输出 5</p>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"赋值操作符\"><a href=\"#赋值操作符\" class=\"headerlink\" title=\"赋值操作符\"></a>赋值操作符</h3><p>除了<code>=</code>，还有<code>??=</code>，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。</p>\n<h3 id=\"相等\"><a href=\"#相等\" class=\"headerlink\" title=\"相等\"></a>相等</h3><p><code>==</code>将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的<code>identical</code>方法</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"built_in\">bool</span> identical(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/</td>\n<td>除，比如 5/2 = 2.5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">~/</td>\n<td>整除， 5/2 = 2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">is</td>\n<td>对象属于指定类型则返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">is!</td>\n<td>对象不属于指定类型返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">as</td>\n<td>类型转换</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><p>分为两种</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">condition ? expr1 : expr2\t<span class=\"comment\">//通用表达式</span></span><br><span class=\"line\">expr1 ?? expr2\t<span class=\"comment\">//如果 expr1 非空，返回其值，否则返回 expr2</span></span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"级联调用与非空调用\"><a href=\"#级联调用与非空调用\" class=\"headerlink\" title=\"级联调用与非空调用\"></a>级联调用与非空调用</h3><figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常规写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>);</span><br><span class=\"line\">button.text = <span class=\"string\">'Confirm'</span>;</span><br><span class=\"line\">button.classes.add(<span class=\"string\">'important'</span>);</span><br><span class=\"line\">button.onClick.listen((e) => <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用级联表达式</span></span><br><span class=\"line\"><span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>) <span class=\"comment\">// Get an object.</span></span><br><span class=\"line\">  ..text = <span class=\"string\">'Confirm'</span>   <span class=\"comment\">// Use its members.</span></span><br><span class=\"line\">  ..classes.add(<span class=\"string\">'important'</span>)</span><br><span class=\"line\">  ..onClick.listen((e) => <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非空调用</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(button?.text);</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>Dart 语言在比如 <code>if/else</code>、<code>[do、]while</code>、<code>for</code>、<code>switch/case</code>等语句上跟 Java 类似，不再赘述。</p>\n<p>异常处理的做法如下</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'x should be less than 10'</span>;\t</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获异常</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> {</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">} on OutOfLlamasException {</span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> {</span><br><span class=\"line\"> <span class=\"comment\">//...</span></span><br><span class=\"line\">} on Exception <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">} catch (e, s) {\t</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Exception details:\\n <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Stack trace:\\n <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">}</span></span></span></span><br></pre></td></tr></tbody></table></figure><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":3876,"excerpt":"<p>终于开始 Flutter 的具体学习，一切从 Dart 语言开始。</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">void main() {</span><br><span class=\"line\">    print('hello world');</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>","more":"<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。</p>\n<p><img src=\"/Dart 基础入门/idea_create.png\" alt=\"\"></p>\n<p>创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的<code>main</code>函数作为运行的入口。在<code>run</code>之前需要<code>edit configuration</code>，很简单，只要指定对应的文件即可。</p>\n<p><img src=\"/Dart 基础入门/idea_category.png\" alt=\"\"></p>\n<h2 id=\"声明变量\"><a href=\"#声明变量\" class=\"headerlink\" title=\"声明变量\"></a>声明变量</h2><p>Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为<code>null</code>。可以使用具体的类型声明，也可以使用<code>var</code>、<code>dynamic</code>、<code>const</code>、<code>final</code>等关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  var d = 2.0;</span><br><span class=\"line\">  var s = &apos;hello&apos;;</span><br><span class=\"line\">  var b = true;</span><br><span class=\"line\">  var l = [1, 2, 3];</span><br><span class=\"line\">  var m = &#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  print(main is Function);  //true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查看官方库的<code>core</code>包，可以大概看出其结构</p>\n<p><img src=\"/Dart 基础入门/dart_core.png\" alt=\"dart_core\"></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>包括 int 和 double，分别代表整形和浮点型。</p>\n<p>int 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"string\">'hello'</span> + <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"string\">'hello'</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s5 = <span class=\"string\">\"\"\"hello </span></span><br><span class=\"line\"><span class=\"string\">              world\"\"\"</span>;</span><br></pre></td></tr></table></figure>\n<p>如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u&#123;1f44f&#125;'</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\"></span><br><span class=\"line\">Runes runes = <span class=\"keyword\">new</span> Runes(<span class=\"string\">'\\u&#123;1f44d&#125;'</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCode(runes.first));</span><br></pre></td></tr></table></figure>\n<p>上面的输出为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">👏</span><br><span class=\"line\">👍</span><br></pre></td></tr></table></figure>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><p>提供 bool 用来声明布尔型变量，默认为 false。</p>\n<h3 id=\"List-和-Map\"><a href=\"#List-和-Map\" class=\"headerlink\" title=\"List 和 Map\"></a>List 和 Map</h3><figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">l.forEach((x) =&gt; <span class=\"built_in\">print</span>(x)); <span class=\"comment\">//forEach的参数为 Function</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x <span class=\"keyword\">in</span> l) &#123; <span class=\"comment\">//使用for-in</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">String</span>&gt; map = &#123;<span class=\"number\">0</span>: <span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"b\"</span>&#125;;</span><br><span class=\"line\">map[<span class=\"number\">0</span>] = <span class=\"string\">\"c\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><h3 id=\"普通Function\"><a href=\"#普通Function\" class=\"headerlink\" title=\"普通Function\"></a>普通Function</h3><p>函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  single1(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single2(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single3(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, weight: <span class=\"number\">30</span>); <span class=\"comment\">//由于没有位置约束，必须指定形参名称</span></span><br><span class=\"line\">  single4(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single1(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类型和参数类型可省略，支持返回表达式</span></span><br><span class=\"line\">single2(name, age) =&gt; <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single3(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, &#123;<span class=\"built_in\">int</span> weight = <span class=\"number\">60</span>, <span class=\"built_in\">int</span> height&#125;) =&gt; <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single4(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, [<span class=\"built_in\">int</span> weight, <span class=\"built_in\">int</span> height]) =&gt; <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>对于<code>main</code>方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h3><p>在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (c) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(c);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">printElement(x) &#123;\t<span class=\"comment\">//方法签名写成 void printElement(int x) 更直观</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">list.forEach(printElement);</span><br></pre></td></tr></table></figure>\n<p><code>forEach</code>的函数定义如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> forEach(<span class=\"keyword\">void</span> f(E element)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (E element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) f(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的例子直观展示将函数作为变量传递的思想</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder(<span class=\"built_in\">num</span> n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; n + i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//更明晰的写法</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder_(<span class=\"built_in\">num</span> n) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> add = (<span class=\"built_in\">num</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + n;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> adder2 = makeAdder(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adder2(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n<p>控制台将输出 5</p>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"赋值操作符\"><a href=\"#赋值操作符\" class=\"headerlink\" title=\"赋值操作符\"></a>赋值操作符</h3><p>除了<code>=</code>，还有<code>??=</code>，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。</p>\n<h3 id=\"相等\"><a href=\"#相等\" class=\"headerlink\" title=\"相等\"></a>相等</h3><p><code>==</code>将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的<code>identical</code>方法</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"built_in\">bool</span> identical(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br></pre></td></tr></table></figure>\n<h3 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/</td>\n<td>除，比如 5/2 = 2.5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">~/</td>\n<td>整除， 5/2 = 2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">is</td>\n<td>对象属于指定类型则返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">is!</td>\n<td>对象不属于指定类型返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">as</td>\n<td>类型转换</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><p>分为两种</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\">condition ? expr1 : expr2\t<span class=\"comment\">//通用表达式</span></span><br><span class=\"line\">expr1 ?? expr2\t<span class=\"comment\">//如果 expr1 非空，返回其值，否则返回 expr2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"级联调用与非空调用\"><a href=\"#级联调用与非空调用\" class=\"headerlink\" title=\"级联调用与非空调用\"></a>级联调用与非空调用</h3><figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常规写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>);</span><br><span class=\"line\">button.text = <span class=\"string\">'Confirm'</span>;</span><br><span class=\"line\">button.classes.add(<span class=\"string\">'important'</span>);</span><br><span class=\"line\">button.onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用级联表达式</span></span><br><span class=\"line\"><span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>) <span class=\"comment\">// Get an object.</span></span><br><span class=\"line\">  ..text = <span class=\"string\">'Confirm'</span>   <span class=\"comment\">// Use its members.</span></span><br><span class=\"line\">  ..classes.add(<span class=\"string\">'important'</span>)</span><br><span class=\"line\">  ..onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非空调用</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(button?.text);</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>Dart 语言在比如 <code>if/else</code>、<code>[do、]while</code>、<code>for</code>、<code>switch/case</code>等语句上跟 Java 类似，不再赘述。</p>\n<p>异常处理的做法如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'x should be less than 10'</span>;\t</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获异常</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125; catch (e, s) &#123;\t</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Exception details:\\n <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Stack trace:\\n <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure>"},{"title":"Dart 反射初识","date":"2019-05-20T02:16:44.000Z","_content":"\n在 [Java 反射详解](https://febers.github.io/Java-反射详解/) 一文中，我们知道`反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力`。换一个角度说，反射可以细分为自省——程序在运行时决定自身结构的能力，以及自我修正——程序在运行时改变自身的能力。Dart 的反射基于 mirror 概念，它指的是反映其他对象的对象，并且目前只支持自省，不支持自我修改。\n\n<!--more-->\n\n## Mirror\n\n### Example\n\n```dart\nmain() {\n    ClassMirror cm = reflectClass(ChildClass);\n    cm.instanceMembers.forEach((key, value) => print('$key >>> $value'));\n    \n    ClassMirror simpleCM = reflectClass(Simple);\n    Simple simple = simpleCM.newInstance(Symbol.empty, ['hey']) as Simple;\n}\n```\n```dart\nclass Simple {\n  Simple(a) {\n    print('A new Simple: $a');\n  }\n}\n```\n\n```dart\n\nclass SuperClass {\n  int superField = 0;\n  final int superFinalField = 1;\n  int get superGetter => 2;\n  set superSetter(x){ superField = x; }\n  int superMethod(x) => 4;\n\n  static int superStaticField = 5;\n  static final int superStaticFinalField = 6;\n  static const superStaticConstField = 7;\n  static int get superStaticGetter => 8;\n  static set superStaticSetter(x) { }\n  static int superStaticMethod(x) => 10;\n}\n\nclass ChildClass extends SuperClass {\n  int aField = 11;\n  final int aFinalField = 12;\n  get aGetter => 13;\n  set aSetter(x) { aField = x; }\n  int aMethod(x) => 15;\n\n  static int staticField = 16;\n  static final staticFinalField = 17;\n  static const staticConstField = 18;\n  static int get staticGetter => 19;\n  static set staticSetter(x) { staticField = x; }\n  static int staticMethod(x) => 21;\n}\n```\n\n\n\n控制台输出为\n\n```bash\nSymbol(\"==\") >>> MethodMirror on '=='\nSymbol(\"hashCode\") >>> MethodMirror on 'hashCode'\nSymbol(\"toString\") >>> MethodMirror on 'toString'\nSymbol(\"noSuchMethod\") >>> MethodMirror on 'noSuchMethod'\nSymbol(\"runtimeType\") >>> MethodMirror on 'runtimeType'\nSymbol(\"superField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"superField=\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"superFinalField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"superGetter\") >>> MethodMirror on 'superGetter'\nSymbol(\"superSetter=\") >>> MethodMirror on 'superSetter='\nSymbol(\"superMethod\") >>> MethodMirror on 'superMethod'\nSymbol(\"aField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"aField=\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"aFinalField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"aGetter\") >>> MethodMirror on 'aGetter'\nSymbol(\"aSetter=\") >>> MethodMirror on 'aSetter='\nSymbol(\"aMethod\") >>> MethodMirror on 'aMethod'\nA new Simple: hey\n```\n\n### 分类\n\n在官方 API 页面可以看到所有的 Mirror 类型：[dart:mirrors library](https://api.dartlang.org/stable/2.3.0/dart-mirrors/dart-mirrors-library.html)。Mirror 的主要类型如下\n\n- ClassMirror：Dart 类的反射类型\n\n- InstanceMirror：Dart 实例的反射类型\n\n- ClosureMirror： 闭包的反射类型\n\n- DeclarationMirror：类属性的反射类型\n\n- IsolateMirror：Isolate 的反射类型\n\n- MethodMirror：Dart 方法（包括函数、构造函数、getter/setter 函数）的反射类型\n\n  \n\n通过`dart:mirrors`包内顶层函数`reflecClass` 获得类的“镜像”的实例，该实例的`instanceMembers`属性如下\n\n```dart\n  Map<Symbol, MethodMirror> get instanceMembers;\n```\n\n\n\n由控制台输出结果可以看到，对于普通字段（属性），除自身外还列出了以“=”结尾的 setter 字段，对于不提供 setter 的`final`字段则只出现一次。\n\n使用`staticMembers`将列出所有的静态字段\n\n```dart\ncm.staticMembers.forEach((key, value) => print('$key >>> $value'));\n```\n\n输出如下\n\n```bash\nSymbol(\"staticField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticField=\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticFinalField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticConstField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticGetter\") >>> MethodMirror on 'staticGetter'\nSymbol(\"staticSetter=\") >>> MethodMirror on 'staticSetter='\nSymbol(\"staticMethod\") >>> MethodMirror on 'staticMethod'\n```\n\n可以发现父类静态成员没有出现在列表中，这是因为静态属性不会被继承、不能被`ChildClass`调用。\n\n### Symbol\n\n`Symbol`表示使用 Dart 的 mirror API 反射得到的实例类型，位于`dart:core`包\n\n```dart\npart of dart.core;\n\n/// Opaque name used by mirrors, invocations and [Function.apply].\nabstract class Symbol {\n\n  static const Symbol unaryMinus = const Symbol(\"unary-\");\n\n  static const Symbol empty = const Symbol(\"\");\n\n  //工厂构造方法\n  //也可以直接通过 Symbol s = #name; 创建\n  const factory Symbol(String name) = internal.Symbol;\n\n  int get hashCode;\n  \n  bool operator ==(other);\n}\n```\n\n### 源码\n\n通过 ClassMirror 的源码，可以大概看出 Dart 语言关于反射的设计思想以及对外提供的 API\n\n```dart\nabstract class ClassMirror implements TypeMirror, ObjectMirror {\n\n  ClassMirror get superclass;\t//父类 ， Object的父类为null\n\n  List<ClassMirror> get superinterfaces;\t//接口列表\n\n  bool get isAbstract;\n\n  bool get isEnum;\n\n  Map<Symbol, DeclarationMirror> get declarations;\t//不包含父类属性和方法\n\n  Map<Symbol, MethodMirror> get instanceMembers;\t//实例属性\n\n  Map<Symbol, MethodMirror> get staticMembers;\t//静态属性\n\n  //如果S = A with B ,那么ClassMirror（S）.mixin 为 ClassMirror（B），否则返回本身\n  ClassMirror get mixin;\n    \n  /**\n   * 调用构造方法\n   * @param constructorName 构造方法名称（默认构造方法为空字符串，命名构造方法为其命名）\n   * @param positionalArguments 参数列表\n   */\n  InstanceMirror newInstance(Symbol constructorName, List positionalArguments,\n      [Map<Symbol, dynamic> namedArguments]);\n\n  bool operator ==(other);\n\n  bool isSubclassOf(ClassMirror other);\n}\n```\n\n\n\n## 影响\n\n在 Java 中，当开发者多次（10w 次以上）访问、修改某一属性时，使用反射的成本会比正常访问高很多，同时会让`private`修饰符失去作用。在 Dart 中，反射的影响主要在于，编译器使用`tree shaking`的过程确定应用真正运行时使用的代码，以减少程序的大小。但是使用反射将使`tree shaking`失效，因为任何代码都有可能被使用，由此严重影响应用的启动时间和内存占用。\n\n解决👆一问题的有效方法是，通过代码生成执行反射。为了“告知”编译器使用反射的代码和方式，开发者可以使用`dart:reflectable`库，通过特定元数据注解反射代码。[reflectable](https://github.com/dart-lang/reflectable)\n\n另一个影响在于最小化，其表示对下载到 Web 浏览器的源程序进行压缩的过程。在最小化过程中，源代码使用的名称在编译代码中被压缩成了短名称。这一过程会对反射带来不良影响，因为最小化之后，原来表示声明的名称的字符串，不再对应程序中的实际名称。\n\n为了解决这一问题， Dart 反射使用 symbol 而非字符串作为 key，symbol 会被执行最小化的程序`minifier`识别并使用与标识符同样的压缩方式。这也是上面的输出中出现`Symbol(...)`的原因。开发者也可以通过 MirrorSystem 提供的`static String getName(Symbol symbol)`方法获得非最小化名称字符串。 \n\n## 小结\n\n目前来看 Dart 还不算一门“足够完善”的语言，比如反射机制的不完全、文档教程匮乏等等，相信随着 Flutter 的发展，这门语言的发展会更加地好。关于 Dart 反射的知识全部来自 Gilad Bracha 所著《Dart 编程语言》，不知道是不是翻译的问题，写得不够明晰，看得也是一头雾水。希望有朝一日，更加掌握 Dart 的反射机制，再写一篇《Dart 反射机制详解》的文章 😄。\n\n\n\n![](https://images-na.ssl-images-amazon.com/images/I/51r64LJDGuL._SX369_BO1,204,203,200_.jpg)","source":"_posts/Dart-反射初识.md","raw":"---\ntitle: Dart 反射初识\ndate: 2019-05-20 10:16:44\ntags:\n- Dart\n- 反射\ncategories:\n- Dart\n---\n\n在 [Java 反射详解](https://febers.github.io/Java-反射详解/) 一文中，我们知道`反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力`。换一个角度说，反射可以细分为自省——程序在运行时决定自身结构的能力，以及自我修正——程序在运行时改变自身的能力。Dart 的反射基于 mirror 概念，它指的是反映其他对象的对象，并且目前只支持自省，不支持自我修改。\n\n<!--more-->\n\n## Mirror\n\n### Example\n\n```dart\nmain() {\n    ClassMirror cm = reflectClass(ChildClass);\n    cm.instanceMembers.forEach((key, value) => print('$key >>> $value'));\n    \n    ClassMirror simpleCM = reflectClass(Simple);\n    Simple simple = simpleCM.newInstance(Symbol.empty, ['hey']) as Simple;\n}\n```\n```dart\nclass Simple {\n  Simple(a) {\n    print('A new Simple: $a');\n  }\n}\n```\n\n```dart\n\nclass SuperClass {\n  int superField = 0;\n  final int superFinalField = 1;\n  int get superGetter => 2;\n  set superSetter(x){ superField = x; }\n  int superMethod(x) => 4;\n\n  static int superStaticField = 5;\n  static final int superStaticFinalField = 6;\n  static const superStaticConstField = 7;\n  static int get superStaticGetter => 8;\n  static set superStaticSetter(x) { }\n  static int superStaticMethod(x) => 10;\n}\n\nclass ChildClass extends SuperClass {\n  int aField = 11;\n  final int aFinalField = 12;\n  get aGetter => 13;\n  set aSetter(x) { aField = x; }\n  int aMethod(x) => 15;\n\n  static int staticField = 16;\n  static final staticFinalField = 17;\n  static const staticConstField = 18;\n  static int get staticGetter => 19;\n  static set staticSetter(x) { staticField = x; }\n  static int staticMethod(x) => 21;\n}\n```\n\n\n\n控制台输出为\n\n```bash\nSymbol(\"==\") >>> MethodMirror on '=='\nSymbol(\"hashCode\") >>> MethodMirror on 'hashCode'\nSymbol(\"toString\") >>> MethodMirror on 'toString'\nSymbol(\"noSuchMethod\") >>> MethodMirror on 'noSuchMethod'\nSymbol(\"runtimeType\") >>> MethodMirror on 'runtimeType'\nSymbol(\"superField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"superField=\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"superFinalField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"superGetter\") >>> MethodMirror on 'superGetter'\nSymbol(\"superSetter=\") >>> MethodMirror on 'superSetter='\nSymbol(\"superMethod\") >>> MethodMirror on 'superMethod'\nSymbol(\"aField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"aField=\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"aFinalField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"aGetter\") >>> MethodMirror on 'aGetter'\nSymbol(\"aSetter=\") >>> MethodMirror on 'aSetter='\nSymbol(\"aMethod\") >>> MethodMirror on 'aMethod'\nA new Simple: hey\n```\n\n### 分类\n\n在官方 API 页面可以看到所有的 Mirror 类型：[dart:mirrors library](https://api.dartlang.org/stable/2.3.0/dart-mirrors/dart-mirrors-library.html)。Mirror 的主要类型如下\n\n- ClassMirror：Dart 类的反射类型\n\n- InstanceMirror：Dart 实例的反射类型\n\n- ClosureMirror： 闭包的反射类型\n\n- DeclarationMirror：类属性的反射类型\n\n- IsolateMirror：Isolate 的反射类型\n\n- MethodMirror：Dart 方法（包括函数、构造函数、getter/setter 函数）的反射类型\n\n  \n\n通过`dart:mirrors`包内顶层函数`reflecClass` 获得类的“镜像”的实例，该实例的`instanceMembers`属性如下\n\n```dart\n  Map<Symbol, MethodMirror> get instanceMembers;\n```\n\n\n\n由控制台输出结果可以看到，对于普通字段（属性），除自身外还列出了以“=”结尾的 setter 字段，对于不提供 setter 的`final`字段则只出现一次。\n\n使用`staticMembers`将列出所有的静态字段\n\n```dart\ncm.staticMembers.forEach((key, value) => print('$key >>> $value'));\n```\n\n输出如下\n\n```bash\nSymbol(\"staticField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticField=\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticFinalField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticConstField\") >>> Instance of '_SyntheticAccessor'\nSymbol(\"staticGetter\") >>> MethodMirror on 'staticGetter'\nSymbol(\"staticSetter=\") >>> MethodMirror on 'staticSetter='\nSymbol(\"staticMethod\") >>> MethodMirror on 'staticMethod'\n```\n\n可以发现父类静态成员没有出现在列表中，这是因为静态属性不会被继承、不能被`ChildClass`调用。\n\n### Symbol\n\n`Symbol`表示使用 Dart 的 mirror API 反射得到的实例类型，位于`dart:core`包\n\n```dart\npart of dart.core;\n\n/// Opaque name used by mirrors, invocations and [Function.apply].\nabstract class Symbol {\n\n  static const Symbol unaryMinus = const Symbol(\"unary-\");\n\n  static const Symbol empty = const Symbol(\"\");\n\n  //工厂构造方法\n  //也可以直接通过 Symbol s = #name; 创建\n  const factory Symbol(String name) = internal.Symbol;\n\n  int get hashCode;\n  \n  bool operator ==(other);\n}\n```\n\n### 源码\n\n通过 ClassMirror 的源码，可以大概看出 Dart 语言关于反射的设计思想以及对外提供的 API\n\n```dart\nabstract class ClassMirror implements TypeMirror, ObjectMirror {\n\n  ClassMirror get superclass;\t//父类 ， Object的父类为null\n\n  List<ClassMirror> get superinterfaces;\t//接口列表\n\n  bool get isAbstract;\n\n  bool get isEnum;\n\n  Map<Symbol, DeclarationMirror> get declarations;\t//不包含父类属性和方法\n\n  Map<Symbol, MethodMirror> get instanceMembers;\t//实例属性\n\n  Map<Symbol, MethodMirror> get staticMembers;\t//静态属性\n\n  //如果S = A with B ,那么ClassMirror（S）.mixin 为 ClassMirror（B），否则返回本身\n  ClassMirror get mixin;\n    \n  /**\n   * 调用构造方法\n   * @param constructorName 构造方法名称（默认构造方法为空字符串，命名构造方法为其命名）\n   * @param positionalArguments 参数列表\n   */\n  InstanceMirror newInstance(Symbol constructorName, List positionalArguments,\n      [Map<Symbol, dynamic> namedArguments]);\n\n  bool operator ==(other);\n\n  bool isSubclassOf(ClassMirror other);\n}\n```\n\n\n\n## 影响\n\n在 Java 中，当开发者多次（10w 次以上）访问、修改某一属性时，使用反射的成本会比正常访问高很多，同时会让`private`修饰符失去作用。在 Dart 中，反射的影响主要在于，编译器使用`tree shaking`的过程确定应用真正运行时使用的代码，以减少程序的大小。但是使用反射将使`tree shaking`失效，因为任何代码都有可能被使用，由此严重影响应用的启动时间和内存占用。\n\n解决👆一问题的有效方法是，通过代码生成执行反射。为了“告知”编译器使用反射的代码和方式，开发者可以使用`dart:reflectable`库，通过特定元数据注解反射代码。[reflectable](https://github.com/dart-lang/reflectable)\n\n另一个影响在于最小化，其表示对下载到 Web 浏览器的源程序进行压缩的过程。在最小化过程中，源代码使用的名称在编译代码中被压缩成了短名称。这一过程会对反射带来不良影响，因为最小化之后，原来表示声明的名称的字符串，不再对应程序中的实际名称。\n\n为了解决这一问题， Dart 反射使用 symbol 而非字符串作为 key，symbol 会被执行最小化的程序`minifier`识别并使用与标识符同样的压缩方式。这也是上面的输出中出现`Symbol(...)`的原因。开发者也可以通过 MirrorSystem 提供的`static String getName(Symbol symbol)`方法获得非最小化名称字符串。 \n\n## 小结\n\n目前来看 Dart 还不算一门“足够完善”的语言，比如反射机制的不完全、文档教程匮乏等等，相信随着 Flutter 的发展，这门语言的发展会更加地好。关于 Dart 反射的知识全部来自 Gilad Bracha 所著《Dart 编程语言》，不知道是不是翻译的问题，写得不够明晰，看得也是一头雾水。希望有朝一日，更加掌握 Dart 的反射机制，再写一篇《Dart 反射机制详解》的文章 😄。\n\n\n\n![](https://images-na.ssl-images-amazon.com/images/I/51r64LJDGuL._SX369_BO1,204,203,200_.jpg)","slug":"Dart-反射初识","published":1,"updated":"2019-06-02T04:55:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqv00008y4up8dihh18f","content":"<p>在 <a href=\"https://febers.github.io/Java-反射详解/\" target=\"_blank\" rel=\"noopener\">Java 反射详解</a> 一文中，我们知道<code>反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力</code>。换一个角度说，反射可以细分为自省——程序在运行时决定自身结构的能力，以及自我修正——程序在运行时改变自身的能力。Dart 的反射基于 mirror 概念，它指的是反映其他对象的对象，并且目前只支持自省，不支持自我修改。</p>\n<a id=\"more\"></a>\n<h2 id=\"Mirror\"><a href=\"#Mirror\" class=\"headerlink\" title=\"Mirror\"></a>Mirror</h2><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">main() {</span><br><span class=\"line\">    ClassMirror cm = reflectClass(ChildClass);</span><br><span class=\"line\">    cm.instanceMembers.forEach((key, value) => <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$key</span> >>> <span class=\"subst\">$value<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    ClassMirror simpleCM = reflectClass(Simple);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    Simple simple = simpleCM.newInstance(Symbol.empty, ['</span></span>hey'</span>]) <span class=\"keyword\">as</span> Simple;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Simple</span> </span>{</span><br><span class=\"line\">  Simple(a) {</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'A new Simple: <span class=\"subst\">$a<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  }</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">}</span></span></span></span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span> </span>{</span><br><span class=\"line\">  <span class=\"built_in\">int</span> superField = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> superFinalField = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> superGetter => <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> superSetter(x){ superField = x; }</span><br><span class=\"line\">  <span class=\"built_in\">int</span> superMethod(x) => <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> superStaticField = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> superStaticFinalField = <span class=\"number\">6</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> superStaticConstField = <span class=\"number\">7</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> superStaticGetter => <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">set</span> superStaticSetter(x) { }</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> superStaticMethod(x) => <span class=\"number\">10</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperClass</span> </span>{</span><br><span class=\"line\">  <span class=\"built_in\">int</span> aField = <span class=\"number\">11</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> aFinalField = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> aGetter => <span class=\"number\">13</span>;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> aSetter(x) { aField = x; }</span><br><span class=\"line\">  <span class=\"built_in\">int</span> aMethod(x) => <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> staticField = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> staticFinalField = <span class=\"number\">17</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> staticConstField = <span class=\"number\">18</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> staticGetter => <span class=\"number\">19</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">set</span> staticSetter(x) { staticField = x; }</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> staticMethod(x) => <span class=\"number\">21</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Symbol(<span class=\"string\">\"==\"</span>) >>> MethodMirror on <span class=\"string\">'=='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"hashCode\"</span>) >>> MethodMirror on <span class=\"string\">'hashCode'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"toString\"</span>) >>> MethodMirror on <span class=\"string\">'toString'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"noSuchMethod\"</span>) >>> MethodMirror on <span class=\"string\">'noSuchMethod'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"runtimeType\"</span>) >>> MethodMirror on <span class=\"string\">'runtimeType'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superField\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superField=\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superFinalField\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superGetter\"</span>) >>> MethodMirror on <span class=\"string\">'superGetter'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superSetter=\"</span>) >>> MethodMirror on <span class=\"string\">'superSetter='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superMethod\"</span>) >>> MethodMirror on <span class=\"string\">'superMethod'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aField\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aField=\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aFinalField\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aGetter\"</span>) >>> MethodMirror on <span class=\"string\">'aGetter'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aSetter=\"</span>) >>> MethodMirror on <span class=\"string\">'aSetter='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aMethod\"</span>) >>> MethodMirror on <span class=\"string\">'aMethod'</span></span><br><span class=\"line\">A new Simple: hey</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>在官方 API 页面可以看到所有的 Mirror 类型：<a href=\"https://api.dartlang.org/stable/2.3.0/dart-mirrors/dart-mirrors-library.html\" target=\"_blank\" rel=\"noopener\">dart:mirrors library</a>。Mirror 的主要类型如下</p>\n<ul>\n<li><p>ClassMirror：Dart 类的反射类型</p>\n</li>\n<li><p>InstanceMirror：Dart 实例的反射类型</p>\n</li>\n<li><p>ClosureMirror： 闭包的反射类型</p>\n</li>\n<li><p>DeclarationMirror：类属性的反射类型</p>\n</li>\n<li><p>IsolateMirror：Isolate 的反射类型</p>\n</li>\n<li><p>MethodMirror：Dart 方法（包括函数、构造函数、getter/setter 函数）的反射类型</p>\n</li>\n</ul>\n<p>通过<code>dart:mirrors</code>包内顶层函数<code>reflecClass</code> 获得类的“镜像”的实例，该实例的<code>instanceMembers</code>属性如下</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span><<span class=\"built_in\">Symbol</span>, MethodMirror> <span class=\"keyword\">get</span> instanceMembers;</span><br></pre></td></tr></tbody></table></figure>\n<p>由控制台输出结果可以看到，对于普通字段（属性），除自身外还列出了以“=”结尾的 setter 字段，对于不提供 setter 的<code>final</code>字段则只出现一次。</p>\n<p>使用<code>staticMembers</code>将列出所有的静态字段</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cm.staticMembers.forEach((key, value) => <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$key</span> >>> <span class=\"subst\">$value<span class=\"string\">'));</span></span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>输出如下</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Symbol(<span class=\"string\">\"staticField\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticField=\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticFinalField\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticConstField\"</span>) >>> Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticGetter\"</span>) >>> MethodMirror on <span class=\"string\">'staticGetter'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticSetter=\"</span>) >>> MethodMirror on <span class=\"string\">'staticSetter='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticMethod\"</span>) >>> MethodMirror on <span class=\"string\">'staticMethod'</span></span><br></pre></td></tr></tbody></table></figure>\n<p>可以发现父类静态成员没有出现在列表中，这是因为静态属性不会被继承、不能被<code>ChildClass</code>调用。</p>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p><code>Symbol</code>表示使用 Dart 的 mirror API 反射得到的实例类型，位于<code>dart:core</code>包</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">part</span> of dart.core;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Opaque name used by mirrors, invocations and [Function.apply].</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Symbol</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span> unaryMinus = <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"unary-\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span> empty = <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//工厂构造方法</span></span><br><span class=\"line\">  <span class=\"comment\">//也可以直接通过 Symbol s = #name; 创建</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">factory</span> <span class=\"built_in\">Symbol</span>(<span class=\"built_in\">String</span> name) = internal.<span class=\"built_in\">Symbol</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> hashCode;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">operator</span> ==(other);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p>通过 ClassMirror 的源码，可以大概看出 Dart 语言关于反射的设计思想以及对外提供的 API</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMirror</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeMirror</span>, <span class=\"title\">ObjectMirror</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">  ClassMirror <span class=\"keyword\">get</span> superclass;\t<span class=\"comment\">//父类 ， Object的父类为null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">List</span><ClassMirror> <span class=\"keyword\">get</span> superinterfaces;\t<span class=\"comment\">//接口列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">get</span> isAbstract;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">get</span> isEnum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span><<span class=\"built_in\">Symbol</span>, DeclarationMirror> <span class=\"keyword\">get</span> declarations;\t<span class=\"comment\">//不包含父类属性和方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span><<span class=\"built_in\">Symbol</span>, MethodMirror> <span class=\"keyword\">get</span> instanceMembers;\t<span class=\"comment\">//实例属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span><<span class=\"built_in\">Symbol</span>, MethodMirror> <span class=\"keyword\">get</span> staticMembers;\t<span class=\"comment\">//静态属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果S = A with B ,那么ClassMirror（S）.mixin 为 ClassMirror（B），否则返回本身</span></span><br><span class=\"line\">  ClassMirror <span class=\"keyword\">get</span> mixin;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 调用构造方法</span></span><br><span class=\"line\"><span class=\"comment\">   * @param constructorName 构造方法名称（默认构造方法为空字符串，命名构造方法为其命名）</span></span><br><span class=\"line\"><span class=\"comment\">   * @param positionalArguments 参数列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  InstanceMirror newInstance(<span class=\"built_in\">Symbol</span> constructorName, <span class=\"built_in\">List</span> positionalArguments,</span><br><span class=\"line\">      [<span class=\"built_in\">Map</span><<span class=\"built_in\">Symbol</span>, <span class=\"keyword\">dynamic</span>> namedArguments]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">operator</span> ==(other);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isSubclassOf(ClassMirror other);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"影响\"><a href=\"#影响\" class=\"headerlink\" title=\"影响\"></a>影响</h2><p>在 Java 中，当开发者多次（10w 次以上）访问、修改某一属性时，使用反射的成本会比正常访问高很多，同时会让<code>private</code>修饰符失去作用。在 Dart 中，反射的影响主要在于，编译器使用<code>tree shaking</code>的过程确定应用真正运行时使用的代码，以减少程序的大小。但是使用反射将使<code>tree shaking</code>失效，因为任何代码都有可能被使用，由此严重影响应用的启动时间和内存占用。</p>\n<p>解决👆一问题的有效方法是，通过代码生成执行反射。为了“告知”编译器使用反射的代码和方式，开发者可以使用<code>dart:reflectable</code>库，通过特定元数据注解反射代码。<a href=\"https://github.com/dart-lang/reflectable\" target=\"_blank\" rel=\"noopener\">reflectable</a></p>\n<p>另一个影响在于最小化，其表示对下载到 Web 浏览器的源程序进行压缩的过程。在最小化过程中，源代码使用的名称在编译代码中被压缩成了短名称。这一过程会对反射带来不良影响，因为最小化之后，原来表示声明的名称的字符串，不再对应程序中的实际名称。</p>\n<p>为了解决这一问题， Dart 反射使用 symbol 而非字符串作为 key，symbol 会被执行最小化的程序<code>minifier</code>识别并使用与标识符同样的压缩方式。这也是上面的输出中出现<code>Symbol(...)</code>的原因。开发者也可以通过 MirrorSystem 提供的<code>static String getName(Symbol symbol)</code>方法获得非最小化名称字符串。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>目前来看 Dart 还不算一门“足够完善”的语言，比如反射机制的不完全、文档教程匮乏等等，相信随着 Flutter 的发展，这门语言的发展会更加地好。关于 Dart 反射的知识全部来自 Gilad Bracha 所著《Dart 编程语言》，不知道是不是翻译的问题，写得不够明晰，看得也是一头雾水。希望有朝一日，更加掌握 Dart 的反射机制，再写一篇《Dart 反射机制详解》的文章 😄。</p>\n<p><img src=\"https://images-na.ssl-images-amazon.com/images/I/51r64LJDGuL._SX369_BO1,204,203,200_.jpg\" alt></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":5674,"excerpt":"<p>在 <a href=\"https://febers.github.io/Java-反射详解/\" target=\"_blank\" rel=\"noopener\">Java 反射详解</a> 一文中，我们知道<code>反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力</code>。换一个角度说，反射可以细分为自省——程序在运行时决定自身结构的能力，以及自我修正——程序在运行时改变自身的能力。Dart 的反射基于 mirror 概念，它指的是反映其他对象的对象，并且目前只支持自省，不支持自我修改。</p>","more":"<h2 id=\"Mirror\"><a href=\"#Mirror\" class=\"headerlink\" title=\"Mirror\"></a>Mirror</h2><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\">main() &#123;</span><br><span class=\"line\">    ClassMirror cm = reflectClass(ChildClass);</span><br><span class=\"line\">    cm.instanceMembers.forEach((key, value) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$key</span> &gt;&gt;&gt; <span class=\"subst\">$value<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    ClassMirror simpleCM = reflectClass(Simple);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    Simple simple = simpleCM.newInstance(Symbol.empty, ['</span></span>hey'</span>]) <span class=\"keyword\">as</span> Simple;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Simple</span> </span>&#123;</span><br><span class=\"line\">  Simple(a) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'A new Simple: <span class=\"subst\">$a<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  &#125;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> superField = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> superFinalField = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> superGetter =&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> superSetter(x)&#123; superField = x; &#125;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> superMethod(x) =&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> superStaticField = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> superStaticFinalField = <span class=\"number\">6</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> superStaticConstField = <span class=\"number\">7</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> superStaticGetter =&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">set</span> superStaticSetter(x) &#123; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> superStaticMethod(x) =&gt; <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> aField = <span class=\"number\">11</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> aFinalField = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> aGetter =&gt; <span class=\"number\">13</span>;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> aSetter(x) &#123; aField = x; &#125;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> aMethod(x) =&gt; <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> staticField = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> staticFinalField = <span class=\"number\">17</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> staticConstField = <span class=\"number\">18</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> staticGetter =&gt; <span class=\"number\">19</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">set</span> staticSetter(x) &#123; staticField = x; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> staticMethod(x) =&gt; <span class=\"number\">21</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Symbol(<span class=\"string\">\"==\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'=='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"hashCode\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'hashCode'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"toString\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'toString'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"noSuchMethod\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'noSuchMethod'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"runtimeType\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'runtimeType'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superField\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superField=\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superFinalField\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superGetter\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'superGetter'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superSetter=\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'superSetter='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"superMethod\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'superMethod'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aField\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aField=\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aFinalField\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aGetter\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'aGetter'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aSetter=\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'aSetter='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"aMethod\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'aMethod'</span></span><br><span class=\"line\">A new Simple: hey</span><br></pre></td></tr></table></figure>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>在官方 API 页面可以看到所有的 Mirror 类型：<a href=\"https://api.dartlang.org/stable/2.3.0/dart-mirrors/dart-mirrors-library.html\" target=\"_blank\" rel=\"noopener\">dart:mirrors library</a>。Mirror 的主要类型如下</p>\n<ul>\n<li><p>ClassMirror：Dart 类的反射类型</p>\n</li>\n<li><p>InstanceMirror：Dart 实例的反射类型</p>\n</li>\n<li><p>ClosureMirror： 闭包的反射类型</p>\n</li>\n<li><p>DeclarationMirror：类属性的反射类型</p>\n</li>\n<li><p>IsolateMirror：Isolate 的反射类型</p>\n</li>\n<li><p>MethodMirror：Dart 方法（包括函数、构造函数、getter/setter 函数）的反射类型</p>\n</li>\n</ul>\n<p>通过<code>dart:mirrors</code>包内顶层函数<code>reflecClass</code> 获得类的“镜像”的实例，该实例的<code>instanceMembers</code>属性如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, MethodMirror&gt; <span class=\"keyword\">get</span> instanceMembers;</span><br></pre></td></tr></table></figure>\n<p>由控制台输出结果可以看到，对于普通字段（属性），除自身外还列出了以“=”结尾的 setter 字段，对于不提供 setter 的<code>final</code>字段则只出现一次。</p>\n<p>使用<code>staticMembers</code>将列出所有的静态字段</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\">cm.staticMembers.forEach((key, value) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$key</span> &gt;&gt;&gt; <span class=\"subst\">$value<span class=\"string\">'));</span></span></span></span><br></pre></td></tr></table></figure>\n<p>输出如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Symbol(<span class=\"string\">\"staticField\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticField=\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticFinalField\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticConstField\"</span>) &gt;&gt;&gt; Instance of <span class=\"string\">'_SyntheticAccessor'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticGetter\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'staticGetter'</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticSetter=\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'staticSetter='</span></span><br><span class=\"line\">Symbol(<span class=\"string\">\"staticMethod\"</span>) &gt;&gt;&gt; MethodMirror on <span class=\"string\">'staticMethod'</span></span><br></pre></td></tr></table></figure>\n<p>可以发现父类静态成员没有出现在列表中，这是因为静态属性不会被继承、不能被<code>ChildClass</code>调用。</p>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p><code>Symbol</code>表示使用 Dart 的 mirror API 反射得到的实例类型，位于<code>dart:core</code>包</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">part</span> of dart.core;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Opaque name used by mirrors, invocations and [Function.apply].</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Symbol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span> unaryMinus = <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"unary-\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span> empty = <span class=\"keyword\">const</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//工厂构造方法</span></span><br><span class=\"line\">  <span class=\"comment\">//也可以直接通过 Symbol s = #name; 创建</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">factory</span> <span class=\"built_in\">Symbol</span>(<span class=\"built_in\">String</span> name) = internal.<span class=\"built_in\">Symbol</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">int</span> <span class=\"keyword\">get</span> hashCode;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">operator</span> ==(other);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p>通过 ClassMirror 的源码，可以大概看出 Dart 语言关于反射的设计思想以及对外提供的 API</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMirror</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeMirror</span>, <span class=\"title\">ObjectMirror</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  ClassMirror <span class=\"keyword\">get</span> superclass;\t<span class=\"comment\">//父类 ， Object的父类为null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;ClassMirror&gt; <span class=\"keyword\">get</span> superinterfaces;\t<span class=\"comment\">//接口列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">get</span> isAbstract;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">get</span> isEnum;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, DeclarationMirror&gt; <span class=\"keyword\">get</span> declarations;\t<span class=\"comment\">//不包含父类属性和方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, MethodMirror&gt; <span class=\"keyword\">get</span> instanceMembers;\t<span class=\"comment\">//实例属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, MethodMirror&gt; <span class=\"keyword\">get</span> staticMembers;\t<span class=\"comment\">//静态属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果S = A with B ,那么ClassMirror（S）.mixin 为 ClassMirror（B），否则返回本身</span></span><br><span class=\"line\">  ClassMirror <span class=\"keyword\">get</span> mixin;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 调用构造方法</span></span><br><span class=\"line\"><span class=\"comment\">   * @param constructorName 构造方法名称（默认构造方法为空字符串，命名构造方法为其命名）</span></span><br><span class=\"line\"><span class=\"comment\">   * @param positionalArguments 参数列表</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  InstanceMirror newInstance(<span class=\"built_in\">Symbol</span> constructorName, <span class=\"built_in\">List</span> positionalArguments,</span><br><span class=\"line\">      [<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, <span class=\"keyword\">dynamic</span>&gt; namedArguments]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> <span class=\"keyword\">operator</span> ==(other);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isSubclassOf(ClassMirror other);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"影响\"><a href=\"#影响\" class=\"headerlink\" title=\"影响\"></a>影响</h2><p>在 Java 中，当开发者多次（10w 次以上）访问、修改某一属性时，使用反射的成本会比正常访问高很多，同时会让<code>private</code>修饰符失去作用。在 Dart 中，反射的影响主要在于，编译器使用<code>tree shaking</code>的过程确定应用真正运行时使用的代码，以减少程序的大小。但是使用反射将使<code>tree shaking</code>失效，因为任何代码都有可能被使用，由此严重影响应用的启动时间和内存占用。</p>\n<p>解决👆一问题的有效方法是，通过代码生成执行反射。为了“告知”编译器使用反射的代码和方式，开发者可以使用<code>dart:reflectable</code>库，通过特定元数据注解反射代码。<a href=\"https://github.com/dart-lang/reflectable\" target=\"_blank\" rel=\"noopener\">reflectable</a></p>\n<p>另一个影响在于最小化，其表示对下载到 Web 浏览器的源程序进行压缩的过程。在最小化过程中，源代码使用的名称在编译代码中被压缩成了短名称。这一过程会对反射带来不良影响，因为最小化之后，原来表示声明的名称的字符串，不再对应程序中的实际名称。</p>\n<p>为了解决这一问题， Dart 反射使用 symbol 而非字符串作为 key，symbol 会被执行最小化的程序<code>minifier</code>识别并使用与标识符同样的压缩方式。这也是上面的输出中出现<code>Symbol(...)</code>的原因。开发者也可以通过 MirrorSystem 提供的<code>static String getName(Symbol symbol)</code>方法获得非最小化名称字符串。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>目前来看 Dart 还不算一门“足够完善”的语言，比如反射机制的不完全、文档教程匮乏等等，相信随着 Flutter 的发展，这门语言的发展会更加地好。关于 Dart 反射的知识全部来自 Gilad Bracha 所著《Dart 编程语言》，不知道是不是翻译的问题，写得不够明晰，看得也是一头雾水。希望有朝一日，更加掌握 Dart 的反射机制，再写一篇《Dart 反射机制详解》的文章 😄。</p>\n<p><img src=\"https://images-na.ssl-images-amazon.com/images/I/51r64LJDGuL._SX369_BO1,204,203,200_.jpg\" alt=\"\"></p>"},{"title":"Java 反射详解","date":"2019-03-16T15:25:47.000Z","_content":"\n反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。<!--more-->\n\n## 使用\n### Example\n```Java\npublic class Apple {\n\n    private int price;\n\n    public Apple(){}\n\n    public Apple(int price) {\n        this.price = price;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, \n            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //正常调用\n        Apple apple = new Apple();\n        apple.setPrice(10);\n        System.out.println(\"Price is \" + apple.getPrice());\n\n        //反射调用\n        Class clazz = Class.forName(\"Apple\");\n\n        //使用 getFields() 无法获取私有属性\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field: fields) {\n            System.out.println(\"Field is \" + field.getName());\n        }\n        Method setPriceMethod = clazz.getMethod(\"setPrice\", int.class);\n\n        Constructor appleConstructor = clazz.getConstructor();\n        Object appleObj = appleConstructor.newInstance();\n        //Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器\n        //Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器\n\n        setPriceMethod.invoke(appleObj, 12);\n\n        Method getPriceMethod = clazz.getMethod(\"getPrice\");\n        System.out.println(\"Price is \" + getPriceMethod.invoke(appleObj));\n    }\n}\n```\n### API\n#### 类的实例化和构造函数\n\n> 获取公有构造函数，不包括父类，Class.class\n> public Constructor<?>[] getConstructors() \n> public Constructor<T> getConstructor(Class<?>... parameterTypes)\n>\n> 获取当前类构造函数，忽略修饰符\n> public Constructor<?>[] getDeclaredConstructors()\n> public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)\n\n> 构造函数调用，Constructor.class\n> public T newInstance(Object... initargs)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类成员变量的获取\n\n> 获取公有变量，包括父类，Class.class\n> public Field[] getFields()\n> public Field getField(String name)\n>\n> 获取当前类成员变量，忽略修饰符\n> public Field[] getDeclaredFields()\n> public Field getDeclaredField(String name)\n\n> 成员变量赋值，Field.class\n> //obj为实例对象\n> public void set(Object obj,Object value)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类方法的获取\n\n> 获取公有方法，包括父类，Class.class\n> public Method[] getMethods()\n> public Method getMethod(String name, Class<?>... parameterTypes)\n>\n> 获取当前类方法，忽略修饰符\n> public Method[] getDeclaredMethods()\n> public Method getDeclaredMethod(String name, Class<?>... parameterTypes)\n\n> 方法调用，Method.class\n> //obj为类实例化对象，如果为静态方法obj为Null\n> invoke(Object obj, Object... args)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类注解的获取\n\n> 获取类的\"annotationClass\"类型的注解，包括父类\n> public Annotation<A>    getAnnotation(Class annotationClass)\n>\n> // 获取类的全部注解 ，包括父类\n> public Annotation[]    getAnnotations()\n>\n> // 获取类自身声明的全部注解 ，忽略修饰符\n> public Annotation[]    getDeclaredAnnotations()\n\n#### 类父类的获取\n\n> 获取实现的全部接口\n> public Type[]    getGenericInterfaces()\n>\n> 获取父类\n> public Type    getGenericSuperclass()\n\n## 原理\n\n### RTTI和Class对象\n\nRTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。\n\n很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。\n\n而这些类型信息是通过一个特殊对象**Class（java.lang.Class）**实现的，它包含跟类相关的信息。\n\n当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。\n\n- 加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。\n- 连接：\n  - 验证 是否有正确的内部结构，并和其他类协调一致\n  - 准备 负责为类的静态成员分配内存，并设置默认初始化值\n  - 解析 将类的二进制数据中的符号引用替换为直接引用\n\n- 初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。\n\n获取 Class 对象的方式有三种\n\n1. Object 类的 getClass() 方法，执行静态块和动态构造块\n\n2. 数据类型的静态属性 class ，不会初始化该类\n\n3. Class类中的静态方法`public static Class forName(String className)`，执行静态块，不执行动态构造块\n\n### RTTI和反射\n\nJava 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。\n\nRTTI和反射之间的真正区别只在于：\n\n> RTTI：编译器在编译时打开和检查.class文件\n> 反射：运行时打开和检查.class文件\n\n严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能\n\n未完待续","source":"_posts/Java-反射详解.md","raw":"---\ntitle: Java 反射详解\ndate: 2019-03-16 23:25:47\ntags:\n- Java\n- 反射\ncategories:\n- Java\n---\n\n反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。<!--more-->\n\n## 使用\n### Example\n```Java\npublic class Apple {\n\n    private int price;\n\n    public Apple(){}\n\n    public Apple(int price) {\n        this.price = price;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, \n            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //正常调用\n        Apple apple = new Apple();\n        apple.setPrice(10);\n        System.out.println(\"Price is \" + apple.getPrice());\n\n        //反射调用\n        Class clazz = Class.forName(\"Apple\");\n\n        //使用 getFields() 无法获取私有属性\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field: fields) {\n            System.out.println(\"Field is \" + field.getName());\n        }\n        Method setPriceMethod = clazz.getMethod(\"setPrice\", int.class);\n\n        Constructor appleConstructor = clazz.getConstructor();\n        Object appleObj = appleConstructor.newInstance();\n        //Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器\n        //Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器\n\n        setPriceMethod.invoke(appleObj, 12);\n\n        Method getPriceMethod = clazz.getMethod(\"getPrice\");\n        System.out.println(\"Price is \" + getPriceMethod.invoke(appleObj));\n    }\n}\n```\n### API\n#### 类的实例化和构造函数\n\n> 获取公有构造函数，不包括父类，Class.class\n> public Constructor<?>[] getConstructors() \n> public Constructor<T> getConstructor(Class<?>... parameterTypes)\n>\n> 获取当前类构造函数，忽略修饰符\n> public Constructor<?>[] getDeclaredConstructors()\n> public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)\n\n> 构造函数调用，Constructor.class\n> public T newInstance(Object... initargs)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类成员变量的获取\n\n> 获取公有变量，包括父类，Class.class\n> public Field[] getFields()\n> public Field getField(String name)\n>\n> 获取当前类成员变量，忽略修饰符\n> public Field[] getDeclaredFields()\n> public Field getDeclaredField(String name)\n\n> 成员变量赋值，Field.class\n> //obj为实例对象\n> public void set(Object obj,Object value)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类方法的获取\n\n> 获取公有方法，包括父类，Class.class\n> public Method[] getMethods()\n> public Method getMethod(String name, Class<?>... parameterTypes)\n>\n> 获取当前类方法，忽略修饰符\n> public Method[] getDeclaredMethods()\n> public Method getDeclaredMethod(String name, Class<?>... parameterTypes)\n\n> 方法调用，Method.class\n> //obj为类实例化对象，如果为静态方法obj为Null\n> invoke(Object obj, Object... args)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类注解的获取\n\n> 获取类的\"annotationClass\"类型的注解，包括父类\n> public Annotation<A>    getAnnotation(Class annotationClass)\n>\n> // 获取类的全部注解 ，包括父类\n> public Annotation[]    getAnnotations()\n>\n> // 获取类自身声明的全部注解 ，忽略修饰符\n> public Annotation[]    getDeclaredAnnotations()\n\n#### 类父类的获取\n\n> 获取实现的全部接口\n> public Type[]    getGenericInterfaces()\n>\n> 获取父类\n> public Type    getGenericSuperclass()\n\n## 原理\n\n### RTTI和Class对象\n\nRTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。\n\n很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。\n\n而这些类型信息是通过一个特殊对象**Class（java.lang.Class）**实现的，它包含跟类相关的信息。\n\n当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。\n\n- 加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。\n- 连接：\n  - 验证 是否有正确的内部结构，并和其他类协调一致\n  - 准备 负责为类的静态成员分配内存，并设置默认初始化值\n  - 解析 将类的二进制数据中的符号引用替换为直接引用\n\n- 初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。\n\n获取 Class 对象的方式有三种\n\n1. Object 类的 getClass() 方法，执行静态块和动态构造块\n\n2. 数据类型的静态属性 class ，不会初始化该类\n\n3. Class类中的静态方法`public static Class forName(String className)`，执行静态块，不执行动态构造块\n\n### RTTI和反射\n\nJava 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。\n\nRTTI和反射之间的真正区别只在于：\n\n> RTTI：编译器在编译时打开和检查.class文件\n> 反射：运行时打开和检查.class文件\n\n严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能\n\n未完待续","slug":"Java-反射详解","published":1,"updated":"2019-06-02T05:00:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqv5000by4upbwybpjwm","content":"<p>反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。<a id=\"more\"></a></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">()</span></span>{}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPrice</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, </span></span><br><span class=\"line\"><span class=\"function\">            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>{</span><br><span class=\"line\">        <span class=\"comment\">//正常调用</span></span><br><span class=\"line\">        Apple apple = <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        apple.setPrice(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + apple.getPrice());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//反射调用</span></span><br><span class=\"line\">        Class clazz = Class.forName(<span class=\"string\">\"Apple\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用 getFields() 无法获取私有属性</span></span><br><span class=\"line\">        Field[] fields = clazz.getDeclaredFields();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field field: fields) {</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Field is \"</span> + field.getName());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        Method setPriceMethod = clazz.getMethod(<span class=\"string\">\"setPrice\"</span>, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        Constructor appleConstructor = clazz.getConstructor();</span><br><span class=\"line\">        Object appleObj = appleConstructor.newInstance();</span><br><span class=\"line\">        <span class=\"comment\">//Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器</span></span><br><span class=\"line\">        <span class=\"comment\">//Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        setPriceMethod.invoke(appleObj, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method getPriceMethod = clazz.getMethod(<span class=\"string\">\"getPrice\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + getPriceMethod.invoke(appleObj));</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"类的实例化和构造函数\"><a href=\"#类的实例化和构造函数\" class=\"headerlink\" title=\"类的实例化和构造函数\"></a>类的实例化和构造函数</h4><blockquote>\n<p>获取公有构造函数，不包括父类，Class.class<br>public Constructor<?>[] getConstructors()<br>public Constructor<t> getConstructor(Class<?>… parameterTypes)</t></p>\n<p>获取当前类构造函数，忽略修饰符<br>public Constructor<?>[] getDeclaredConstructors()<br>public Constructor<t> getDeclaredConstructor(Class<?>… parameterTypes)</t></p>\n</blockquote>\n<blockquote>\n<p>构造函数调用，Constructor.class<br>public T newInstance(Object… initargs)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类成员变量的获取\"><a href=\"#类成员变量的获取\" class=\"headerlink\" title=\"类成员变量的获取\"></a>类成员变量的获取</h4><blockquote>\n<p>获取公有变量，包括父类，Class.class<br>public Field[] getFields()<br>public Field getField(String name)</p>\n<p>获取当前类成员变量，忽略修饰符<br>public Field[] getDeclaredFields()<br>public Field getDeclaredField(String name)</p>\n</blockquote>\n<blockquote>\n<p>成员变量赋值，Field.class<br>//obj为实例对象<br>public void set(Object obj,Object value)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类方法的获取\"><a href=\"#类方法的获取\" class=\"headerlink\" title=\"类方法的获取\"></a>类方法的获取</h4><blockquote>\n<p>获取公有方法，包括父类，Class.class<br>public Method[] getMethods()<br>public Method getMethod(String name, Class<?>… parameterTypes)</p>\n<p>获取当前类方法，忽略修饰符<br>public Method[] getDeclaredMethods()<br>public Method getDeclaredMethod(String name, Class<?>… parameterTypes)</p>\n</blockquote>\n<blockquote>\n<p>方法调用，Method.class<br>//obj为类实例化对象，如果为静态方法obj为Null<br>invoke(Object obj, Object… args)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类注解的获取\"><a href=\"#类注解的获取\" class=\"headerlink\" title=\"类注解的获取\"></a>类注解的获取</h4><blockquote>\n<p>获取类的”annotationClass”类型的注解，包括父类<br>public Annotation<a>    getAnnotation(Class annotationClass)</a></p>\n<p>// 获取类的全部注解 ，包括父类<br>public Annotation[]    getAnnotations()</p>\n<p>// 获取类自身声明的全部注解 ，忽略修饰符<br>public Annotation[]    getDeclaredAnnotations()</p>\n</blockquote>\n<h4 id=\"类父类的获取\"><a href=\"#类父类的获取\" class=\"headerlink\" title=\"类父类的获取\"></a>类父类的获取</h4><blockquote>\n<p>获取实现的全部接口<br>public Type[]    getGenericInterfaces()</p>\n<p>获取父类<br>public Type    getGenericSuperclass()</p>\n</blockquote>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"RTTI和Class对象\"><a href=\"#RTTI和Class对象\" class=\"headerlink\" title=\"RTTI和Class对象\"></a>RTTI和Class对象</h3><p>RTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。</p>\n<p>很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。</p>\n<p>而这些类型信息是通过一个特殊对象<strong>Class（java.lang.Class）</strong>实现的，它包含跟类相关的信息。</p>\n<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。</p>\n<ul>\n<li>加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。</li>\n<li><p>连接：</p>\n<ul>\n<li>验证 是否有正确的内部结构，并和其他类协调一致</li>\n<li>准备 负责为类的静态成员分配内存，并设置默认初始化值</li>\n<li>解析 将类的二进制数据中的符号引用替换为直接引用</li>\n</ul>\n</li>\n<li><p>初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。</p>\n</li>\n</ul>\n<p>获取 Class 对象的方式有三种</p>\n<ol>\n<li><p>Object 类的 getClass() 方法，执行静态块和动态构造块</p>\n</li>\n<li><p>数据类型的静态属性 class ，不会初始化该类</p>\n</li>\n<li><p>Class类中的静态方法<code>public static Class forName(String className)</code>，执行静态块，不执行动态构造块</p>\n</li>\n</ol>\n<h3 id=\"RTTI和反射\"><a href=\"#RTTI和反射\" class=\"headerlink\" title=\"RTTI和反射\"></a>RTTI和反射</h3><p>Java 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。</p>\n<p>RTTI和反射之间的真正区别只在于：</p>\n<blockquote>\n<p>RTTI：编译器在编译时打开和检查.class文件<br>反射：运行时打开和检查.class文件</p>\n</blockquote>\n<p>严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能</p>\n<p>未完待续</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":3905,"excerpt":"<p>反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。</p>","more":"<p></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPrice</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, </span></span><br><span class=\"line\"><span class=\"function\">            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//正常调用</span></span><br><span class=\"line\">        Apple apple = <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        apple.setPrice(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + apple.getPrice());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//反射调用</span></span><br><span class=\"line\">        Class clazz = Class.forName(<span class=\"string\">\"Apple\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用 getFields() 无法获取私有属性</span></span><br><span class=\"line\">        Field[] fields = clazz.getDeclaredFields();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field field: fields) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Field is \"</span> + field.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Method setPriceMethod = clazz.getMethod(<span class=\"string\">\"setPrice\"</span>, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        Constructor appleConstructor = clazz.getConstructor();</span><br><span class=\"line\">        Object appleObj = appleConstructor.newInstance();</span><br><span class=\"line\">        <span class=\"comment\">//Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器</span></span><br><span class=\"line\">        <span class=\"comment\">//Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        setPriceMethod.invoke(appleObj, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method getPriceMethod = clazz.getMethod(<span class=\"string\">\"getPrice\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + getPriceMethod.invoke(appleObj));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"类的实例化和构造函数\"><a href=\"#类的实例化和构造函数\" class=\"headerlink\" title=\"类的实例化和构造函数\"></a>类的实例化和构造函数</h4><blockquote>\n<p>获取公有构造函数，不包括父类，Class.class<br>public Constructor&lt;?&gt;[] getConstructors()<br>public Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)</t></p>\n<p>获取当前类构造函数，忽略修饰符<br>public Constructor&lt;?&gt;[] getDeclaredConstructors()<br>public Constructor<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</t></p>\n</blockquote>\n<blockquote>\n<p>构造函数调用，Constructor.class<br>public T newInstance(Object… initargs)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类成员变量的获取\"><a href=\"#类成员变量的获取\" class=\"headerlink\" title=\"类成员变量的获取\"></a>类成员变量的获取</h4><blockquote>\n<p>获取公有变量，包括父类，Class.class<br>public Field[] getFields()<br>public Field getField(String name)</p>\n<p>获取当前类成员变量，忽略修饰符<br>public Field[] getDeclaredFields()<br>public Field getDeclaredField(String name)</p>\n</blockquote>\n<blockquote>\n<p>成员变量赋值，Field.class<br>//obj为实例对象<br>public void set(Object obj,Object value)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类方法的获取\"><a href=\"#类方法的获取\" class=\"headerlink\" title=\"类方法的获取\"></a>类方法的获取</h4><blockquote>\n<p>获取公有方法，包括父类，Class.class<br>public Method[] getMethods()<br>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</p>\n<p>获取当前类方法，忽略修饰符<br>public Method[] getDeclaredMethods()<br>public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</p>\n</blockquote>\n<blockquote>\n<p>方法调用，Method.class<br>//obj为类实例化对象，如果为静态方法obj为Null<br>invoke(Object obj, Object… args)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类注解的获取\"><a href=\"#类注解的获取\" class=\"headerlink\" title=\"类注解的获取\"></a>类注解的获取</h4><blockquote>\n<p>获取类的”annotationClass”类型的注解，包括父类<br>public Annotation<a>    getAnnotation(Class annotationClass)</a></p>\n<p>// 获取类的全部注解 ，包括父类<br>public Annotation[]    getAnnotations()</p>\n<p>// 获取类自身声明的全部注解 ，忽略修饰符<br>public Annotation[]    getDeclaredAnnotations()</p>\n</blockquote>\n<h4 id=\"类父类的获取\"><a href=\"#类父类的获取\" class=\"headerlink\" title=\"类父类的获取\"></a>类父类的获取</h4><blockquote>\n<p>获取实现的全部接口<br>public Type[]    getGenericInterfaces()</p>\n<p>获取父类<br>public Type    getGenericSuperclass()</p>\n</blockquote>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"RTTI和Class对象\"><a href=\"#RTTI和Class对象\" class=\"headerlink\" title=\"RTTI和Class对象\"></a>RTTI和Class对象</h3><p>RTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。</p>\n<p>很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。</p>\n<p>而这些类型信息是通过一个特殊对象<strong>Class（java.lang.Class）</strong>实现的，它包含跟类相关的信息。</p>\n<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。</p>\n<ul>\n<li>加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。</li>\n<li><p>连接：</p>\n<ul>\n<li>验证 是否有正确的内部结构，并和其他类协调一致</li>\n<li>准备 负责为类的静态成员分配内存，并设置默认初始化值</li>\n<li>解析 将类的二进制数据中的符号引用替换为直接引用</li>\n</ul>\n</li>\n<li><p>初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。</p>\n</li>\n</ul>\n<p>获取 Class 对象的方式有三种</p>\n<ol>\n<li><p>Object 类的 getClass() 方法，执行静态块和动态构造块</p>\n</li>\n<li><p>数据类型的静态属性 class ，不会初始化该类</p>\n</li>\n<li><p>Class类中的静态方法<code>public static Class forName(String className)</code>，执行静态块，不执行动态构造块</p>\n</li>\n</ol>\n<h3 id=\"RTTI和反射\"><a href=\"#RTTI和反射\" class=\"headerlink\" title=\"RTTI和反射\"></a>RTTI和反射</h3><p>Java 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。</p>\n<p>RTTI和反射之间的真正区别只在于：</p>\n<blockquote>\n<p>RTTI：编译器在编译时打开和检查.class文件<br>反射：运行时打开和检查.class文件</p>\n</blockquote>\n<p>严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能</p>\n<p>未完待续</p>"},{"title":"Java 数据库知识整理","date":"2019-03-18T02:45:26.000Z","_content":"\nTODO","source":"_posts/Java-数据库知识整理.md","raw":"---\ntitle: Java 数据库知识整理\ndate: 2019-03-18 10:45:26\ntags:\n- Java\n- 数据库\ncategories:\n- Java\n---\n\nTODO","slug":"Java-数据库知识整理","published":1,"updated":"2019-04-24T05:32:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqv6000cy4upnizm40t7","content":"<p>TODO</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":5,"excerpt":"","more":"<p>TODO</p>\n"},{"title":"Android LruCache 缓存详解","date":"2019-03-17T02:49:27.000Z","_content":"\n![](Android-LruCache-缓存详解\\LruCache.png)\n<!--more-->\n\n## Android 缓存策略\n一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。\n\nLRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。\n\nLRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：\n\n![](https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp)\n\n## 使用\nLruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。\n\n讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。\n\nLinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数\n\n```java\npublic LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)\n```\n\n中的最后一个参数 accessOrder 来指定。\n\n对于`get`、`put`、`remove`等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 `get`(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用`put` 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。\n\n![](https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp)\n\nLruCache 的使用非常简单，以图片缓存为例：\n```Java\nint maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);\nint cacheSize = maxMemory/8;\n\nmMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n    @Override\n    protected int sizeOf(String key, Bitmap value) {\n        return value.getRowBytes() * value.getHeight() / 1024;\n    }\n};\n```\n\n1. 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。\n2. 重写sizeOf方法，计算出要缓存的每张图片的大小。\n\n注意：缓存的总容量和每个缓存对象的大小所用单位要一致。\n\n## 原理\nLruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。\n这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的`<key,value>`对按照一定顺序排列起来。\n\n通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。\n\n```Java\npublic LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {\n    super(initialCapacity, loadFactor);\n    this.accessOrder = accessOrder;\n}\n```\naccessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。\n\n以具体例子解释，当设置为true时\n\n```Java\npublic static final void main(String[] args) {\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>(0, 0.75f, true);\n    map.put(0, 0);\n    map.put(1, 1);\n    map.put(2, 2);\n    map.put(3, 3);\n    map.put(4, 4);\n    map.put(5, 5);\n    map.put(6, 6);\n    map.get(1);\n    map.get(2);\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n}\n```\n输出结果为:\n```Java\n0:0\n3:3\n4:4\n5:5\n6:6\n1:1\n2:2\n```\n即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。\n\n下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除\n\n构造方法\n\n````Java\npublic LruCache(int maxSize) {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    this.maxSize = maxSize;\n    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n}\n​```\n`put`方法\n\n​```Java\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n    \n    V previous;\n    synchronized (this) {\n        //插入的缓存对象值加1\n        putCount++;\n        //增加已有缓存的大小\n        size += safeSizeOf(key, value);\n        //向map中加入缓存对象\n        previous = map.put(key, value);\n        //如果已有缓存对象，则缓存大小恢复到之前\n        if (previous != null) {\n            size -= safeSizeOf(key, previous);\n        }\n    }\n    \n    //entryRemoved()是个空方法，可以自行实现\n    if (previous != null) {\n        entryRemoved(false, key, previous, value);\n    }\n    \n    //调整缓存大小(关键方法)\n    trimToSize(maxSize);\n    return previous;\n}\n​```\n可以看到，添加过缓存对象后会调用`trimToSize`方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象\n\n`trimToSize`方法\n\n​```Java\npublic void trimToSize(int maxSize) {\n    //死循环\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(getClass().getName()\n                        + \".sizeOf() is reporting inconsistent results!\");\n            }\n            \n            //如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            \n            //迭代器获取第一个对象，即队尾的元素，近期最少访问的元素\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            \n            //删除该对象，并更新缓存大小\n            map.remove(key);\n            size -= safeSizeOf(key, value);\n            evictionCount++;\n        }\n        entryRemoved(true, key, value, null);\n    }\n}\n​```\n该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。\n\n当调用 LruCache 的`get`方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的`get`方法中完成的。\n\n先看 LruCache 的`get`方法\n\n​```Java\npublic final V get(K key) {\n    //key为空抛出异常\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n    //获取对应的缓存对象\n    //get()方法会实现将访问的元素更新到队列头部的功能\n    mapValue = map.get(key);\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        missCount++;\n    }\n}\n​```\n\n\nLinkedHashMap 的`get`方法如下：\n\n​```Java\npublic V get(Object key) {\n    LinkedHashMapEntry<K,V> e = (LinkedHashMapEntry<K,V>)getEntry(key);\n    if (e == null)\n        return null;\n    //实现排序的关键方法\n    e.recordAccess(this);\n    return e.value;\n}\n​```\n\n​```Java\n void recordAccess(HashMap<K,V> m) {\n    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n    //判断是否是访问排序\n    if (lm.accessOrder) {\n        lm.modCount++;\n        //删除此元素\n        remove();\n        //将此元素移动到队列的头部\n        addBefore(lm.header);\n    }\n}\n​```\n\n\n\n**由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用`put`方法时，就会在队列中添加元素，并调用`trimToSize`判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用`get(`方法访问缓存对象时，就会调用 LinkedHashMap 的`get`方法获得对应集合元素，同时更新该元素到队头。**\n\n以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。\n\n本文转自 [彻底解析Android缓存机制——LruCache](https://www.jianshu.com/p/b49a111147ee)\n````","source":"_posts/Android-LruCache-缓存详解.md","raw":"---\ntitle: Android LruCache 缓存详解\ndate: 2019-03-17 10:49:27\ntags:\n- Android\n- LRU\n- 缓存\ncategories:\n- Android \n---\n\n![](Android-LruCache-缓存详解\\LruCache.png)\n<!--more-->\n\n## Android 缓存策略\n一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。\n\nLRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。\n\nLRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：\n\n![](https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp)\n\n## 使用\nLruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。\n\n讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。\n\nLinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数\n\n```java\npublic LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)\n```\n\n中的最后一个参数 accessOrder 来指定。\n\n对于`get`、`put`、`remove`等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 `get`(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用`put` 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。\n\n![](https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp)\n\nLruCache 的使用非常简单，以图片缓存为例：\n```Java\nint maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);\nint cacheSize = maxMemory/8;\n\nmMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n    @Override\n    protected int sizeOf(String key, Bitmap value) {\n        return value.getRowBytes() * value.getHeight() / 1024;\n    }\n};\n```\n\n1. 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。\n2. 重写sizeOf方法，计算出要缓存的每张图片的大小。\n\n注意：缓存的总容量和每个缓存对象的大小所用单位要一致。\n\n## 原理\nLruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。\n这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的`<key,value>`对按照一定顺序排列起来。\n\n通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。\n\n```Java\npublic LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {\n    super(initialCapacity, loadFactor);\n    this.accessOrder = accessOrder;\n}\n```\naccessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。\n\n以具体例子解释，当设置为true时\n\n```Java\npublic static final void main(String[] args) {\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>(0, 0.75f, true);\n    map.put(0, 0);\n    map.put(1, 1);\n    map.put(2, 2);\n    map.put(3, 3);\n    map.put(4, 4);\n    map.put(5, 5);\n    map.put(6, 6);\n    map.get(1);\n    map.get(2);\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n}\n```\n输出结果为:\n```Java\n0:0\n3:3\n4:4\n5:5\n6:6\n1:1\n2:2\n```\n即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。\n\n下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除\n\n构造方法\n\n````Java\npublic LruCache(int maxSize) {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    this.maxSize = maxSize;\n    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n}\n​```\n`put`方法\n\n​```Java\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n    \n    V previous;\n    synchronized (this) {\n        //插入的缓存对象值加1\n        putCount++;\n        //增加已有缓存的大小\n        size += safeSizeOf(key, value);\n        //向map中加入缓存对象\n        previous = map.put(key, value);\n        //如果已有缓存对象，则缓存大小恢复到之前\n        if (previous != null) {\n            size -= safeSizeOf(key, previous);\n        }\n    }\n    \n    //entryRemoved()是个空方法，可以自行实现\n    if (previous != null) {\n        entryRemoved(false, key, previous, value);\n    }\n    \n    //调整缓存大小(关键方法)\n    trimToSize(maxSize);\n    return previous;\n}\n​```\n可以看到，添加过缓存对象后会调用`trimToSize`方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象\n\n`trimToSize`方法\n\n​```Java\npublic void trimToSize(int maxSize) {\n    //死循环\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(getClass().getName()\n                        + \".sizeOf() is reporting inconsistent results!\");\n            }\n            \n            //如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            \n            //迭代器获取第一个对象，即队尾的元素，近期最少访问的元素\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            \n            //删除该对象，并更新缓存大小\n            map.remove(key);\n            size -= safeSizeOf(key, value);\n            evictionCount++;\n        }\n        entryRemoved(true, key, value, null);\n    }\n}\n​```\n该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。\n\n当调用 LruCache 的`get`方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的`get`方法中完成的。\n\n先看 LruCache 的`get`方法\n\n​```Java\npublic final V get(K key) {\n    //key为空抛出异常\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n    //获取对应的缓存对象\n    //get()方法会实现将访问的元素更新到队列头部的功能\n    mapValue = map.get(key);\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        missCount++;\n    }\n}\n​```\n\n\nLinkedHashMap 的`get`方法如下：\n\n​```Java\npublic V get(Object key) {\n    LinkedHashMapEntry<K,V> e = (LinkedHashMapEntry<K,V>)getEntry(key);\n    if (e == null)\n        return null;\n    //实现排序的关键方法\n    e.recordAccess(this);\n    return e.value;\n}\n​```\n\n​```Java\n void recordAccess(HashMap<K,V> m) {\n    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n    //判断是否是访问排序\n    if (lm.accessOrder) {\n        lm.modCount++;\n        //删除此元素\n        remove();\n        //将此元素移动到队列的头部\n        addBefore(lm.header);\n    }\n}\n​```\n\n\n\n**由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用`put`方法时，就会在队列中添加元素，并调用`trimToSize`判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用`get(`方法访问缓存对象时，就会调用 LinkedHashMap 的`get`方法获得对应集合元素，同时更新该元素到队头。**\n\n以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。\n\n本文转自 [彻底解析Android缓存机制——LruCache](https://www.jianshu.com/p/b49a111147ee)\n````","slug":"Android-LruCache-缓存详解","published":1,"updated":"2019-05-03T11:34:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqw5001fy4upc9ink8ck","content":"<p><img src=\"/Android-LruCache-缓存详解/LruCache.png\" alt><br><a id=\"more\"></a></p>\n<h2 id=\"Android-缓存策略\"><a href=\"#Android-缓存策略\" class=\"headerlink\" title=\"Android 缓存策略\"></a>Android 缓存策略</h2><p>一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。</p>\n<p>LRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。</p>\n<p>LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp\" alt></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>LruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。</p>\n<p>讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。</p>\n<p>LinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,<span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>中的最后一个参数 accessOrder 来指定。</p>\n<p>对于<code>get</code>、<code>put</code>、<code>remove</code>等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 <code>get</code>(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用<code>put</code> 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp\" alt></p>\n<p>LruCache 的使用非常简单，以图片缓存为例：<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().totalMemory()/<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> cacheSize = maxMemory/<span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">mMemoryCache = <span class=\"keyword\">new</span> LruCache<String, Bitmap>(cacheSize) {</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.getRowBytes() * value.getHeight() / <span class=\"number\">1024</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure><p></p>\n<ol>\n<li>设置LruCache缓存的大小，一般为当前进程可用容量的1/8。</li>\n<li>重写sizeOf方法，计算出要缓存的每张图片的大小。</li>\n</ol>\n<p>注意：缓存的总容量和每个缓存对象的大小所用单位要一致。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>LruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。<br>这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的<code><key,value></code>对按照一定顺序排列起来。</p>\n<p>通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>accessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。</p>\n<p>以具体例子解释，当设置为true时</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    LinkedHashMap<Integer, Integer> map = <span class=\"keyword\">new</span> LinkedHashMap<>(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">6</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry<Integer, Integer> entry : map.entrySet()) {</span><br><span class=\"line\">        System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输出结果为:<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>:<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">3</span>:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span>:<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span>:<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>:<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">1</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span>:<span class=\"number\">2</span></span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。</p>\n<p>下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除</p>\n<p>构造方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxSize <= <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize <= 0\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap<K, V>(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\">​```</span><br><span class=\"line\">`put`方法</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    V previous;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {</span><br><span class=\"line\">        <span class=\"comment\">//插入的缓存对象值加1</span></span><br><span class=\"line\">        putCount++;</span><br><span class=\"line\">        <span class=\"comment\">//增加已有缓存的大小</span></span><br><span class=\"line\">        size += safeSizeOf(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//向map中加入缓存对象</span></span><br><span class=\"line\">        previous = map.put(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//如果已有缓存对象，则缓存大小恢复到之前</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            size -= safeSizeOf(key, previous);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//entryRemoved()是个空方法，可以自行实现</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//调整缓存大小(关键方法)</span></span><br><span class=\"line\">    trimToSize(maxSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">}</span><br><span class=\"line\">​```</span><br><span class=\"line\">可以看到，添加过缓存对象后会调用`trimToSize`方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象</span><br><span class=\"line\"></span><br><span class=\"line\">`trimToSize`方法</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">//死循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) {</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size < <span class=\"number\">0</span> || (map.isEmpty() && size != <span class=\"number\">0</span>)) {</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                        + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">            }</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size <= maxSize || map.isEmpty()) {</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//迭代器获取第一个对象，即队尾的元素，近期最少访问的元素</span></span><br><span class=\"line\">            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">            key = toEvict.getKey();</span><br><span class=\"line\">            value = toEvict.getValue();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//删除该对象，并更新缓存大小</span></span><br><span class=\"line\">            map.remove(key);</span><br><span class=\"line\">            size -= safeSizeOf(key, value);</span><br><span class=\"line\">            evictionCount++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\">​```</span><br><span class=\"line\">该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。</span><br><span class=\"line\"></span><br><span class=\"line\">当调用 LruCache 的`get`方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的`get`方法中完成的。</span><br><span class=\"line\"></span><br><span class=\"line\">先看 LruCache 的`get`方法</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">//key为空抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    V mapValue;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {</span><br><span class=\"line\">    <span class=\"comment\">//获取对应的缓存对象</span></span><br><span class=\"line\">    <span class=\"comment\">//get()方法会实现将访问的元素更新到队列头部的功能</span></span><br><span class=\"line\">    mapValue = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            hitCount++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        missCount++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\">​```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">LinkedHashMap 的`get`方法如下：</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>{</span><br><span class=\"line\">    LinkedHashMapEntry<K,V> e = (LinkedHashMapEntry<K,V>)getEntry(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//实现排序的关键方法</span></span><br><span class=\"line\">    e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">}</span><br><span class=\"line\">​```</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordAccess</span><span class=\"params\">(HashMap<K,V> m)</span> </span>{</span><br><span class=\"line\">    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否是访问排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lm.accessOrder) {</span><br><span class=\"line\">        lm.modCount++;</span><br><span class=\"line\">        <span class=\"comment\">//删除此元素</span></span><br><span class=\"line\">        remove();</span><br><span class=\"line\">        <span class=\"comment\">//将此元素移动到队列的头部</span></span><br><span class=\"line\">        addBefore(lm.header);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\">​```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用`put`方法时，就会在队列中添加元素，并调用`trimToSize`判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用`get(`方法访问缓存对象时，就会调用 LinkedHashMap 的`get`方法获得对应集合元素，同时更新该元素到队头。**</span><br><span class=\"line\"></span><br><span class=\"line\">以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。</span><br><span class=\"line\"></span><br><span class=\"line\">本文转自 [彻底解析Android缓存机制——LruCache](https:<span class=\"comment\">//www.jianshu.com/p/b49a111147ee)</span></span><br></pre></td></tr></tbody></table></figure><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":5997,"excerpt":"<p><img src=\"/Android-LruCache-缓存详解/LruCache.png\" alt><br></p>","more":"<p></p>\n<h2 id=\"Android-缓存策略\"><a href=\"#Android-缓存策略\" class=\"headerlink\" title=\"Android 缓存策略\"></a>Android 缓存策略</h2><p>一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。</p>\n<p>LRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。</p>\n<p>LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp\" alt=\"\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>LruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。</p>\n<p>讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。</p>\n<p>LinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,<span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></table></figure>\n<p>中的最后一个参数 accessOrder 来指定。</p>\n<p>对于<code>get</code>、<code>put</code>、<code>remove</code>等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 <code>get</code>(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用<code>put</code> 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp\" alt=\"\"></p>\n<p>LruCache 的使用非常简单，以图片缓存为例：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().totalMemory()/<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> cacheSize = maxMemory/<span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.getRowBytes() * value.getHeight() / <span class=\"number\">1024</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>设置LruCache缓存的大小，一般为当前进程可用容量的1/8。</li>\n<li>重写sizeOf方法，计算出要缓存的每张图片的大小。</li>\n</ol>\n<p>注意：缓存的总容量和每个缓存对象的大小所用单位要一致。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>LruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。<br>这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的<code>&lt;key,value&gt;</code>对按照一定顺序排列起来。</p>\n<p>通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>accessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。</p>\n<p>以具体例子解释，当设置为true时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">6</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">        System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>:<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">3</span>:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span>:<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span>:<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>:<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">1</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span>:<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。</p>\n<p>下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除</p>\n<p>构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​```</span><br><span class=\"line\">`put`方法</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    V previous;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//插入的缓存对象值加1</span></span><br><span class=\"line\">        putCount++;</span><br><span class=\"line\">        <span class=\"comment\">//增加已有缓存的大小</span></span><br><span class=\"line\">        size += safeSizeOf(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//向map中加入缓存对象</span></span><br><span class=\"line\">        previous = map.put(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//如果已有缓存对象，则缓存大小恢复到之前</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            size -= safeSizeOf(key, previous);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//entryRemoved()是个空方法，可以自行实现</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//调整缓存大小(关键方法)</span></span><br><span class=\"line\">    trimToSize(maxSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​```</span><br><span class=\"line\">可以看到，添加过缓存对象后会调用`trimToSize`方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象</span><br><span class=\"line\"></span><br><span class=\"line\">`trimToSize`方法</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                        + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//迭代器获取第一个对象，即队尾的元素，近期最少访问的元素</span></span><br><span class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">            key = toEvict.getKey();</span><br><span class=\"line\">            value = toEvict.getValue();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//删除该对象，并更新缓存大小</span></span><br><span class=\"line\">            map.remove(key);</span><br><span class=\"line\">            size -= safeSizeOf(key, value);</span><br><span class=\"line\">            evictionCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​```</span><br><span class=\"line\">该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。</span><br><span class=\"line\"></span><br><span class=\"line\">当调用 LruCache 的`get`方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的`get`方法中完成的。</span><br><span class=\"line\"></span><br><span class=\"line\">先看 LruCache 的`get`方法</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//key为空抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    V mapValue;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取对应的缓存对象</span></span><br><span class=\"line\">    <span class=\"comment\">//get()方法会实现将访问的元素更新到队列头部的功能</span></span><br><span class=\"line\">    mapValue = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hitCount++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        missCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">LinkedHashMap 的`get`方法如下：</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//实现排序的关键方法</span></span><br><span class=\"line\">    e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​```</span><br><span class=\"line\"></span><br><span class=\"line\">​```Java</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordAccess</span><span class=\"params\">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否是访问排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lm.accessOrder) &#123;</span><br><span class=\"line\">        lm.modCount++;</span><br><span class=\"line\">        <span class=\"comment\">//删除此元素</span></span><br><span class=\"line\">        remove();</span><br><span class=\"line\">        <span class=\"comment\">//将此元素移动到队列的头部</span></span><br><span class=\"line\">        addBefore(lm.header);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用`put`方法时，就会在队列中添加元素，并调用`trimToSize`判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用`get(`方法访问缓存对象时，就会调用 LinkedHashMap 的`get`方法获得对应集合元素，同时更新该元素到队头。**</span><br><span class=\"line\"></span><br><span class=\"line\">以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。</span><br><span class=\"line\"></span><br><span class=\"line\">本文转自 [彻底解析Android缓存机制——LruCache](https:<span class=\"comment\">//www.jianshu.com/p/b49a111147ee)</span></span><br></pre></td></tr></table></figure>"},{"title":"Android 消息机制详解","date":"2019-03-16T06:13:19.000Z","_content":"\nAndroid 的消息机制，主要是指 Handler 的运行机制。<!--more-->\n\n## ANR\nApplication Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。\n\n### 原因 \nAndroid系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。\n\n以下四种条件都可以造成 ANR\n- InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件\n- BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的`onReceive`方法中10秒没有处理完成，后台则为60秒。\n- Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。\n- ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。\n\n### 分析和解决\n#### 分析\n- 查看 log 信息\n- Java 线程调用分析，`jstack {pid}`，其中 pid 为虚拟机进程 id，可以通过`jps`查看当前所有线程。\n- 查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令`./adb pull /data/anr/traces.txt`查看\n\n#### 解决\n- 避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。\n- 避免在主线程 query provider、不要滥用SharePreferences\n- 文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。\n- BroadcastReciever 的`onRecieve`不要进行耗时操作。\n\n## Handler 机制\n由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的`checkThread`进行验证\n```Java\nvoid checkThread() {\n    if (mThread != Thread.currrentThread()) {\n        throw new CalledFromWrongThreadException(\n            \"Only the original thread that created a view hierarchy can\n            touch its views\");\n    }\n}\n```\n使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。\n那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？\n\n答案是使用 Handler 。\n\n### 创建\n```Java\n//接收消息\n@SuppressLint(\"HandlerLeak\")\nprivate Handler mHandler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n        super.handleMessage(msg);\n        if (msg.what == 1) {\n            log.e(\"MSG\", \"收到消息\")；\n        }\n    }\n};\n\n//发送消息\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(1000);\n            mHandler.sendEmptyMessage(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}).start();\n```\n使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用\n```Java\nMyHandler hander = new MyHandler(context);\n\nstatic class MyHandler extends Handler {\n    private WeakReference<Context> out;\n    \n    MyHandler(Context ctx) {\n        super();\n        out = new WeakReference<>(ctx);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        if (out.get() != null) {\n            //进行消息处理\n        }\n    }\n}\n```\n\nHandler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。\n\n### Handler\n观察 Handler 的构造函数\n```Java\npublic Handler(Callback callback, boolean async) {\n    ......\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()  + \" that has not called\" \n            + \" Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用`Looper.prepare`的线程内创建 handler。\n\n不过，为什么在主线程中创建 Handler 不需要调用`Looper.prepare`和`Looper.loop`方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的`main`方法，在其中调用了`prepareMainLooper`\n```Java\npublic static void main(String[] args) {\n        ......\n        Looper.prepareMainLooper();\n        ......\n        Looper.loop();\n        ......\n}\n\npublic static void prepareMainLooper() {\n    prepare(false);     //quitAllowed 参数传false\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(\"The main Looper has already been prepared.\");\n        }\n        sMainLooper = myLooper();\n    }\n}\n```\n关于 ActivityThread：[Android线程管理（二）——ActivityThread](http://www.cnblogs.com/younghao/p/5126408.html)\n\n### MessageQueue\n顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。\n\n由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。\n\n当 Handler 调用`sendMessage`时，最后会调用到\n\n```Java\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n查看`enqueueMessage`方法，\n\n```Java\nboolean enqueueMessage(Message msg, long when) {\n    ......\n    synchronized (this) {\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n        ......\n    }\n    return true;\n}\n```\n- 首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒\n- 如果队列已有消息，则根据 Message 创建的时间进行插入\n\n### Looper\n通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用`Looper.prepare`方法使消息循环初始化，并且调用`Looper.loop`使消息循环一直处于运行状态，**取出 MessageQueue 中的消息分发给 Handler**。\n\n```Java\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n可以看到，`prepare(boolean quitAllowed)`实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当`Looper.prepare`执行完毕之后才可以执行`loop`方法\n```Java\npublic static void loop() {\n        //获取当前线程绑定的Looper\n        final Looper me = myLooper();\n        \n        //当前线程的MessageQueue\n        final MessageQueue queue = me.mQueue;\n        ......\n        //循环从 MessageQueue 取出消息.\n        for (;;) {\n            Message msg = queue.next();\n            ......\n            //将消息分发出去\n            msg.target.dispatchMessage(msg);\n            ......\n            //将消息回收\n            msg.recycle();\n        }\n}\n```\n可以看到，如果消息队列的 next 返回了新消息，就会调用`msg.target.dispatchMessage(msg)`，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。\n\n```Java\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n- 首先检查 Message 的 callBack 是否为空，不为空则`handlerCallback(msg)`，最终调用 callback 的`run`方法\n- 如果为空，检查 mCallBack 是否为空，不为空则调用它的`handleMassage`，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。\n- 如果都为空，调用 Handler 内部的`handleMessage`，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。\n\n### ThreadLocal\n一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。\n\n使用一个简单的例子演示 ThreadLocal 的真正含义\n```Java\n//新建一个 boolean 类型的变量\nprivate ThreadLocal<Boolean> value = new ThreadLocal<>();\n\n//在主线程中将其设为 true\nvalue.set(true);\nlog.e(\"MainThread\", value.get());\n\n//子线程中设为 false\nnew Thread(\"Thread1\") {\n    @Override\n    public void run() {\n        value.set(false);\n        log.e(\"Thread1\", value.get());\n    }\n}\n\n//另一个子线程直接读取\nnew Thread(\"Thread2\") {\n    @Override\n    public void run() {\n        log.e(\"Thread2\", value.get());\n    }\n}\n```\n运行日志如下\n> MainThread, true\n> Thread1, false\n> Thread2, null\n\n由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：[Java并发编程：深入剖析ThreadLocal](https://www.cnblogs.com/dolphin0520/p/3920407.html)\n\n## 总结\n\nHandler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的`runOnUiThread`\n\n```Java\npublic final void runOnUiThread(Runnable action) { \n\tif (Thread.currentThread() != mUiThread) { \n\t\tmHandler.post(action); \n\t} else { \n\t\taction.run(); \n\t} \n\t...... \n}\n```\n\n比如 View 的`post`\n\n```Java\npublic boolean post(Runnable action) {\n\tfinal AttachInfo attachInfo = mAttachInfo;\n    \tif (attachInfo != null) {\n            return attachInfo.mHandler.post(action);         ①\n        }\n        // Assume that post will succeed later\n        ViewRootImpl.getRunQueue().post(action);        ②\n        return true;\n    }\n```\n\n\n\n最后用一张图来结束本文\n\n![流程图](Android-消息机制详解\\消息流程图.jpg)","source":"_posts/Android-消息机制详解.md","raw":"---\ntitle: Android 消息机制详解\ndate: 2019-03-16 14:13:19\ntags:\n- Android \n- Handler\ncategories:\n- Android \n---\n\nAndroid 的消息机制，主要是指 Handler 的运行机制。<!--more-->\n\n## ANR\nApplication Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。\n\n### 原因 \nAndroid系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。\n\n以下四种条件都可以造成 ANR\n- InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件\n- BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的`onReceive`方法中10秒没有处理完成，后台则为60秒。\n- Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。\n- ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。\n\n### 分析和解决\n#### 分析\n- 查看 log 信息\n- Java 线程调用分析，`jstack {pid}`，其中 pid 为虚拟机进程 id，可以通过`jps`查看当前所有线程。\n- 查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令`./adb pull /data/anr/traces.txt`查看\n\n#### 解决\n- 避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。\n- 避免在主线程 query provider、不要滥用SharePreferences\n- 文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。\n- BroadcastReciever 的`onRecieve`不要进行耗时操作。\n\n## Handler 机制\n由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的`checkThread`进行验证\n```Java\nvoid checkThread() {\n    if (mThread != Thread.currrentThread()) {\n        throw new CalledFromWrongThreadException(\n            \"Only the original thread that created a view hierarchy can\n            touch its views\");\n    }\n}\n```\n使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。\n那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？\n\n答案是使用 Handler 。\n\n### 创建\n```Java\n//接收消息\n@SuppressLint(\"HandlerLeak\")\nprivate Handler mHandler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n        super.handleMessage(msg);\n        if (msg.what == 1) {\n            log.e(\"MSG\", \"收到消息\")；\n        }\n    }\n};\n\n//发送消息\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(1000);\n            mHandler.sendEmptyMessage(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}).start();\n```\n使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用\n```Java\nMyHandler hander = new MyHandler(context);\n\nstatic class MyHandler extends Handler {\n    private WeakReference<Context> out;\n    \n    MyHandler(Context ctx) {\n        super();\n        out = new WeakReference<>(ctx);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        if (out.get() != null) {\n            //进行消息处理\n        }\n    }\n}\n```\n\nHandler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。\n\n### Handler\n观察 Handler 的构造函数\n```Java\npublic Handler(Callback callback, boolean async) {\n    ......\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()  + \" that has not called\" \n            + \" Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用`Looper.prepare`的线程内创建 handler。\n\n不过，为什么在主线程中创建 Handler 不需要调用`Looper.prepare`和`Looper.loop`方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的`main`方法，在其中调用了`prepareMainLooper`\n```Java\npublic static void main(String[] args) {\n        ......\n        Looper.prepareMainLooper();\n        ......\n        Looper.loop();\n        ......\n}\n\npublic static void prepareMainLooper() {\n    prepare(false);     //quitAllowed 参数传false\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(\"The main Looper has already been prepared.\");\n        }\n        sMainLooper = myLooper();\n    }\n}\n```\n关于 ActivityThread：[Android线程管理（二）——ActivityThread](http://www.cnblogs.com/younghao/p/5126408.html)\n\n### MessageQueue\n顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。\n\n由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。\n\n当 Handler 调用`sendMessage`时，最后会调用到\n\n```Java\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n查看`enqueueMessage`方法，\n\n```Java\nboolean enqueueMessage(Message msg, long when) {\n    ......\n    synchronized (this) {\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n        ......\n    }\n    return true;\n}\n```\n- 首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒\n- 如果队列已有消息，则根据 Message 创建的时间进行插入\n\n### Looper\n通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用`Looper.prepare`方法使消息循环初始化，并且调用`Looper.loop`使消息循环一直处于运行状态，**取出 MessageQueue 中的消息分发给 Handler**。\n\n```Java\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n可以看到，`prepare(boolean quitAllowed)`实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当`Looper.prepare`执行完毕之后才可以执行`loop`方法\n```Java\npublic static void loop() {\n        //获取当前线程绑定的Looper\n        final Looper me = myLooper();\n        \n        //当前线程的MessageQueue\n        final MessageQueue queue = me.mQueue;\n        ......\n        //循环从 MessageQueue 取出消息.\n        for (;;) {\n            Message msg = queue.next();\n            ......\n            //将消息分发出去\n            msg.target.dispatchMessage(msg);\n            ......\n            //将消息回收\n            msg.recycle();\n        }\n}\n```\n可以看到，如果消息队列的 next 返回了新消息，就会调用`msg.target.dispatchMessage(msg)`，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。\n\n```Java\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n- 首先检查 Message 的 callBack 是否为空，不为空则`handlerCallback(msg)`，最终调用 callback 的`run`方法\n- 如果为空，检查 mCallBack 是否为空，不为空则调用它的`handleMassage`，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。\n- 如果都为空，调用 Handler 内部的`handleMessage`，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。\n\n### ThreadLocal\n一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。\n\n使用一个简单的例子演示 ThreadLocal 的真正含义\n```Java\n//新建一个 boolean 类型的变量\nprivate ThreadLocal<Boolean> value = new ThreadLocal<>();\n\n//在主线程中将其设为 true\nvalue.set(true);\nlog.e(\"MainThread\", value.get());\n\n//子线程中设为 false\nnew Thread(\"Thread1\") {\n    @Override\n    public void run() {\n        value.set(false);\n        log.e(\"Thread1\", value.get());\n    }\n}\n\n//另一个子线程直接读取\nnew Thread(\"Thread2\") {\n    @Override\n    public void run() {\n        log.e(\"Thread2\", value.get());\n    }\n}\n```\n运行日志如下\n> MainThread, true\n> Thread1, false\n> Thread2, null\n\n由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：[Java并发编程：深入剖析ThreadLocal](https://www.cnblogs.com/dolphin0520/p/3920407.html)\n\n## 总结\n\nHandler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的`runOnUiThread`\n\n```Java\npublic final void runOnUiThread(Runnable action) { \n\tif (Thread.currentThread() != mUiThread) { \n\t\tmHandler.post(action); \n\t} else { \n\t\taction.run(); \n\t} \n\t...... \n}\n```\n\n比如 View 的`post`\n\n```Java\npublic boolean post(Runnable action) {\n\tfinal AttachInfo attachInfo = mAttachInfo;\n    \tif (attachInfo != null) {\n            return attachInfo.mHandler.post(action);         ①\n        }\n        // Assume that post will succeed later\n        ViewRootImpl.getRunQueue().post(action);        ②\n        return true;\n    }\n```\n\n\n\n最后用一张图来结束本文\n\n![流程图](Android-消息机制详解\\消息流程图.jpg)","slug":"Android-消息机制详解","published":1,"updated":"2019-06-02T04:54:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqw7001hy4upiqzjqqoo","content":"<p>Android 的消息机制，主要是指 Handler 的运行机制。<a id=\"more\"></a></p>\n<h2 id=\"ANR\"><a href=\"#ANR\" class=\"headerlink\" title=\"ANR\"></a>ANR</h2><p>Application Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>Android系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。</p>\n<p>以下四种条件都可以造成 ANR</p>\n<ul>\n<li>InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件</li>\n<li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的<code>onReceive</code>方法中10秒没有处理完成，后台则为60秒。</li>\n<li>Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。</li>\n<li>ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。</li>\n</ul>\n<h3 id=\"分析和解决\"><a href=\"#分析和解决\" class=\"headerlink\" title=\"分析和解决\"></a>分析和解决</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>查看 log 信息</li>\n<li>Java 线程调用分析，<code>jstack {pid}</code>，其中 pid 为虚拟机进程 id，可以通过<code>jps</code>查看当前所有线程。</li>\n<li>查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令<code>./adb pull /data/anr/traces.txt</code>查看</li>\n</ul>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ul>\n<li>避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。</li>\n<li>避免在主线程 query provider、不要滥用SharePreferences</li>\n<li>文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。</li>\n<li>BroadcastReciever 的<code>onRecieve</code>不要进行耗时操作。</li>\n</ul>\n<h2 id=\"Handler-机制\"><a href=\"#Handler-机制\" class=\"headerlink\" title=\"Handler 机制\"></a>Handler 机制</h2><p>由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的<code>checkThread</code>进行验证<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkThread</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThread != Thread.currrentThread()) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CalledFromWrongThreadException(</span><br><span class=\"line\">            <span class=\"string\">\"Only the original thread that created a view hierarchy can</span></span><br><span class=\"line\"><span class=\"string\">            touch its views\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。<br>那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？</p>\n<p>答案是使用 Handler 。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接收消息</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"HandlerLeak\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> Handler mHandler = <span class=\"keyword\">new</span> Handler() {</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            log.e(<span class=\"string\">\"MSG\"</span>, <span class=\"string\">\"收到消息\"</span>)；</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() {</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            mHandler.sendEmptyMessage(<span class=\"number\">1</span>);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (InterruptedException e) {</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}).start();</span><br></pre></td></tr></tbody></table></figure>\n<p>使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">MyHandler hander = <span class=\"keyword\">new</span> MyHandler(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference<Context> out;</span><br><span class=\"line\">    </span><br><span class=\"line\">    MyHandler(Context ctx) {</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        out = <span class=\"keyword\">new</span> WeakReference<>(ctx);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (out.get() != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"comment\">//进行消息处理</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>Handler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><p>观察 Handler 的构造函数<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>{</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread \"</span> + Thread.currentThread()  + <span class=\"string\">\" that has not called\"</span> </span><br><span class=\"line\">            + <span class=\"string\">\" Looper.prepare()\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用<code>Looper.prepare</code>的线程内创建 handler。</p>\n<p>不过，为什么在主线程中创建 Handler 不需要调用<code>Looper.prepare</code>和<code>Looper.loop</code>方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的<code>main</code>方法，在其中调用了<code>prepareMainLooper</code><br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    prepare(<span class=\"keyword\">false</span>);     <span class=\"comment\">//quitAllowed 参数传false</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        sMainLooper = myLooper();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>关于 ActivityThread：<a href=\"http://www.cnblogs.com/younghao/p/5126408.html\" target=\"_blank\" rel=\"noopener\">Android线程管理（二）——ActivityThread</a></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><p>顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。</p>\n<p>由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。</p>\n<p>当 Handler 调用<code>sendMessage</code>时，最后会调用到</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>{</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>查看<code>enqueueMessage</code>方法，</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>{</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) {</span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when < p.when) {</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            needWake = mBlocked && p.target == <span class=\"keyword\">null</span> && msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) {</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when < p.when) {</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake && p.isAsynchronous()) {</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒</li>\n<li>如果队列已有消息，则根据 Message 创建的时间进行插入</li>\n</ul>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用<code>Looper.prepare</code>方法使消息循环初始化，并且调用<code>Looper.loop</code>使消息循环一直处于运行状态，<strong>取出 MessageQueue 中的消息分发给 Handler</strong>。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到，<code>prepare(boolean quitAllowed)</code>实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当<code>Looper.prepare</code>执行完毕之后才可以执行<code>loop</code>方法<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程绑定的Looper</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//当前线程的MessageQueue</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">//循环从 MessageQueue 取出消息.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) {</span><br><span class=\"line\">            Message msg = queue.next();</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息分发出去</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息回收</span></span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">        }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>可以看到，如果消息队列的 next 返回了新消息，就会调用<code>msg.target.dispatchMessage(msg)</code>，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>首先检查 Message 的 callBack 是否为空，不为空则<code>handlerCallback(msg)</code>，最终调用 callback 的<code>run</code>方法</li>\n<li>如果为空，检查 mCallBack 是否为空，不为空则调用它的<code>handleMassage</code>，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。</li>\n<li>如果都为空，调用 Handler 内部的<code>handleMessage</code>，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。</p>\n<p>使用一个简单的例子演示 ThreadLocal 的真正含义<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新建一个 boolean 类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ThreadLocal<Boolean> value = <span class=\"keyword\">new</span> ThreadLocal<>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在主线程中将其设为 true</span></span><br><span class=\"line\">value.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">log.e(<span class=\"string\">\"MainThread\"</span>, value.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//子线程中设为 false</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread1\"</span>) {</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        value.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread1\"</span>, value.get());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另一个子线程直接读取</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread2\"</span>) {</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread2\"</span>, value.get());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>运行日志如下</p>\n<blockquote>\n<p>MainThread, true<br>Thread1, false<br>Thread2, null</p>\n</blockquote>\n<p>由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920407.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：深入剖析ThreadLocal</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Handler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的<code>runOnUiThread</code></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runOnUiThread</span><span class=\"params\">(Runnable action)</span> </span>{ </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Thread.currentThread() != mUiThread) { </span><br><span class=\"line\">\t\tmHandler.post(action); </span><br><span class=\"line\">\t} <span class=\"keyword\">else</span> { </span><br><span class=\"line\">\t\taction.run(); </span><br><span class=\"line\">\t} </span><br><span class=\"line\">\t...... </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>比如 View 的<code>post</code></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(Runnable action)</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> attachInfo.mHandler.post(action);         ①</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// Assume that post will succeed later</span></span><br><span class=\"line\">        ViewRootImpl.getRunQueue().post(action);        ②</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n<p>最后用一张图来结束本文</p>\n<p><img src=\"/Android-消息机制详解/消息流程图.jpg\" alt=\"流程图\"></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":8644,"excerpt":"<p>Android 的消息机制，主要是指 Handler 的运行机制。</p>","more":"<p></p>\n<h2 id=\"ANR\"><a href=\"#ANR\" class=\"headerlink\" title=\"ANR\"></a>ANR</h2><p>Application Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>Android系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。</p>\n<p>以下四种条件都可以造成 ANR</p>\n<ul>\n<li>InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件</li>\n<li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的<code>onReceive</code>方法中10秒没有处理完成，后台则为60秒。</li>\n<li>Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。</li>\n<li>ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。</li>\n</ul>\n<h3 id=\"分析和解决\"><a href=\"#分析和解决\" class=\"headerlink\" title=\"分析和解决\"></a>分析和解决</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>查看 log 信息</li>\n<li>Java 线程调用分析，<code>jstack {pid}</code>，其中 pid 为虚拟机进程 id，可以通过<code>jps</code>查看当前所有线程。</li>\n<li>查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令<code>./adb pull /data/anr/traces.txt</code>查看</li>\n</ul>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ul>\n<li>避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。</li>\n<li>避免在主线程 query provider、不要滥用SharePreferences</li>\n<li>文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。</li>\n<li>BroadcastReciever 的<code>onRecieve</code>不要进行耗时操作。</li>\n</ul>\n<h2 id=\"Handler-机制\"><a href=\"#Handler-机制\" class=\"headerlink\" title=\"Handler 机制\"></a>Handler 机制</h2><p>由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的<code>checkThread</code>进行验证<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThread != Thread.currrentThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CalledFromWrongThreadException(</span><br><span class=\"line\">            <span class=\"string\">\"Only the original thread that created a view hierarchy can</span></span><br><span class=\"line\"><span class=\"string\">            touch its views\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。<br>那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？</p>\n<p>答案是使用 Handler 。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接收消息</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"HandlerLeak\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> Handler mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            log.e(<span class=\"string\">\"MSG\"</span>, <span class=\"string\">\"收到消息\"</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            mHandler.sendEmptyMessage(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyHandler hander = <span class=\"keyword\">new</span> MyHandler(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference&lt;Context&gt; out;</span><br><span class=\"line\">    </span><br><span class=\"line\">    MyHandler(Context ctx) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        out = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (out.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//进行消息处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Handler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><p>观察 Handler 的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread \"</span> + Thread.currentThread()  + <span class=\"string\">\" that has not called\"</span> </span><br><span class=\"line\">            + <span class=\"string\">\" Looper.prepare()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用<code>Looper.prepare</code>的线程内创建 handler。</p>\n<p>不过，为什么在主线程中创建 Handler 不需要调用<code>Looper.prepare</code>和<code>Looper.loop</code>方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的<code>main</code>方法，在其中调用了<code>prepareMainLooper</code><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">false</span>);     <span class=\"comment\">//quitAllowed 参数传false</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sMainLooper = myLooper();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 ActivityThread：<a href=\"http://www.cnblogs.com/younghao/p/5126408.html\" target=\"_blank\" rel=\"noopener\">Android线程管理（二）——ActivityThread</a></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><p>顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。</p>\n<p>由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。</p>\n<p>当 Handler 调用<code>sendMessage</code>时，最后会调用到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看<code>enqueueMessage</code>方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒</li>\n<li>如果队列已有消息，则根据 Message 创建的时间进行插入</li>\n</ul>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用<code>Looper.prepare</code>方法使消息循环初始化，并且调用<code>Looper.loop</code>使消息循环一直处于运行状态，<strong>取出 MessageQueue 中的消息分发给 Handler</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>prepare(boolean quitAllowed)</code>实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当<code>Looper.prepare</code>执行完毕之后才可以执行<code>loop</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程绑定的Looper</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//当前线程的MessageQueue</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">//循环从 MessageQueue 取出消息.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Message msg = queue.next();</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息分发出去</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息回收</span></span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，如果消息队列的 next 返回了新消息，就会调用<code>msg.target.dispatchMessage(msg)</code>，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先检查 Message 的 callBack 是否为空，不为空则<code>handlerCallback(msg)</code>，最终调用 callback 的<code>run</code>方法</li>\n<li>如果为空，检查 mCallBack 是否为空，不为空则调用它的<code>handleMassage</code>，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。</li>\n<li>如果都为空，调用 Handler 内部的<code>handleMessage</code>，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。</p>\n<p>使用一个简单的例子演示 ThreadLocal 的真正含义<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新建一个 boolean 类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ThreadLocal&lt;Boolean&gt; value = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在主线程中将其设为 true</span></span><br><span class=\"line\">value.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">log.e(<span class=\"string\">\"MainThread\"</span>, value.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//子线程中设为 false</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread1\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        value.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread1\"</span>, value.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另一个子线程直接读取</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread2\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread2\"</span>, value.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行日志如下</p>\n<blockquote>\n<p>MainThread, true<br>Thread1, false<br>Thread2, null</p>\n</blockquote>\n<p>由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920407.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：深入剖析ThreadLocal</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Handler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的<code>runOnUiThread</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runOnUiThread</span><span class=\"params\">(Runnable action)</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Thread.currentThread() != mUiThread) &#123; </span><br><span class=\"line\">\t\tmHandler.post(action); </span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\t\taction.run(); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t...... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如 View 的<code>post</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(Runnable action)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> attachInfo.mHandler.post(action);         ①</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Assume that post will succeed later</span></span><br><span class=\"line\">        ViewRootImpl.getRunQueue().post(action);        ②</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>最后用一张图来结束本文</p>\n<p><img src=\"/Android-消息机制详解/消息流程图.jpg\" alt=\"流程图\"></p>"},{"title":"Dart 异步编程","date":"2019-04-30T00:21:26.000Z","_content":"\nDart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。\n\n<!--more-->\n\n## 事件循环\n\n作为一个事件驱动语言，Dart 同样拥有事件循环（Event Loop，类似于 Android 中的Looper/Handler）。Dart 有两个队列，一个是微任务队列（MicroTask Queue），一个是事件队列（Event Queue）\n\n- 微任务队列包含 Dart 内部的微任务，主要通过`scheduleMicrotask`调度\n- 事件队列包含外部事件，如 I/O、Timer、绘制事件等\n\n![](Dart-异步编程\\事件循环.png.jpg)\n\n\n\n从上图可以看出，Dart 处理事件循环的逻辑\n\n- 首先处理所有微任务队列里的微任务\n- 处理完所有微任务之后，处理事件队列里的一个事件\n- 回到微任务队列继续循环\n\n对于微任务队列，一次性全部处理，对于事件队列，一次只处理一个。\n\n## 微任务和事件\n\n### 微任务\n\n`dart:async`定义了一个顶级函数`scheduleMicrotask`，使用其让代码以微任务的方式异步执行\n\n```dart\nimport 'dart:async';\t//下文不再显式导入\n\nvoid main() {\n  print('开始');\n  scheduleMicrotask(() {\n    print('这是一个微任务');\n  });\n  print(\"结束\");\n}\n```\n\n控制台输出\n\n> 开始\n> 结束\n> 这是一个微任务\n\n### 事件\n\n使用`Timer.run(callback)`让代码以事件的方式异步执行\n\n```dart\nvoid main() {\n  print('开始');\n\n  Timer.run(() {\n    print('这是一个事件');\n  });\n\n  scheduleMicrotask((){ print('这是微任务0'); });\n  scheduleMicrotask((){ print('这是微任务1'); });\n  scheduleMicrotask((){ print('这是微任务2'); });\n  \n  print(\"结束\");\n}\n```\n\n控制台输出\n\n> 开始\n> 结束\n> 这是微任务0\n> 这是微任务1\n> 这是微任务2\n> 这是一个事件\n\n同时可以看出和 Java 使用`new Thread（Runnable r）`不同，在 Dart 中，微任务的执行顺序是有序的。\n\n考虑下面的代码，会输出`这是一个事件`吗？\n\n```dart\n  Timer.run(() {\n    print('这是一个事件');\n  });\n  \n  foo() {\n    scheduleMicrotask(foo);\n  }\n\n  foo();\n```\n\n根据上面 Dart 处理事件循环的逻辑图，`Timer.run`永远不会被执行，因为`scheduleMicrotask`永远在执行。\n\n仅仅使用回调函数实现异步很容易陷入“回调地狱（Callback hell）”，为此 Dart 引入了`Future`\n\n## Future\n\nFuture 封装了一系列静态函数完成异步操作，其内部通过`scheduleMicrotask`和`Timer`实现。此外还有一个`then`方法，接收一个名为`onValue`的闭包作为参数，该闭包在 Future 成功完成时被调用\n\n| 函数                                                    | 用途              |\n| ------------------------------------------------------- | ----------------- |\n| Future(FutureOr<T> computation())                       | 创建事件任务      |\n| microtask(FutureOr<T> computation())                    | 创建microtask任务 |\n| sync(FutureOr<T> computation())                         | 创建同步任务      |\n| delayed(Duration duration, [FutureOr<T> computation()]) | 创建延迟任务      |\n\n通过代码理解\n\n```dart\nvoid main() {\n  print('开始');\n\n  Timer.run(() => print('这是一个事件'));\n\n  scheduleMicrotask((){print('这是微任务0');});\n  scheduleMicrotask((){print('这是微任务1');});\n  scheduleMicrotask((){print('这是微任务2');});\n\n  print(\"结束\");\n\n  Future(() => print('普通Future，通过Timer实现'));\n\n  Future.delayed(const Duration(seconds: 2), () => print('延迟Future，通过Timer实现'));\n\n  Future.microtask(() => print('Future创建微任务，通过scheduleMicrotask实现'));\n\n  Future.sync(() => print('同步Future，执行同步代码'))\n      .then((a) => print('then中的代码0'))\n      .then((b) => print('then中的代码1'))\n      .then((c) { throw '抛出then中的错误'; })\n      .catchError((error) => print('捕获Error $error'))\n      .whenComplete(() {print('then任务完成');});\n}\n```\n\n输出结果\n\n> 开始\n> 结束\n> 同步Future，执行同步代码\n> 这是微任务0\n> 这是微任务1\n> 这是微任务2\n> Future创建微任务，通过scheduleMicrotask实现\n> then中的代码0\n> then中的代码1\n> 捕获Error 抛出then中的错误\n> then任务完成\n> 这是一个事件\n> 普通Future，通过Timer实现\n>\n> //延迟2s\n>\n> 延迟Future，通过Timer实现\n\n---\n\n在`dart:async`中，除了 Future，还有 Completer，用来将具体的 Future 流程控制权交给开发者\n\n```dart\n  var completer = Completer();\n  var future = completer.future;\n  future.then((d) => '返回的字符串')\n      .then((e) => print('获得Completer中的future $e'));\n  completer.complete((e) => print('设为完成状态'));\n```\n\n控制台输出\n\n> 获得Completer中的future 返回的字符串\n\n\n\n虽然 Future 缓解了回调地狱的问题，但如果串太多的`then`代码，可读性仍然会非常差，特别是各种 Future 嵌套的时候。与 JavaScript 类似，Dart 引入了`async/await`。\n\n## async 和 await\n\nasync 关键字修饰的函数与传统函数并无区别，只是将返回值类型使用 Future 进行了封装。\n\n通过代码具体理解\n\n```dart\nvoid main() async {\n  getInt().then((i) => print('getInt: $i'));\n  getString().then((s) => print('getString: $s'));\n  print('main');\n}\n\ngetInt() async => 2333;\ngetString() async => 'hello';\n```\n\n控制台输出\n\n> main\n> getInt: 2333\n> getString: hello\n\n可以看到，调用`async`方法的代码转换成了异步任务。要想使之变成同步顺序，使用`await`关键字。不过需要注意的是，该关键字必须要在`async`函数中使用\n\n```dart\nvoid main() async {\n  var i = await getInt();\n  print('getInt: $i');\n  \n  var s = await getString();\n  print('getString: $s');\n  \n  print('main');\n}\n```\n\n控制台输出\n\n> getInt: 2333\n> getString: hello\n> main\n\n继续下面的例子\n\n```dart\nvoid main() {\n  print('main 0');\n  foo();\n  print('main 1');\n}\n\nfoo() async {\n  print('Foo');\n  var s = await bar();\n  print('from bar: $s');\n}\n\nbar() {\n  print('Bar');\n  return 'hello';\n}\n```\n\n控制台输出为\n\n> main 0\n> Foo\n> Bar\n> main 1\n> from bar: hello\n\n也就是说，在`foo`中，除了第一行代码以及`bar()`这一函数调用之外的其他代码均为异步执行。当使用`await`的时候，其右边会马上返回一个 Future 对象，下面的代码则会以`then`的形式运行。\n\n上面的代码转换成 Future 风格\n\n```dart\nfoo() {\n  print('Foo');\n  return Future.sync(bar).then((s) => print('from bar: $s'));\n}\n```\n\n\n\n## Generator\n\n### stream \n\nstream 是 Dart 中一个长度不确定的值列表，可以是有限的或者无限的，重要的是我们不知道 stream 何时结束或已经结束。随时间改变的鼠标位置、所有素数的列表或者网络上的视频流，都可以看做一个 stream。\n\n可以通过为 stream 注册一个或多个回调函数的方式，对其进行订阅监听。\n\n### yield\n\nyield 语句被用于生成器函数内，目的是给生成的集合添加新的结果。yield 语句总是使它的表达式被求值，通常情况下，求值结果会被追加到外层生成器所关联的集合中。如果生成器是同步的，则关联的集合是一个 iterable；如果是异步的，则关联的集合是一个 stream。\n\n此外，yield 也会因外层的生成器是否同步产生不同的行为：同步时 yield 会暂停外层生成器，直至调用`moveNext`且返回值为 true，异步时生成器的执行会继续。\n\n### 异步\n\n一个函数体标记有`async*`修饰符的函数，将作为 stream 的生成函数。下面的函数生成一个包含自然数序列的 stream\n\n```dart\nget naturals async* {\n  int k = 0;\n  while (k < 3) {\n    yield await k++;\n  }\n}\n\nvoid main() async {\n  await for (var i in naturals) {\n    print('get a natural $i');\n  }\n}\n```\n\n运行`main`函数，控制台将输出\n\n> get a natural 0\n> get a natural 1\n> get a natural 2\n\n当 naturals 被调用时，立即返回一个新的 stream，一旦 stream 被监听，函数体将运行，以便生成值来填充 stream。每一次迭代执行一次 yield 语句，k 将自增（由于 await 的存在，函数会有短暂停止），然后函数将继续执行并使用新的 k 值，该值将被 yield 追加到 stream 中。\n\n### 同步\n\n上述函数的同步形式\n\n```dart\nIterable naturalsTo(n) sync* {\n  int k = 0;\n  while(k < n) {\n    yield k++;\n  }\n}\n```\n\n---\n\n通过一个混合编程的例子来体会两者的区别\n\n```javascript\nIterable nSync(n) sync* {\n  int k = 0;\n  while (k < n)  {\n    print('sync before k++ and k is $k');\n    yield k++;\n    print('sync after k++ and k is $k');\n  }\n}\n\nStream nAsync(n) async* {\n  int k = 0;\n  while (k < n)  {\n    print('async before k++ and k is $k');\n    yield await k++;\n    print('async after k++ and k is $k');\n  }\n}\n\nvoid main() {\n  nAsync(2).last;\n  nSync(2).last;\n  print('main');\n}\n```\n\n控制台输出为\n\n> sync before k++ and k is 0\n> sync after k++ and k is 1\n> sync before k++ and k is 1\n> sync after k++ and k is 2\n> main\n> async before k++ and k is 0\n> async after k++ and k is 1\n> async before k++ and k is 1\n> async after k++ and k is 2","source":"_posts/Dart-异步编程.md","raw":"---\ntitle: Dart 异步编程\ndate: 2019-04-30 08:21:26\ntags:\n- Dart\n- 异步\ncategories:\n- Dart\n---\n\nDart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。\n\n<!--more-->\n\n## 事件循环\n\n作为一个事件驱动语言，Dart 同样拥有事件循环（Event Loop，类似于 Android 中的Looper/Handler）。Dart 有两个队列，一个是微任务队列（MicroTask Queue），一个是事件队列（Event Queue）\n\n- 微任务队列包含 Dart 内部的微任务，主要通过`scheduleMicrotask`调度\n- 事件队列包含外部事件，如 I/O、Timer、绘制事件等\n\n![](Dart-异步编程\\事件循环.png.jpg)\n\n\n\n从上图可以看出，Dart 处理事件循环的逻辑\n\n- 首先处理所有微任务队列里的微任务\n- 处理完所有微任务之后，处理事件队列里的一个事件\n- 回到微任务队列继续循环\n\n对于微任务队列，一次性全部处理，对于事件队列，一次只处理一个。\n\n## 微任务和事件\n\n### 微任务\n\n`dart:async`定义了一个顶级函数`scheduleMicrotask`，使用其让代码以微任务的方式异步执行\n\n```dart\nimport 'dart:async';\t//下文不再显式导入\n\nvoid main() {\n  print('开始');\n  scheduleMicrotask(() {\n    print('这是一个微任务');\n  });\n  print(\"结束\");\n}\n```\n\n控制台输出\n\n> 开始\n> 结束\n> 这是一个微任务\n\n### 事件\n\n使用`Timer.run(callback)`让代码以事件的方式异步执行\n\n```dart\nvoid main() {\n  print('开始');\n\n  Timer.run(() {\n    print('这是一个事件');\n  });\n\n  scheduleMicrotask((){ print('这是微任务0'); });\n  scheduleMicrotask((){ print('这是微任务1'); });\n  scheduleMicrotask((){ print('这是微任务2'); });\n  \n  print(\"结束\");\n}\n```\n\n控制台输出\n\n> 开始\n> 结束\n> 这是微任务0\n> 这是微任务1\n> 这是微任务2\n> 这是一个事件\n\n同时可以看出和 Java 使用`new Thread（Runnable r）`不同，在 Dart 中，微任务的执行顺序是有序的。\n\n考虑下面的代码，会输出`这是一个事件`吗？\n\n```dart\n  Timer.run(() {\n    print('这是一个事件');\n  });\n  \n  foo() {\n    scheduleMicrotask(foo);\n  }\n\n  foo();\n```\n\n根据上面 Dart 处理事件循环的逻辑图，`Timer.run`永远不会被执行，因为`scheduleMicrotask`永远在执行。\n\n仅仅使用回调函数实现异步很容易陷入“回调地狱（Callback hell）”，为此 Dart 引入了`Future`\n\n## Future\n\nFuture 封装了一系列静态函数完成异步操作，其内部通过`scheduleMicrotask`和`Timer`实现。此外还有一个`then`方法，接收一个名为`onValue`的闭包作为参数，该闭包在 Future 成功完成时被调用\n\n| 函数                                                    | 用途              |\n| ------------------------------------------------------- | ----------------- |\n| Future(FutureOr<T> computation())                       | 创建事件任务      |\n| microtask(FutureOr<T> computation())                    | 创建microtask任务 |\n| sync(FutureOr<T> computation())                         | 创建同步任务      |\n| delayed(Duration duration, [FutureOr<T> computation()]) | 创建延迟任务      |\n\n通过代码理解\n\n```dart\nvoid main() {\n  print('开始');\n\n  Timer.run(() => print('这是一个事件'));\n\n  scheduleMicrotask((){print('这是微任务0');});\n  scheduleMicrotask((){print('这是微任务1');});\n  scheduleMicrotask((){print('这是微任务2');});\n\n  print(\"结束\");\n\n  Future(() => print('普通Future，通过Timer实现'));\n\n  Future.delayed(const Duration(seconds: 2), () => print('延迟Future，通过Timer实现'));\n\n  Future.microtask(() => print('Future创建微任务，通过scheduleMicrotask实现'));\n\n  Future.sync(() => print('同步Future，执行同步代码'))\n      .then((a) => print('then中的代码0'))\n      .then((b) => print('then中的代码1'))\n      .then((c) { throw '抛出then中的错误'; })\n      .catchError((error) => print('捕获Error $error'))\n      .whenComplete(() {print('then任务完成');});\n}\n```\n\n输出结果\n\n> 开始\n> 结束\n> 同步Future，执行同步代码\n> 这是微任务0\n> 这是微任务1\n> 这是微任务2\n> Future创建微任务，通过scheduleMicrotask实现\n> then中的代码0\n> then中的代码1\n> 捕获Error 抛出then中的错误\n> then任务完成\n> 这是一个事件\n> 普通Future，通过Timer实现\n>\n> //延迟2s\n>\n> 延迟Future，通过Timer实现\n\n---\n\n在`dart:async`中，除了 Future，还有 Completer，用来将具体的 Future 流程控制权交给开发者\n\n```dart\n  var completer = Completer();\n  var future = completer.future;\n  future.then((d) => '返回的字符串')\n      .then((e) => print('获得Completer中的future $e'));\n  completer.complete((e) => print('设为完成状态'));\n```\n\n控制台输出\n\n> 获得Completer中的future 返回的字符串\n\n\n\n虽然 Future 缓解了回调地狱的问题，但如果串太多的`then`代码，可读性仍然会非常差，特别是各种 Future 嵌套的时候。与 JavaScript 类似，Dart 引入了`async/await`。\n\n## async 和 await\n\nasync 关键字修饰的函数与传统函数并无区别，只是将返回值类型使用 Future 进行了封装。\n\n通过代码具体理解\n\n```dart\nvoid main() async {\n  getInt().then((i) => print('getInt: $i'));\n  getString().then((s) => print('getString: $s'));\n  print('main');\n}\n\ngetInt() async => 2333;\ngetString() async => 'hello';\n```\n\n控制台输出\n\n> main\n> getInt: 2333\n> getString: hello\n\n可以看到，调用`async`方法的代码转换成了异步任务。要想使之变成同步顺序，使用`await`关键字。不过需要注意的是，该关键字必须要在`async`函数中使用\n\n```dart\nvoid main() async {\n  var i = await getInt();\n  print('getInt: $i');\n  \n  var s = await getString();\n  print('getString: $s');\n  \n  print('main');\n}\n```\n\n控制台输出\n\n> getInt: 2333\n> getString: hello\n> main\n\n继续下面的例子\n\n```dart\nvoid main() {\n  print('main 0');\n  foo();\n  print('main 1');\n}\n\nfoo() async {\n  print('Foo');\n  var s = await bar();\n  print('from bar: $s');\n}\n\nbar() {\n  print('Bar');\n  return 'hello';\n}\n```\n\n控制台输出为\n\n> main 0\n> Foo\n> Bar\n> main 1\n> from bar: hello\n\n也就是说，在`foo`中，除了第一行代码以及`bar()`这一函数调用之外的其他代码均为异步执行。当使用`await`的时候，其右边会马上返回一个 Future 对象，下面的代码则会以`then`的形式运行。\n\n上面的代码转换成 Future 风格\n\n```dart\nfoo() {\n  print('Foo');\n  return Future.sync(bar).then((s) => print('from bar: $s'));\n}\n```\n\n\n\n## Generator\n\n### stream \n\nstream 是 Dart 中一个长度不确定的值列表，可以是有限的或者无限的，重要的是我们不知道 stream 何时结束或已经结束。随时间改变的鼠标位置、所有素数的列表或者网络上的视频流，都可以看做一个 stream。\n\n可以通过为 stream 注册一个或多个回调函数的方式，对其进行订阅监听。\n\n### yield\n\nyield 语句被用于生成器函数内，目的是给生成的集合添加新的结果。yield 语句总是使它的表达式被求值，通常情况下，求值结果会被追加到外层生成器所关联的集合中。如果生成器是同步的，则关联的集合是一个 iterable；如果是异步的，则关联的集合是一个 stream。\n\n此外，yield 也会因外层的生成器是否同步产生不同的行为：同步时 yield 会暂停外层生成器，直至调用`moveNext`且返回值为 true，异步时生成器的执行会继续。\n\n### 异步\n\n一个函数体标记有`async*`修饰符的函数，将作为 stream 的生成函数。下面的函数生成一个包含自然数序列的 stream\n\n```dart\nget naturals async* {\n  int k = 0;\n  while (k < 3) {\n    yield await k++;\n  }\n}\n\nvoid main() async {\n  await for (var i in naturals) {\n    print('get a natural $i');\n  }\n}\n```\n\n运行`main`函数，控制台将输出\n\n> get a natural 0\n> get a natural 1\n> get a natural 2\n\n当 naturals 被调用时，立即返回一个新的 stream，一旦 stream 被监听，函数体将运行，以便生成值来填充 stream。每一次迭代执行一次 yield 语句，k 将自增（由于 await 的存在，函数会有短暂停止），然后函数将继续执行并使用新的 k 值，该值将被 yield 追加到 stream 中。\n\n### 同步\n\n上述函数的同步形式\n\n```dart\nIterable naturalsTo(n) sync* {\n  int k = 0;\n  while(k < n) {\n    yield k++;\n  }\n}\n```\n\n---\n\n通过一个混合编程的例子来体会两者的区别\n\n```javascript\nIterable nSync(n) sync* {\n  int k = 0;\n  while (k < n)  {\n    print('sync before k++ and k is $k');\n    yield k++;\n    print('sync after k++ and k is $k');\n  }\n}\n\nStream nAsync(n) async* {\n  int k = 0;\n  while (k < n)  {\n    print('async before k++ and k is $k');\n    yield await k++;\n    print('async after k++ and k is $k');\n  }\n}\n\nvoid main() {\n  nAsync(2).last;\n  nSync(2).last;\n  print('main');\n}\n```\n\n控制台输出为\n\n> sync before k++ and k is 0\n> sync after k++ and k is 1\n> sync before k++ and k is 1\n> sync after k++ and k is 2\n> main\n> async before k++ and k is 0\n> async after k++ and k is 1\n> async before k++ and k is 1\n> async after k++ and k is 2","slug":"Dart-异步编程","published":1,"updated":"2019-06-02T04:55:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqwa001ky4upbi8xvpnt","content":"<p>Dart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。</p>\n<a id=\"more\"></a>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p>作为一个事件驱动语言，Dart 同样拥有事件循环（Event Loop，类似于 Android 中的Looper/Handler）。Dart 有两个队列，一个是微任务队列（MicroTask Queue），一个是事件队列（Event Queue）</p>\n<ul>\n<li>微任务队列包含 Dart 内部的微任务，主要通过<code>scheduleMicrotask</code>调度</li>\n<li>事件队列包含外部事件，如 I/O、Timer、绘制事件等</li>\n</ul>\n<p><img src=\"/Dart-异步编程/事件循环.png.jpg\" alt></p>\n<p>从上图可以看出，Dart 处理事件循环的逻辑</p>\n<ul>\n<li>首先处理所有微任务队列里的微任务</li>\n<li>处理完所有微任务之后，处理事件队列里的一个事件</li>\n<li>回到微任务队列继续循环</li>\n</ul>\n<p>对于微任务队列，一次性全部处理，对于事件队列，一次只处理一个。</p>\n<h2 id=\"微任务和事件\"><a href=\"#微任务和事件\" class=\"headerlink\" title=\"微任务和事件\"></a>微任务和事件</h2><h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p><code>dart:async</code>定义了一个顶级函数<code>scheduleMicrotask</code>，使用其让代码以微任务的方式异步执行</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span>;\t<span class=\"comment\">//下文不再显式导入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\">  scheduleMicrotask(() {</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个微任务'</span>);</span><br><span class=\"line\">  });</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"结束\"</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>开始<br>结束<br>这是一个微任务</p>\n</blockquote>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>使用<code>Timer.run(callback)</code>让代码以事件的方式异步执行</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  Timer.run(() {</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个事件'</span>);</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\">  scheduleMicrotask((){ <span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务0'</span>); });</span><br><span class=\"line\">  scheduleMicrotask((){ <span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务1'</span>); });</span><br><span class=\"line\">  scheduleMicrotask((){ <span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务2'</span>); });</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"结束\"</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>开始<br>结束<br>这是微任务0<br>这是微任务1<br>这是微任务2<br>这是一个事件</p>\n</blockquote>\n<p>同时可以看出和 Java 使用<code>new Thread（Runnable r）</code>不同，在 Dart 中，微任务的执行顺序是有序的。</p>\n<p>考虑下面的代码，会输出<code>这是一个事件</code>吗？</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Timer.run(() {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个事件'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\">foo() {</span><br><span class=\"line\">  scheduleMicrotask(foo);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></tbody></table></figure>\n<p>根据上面 Dart 处理事件循环的逻辑图，<code>Timer.run</code>永远不会被执行，因为<code>scheduleMicrotask</code>永远在执行。</p>\n<p>仅仅使用回调函数实现异步很容易陷入“回调地狱（Callback hell）”，为此 Dart 引入了<code>Future</code></p>\n<h2 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h2><p>Future 封装了一系列静态函数完成异步操作，其内部通过<code>scheduleMicrotask</code>和<code>Timer</code>实现。此外还有一个<code>then</code>方法，接收一个名为<code>onValue</code>的闭包作为参数，该闭包在 Future 成功完成时被调用</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Future(FutureOr<t> computation())</t></td>\n<td>创建事件任务</td>\n</tr>\n<tr>\n<td>microtask(FutureOr<t> computation())</t></td>\n<td>创建microtask任务</td>\n</tr>\n<tr>\n<td>sync(FutureOr<t> computation())</t></td>\n<td>创建同步任务</td>\n</tr>\n<tr>\n<td>delayed(Duration duration, [FutureOr<t> computation()])</t></td>\n<td>创建延迟任务</td>\n</tr>\n</tbody>\n</table>\n<p>通过代码理解</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  Timer.run(() => <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个事件'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  scheduleMicrotask((){<span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务0'</span>);});</span><br><span class=\"line\">  scheduleMicrotask((){<span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务1'</span>);});</span><br><span class=\"line\">  scheduleMicrotask((){<span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务2'</span>);});</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"结束\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  Future(() => <span class=\"built_in\">print</span>(<span class=\"string\">'普通Future，通过Timer实现'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  Future.delayed(<span class=\"keyword\">const</span> <span class=\"built_in\">Duration</span>(seconds: <span class=\"number\">2</span>), () => <span class=\"built_in\">print</span>(<span class=\"string\">'延迟Future，通过Timer实现'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  Future.microtask(() => <span class=\"built_in\">print</span>(<span class=\"string\">'Future创建微任务，通过scheduleMicrotask实现'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  Future.<span class=\"keyword\">sync</span>(() => <span class=\"built_in\">print</span>(<span class=\"string\">'同步Future，执行同步代码'</span>))</span><br><span class=\"line\">      .then((a) => <span class=\"built_in\">print</span>(<span class=\"string\">'then中的代码0'</span>))</span><br><span class=\"line\">      .then((b) => <span class=\"built_in\">print</span>(<span class=\"string\">'then中的代码1'</span>))</span><br><span class=\"line\">      .then((c) { <span class=\"keyword\">throw</span> <span class=\"string\">'抛出then中的错误'</span>; })</span><br><span class=\"line\">      .catchError((error) => <span class=\"built_in\">print</span>(<span class=\"string\">'捕获Error <span class=\"subst\">$error<span class=\"string\">'))</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">      .whenComplete(() {print('</span></span>then任务完成'</span>);});</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输出结果</p>\n<blockquote>\n<p>开始<br>结束<br>同步Future，执行同步代码<br>这是微任务0<br>这是微任务1<br>这是微任务2<br>Future创建微任务，通过scheduleMicrotask实现<br>then中的代码0<br>then中的代码1<br>捕获Error 抛出then中的错误<br>then任务完成<br>这是一个事件<br>普通Future，通过Timer实现</p>\n<p>//延迟2s</p>\n<p>延迟Future，通过Timer实现</p>\n</blockquote>\n<hr>\n<p>在<code>dart:async</code>中，除了 Future，还有 Completer，用来将具体的 Future 流程控制权交给开发者</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> completer = Completer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> future = completer.future;</span><br><span class=\"line\">future.then((d) => <span class=\"string\">'返回的字符串'</span>)</span><br><span class=\"line\">    .then((e) => <span class=\"built_in\">print</span>(<span class=\"string\">'获得Completer中的future <span class=\"subst\">$e<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">completer.complete((e) => print('</span></span>设为完成状态'</span>));</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>获得Completer中的future 返回的字符串</p>\n</blockquote>\n<p>虽然 Future 缓解了回调地狱的问题，但如果串太多的<code>then</code>代码，可读性仍然会非常差，特别是各种 Future 嵌套的时候。与 JavaScript 类似，Dart 引入了<code>async/await</code>。</p>\n<h2 id=\"async-和-await\"><a href=\"#async-和-await\" class=\"headerlink\" title=\"async 和 await\"></a>async 和 await</h2><p>async 关键字修饰的函数与传统函数并无区别，只是将返回值类型使用 Future 进行了封装。</p>\n<p>通过代码具体理解</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() <span class=\"keyword\">async</span> {</span><br><span class=\"line\">  getInt().then((i) => <span class=\"built_in\">print</span>(<span class=\"string\">'getInt: <span class=\"subst\">$i<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  getString().then((s) => print('</span></span>getString: <span class=\"subst\">$s<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>main'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">getInt() <span class=\"keyword\">async</span> => <span class=\"number\">2333</span>;</span><br><span class=\"line\">getString() <span class=\"keyword\">async</span> => <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>main<br>getInt: 2333<br>getString: hello</p>\n</blockquote>\n<p>可以看到，调用<code>async</code>方法的代码转换成了异步任务。要想使之变成同步顺序，使用<code>await</code>关键字。不过需要注意的是，该关键字必须要在<code>async</code>函数中使用</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() <span class=\"keyword\">async</span> {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"keyword\">await</span> getInt();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'getInt: <span class=\"subst\">$i<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  var s = await getString();</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>getString: <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>main'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>getInt: 2333<br>getString: hello<br>main</p>\n</blockquote>\n<p>继续下面的例子</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'main 0'</span>);</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'main 1'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">foo() <span class=\"keyword\">async</span> {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Foo'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"keyword\">await</span> bar();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'from bar: <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">}</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">bar() {</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Bar'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出为</p>\n<blockquote>\n<p>main 0<br>Foo<br>Bar<br>main 1<br>from bar: hello</p>\n</blockquote>\n<p>也就是说，在<code>foo</code>中，除了第一行代码以及<code>bar()</code>这一函数调用之外的其他代码均为异步执行。当使用<code>await</code>的时候，其右边会马上返回一个 Future 对象，下面的代码则会以<code>then</code>的形式运行。</p>\n<p>上面的代码转换成 Future 风格</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">foo() {</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Foo'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Future.<span class=\"keyword\">sync</span>(bar).then((s) => <span class=\"built_in\">print</span>(<span class=\"string\">'from bar: <span class=\"subst\">$s<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">}</span></span></span></span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><h3 id=\"stream\"><a href=\"#stream\" class=\"headerlink\" title=\"stream\"></a>stream</h3><p>stream 是 Dart 中一个长度不确定的值列表，可以是有限的或者无限的，重要的是我们不知道 stream 何时结束或已经结束。随时间改变的鼠标位置、所有素数的列表或者网络上的视频流，都可以看做一个 stream。</p>\n<p>可以通过为 stream 注册一个或多个回调函数的方式，对其进行订阅监听。</p>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><p>yield 语句被用于生成器函数内，目的是给生成的集合添加新的结果。yield 语句总是使它的表达式被求值，通常情况下，求值结果会被追加到外层生成器所关联的集合中。如果生成器是同步的，则关联的集合是一个 iterable；如果是异步的，则关联的集合是一个 stream。</p>\n<p>此外，yield 也会因外层的生成器是否同步产生不同的行为：同步时 yield 会暂停外层生成器，直至调用<code>moveNext</code>且返回值为 true，异步时生成器的执行会继续。</p>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p>一个函数体标记有<code>async*</code>修饰符的函数，将作为 stream 的生成函数。下面的函数生成一个包含自然数序列的 stream</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">get</span> naturals <span class=\"keyword\">async</span>* {</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k < <span class=\"number\">3</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">await</span> k++;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() <span class=\"keyword\">async</span> {</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> naturals) {</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'get a natural <span class=\"subst\">$i<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  }</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">}</span></span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>运行<code>main</code>函数，控制台将输出</p>\n<blockquote>\n<p>get a natural 0<br>get a natural 1<br>get a natural 2</p>\n</blockquote>\n<p>当 naturals 被调用时，立即返回一个新的 stream，一旦 stream 被监听，函数体将运行，以便生成值来填充 stream。每一次迭代执行一次 yield 语句，k 将自增（由于 await 的存在，函数会有短暂停止），然后函数将继续执行并使用新的 k 值，该值将被 yield 追加到 stream 中。</p>\n<h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3><p>上述函数的同步形式</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span> naturalsTo(n) <span class=\"keyword\">sync</span>* {</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(k < n) {</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<hr>\n<p>通过一个混合编程的例子来体会两者的区别</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Iterable nSync(n) sync* {</span><br><span class=\"line\">  int k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k < n)  {</span><br><span class=\"line\">    print(<span class=\"string\">'sync before k++ and k is $k'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">    print(<span class=\"string\">'sync after k++ and k is $k'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">Stream nAsync(n) <span class=\"keyword\">async</span>* {</span><br><span class=\"line\">  int k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k < n)  {</span><br><span class=\"line\">    print(<span class=\"string\">'async before k++ and k is $k'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">await</span> k++;</span><br><span class=\"line\">    print(<span class=\"string\">'async after k++ and k is $k'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  nAsync(<span class=\"number\">2</span>).last;</span><br><span class=\"line\">  nSync(<span class=\"number\">2</span>).last;</span><br><span class=\"line\">  print(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出为</p>\n<blockquote>\n<p>sync before k++ and k is 0<br>sync after k++ and k is 1<br>sync before k++ and k is 1<br>sync after k++ and k is 2<br>main<br>async before k++ and k is 0<br>async after k++ and k is 1<br>async before k++ and k is 1<br>async after k++ and k is 2</p>\n</blockquote>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":5604,"excerpt":"<p>Dart 属于单线程编程语言，在进行 I/O 操作或者其他耗时操作的时候，程序会进入阻塞状态。异步是 Dart 并发方案的基础。</p>","more":"<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p>作为一个事件驱动语言，Dart 同样拥有事件循环（Event Loop，类似于 Android 中的Looper/Handler）。Dart 有两个队列，一个是微任务队列（MicroTask Queue），一个是事件队列（Event Queue）</p>\n<ul>\n<li>微任务队列包含 Dart 内部的微任务，主要通过<code>scheduleMicrotask</code>调度</li>\n<li>事件队列包含外部事件，如 I/O、Timer、绘制事件等</li>\n</ul>\n<p><img src=\"/Dart-异步编程/事件循环.png.jpg\" alt=\"\"></p>\n<p>从上图可以看出，Dart 处理事件循环的逻辑</p>\n<ul>\n<li>首先处理所有微任务队列里的微任务</li>\n<li>处理完所有微任务之后，处理事件队列里的一个事件</li>\n<li>回到微任务队列继续循环</li>\n</ul>\n<p>对于微任务队列，一次性全部处理，对于事件队列，一次只处理一个。</p>\n<h2 id=\"微任务和事件\"><a href=\"#微任务和事件\" class=\"headerlink\" title=\"微任务和事件\"></a>微任务和事件</h2><h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p><code>dart:async</code>定义了一个顶级函数<code>scheduleMicrotask</code>，使用其让代码以微任务的方式异步执行</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span>;\t<span class=\"comment\">//下文不再显式导入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\">  scheduleMicrotask(() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个微任务'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"结束\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>开始<br>结束<br>这是一个微任务</p>\n</blockquote>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>使用<code>Timer.run(callback)</code>让代码以事件的方式异步执行</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  Timer.run(() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个事件'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  scheduleMicrotask(()&#123; <span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务0'</span>); &#125;);</span><br><span class=\"line\">  scheduleMicrotask(()&#123; <span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务1'</span>); &#125;);</span><br><span class=\"line\">  scheduleMicrotask(()&#123; <span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务2'</span>); &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"结束\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>开始<br>结束<br>这是微任务0<br>这是微任务1<br>这是微任务2<br>这是一个事件</p>\n</blockquote>\n<p>同时可以看出和 Java 使用<code>new Thread（Runnable r）</code>不同，在 Dart 中，微任务的执行顺序是有序的。</p>\n<p>考虑下面的代码，会输出<code>这是一个事件</code>吗？</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\">Timer.run(() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个事件'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">foo() &#123;</span><br><span class=\"line\">  scheduleMicrotask(foo);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>根据上面 Dart 处理事件循环的逻辑图，<code>Timer.run</code>永远不会被执行，因为<code>scheduleMicrotask</code>永远在执行。</p>\n<p>仅仅使用回调函数实现异步很容易陷入“回调地狱（Callback hell）”，为此 Dart 引入了<code>Future</code></p>\n<h2 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h2><p>Future 封装了一系列静态函数完成异步操作，其内部通过<code>scheduleMicrotask</code>和<code>Timer</code>实现。此外还有一个<code>then</code>方法，接收一个名为<code>onValue</code>的闭包作为参数，该闭包在 Future 成功完成时被调用</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Future(FutureOr<t> computation())</t></td>\n<td>创建事件任务</td>\n</tr>\n<tr>\n<td>microtask(FutureOr<t> computation())</t></td>\n<td>创建microtask任务</td>\n</tr>\n<tr>\n<td>sync(FutureOr<t> computation())</t></td>\n<td>创建同步任务</td>\n</tr>\n<tr>\n<td>delayed(Duration duration, [FutureOr<t> computation()])</t></td>\n<td>创建延迟任务</td>\n</tr>\n</tbody>\n</table>\n<p>通过代码理解</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  Timer.run(() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'这是一个事件'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  scheduleMicrotask(()&#123;<span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务0'</span>);&#125;);</span><br><span class=\"line\">  scheduleMicrotask(()&#123;<span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务1'</span>);&#125;);</span><br><span class=\"line\">  scheduleMicrotask(()&#123;<span class=\"built_in\">print</span>(<span class=\"string\">'这是微任务2'</span>);&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"结束\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  Future(() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'普通Future，通过Timer实现'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  Future.delayed(<span class=\"keyword\">const</span> <span class=\"built_in\">Duration</span>(seconds: <span class=\"number\">2</span>), () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'延迟Future，通过Timer实现'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  Future.microtask(() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'Future创建微任务，通过scheduleMicrotask实现'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  Future.<span class=\"keyword\">sync</span>(() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'同步Future，执行同步代码'</span>))</span><br><span class=\"line\">      .then((a) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'then中的代码0'</span>))</span><br><span class=\"line\">      .then((b) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'then中的代码1'</span>))</span><br><span class=\"line\">      .then((c) &#123; <span class=\"keyword\">throw</span> <span class=\"string\">'抛出then中的错误'</span>; &#125;)</span><br><span class=\"line\">      .catchError((error) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'捕获Error <span class=\"subst\">$error<span class=\"string\">'))</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">      .whenComplete(() &#123;print('</span></span>then任务完成'</span>);&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<blockquote>\n<p>开始<br>结束<br>同步Future，执行同步代码<br>这是微任务0<br>这是微任务1<br>这是微任务2<br>Future创建微任务，通过scheduleMicrotask实现<br>then中的代码0<br>then中的代码1<br>捕获Error 抛出then中的错误<br>then任务完成<br>这是一个事件<br>普通Future，通过Timer实现</p>\n<p>//延迟2s</p>\n<p>延迟Future，通过Timer实现</p>\n</blockquote>\n<hr>\n<p>在<code>dart:async</code>中，除了 Future，还有 Completer，用来将具体的 Future 流程控制权交给开发者</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> completer = Completer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> future = completer.future;</span><br><span class=\"line\">future.then((d) =&gt; <span class=\"string\">'返回的字符串'</span>)</span><br><span class=\"line\">    .then((e) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'获得Completer中的future <span class=\"subst\">$e<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">completer.complete((e) =&gt; print('</span></span>设为完成状态'</span>));</span><br></pre></td></tr></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>获得Completer中的future 返回的字符串</p>\n</blockquote>\n<p>虽然 Future 缓解了回调地狱的问题，但如果串太多的<code>then</code>代码，可读性仍然会非常差，特别是各种 Future 嵌套的时候。与 JavaScript 类似，Dart 引入了<code>async/await</code>。</p>\n<h2 id=\"async-和-await\"><a href=\"#async-和-await\" class=\"headerlink\" title=\"async 和 await\"></a>async 和 await</h2><p>async 关键字修饰的函数与传统函数并无区别，只是将返回值类型使用 Future 进行了封装。</p>\n<p>通过代码具体理解</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  getInt().then((i) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'getInt: <span class=\"subst\">$i<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  getString().then((s) =&gt; print('</span></span>getString: <span class=\"subst\">$s<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>main'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getInt() <span class=\"keyword\">async</span> =&gt; <span class=\"number\">2333</span>;</span><br><span class=\"line\">getString() <span class=\"keyword\">async</span> =&gt; <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>main<br>getInt: 2333<br>getString: hello</p>\n</blockquote>\n<p>可以看到，调用<code>async</code>方法的代码转换成了异步任务。要想使之变成同步顺序，使用<code>await</code>关键字。不过需要注意的是，该关键字必须要在<code>async</code>函数中使用</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"keyword\">await</span> getInt();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'getInt: <span class=\"subst\">$i<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  var s = await getString();</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>getString: <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>main'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出</p>\n<blockquote>\n<p>getInt: 2333<br>getString: hello<br>main</p>\n</blockquote>\n<p>继续下面的例子</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'main 0'</span>);</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'main 1'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Foo'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"keyword\">await</span> bar();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'from bar: <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">bar() &#123;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Bar'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出为</p>\n<blockquote>\n<p>main 0<br>Foo<br>Bar<br>main 1<br>from bar: hello</p>\n</blockquote>\n<p>也就是说，在<code>foo</code>中，除了第一行代码以及<code>bar()</code>这一函数调用之外的其他代码均为异步执行。当使用<code>await</code>的时候，其右边会马上返回一个 Future 对象，下面的代码则会以<code>then</code>的形式运行。</p>\n<p>上面的代码转换成 Future 风格</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Foo'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Future.<span class=\"keyword\">sync</span>(bar).then((s) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'from bar: <span class=\"subst\">$s<span class=\"string\">'));</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><h3 id=\"stream\"><a href=\"#stream\" class=\"headerlink\" title=\"stream\"></a>stream</h3><p>stream 是 Dart 中一个长度不确定的值列表，可以是有限的或者无限的，重要的是我们不知道 stream 何时结束或已经结束。随时间改变的鼠标位置、所有素数的列表或者网络上的视频流，都可以看做一个 stream。</p>\n<p>可以通过为 stream 注册一个或多个回调函数的方式，对其进行订阅监听。</p>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><p>yield 语句被用于生成器函数内，目的是给生成的集合添加新的结果。yield 语句总是使它的表达式被求值，通常情况下，求值结果会被追加到外层生成器所关联的集合中。如果生成器是同步的，则关联的集合是一个 iterable；如果是异步的，则关联的集合是一个 stream。</p>\n<p>此外，yield 也会因外层的生成器是否同步产生不同的行为：同步时 yield 会暂停外层生成器，直至调用<code>moveNext</code>且返回值为 true，异步时生成器的执行会继续。</p>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p>一个函数体标记有<code>async*</code>修饰符的函数，将作为 stream 的生成函数。下面的函数生成一个包含自然数序列的 stream</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">get</span> naturals <span class=\"keyword\">async</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">await</span> k++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> naturals) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'get a natural <span class=\"subst\">$i<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  &#125;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure>\n<p>运行<code>main</code>函数，控制台将输出</p>\n<blockquote>\n<p>get a natural 0<br>get a natural 1<br>get a natural 2</p>\n</blockquote>\n<p>当 naturals 被调用时，立即返回一个新的 stream，一旦 stream 被监听，函数体将运行，以便生成值来填充 stream。每一次迭代执行一次 yield 语句，k 将自增（由于 await 的存在，函数会有短暂停止），然后函数将继续执行并使用新的 k 值，该值将被 yield 追加到 stream 中。</p>\n<h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3><p>上述函数的同步形式</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span> naturalsTo(n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(k &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>通过一个混合编程的例子来体会两者的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Iterable nSync(n) sync* &#123;</span><br><span class=\"line\">  int k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n)  &#123;</span><br><span class=\"line\">    print(<span class=\"string\">'sync before k++ and k is $k'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">    print(<span class=\"string\">'sync after k++ and k is $k'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Stream nAsync(n) <span class=\"keyword\">async</span>* &#123;</span><br><span class=\"line\">  int k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n)  &#123;</span><br><span class=\"line\">    print(<span class=\"string\">'async before k++ and k is $k'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">await</span> k++;</span><br><span class=\"line\">    print(<span class=\"string\">'async after k++ and k is $k'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  nAsync(<span class=\"number\">2</span>).last;</span><br><span class=\"line\">  nSync(<span class=\"number\">2</span>).last;</span><br><span class=\"line\">  print(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出为</p>\n<blockquote>\n<p>sync before k++ and k is 0<br>sync after k++ and k is 1<br>sync before k++ and k is 1<br>sync after k++ and k is 2<br>main<br>async before k++ and k is 0<br>async after k++ and k is 1<br>async before k++ and k is 1<br>async after k++ and k is 2</p>\n</blockquote>"},{"title":"Dart 面向对象","date":"2019-04-23T01:10:53.000Z","_content":"\n作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。\n\n<!--more-->\n\n## 定义\n\n使用 class 关键字定义一个类。与 Java 类似，如果没有显示地定义构造函数，会默认一个无参构造函数。使用 new 关键字和构造函数来创建对象。\n\n```dart\nclass Point {\n  num x;\n  num y;\n  num z;\n}\n\nvoid main() {\n  var point = new Point();\n  print(point.hasCode);//未定义父类的时候，默认继承自Object\n}\n```\n\n### 构造函数\n\n可以在构造函数的参数前加 this 关键字直接赋值\n\n```dart\nclass Point {\n    num x;\n    num y;\n    num z;\n    \n    //第一个值传递给this.x，第二个值传递给this.y\n    Point(this.x, this.y, z) {\t\n            this.z = z;\n    }\n    \n    //命名构造函数，格式为Class.name(var param)\n    Point.fromeList(var list): \n            x = list[0], y = list[1], z = list[2]{\t//使用冒号初始化变量\n    }\n\n    //当然，上面也可以简写为：\n    //Point.fromeList(var list):this(list[0], list[1], list[2]);\n\n     String toString() => 'x:$x  y:$y  z:$z';\n}\n\n//调用父类的构造方法\nclass ColorPoint extends Point {\n  String color;\n\n  ColorPoint.fromXYZAndColor(num x, num y, num z, String color)\n      : super.fromXYZ(x, y, z) {\n    this.color = color;\n    print('ColorPoint');\n  }\n}\n\nvoid main() {\n    var p1 = new Point(1, 2, 3);\n    var p2 = new Point.fromeList([1, 2, 3]);\n    print(p1);\t//默认调用toString()函数\n}\n```\n\n需要创建不可变对象的话，可以在构造函数前使用`const`关键字定义编译时常量对象\n\n```dart\nclass ImmutablePoint {\n    final num x;\n    final num y;\n    const ImmutablePoint(this.x, this.y); // 常量构造函数\n    static final ImmutablePoint origin = const ImmutablePoint(0, 0); // 创建一个常量对象不能用new，要用const\n}\n```\n\n### 工厂构造函数\n\nDart 中一种获取单例对象的方式，使用工厂模式来定义构造函数。对于调用者来说，仍然使用 new 关键字来获取对象，具体的实现细节对外隐藏。\n\n```dart\nclass Logger { \n\tfinal String name; \n    bool mute = false; \n    \n    // 变量前加下划线表示私有属性 \n    static final Map<String, Logger> _cache = <String, Logger>{}; \n    \n    factory Logger(String name) { \n        if (_cache.containsKey(name)) { \n            return _cache[name]; \n        } else { \n            final logger = new Logger._internal(name); \n            _cache[name] = logger; \n            return logger; \n        } \n    }\n\n    Logger._internal(this.name); \n    \n    void log(String msg) { \n        if (!mute) { \n            print('$name: $msg'); \n        } \n    } \n} \n\nvar logger = new Logger('UI'); \nlogger.log('Button clicked');\n```\n\n\n\n### Getter / Setter\n\n用来读写对象的属性，每个属性都对应一个隐式的 Getter 和 Setter，通过`obj.x`调用。类似于 Kotlin，可以使用`get`、`set`关键字拓展相应的功能。如果属性为`final`或者`const`，则只有对外的 Getter。\n\n```dart\nclass Rectangle {\n    num left;\n    num top;\n    num width;\n    num height;\n\n    Rectangle(this.left, this.top, this.width, this.height);\n    \n    // right 和 bottom 两个属性的计算方法\n    num get right => left + width;\n    set right(num value) => left = value - width;\n    \n    num get bottom => top + height;\n    set bottom(num value) => top = value - height;\n}\n\nvoid main() {\n    var rect = new Rectangle(3, 4, 20, 15);\n    assert(rect.left == 3);\n    \n    rect.right = 12;\n    assert(rect.left == -8);\n}\n```\n\n### 类方法\n\n实例方法跟 Java 类似，抽象方法有所不同，不需要使用`abstract`显示定义，只需要在方法签名后用`;`来代替方法体即表示其为一抽象方法，Dart 中非抽象类也可以定义抽象方法。\n\n```dart\nabstract class Bird {\n  void fly();\n}\n\nclass Sparrow extends Bird {\n  void fly() {\n\n  }\n    \n  void sleep();\n}\n```\n\n\n\n## 继承\n\n在 Dart 中没有“接口”这一概念，类分为抽象类和非抽象类，唯一的区别是后者不可直接实例化。Dart 中仍然使用了`implements`和`extends`关键字，不过两者有所不同\n\n- implements 代表实现，子类无法访问父类的参数，可以实现多个类\n- extends 代表继承，可继承父类的非私有变量，使用单继承机制\n\n在构造函数体前使用 `super`关键字调用父类构造函数，使用`@override`来注解复写父类的方法。\n\n### Mixin 继承机制\n\n#### 继承歧义\n\n在了解该机制之前先认识“继承歧义”，也叫“菱形问题”。当两个类 B 和 C 继承自 A，D类继承自 B 和 C 时将产生歧义。当 A 中有一个方法在 B 和 C 中已经重写，而 D 没有 重写，那么 D 继承的方法的版本是 B 还是 C？\n\n![继承歧义](Dart-面向对象\\继承歧义.png)\n\n\n\n不同的编程语言有不同的方法处理该问题\n\n| 语言   |                           解决方案                           |\n| ------ | :----------------------------------------------------------: |\n| C++    | 需要显式地声明要使用的特性是从哪个父类调用的(如：`Worker::Human.Age`)。C++不支持显式的重复继承，因为无法限定要使用哪个父类 |\n| Java 8 | Java 8 在接口上引入默认方法。如果`A、B、C`是接口，`B、C`可以为`A`的抽象方法提供不同的实现，从而导致`菱形问题`。`D`类必须重新实现该方法，否则发生编译错误。（Java 8 之前不支持多重继承、没有默认方法） |\n\nDart 使用 Mixin 机制解决该方法，或者写作“mix-in（混入）”更容易理解。\n\n### Mixin\n\n在 Java8 之前，由于单继承机制以及接口没有默认方法，避免了继承歧义，而 Dart 虽然也使用了单继承机制，但是没有`interface`这一概念 —— 实际上，Dart 中的每一个类都可以被`implements` —— 所以使用了基于线性逻辑的`Mixin`解决该问题。\n\n`Mixin`即为混入：`Mixins are a way of reusing a class’s code in multiple class hierarchies`。\n\n通过一个例子理解\n\n```dart\nclass A {\n  var s = 'A';\n  get() => 'A';\n}\n\nclass B {\n  var s = 'B';\n  get() => 'B';\n}\n\nclass P {\n  var s = 'P';\n  get() => 'P';\n}\n\nclass AB extends P with A, B {\n  var s = 'AB';\n}\n\nclass BA extends P with B, A {}\n\nvoid main() {\n  AB ab = AB();\n  print(ab.get());\n  print(ab.s);\n\n  BA ba = BA();\n  print(ba.get());\n}\n```\n\n控制台输出为：\n\n> B\n> AB\n> A\n\n这是因为下面的代码\n\n```dart\nclass AB extends P with A, B {}\n\nclass BA extends P with B, A {}\n```\n\n相当于\n\n```dart\nclass PA = P with A;\nclass PAB = PA with B;\n\nclass AB extends PAB {}\n\nclass PB = P with B;\nclass PBA = PB with A;\n\nclass BA extends PBA {}\n```\n\n继承图如下\n\n![ABP继承图](Dart-面向对象\\ABP继承图.png)\n\n\n\n有意思的是，当我们将上面的代码中的`with`换成`implements`时，输出的结果将为\n\n> P\n> AB\n> P\n\n### extends、with、implements\n\n在 Dart 中，类声明必须严格按照 extends -> with -> implements 的顺序\n\n- extends 的用法类似于 Java，唯一的不同在于子类可以完全访问父类的属性和函数，因为在 Dart 中并没有私有、公有的概念，下划线`_`的仅仅是一种约定。\n\n- 除了上面的内容，`with`还可以与之搭配关键字`on`，表示要进行 mixin 的类必须先 “implements” 被 mixin 的类声明中 on 关键字后面的类，否则编译失败\n\n  ```dart\n  abstract class D {\n    void fromD();\n  }\n  \n  mixin C on D {\n    fromC() => 'C';\n  }\n  \n  /*\n    下面的代码将编译失败，因为 F 要 mixin C 必须先“implements” D\n    但是 implements 关键字又必须在 with 的后面，所以只能定义一个新的类 E\n    使 E implements D，F 再 extends E，才能 mixin C\n   */\n  class F with C { }\t\n  ```\n\n  正确的做法\n\n  ```dart\n  class E implements D {\n    @override\n    void fromD() => 'E';\n  }\n  \n  class F extends E with C { }\n  ```\n\n- Dart 中每个类都是一个隐式地接口。`implements`一个类之后，必须`override`所有的方法和成员变量\n\n  ","source":"_posts/Dart-面向对象.md","raw":"---\ntitle: Dart 面向对象\ndate: 2019-04-23 09:10:53\ntags:\n- Dart\ncategories:\n- Dart\n---\n\n作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。\n\n<!--more-->\n\n## 定义\n\n使用 class 关键字定义一个类。与 Java 类似，如果没有显示地定义构造函数，会默认一个无参构造函数。使用 new 关键字和构造函数来创建对象。\n\n```dart\nclass Point {\n  num x;\n  num y;\n  num z;\n}\n\nvoid main() {\n  var point = new Point();\n  print(point.hasCode);//未定义父类的时候，默认继承自Object\n}\n```\n\n### 构造函数\n\n可以在构造函数的参数前加 this 关键字直接赋值\n\n```dart\nclass Point {\n    num x;\n    num y;\n    num z;\n    \n    //第一个值传递给this.x，第二个值传递给this.y\n    Point(this.x, this.y, z) {\t\n            this.z = z;\n    }\n    \n    //命名构造函数，格式为Class.name(var param)\n    Point.fromeList(var list): \n            x = list[0], y = list[1], z = list[2]{\t//使用冒号初始化变量\n    }\n\n    //当然，上面也可以简写为：\n    //Point.fromeList(var list):this(list[0], list[1], list[2]);\n\n     String toString() => 'x:$x  y:$y  z:$z';\n}\n\n//调用父类的构造方法\nclass ColorPoint extends Point {\n  String color;\n\n  ColorPoint.fromXYZAndColor(num x, num y, num z, String color)\n      : super.fromXYZ(x, y, z) {\n    this.color = color;\n    print('ColorPoint');\n  }\n}\n\nvoid main() {\n    var p1 = new Point(1, 2, 3);\n    var p2 = new Point.fromeList([1, 2, 3]);\n    print(p1);\t//默认调用toString()函数\n}\n```\n\n需要创建不可变对象的话，可以在构造函数前使用`const`关键字定义编译时常量对象\n\n```dart\nclass ImmutablePoint {\n    final num x;\n    final num y;\n    const ImmutablePoint(this.x, this.y); // 常量构造函数\n    static final ImmutablePoint origin = const ImmutablePoint(0, 0); // 创建一个常量对象不能用new，要用const\n}\n```\n\n### 工厂构造函数\n\nDart 中一种获取单例对象的方式，使用工厂模式来定义构造函数。对于调用者来说，仍然使用 new 关键字来获取对象，具体的实现细节对外隐藏。\n\n```dart\nclass Logger { \n\tfinal String name; \n    bool mute = false; \n    \n    // 变量前加下划线表示私有属性 \n    static final Map<String, Logger> _cache = <String, Logger>{}; \n    \n    factory Logger(String name) { \n        if (_cache.containsKey(name)) { \n            return _cache[name]; \n        } else { \n            final logger = new Logger._internal(name); \n            _cache[name] = logger; \n            return logger; \n        } \n    }\n\n    Logger._internal(this.name); \n    \n    void log(String msg) { \n        if (!mute) { \n            print('$name: $msg'); \n        } \n    } \n} \n\nvar logger = new Logger('UI'); \nlogger.log('Button clicked');\n```\n\n\n\n### Getter / Setter\n\n用来读写对象的属性，每个属性都对应一个隐式的 Getter 和 Setter，通过`obj.x`调用。类似于 Kotlin，可以使用`get`、`set`关键字拓展相应的功能。如果属性为`final`或者`const`，则只有对外的 Getter。\n\n```dart\nclass Rectangle {\n    num left;\n    num top;\n    num width;\n    num height;\n\n    Rectangle(this.left, this.top, this.width, this.height);\n    \n    // right 和 bottom 两个属性的计算方法\n    num get right => left + width;\n    set right(num value) => left = value - width;\n    \n    num get bottom => top + height;\n    set bottom(num value) => top = value - height;\n}\n\nvoid main() {\n    var rect = new Rectangle(3, 4, 20, 15);\n    assert(rect.left == 3);\n    \n    rect.right = 12;\n    assert(rect.left == -8);\n}\n```\n\n### 类方法\n\n实例方法跟 Java 类似，抽象方法有所不同，不需要使用`abstract`显示定义，只需要在方法签名后用`;`来代替方法体即表示其为一抽象方法，Dart 中非抽象类也可以定义抽象方法。\n\n```dart\nabstract class Bird {\n  void fly();\n}\n\nclass Sparrow extends Bird {\n  void fly() {\n\n  }\n    \n  void sleep();\n}\n```\n\n\n\n## 继承\n\n在 Dart 中没有“接口”这一概念，类分为抽象类和非抽象类，唯一的区别是后者不可直接实例化。Dart 中仍然使用了`implements`和`extends`关键字，不过两者有所不同\n\n- implements 代表实现，子类无法访问父类的参数，可以实现多个类\n- extends 代表继承，可继承父类的非私有变量，使用单继承机制\n\n在构造函数体前使用 `super`关键字调用父类构造函数，使用`@override`来注解复写父类的方法。\n\n### Mixin 继承机制\n\n#### 继承歧义\n\n在了解该机制之前先认识“继承歧义”，也叫“菱形问题”。当两个类 B 和 C 继承自 A，D类继承自 B 和 C 时将产生歧义。当 A 中有一个方法在 B 和 C 中已经重写，而 D 没有 重写，那么 D 继承的方法的版本是 B 还是 C？\n\n![继承歧义](Dart-面向对象\\继承歧义.png)\n\n\n\n不同的编程语言有不同的方法处理该问题\n\n| 语言   |                           解决方案                           |\n| ------ | :----------------------------------------------------------: |\n| C++    | 需要显式地声明要使用的特性是从哪个父类调用的(如：`Worker::Human.Age`)。C++不支持显式的重复继承，因为无法限定要使用哪个父类 |\n| Java 8 | Java 8 在接口上引入默认方法。如果`A、B、C`是接口，`B、C`可以为`A`的抽象方法提供不同的实现，从而导致`菱形问题`。`D`类必须重新实现该方法，否则发生编译错误。（Java 8 之前不支持多重继承、没有默认方法） |\n\nDart 使用 Mixin 机制解决该方法，或者写作“mix-in（混入）”更容易理解。\n\n### Mixin\n\n在 Java8 之前，由于单继承机制以及接口没有默认方法，避免了继承歧义，而 Dart 虽然也使用了单继承机制，但是没有`interface`这一概念 —— 实际上，Dart 中的每一个类都可以被`implements` —— 所以使用了基于线性逻辑的`Mixin`解决该问题。\n\n`Mixin`即为混入：`Mixins are a way of reusing a class’s code in multiple class hierarchies`。\n\n通过一个例子理解\n\n```dart\nclass A {\n  var s = 'A';\n  get() => 'A';\n}\n\nclass B {\n  var s = 'B';\n  get() => 'B';\n}\n\nclass P {\n  var s = 'P';\n  get() => 'P';\n}\n\nclass AB extends P with A, B {\n  var s = 'AB';\n}\n\nclass BA extends P with B, A {}\n\nvoid main() {\n  AB ab = AB();\n  print(ab.get());\n  print(ab.s);\n\n  BA ba = BA();\n  print(ba.get());\n}\n```\n\n控制台输出为：\n\n> B\n> AB\n> A\n\n这是因为下面的代码\n\n```dart\nclass AB extends P with A, B {}\n\nclass BA extends P with B, A {}\n```\n\n相当于\n\n```dart\nclass PA = P with A;\nclass PAB = PA with B;\n\nclass AB extends PAB {}\n\nclass PB = P with B;\nclass PBA = PB with A;\n\nclass BA extends PBA {}\n```\n\n继承图如下\n\n![ABP继承图](Dart-面向对象\\ABP继承图.png)\n\n\n\n有意思的是，当我们将上面的代码中的`with`换成`implements`时，输出的结果将为\n\n> P\n> AB\n> P\n\n### extends、with、implements\n\n在 Dart 中，类声明必须严格按照 extends -> with -> implements 的顺序\n\n- extends 的用法类似于 Java，唯一的不同在于子类可以完全访问父类的属性和函数，因为在 Dart 中并没有私有、公有的概念，下划线`_`的仅仅是一种约定。\n\n- 除了上面的内容，`with`还可以与之搭配关键字`on`，表示要进行 mixin 的类必须先 “implements” 被 mixin 的类声明中 on 关键字后面的类，否则编译失败\n\n  ```dart\n  abstract class D {\n    void fromD();\n  }\n  \n  mixin C on D {\n    fromC() => 'C';\n  }\n  \n  /*\n    下面的代码将编译失败，因为 F 要 mixin C 必须先“implements” D\n    但是 implements 关键字又必须在 with 的后面，所以只能定义一个新的类 E\n    使 E implements D，F 再 extends E，才能 mixin C\n   */\n  class F with C { }\t\n  ```\n\n  正确的做法\n\n  ```dart\n  class E implements D {\n    @override\n    void fromD() => 'E';\n  }\n  \n  class F extends E with C { }\n  ```\n\n- Dart 中每个类都是一个隐式地接口。`implements`一个类之后，必须`override`所有的方法和成员变量\n\n  ","slug":"Dart-面向对象","published":1,"updated":"2019-06-02T04:55:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqwb001my4up5nhqo8hz","content":"<p>作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。</p>\n<a id=\"more\"></a>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>使用 class 关键字定义一个类。与 Java 类似，如果没有显示地定义构造函数，会默认一个无参构造函数。使用 new 关键字和构造函数来创建对象。</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>{</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> z;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(point.hasCode);<span class=\"comment\">//未定义父类的时候，默认继承自Object</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>可以在构造函数的参数前加 this 关键字直接赋值</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> z;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//第一个值传递给this.x，第二个值传递给this.y</span></span><br><span class=\"line\">    Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y, z) {\t</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.z = z;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//命名构造函数，格式为Class.name(var param)</span></span><br><span class=\"line\">    Point.fromeList(<span class=\"keyword\">var</span> list): </span><br><span class=\"line\">            x = list[<span class=\"number\">0</span>], y = list[<span class=\"number\">1</span>], z = list[<span class=\"number\">2</span>]{\t<span class=\"comment\">//使用冒号初始化变量</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//当然，上面也可以简写为：</span></span><br><span class=\"line\">    <span class=\"comment\">//Point.fromeList(var list):this(list[0], list[1], list[2]);</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">String</span> toString() => <span class=\"string\">'x:<span class=\"subst\">$x</span>  y:<span class=\"subst\">$y</span>  z:<span class=\"subst\">$z<span class=\"string\">';</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">}</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">//调用父类的构造方法</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">class ColorPoint extends Point {</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  String color;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  ColorPoint.fromXYZAndColor(num x, num y, num z, String color)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">      : super.fromXYZ(x, y, z) {</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    this.color = color;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    print('</span></span>ColorPoint'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point.fromeList([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(p1);\t<span class=\"comment\">//默认调用toString()函数</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>需要创建不可变对象的话，可以在构造函数前使用<code>const</code>关键字定义编译时常量对象</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImmutablePoint</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y); <span class=\"comment\">// 常量构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutablePoint origin = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 创建一个常量对象不能用new，要用const</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"工厂构造函数\"><a href=\"#工厂构造函数\" class=\"headerlink\" title=\"工厂构造函数\"></a>工厂构造函数</h3><p>Dart 中一种获取单例对象的方式，使用工厂模式来定义构造函数。对于调用者来说，仍然使用 new 关键字来获取对象，具体的实现细节对外隐藏。</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>{ </span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name; </span><br><span class=\"line\">    <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 变量前加下划线表示私有属性 </span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span><<span class=\"built_in\">String</span>, Logger> _cache = <<span class=\"built_in\">String</span>, Logger>{}; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) { </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_cache.containsKey(name)) { </span><br><span class=\"line\">            <span class=\"keyword\">return</span> _cache[name]; </span><br><span class=\"line\">        } <span class=\"keyword\">else</span> { </span><br><span class=\"line\">            <span class=\"keyword\">final</span> logger = <span class=\"keyword\">new</span> Logger._internal(name); </span><br><span class=\"line\">            _cache[name] = logger; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> logger; </span><br><span class=\"line\">        } </span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    Logger._internal(<span class=\"keyword\">this</span>.name); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) { </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mute) { </span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$name</span>: <span class=\"subst\">$msg<span class=\"string\">'); </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">        } </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    } </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">} </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">var logger = new Logger('</span></span>UI'</span>); </span><br><span class=\"line\">logger.log(<span class=\"string\">'Button clicked'</span>);</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Getter-Setter\"><a href=\"#Getter-Setter\" class=\"headerlink\" title=\"Getter / Setter\"></a>Getter / Setter</h3><p>用来读写对象的属性，每个属性都对应一个隐式的 Getter 和 Setter，通过<code>obj.x</code>调用。类似于 Kotlin，可以使用<code>get</code>、<code>set</code>关键字拓展相应的功能。如果属性为<code>final</code>或者<code>const</code>，则只有对外的 Getter。</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">num</span> left;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> top;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> width;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\">    Rectangle(<span class=\"keyword\">this</span>.left, <span class=\"keyword\">this</span>.top, <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// right 和 bottom 两个属性的计算方法</span></span><br><span class=\"line\">    <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> right => left + width;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> right(<span class=\"built_in\">num</span> value) => left = value - width;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> bottom => top + height;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> bottom(<span class=\"built_in\">num</span> value) => top = value - height;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rect = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    rect.right = <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">-8</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>实例方法跟 Java 类似，抽象方法有所不同，不需要使用<code>abstract</code>显示定义，只需要在方法签名后用<code>;</code>来代替方法体即表示其为一抽象方法，Dart 中非抽象类也可以定义抽象方法。</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">void</span> fly();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sparrow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Bird</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">void</span> fly() {</span><br><span class=\"line\"></span><br><span class=\"line\">  }</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">void</span> sleep();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在 Dart 中没有“接口”这一概念，类分为抽象类和非抽象类，唯一的区别是后者不可直接实例化。Dart 中仍然使用了<code>implements</code>和<code>extends</code>关键字，不过两者有所不同</p>\n<ul>\n<li>implements 代表实现，子类无法访问父类的参数，可以实现多个类</li>\n<li>extends 代表继承，可继承父类的非私有变量，使用单继承机制</li>\n</ul>\n<p>在构造函数体前使用 <code>super</code>关键字调用父类构造函数，使用<code>@override</code>来注解复写父类的方法。</p>\n<h3 id=\"Mixin-继承机制\"><a href=\"#Mixin-继承机制\" class=\"headerlink\" title=\"Mixin 继承机制\"></a>Mixin 继承机制</h3><h4 id=\"继承歧义\"><a href=\"#继承歧义\" class=\"headerlink\" title=\"继承歧义\"></a>继承歧义</h4><p>在了解该机制之前先认识“继承歧义”，也叫“菱形问题”。当两个类 B 和 C 继承自 A，D类继承自 B 和 C 时将产生歧义。当 A 中有一个方法在 B 和 C 中已经重写，而 D 没有 重写，那么 D 继承的方法的版本是 B 还是 C？</p>\n<p><img src=\"/Dart-面向对象/继承歧义.png\" alt=\"继承歧义\"></p>\n<p>不同的编程语言有不同的方法处理该问题</p>\n<table>\n<thead>\n<tr>\n<th>语言</th>\n<th style=\"text-align:center\">解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C++</td>\n<td style=\"text-align:center\">需要显式地声明要使用的特性是从哪个父类调用的(如：<code>Worker::Human.Age</code>)。C++不支持显式的重复继承，因为无法限定要使用哪个父类</td>\n</tr>\n<tr>\n<td>Java 8</td>\n<td style=\"text-align:center\">Java 8 在接口上引入默认方法。如果<code>A、B、C</code>是接口，<code>B、C</code>可以为<code>A</code>的抽象方法提供不同的实现，从而导致<code>菱形问题</code>。<code>D</code>类必须重新实现该方法，否则发生编译错误。（Java 8 之前不支持多重继承、没有默认方法）</td>\n</tr>\n</tbody>\n</table>\n<p>Dart 使用 Mixin 机制解决该方法，或者写作“mix-in（混入）”更容易理解。</p>\n<h3 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h3><p>在 Java8 之前，由于单继承机制以及接口没有默认方法，避免了继承歧义，而 Dart 虽然也使用了单继承机制，但是没有<code>interface</code>这一概念 —— 实际上，Dart 中的每一个类都可以被<code>implements</code> —— 所以使用了基于线性逻辑的<code>Mixin</code>解决该问题。</p>\n<p><code>Mixin</code>即为混入：<code>Mixins are a way of reusing a class’s code in multiple class hierarchies</code>。</p>\n<p>通过一个例子理解</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() => <span class=\"string\">'A'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'B'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() => <span class=\"string\">'B'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">P</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'P'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() => <span class=\"string\">'P'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AB</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'AB'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BA</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">B</span>, <span class=\"title\">A</span> </span>{}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() {</span><br><span class=\"line\">  AB ab = AB();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(ab.<span class=\"keyword\">get</span>());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(ab.s);</span><br><span class=\"line\"></span><br><span class=\"line\">  BA ba = BA();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(ba.<span class=\"keyword\">get</span>());</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出为：</p>\n<blockquote>\n<p>B<br>AB<br>A</p>\n</blockquote>\n<p>这是因为下面的代码</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AB</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> </span>{}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BA</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">B</span>, <span class=\"title\">A</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>\n<p>相当于</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PA</span> = <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">PAB</span> = <span class=\"title\">PA</span> <span class=\"title\">with</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">AB</span> <span class=\"keyword\">extends</span> <span class=\"title\">PAB</span> </span>{}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PB</span> = <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">PBA</span> = <span class=\"title\">PB</span> <span class=\"title\">with</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">BA</span> <span class=\"keyword\">extends</span> <span class=\"title\">PBA</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>\n<p>继承图如下</p>\n<p><img src=\"/Dart-面向对象/ABP继承图.png\" alt=\"ABP继承图\"></p>\n<p>有意思的是，当我们将上面的代码中的<code>with</code>换成<code>implements</code>时，输出的结果将为</p>\n<blockquote>\n<p>P<br>AB<br>P</p>\n</blockquote>\n<h3 id=\"extends、with、implements\"><a href=\"#extends、with、implements\" class=\"headerlink\" title=\"extends、with、implements\"></a>extends、with、implements</h3><p>在 Dart 中，类声明必须严格按照 extends -> with -> implements 的顺序</p>\n<ul>\n<li><p>extends 的用法类似于 Java，唯一的不同在于子类可以完全访问父类的属性和函数，因为在 Dart 中并没有私有、公有的概念，下划线<code>_</code>的仅仅是一种约定。</p>\n</li>\n<li><p>除了上面的内容，<code>with</code>还可以与之搭配关键字<code>on</code>，表示要进行 mixin 的类必须先 “implements” 被 mixin 的类声明中 on 关键字后面的类，否则编译失败</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">void</span> fromD();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">mixin C on D {</span><br><span class=\"line\">  fromC() => <span class=\"string\">'C'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  下面的代码将编译失败，因为 F 要 mixin C 必须先“implements” D</span></span><br><span class=\"line\"><span class=\"comment\">  但是 implements 关键字又必须在 with 的后面，所以只能定义一个新的类 E</span></span><br><span class=\"line\"><span class=\"comment\">  使 E implements D，F 再 extends E，才能 mixin C</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span> <span class=\"title\">with</span> <span class=\"title\">C</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>\n<p>正确的做法</p>\n<figure class=\"highlight dart\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span> <span class=\"keyword\">implements</span> <span class=\"title\">D</span> </span>{</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> fromD() => <span class=\"string\">'E'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span> <span class=\"keyword\">extends</span> <span class=\"title\">E</span> <span class=\"title\">with</span> <span class=\"title\">C</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>Dart 中每个类都是一个隐式地接口。<code>implements</code>一个类之后，必须<code>override</code>所有的方法和成员变量</p>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":5227,"excerpt":"<p>作为一门面向对象的语言，Dart 在很多方面跟 Java 都很相似。Dart 中所有对象都是类的实例，所有类都属于 Object 的子类，类的继承则使用 Mixin 机制。</p>","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>使用 class 关键字定义一个类。与 Java 类似，如果没有显示地定义构造函数，会默认一个无参构造函数。使用 new 关键字和构造函数来创建对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(point.hasCode);<span class=\"comment\">//未定义父类的时候，默认继承自Object</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>可以在构造函数的参数前加 this 关键字直接赋值</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> z;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//第一个值传递给this.x，第二个值传递给this.y</span></span><br><span class=\"line\">    Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y, z) &#123;\t</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.z = z;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//命名构造函数，格式为Class.name(var param)</span></span><br><span class=\"line\">    Point.fromeList(<span class=\"keyword\">var</span> list): </span><br><span class=\"line\">            x = list[<span class=\"number\">0</span>], y = list[<span class=\"number\">1</span>], z = list[<span class=\"number\">2</span>]&#123;\t<span class=\"comment\">//使用冒号初始化变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//当然，上面也可以简写为：</span></span><br><span class=\"line\">    <span class=\"comment\">//Point.fromeList(var list):this(list[0], list[1], list[2]);</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">String</span> toString() =&gt; <span class=\"string\">'x:<span class=\"subst\">$x</span>  y:<span class=\"subst\">$y</span>  z:<span class=\"subst\">$z<span class=\"string\">';</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">//调用父类的构造方法</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">class ColorPoint extends Point &#123;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  String color;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  ColorPoint.fromXYZAndColor(num x, num y, num z, String color)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">      : super.fromXYZ(x, y, z) &#123;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    this.color = color;</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    print('</span></span>ColorPoint'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point.fromeList([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(p1);\t<span class=\"comment\">//默认调用toString()函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要创建不可变对象的话，可以在构造函数前使用<code>const</code>关键字定义编译时常量对象</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImmutablePoint</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y); <span class=\"comment\">// 常量构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutablePoint origin = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 创建一个常量对象不能用new，要用const</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"工厂构造函数\"><a href=\"#工厂构造函数\" class=\"headerlink\" title=\"工厂构造函数\"></a>工厂构造函数</h3><p>Dart 中一种获取单例对象的方式，使用工厂模式来定义构造函数。对于调用者来说，仍然使用 new 关键字来获取对象，具体的实现细节对外隐藏。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name; </span><br><span class=\"line\">    <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 变量前加下划线表示私有属性 </span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache = &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> _cache[name]; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            <span class=\"keyword\">final</span> logger = <span class=\"keyword\">new</span> Logger._internal(name); </span><br><span class=\"line\">            _cache[name] = logger; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> logger; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Logger._internal(<span class=\"keyword\">this</span>.name); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mute) &#123; </span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$name</span>: <span class=\"subst\">$msg<span class=\"string\">'); </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">        &#125; </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">    &#125; </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125; </span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">var logger = new Logger('</span></span>UI'</span>); </span><br><span class=\"line\">logger.log(<span class=\"string\">'Button clicked'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Getter-Setter\"><a href=\"#Getter-Setter\" class=\"headerlink\" title=\"Getter / Setter\"></a>Getter / Setter</h3><p>用来读写对象的属性，每个属性都对应一个隐式的 Getter 和 Setter，通过<code>obj.x</code>调用。类似于 Kotlin，可以使用<code>get</code>、<code>set</code>关键字拓展相应的功能。如果属性为<code>final</code>或者<code>const</code>，则只有对外的 Getter。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> left;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> top;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> width;</span><br><span class=\"line\">    <span class=\"built_in\">num</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\">    Rectangle(<span class=\"keyword\">this</span>.left, <span class=\"keyword\">this</span>.top, <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// right 和 bottom 两个属性的计算方法</span></span><br><span class=\"line\">    <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> right =&gt; left + width;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> right(<span class=\"built_in\">num</span> value) =&gt; left = value - width;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> bottom =&gt; top + height;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> bottom(<span class=\"built_in\">num</span> value) =&gt; top = value - height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rect = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    rect.right = <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">-8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>实例方法跟 Java 类似，抽象方法有所不同，不需要使用<code>abstract</code>显示定义，只需要在方法签名后用<code>;</code>来代替方法体即表示其为一抽象方法，Dart 中非抽象类也可以定义抽象方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> fly();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sparrow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> fly() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">void</span> sleep();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在 Dart 中没有“接口”这一概念，类分为抽象类和非抽象类，唯一的区别是后者不可直接实例化。Dart 中仍然使用了<code>implements</code>和<code>extends</code>关键字，不过两者有所不同</p>\n<ul>\n<li>implements 代表实现，子类无法访问父类的参数，可以实现多个类</li>\n<li>extends 代表继承，可继承父类的非私有变量，使用单继承机制</li>\n</ul>\n<p>在构造函数体前使用 <code>super</code>关键字调用父类构造函数，使用<code>@override</code>来注解复写父类的方法。</p>\n<h3 id=\"Mixin-继承机制\"><a href=\"#Mixin-继承机制\" class=\"headerlink\" title=\"Mixin 继承机制\"></a>Mixin 继承机制</h3><h4 id=\"继承歧义\"><a href=\"#继承歧义\" class=\"headerlink\" title=\"继承歧义\"></a>继承歧义</h4><p>在了解该机制之前先认识“继承歧义”，也叫“菱形问题”。当两个类 B 和 C 继承自 A，D类继承自 B 和 C 时将产生歧义。当 A 中有一个方法在 B 和 C 中已经重写，而 D 没有 重写，那么 D 继承的方法的版本是 B 还是 C？</p>\n<p><img src=\"/Dart-面向对象/继承歧义.png\" alt=\"继承歧义\"></p>\n<p>不同的编程语言有不同的方法处理该问题</p>\n<table>\n<thead>\n<tr>\n<th>语言</th>\n<th style=\"text-align:center\">解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C++</td>\n<td style=\"text-align:center\">需要显式地声明要使用的特性是从哪个父类调用的(如：<code>Worker::Human.Age</code>)。C++不支持显式的重复继承，因为无法限定要使用哪个父类</td>\n</tr>\n<tr>\n<td>Java 8</td>\n<td style=\"text-align:center\">Java 8 在接口上引入默认方法。如果<code>A、B、C</code>是接口，<code>B、C</code>可以为<code>A</code>的抽象方法提供不同的实现，从而导致<code>菱形问题</code>。<code>D</code>类必须重新实现该方法，否则发生编译错误。（Java 8 之前不支持多重继承、没有默认方法）</td>\n</tr>\n</tbody>\n</table>\n<p>Dart 使用 Mixin 机制解决该方法，或者写作“mix-in（混入）”更容易理解。</p>\n<h3 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h3><p>在 Java8 之前，由于单继承机制以及接口没有默认方法，避免了继承歧义，而 Dart 虽然也使用了单继承机制，但是没有<code>interface</code>这一概念 —— 实际上，Dart 中的每一个类都可以被<code>implements</code> —— 所以使用了基于线性逻辑的<code>Mixin</code>解决该问题。</p>\n<p><code>Mixin</code>即为混入：<code>Mixins are a way of reusing a class’s code in multiple class hierarchies</code>。</p>\n<p>通过一个例子理解</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() =&gt; <span class=\"string\">'A'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'B'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() =&gt; <span class=\"string\">'B'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">P</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'P'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() =&gt; <span class=\"string\">'P'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AB</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"string\">'AB'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BA</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">B</span>, <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  AB ab = AB();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(ab.<span class=\"keyword\">get</span>());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(ab.s);</span><br><span class=\"line\"></span><br><span class=\"line\">  BA ba = BA();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(ba.<span class=\"keyword\">get</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出为：</p>\n<blockquote>\n<p>B<br>AB<br>A</p>\n</blockquote>\n<p>这是因为下面的代码</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AB</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BA</span> <span class=\"keyword\">extends</span> <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">B</span>, <span class=\"title\">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PA</span> = <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">PAB</span> = <span class=\"title\">PA</span> <span class=\"title\">with</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">AB</span> <span class=\"keyword\">extends</span> <span class=\"title\">PAB</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PB</span> = <span class=\"title\">P</span> <span class=\"title\">with</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">PBA</span> = <span class=\"title\">PB</span> <span class=\"title\">with</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">BA</span> <span class=\"keyword\">extends</span> <span class=\"title\">PBA</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>继承图如下</p>\n<p><img src=\"/Dart-面向对象/ABP继承图.png\" alt=\"ABP继承图\"></p>\n<p>有意思的是，当我们将上面的代码中的<code>with</code>换成<code>implements</code>时，输出的结果将为</p>\n<blockquote>\n<p>P<br>AB<br>P</p>\n</blockquote>\n<h3 id=\"extends、with、implements\"><a href=\"#extends、with、implements\" class=\"headerlink\" title=\"extends、with、implements\"></a>extends、with、implements</h3><p>在 Dart 中，类声明必须严格按照 extends -&gt; with -&gt; implements 的顺序</p>\n<ul>\n<li><p>extends 的用法类似于 Java，唯一的不同在于子类可以完全访问父类的属性和函数，因为在 Dart 中并没有私有、公有的概念，下划线<code>_</code>的仅仅是一种约定。</p>\n</li>\n<li><p>除了上面的内容，<code>with</code>还可以与之搭配关键字<code>on</code>，表示要进行 mixin 的类必须先 “implements” 被 mixin 的类声明中 on 关键字后面的类，否则编译失败</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> fromD();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mixin C on D &#123;</span><br><span class=\"line\">  fromC() =&gt; <span class=\"string\">'C'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  下面的代码将编译失败，因为 F 要 mixin C 必须先“implements” D</span></span><br><span class=\"line\"><span class=\"comment\">  但是 implements 关键字又必须在 with 的后面，所以只能定义一个新的类 E</span></span><br><span class=\"line\"><span class=\"comment\">  使 E implements D，F 再 extends E，才能 mixin C</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span> <span class=\"title\">with</span> <span class=\"title\">C</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>正确的做法</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span> <span class=\"keyword\">implements</span> <span class=\"title\">D</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> fromD() =&gt; <span class=\"string\">'E'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span> <span class=\"keyword\">extends</span> <span class=\"title\">E</span> <span class=\"title\">with</span> <span class=\"title\">C</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Dart 中每个类都是一个隐式地接口。<code>implements</code>一个类之后，必须<code>override</code>所有的方法和成员变量</p>\n</li>\n</ul>"},{"title":"Java 排序算法","date":"2019-03-15T10:36:47.000Z","mathjax":true,"_content":"\n排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。<!--more-->\n\n## 稳定性\n对于一个数组`a {6,2,4,6,1}`，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种\n\n|  1   |  2   |  4   |    6    |    6    |\n| :--: | :--: | :--: | :-----: | :-----: |\n| a[4] | a[1] | a[2] | <b>a[0] | <b>a[3] |\n| a[4] | a[1] | a[2] | <b>a[3] | <B>a[0] |\n\n如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法\n> 冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等\n\n否则，属于不稳定的排序算法\n> 选择排序，希尔排序，堆排序，快速排序等\n\n## 冒泡排序\n```Java\n/**\n * 冒泡排序，O(n^2)\n * 每一次内层循环中，两两比较，将较大的数放到后面\n * \n * @param a 待排序数据\n */\npublic static void bubbleSort(int[] a) {\n    int length = a.length;\n    int i = 0;\n    int temp;\n\n    for ( ; i < length - 1; i++) {\n        int j = 0;\n\n        for ( ; j < length - 1 - i; j++) {\n            if (a[j] > a[j+1]) {\n                temp = a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序\n\n### 直接插入排序\n```Java\n/**\n * 直接插入排序，O(n^2)\n * i从第一个元素开始，默认i前面的序列已经排好序\n * 取出i的下一个元素，从后往前比较，找到适合的位置就插入\n *\n * @param a 待排序序列\n */\npublic static void insertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n\n        for (int j = i; j > 0; j--) {\n            if (a[j] < a[j-1]) {\n                a[j] = a[j-1];\n                a[j-1] = temp;\n            }\n        }\n    }\n}\n```\n\n### 折半插入排序\n```Java\n/**\n * 折半插入排序，O(n^2)\n * 对直接插入排序算法进行了改进\n * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要\n * 折半插入排序则使用了折半查找/二分查找\n *\n * Arrays类的binarySearch()方法便是折半查找的实现\n *\n * @param a 待排序序列\n */\npublic static void binaryInsertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n        int low = 0;\n        int high = i-1;\n        while (low <= high) {\n            int middle = (low+high) / 2;\n            if (a[middle] < temp) {\n                low = middle+1;\n            } else {\n                high = middle-1;\n            }\n        }\n        for(int j = i-1; j >= low; j--) {\n             //元素后移，为插入temp做准备\n            a[j+1] = a[j];\n        }\n        a[low] = temp;\n    }\n}\n```\n### 希尔排序\n```Java\n/**\n * 希尔排序，也称 递减增量排序，O(n*(logn)^2)\n * 对于n个元素的序列，假设增量为increment\n * 从第一个元素开始，每隔increment取一个元素组成一个子序列\n * 对每个子序列进行直接插入排序，increment /= 2\n * 重复上述过程，直至increment为1\n *\n * @param a 待排序序列\n */\npublic static void shellSort(int[] a) {\n    int length = a.length;\n\n    // increment为增量，每次减为原来的一半，直至为1\n    for (int increment = length / 2; increment > 0; increment /= 2) {\n\n        // 共increment个组，对每一组都执行直接插入排序\n        for (int i = 0; i < increment; i++) {\n\n            for (int j = i + increment; j < length; j += increment) {\n\n                // 如果a[j] < a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。\n                if (a[j] < a[j - increment]) {\n\n                    int temp = a[j];\n                    int k = j - increment;\n                    while (k >= 0 && a[k] > temp) {\n                        a[k + increment] = a[k];\n                        k -= increment;\n                    }\n                    a[k + increment] = temp;\n                }\n            }\n        }\n    }\n}\n```\n## 桶排序（基数排序）\n```Java\n/**\n * 基数排序，也称桶排序，O(d(k+n))\n * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。\n * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n *\n * @param a 待排序数组\n * @param d 位数，如果最大数为9527，则d为10000，如果为7，则d为10\n */\npublic static void radixSort(int[] a,int d) {\n    int n = 1;  //代表位数对应的数：1,10,100...\n    int k = 0;  //保存每一位排序后的结果用于下一位的排序输入\n    int length = a.length;\n\n    int[][] bucket = new int[10][length];  //排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n    int[] order = new int[length];  //用于保存每个桶里有多少个数字\n\n    while(n < d) {\n        for(int num : a) { //将数组array里的每个数字放在相应的桶里\n            int digit = (num/n)%10;\n            bucket[digit][order[digit]] = num;\n            order[digit]++;\n        }\n        int i = 0;\n        for( ; i<length; i++) { //将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            if(order[i] != 0) {  //这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                int j = 0;\n                for( ; j < order[i]; j++) {\n                    a[k] = bucket[i][j];\n                    k++;\n                }\n            }\n            order[i]=0;  //将桶里计数器置0，用于下一次位排序\n        }\n        n *= 10;\n        k = 0;  //将k置0，用于下一轮保存位排序结果\n    }\n}\n```\n\n## 归并排序\n```Java\n/**\n * 归并排序，O(nlog(n))\n * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1\n * 然合并以上序列\n *\n * @param array\n * @param left\n * @param right\n */\npublic static void mergeSort(int[] array, int left, int right) {\n   if (left < right) {\n       int center = (left + right) / 2;\n       mergeSort(array, left, center);\n       mergeSort(array, center+1, right);\n       merge(array, left, center, right);\n   }\n}\n\nstatic void merge(int[] array, int low, int mid, int high) {\n    int[] tempArray = new int[high - low + 1];\n    int temp = 0;\n    int i = low;\n    int j = mid + 1;\n\n    while (i <= mid && j <= high) {\n        if (array[i] <= array[j]) {\n            tempArray[temp++] = array[i++];\n        } else {\n            tempArray[temp++] = array[j++];\n        }\n    }\n\n    while (i <= mid) {  //此时右边已到底\n        tempArray[temp++] = array[i++];\n    }\n    while (j <= high) { //此时左边已到底\n        tempArray[temp++] = array[j++];\n    }\n    //将新数组中的数 覆盖原数组low之后的数据\n    for (int k = 0; k < tempArray.length; k++) {\n        array[k+low] = tempArray[k];\n    }\n}\n```\n\n## 选择排序\n```Java\n/**\n  * 选择排序，O(n^2)\n  * 遍历整个序列，将最小的数放在最前面\n  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程\n  *\n  * @param a 待排序序列\n  */\n public static void selectSort(int[] a){\n     int length = a.length;\n     int i = 0;\n\n     for( ; i < length; i++){  //外层循环\n         int temp = a[i];\n         int position = i;\n         int j = i+1;\n\n         for( ; j < length; j++) {  //往后遍历，找到最小的值以及其位置\n             if(a[j] < temp) {\n                 temp = a[j];\n                 position = j;\n             }\n         }\n         a[position]=a[i];  //进行交换\n         a[i] = temp;\n     }\n \n```\n\n## 快速排序\n```Java\n/**\n * 快速排序，O(nlog(n))\n * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分\n * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序\n *\n * @param a 待排序序列\n * @param start 序列开始值\n * @param end 序列结束值\n */\npublic static void quickSort(int[] a, int start, int end) {\n    int baseNum = a[start];\n    int temp;\n    int left = start;\n    int right = end;\n    do {\n        while (a[left] < baseNum && left < end) {\n            left++;\n        }\n        while (a[right] > baseNum && right > start) {\n            right--;\n        }\n\n        if (left <= right) {  //左边出现大于基准值或者右边出现小于基准值，且left<=right\n            temp = a[left];\n            a[left] = a[right];\n            a[right] = temp;\n            left++; right--;\n        }\n    } while (left <= right);\n\n    if (start < right) {\n        quickSort(a, start, right);\n    }\n    if (end > left) {\n        quickSort(a, left, end);\n    }\n}\n```\n\n## 二叉树排序\n通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$\n近似于折半查找。\n\n如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$\n```Java\npublic class BinarySortTree {\n    static class Node {\n        private Comparable data;\n        private Node left;\n        private Node right;\n\n        public Node(Comparable data) {\n            this.data = data;\n        }\n\n        public void addNode(Node newNode) {\n            if (newNode.data.compareTo(this.data) < 0) {\n                if (left == null) {\n                    left = newNode;\n                } else {\n                    left.addNode(newNode);\n                }\n            } else {\n                if (right == null) {\n                    right = newNode;\n                } else {\n                    right.addNode(newNode);\n                }\n            }\n        }\n\n        public void printNode() {   //中序遍历\n            if (left != null) {\n                left.printNode();\n            }\n            System.out.println(this.data);\n            if (right != null) {\n                right.printNode();\n            }\n        }\n    }\n\n    private Node root;\n\n    public void add(Comparable data) {  //向二叉树中插入元素\n        Node node = new Node(data);\n        if (root == null) {\n            root = node;\n        } else {\n            root.addNode(node);\n        }\n    }\n\n    public void print() {\n        root.printNode();\n    }\n}\n```\n调用如下\n```Java\npublic static void main(String[] args) {\n    int[] a = {12,0,34,5,2,8,456};\n    BinarySortTree tree = new BinarySortTree();\n    for (int i : a) {            \n        tree.add(i);\n    }\n    tree.print();\n}\n```\n\n## 查找算法\n\n### 二分查找\n只能对有序序列进行查找\n```Java\npublic static int binarySearch(int[] array, int low, int high, int target) {\n    if (low > high) return -1;\n    int mid = low + (high - low) / 2;\n    \n    if (array[mid] > target)\n        return binarySearch(array, low, mid - 1, target);\n\n    if (array[mid] < target)\n        return binarySearch(array, mid + 1, high, target);\n\n    return mid;\n}\n\npublic static int bSearchWithoutRecursion(int a[], int key) {\n    int low = 0;\n    int high = a.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (a[mid] > key)\n            high = mid - 1;\n        else if (a[mid] < key)\n            low = mid + 1;\n        else\n            return mid;\n    }\n    return -1;\n}\n```\n\n### 顺序查找\n实现较简单，略过\n\n### 二叉树查找\n可以通过构建一个二叉搜索树实现","source":"_posts/Java-排序算法.md","raw":"---\ntitle: Java 排序算法\ndate: 2019-03-15 18:36:47\nmathjax: true\ntags:\n- 算法\n- Java\ncategories:\n- 算法\n---\n\n排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。<!--more-->\n\n## 稳定性\n对于一个数组`a {6,2,4,6,1}`，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种\n\n|  1   |  2   |  4   |    6    |    6    |\n| :--: | :--: | :--: | :-----: | :-----: |\n| a[4] | a[1] | a[2] | <b>a[0] | <b>a[3] |\n| a[4] | a[1] | a[2] | <b>a[3] | <B>a[0] |\n\n如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法\n> 冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等\n\n否则，属于不稳定的排序算法\n> 选择排序，希尔排序，堆排序，快速排序等\n\n## 冒泡排序\n```Java\n/**\n * 冒泡排序，O(n^2)\n * 每一次内层循环中，两两比较，将较大的数放到后面\n * \n * @param a 待排序数据\n */\npublic static void bubbleSort(int[] a) {\n    int length = a.length;\n    int i = 0;\n    int temp;\n\n    for ( ; i < length - 1; i++) {\n        int j = 0;\n\n        for ( ; j < length - 1 - i; j++) {\n            if (a[j] > a[j+1]) {\n                temp = a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序\n\n### 直接插入排序\n```Java\n/**\n * 直接插入排序，O(n^2)\n * i从第一个元素开始，默认i前面的序列已经排好序\n * 取出i的下一个元素，从后往前比较，找到适合的位置就插入\n *\n * @param a 待排序序列\n */\npublic static void insertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n\n        for (int j = i; j > 0; j--) {\n            if (a[j] < a[j-1]) {\n                a[j] = a[j-1];\n                a[j-1] = temp;\n            }\n        }\n    }\n}\n```\n\n### 折半插入排序\n```Java\n/**\n * 折半插入排序，O(n^2)\n * 对直接插入排序算法进行了改进\n * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要\n * 折半插入排序则使用了折半查找/二分查找\n *\n * Arrays类的binarySearch()方法便是折半查找的实现\n *\n * @param a 待排序序列\n */\npublic static void binaryInsertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n        int low = 0;\n        int high = i-1;\n        while (low <= high) {\n            int middle = (low+high) / 2;\n            if (a[middle] < temp) {\n                low = middle+1;\n            } else {\n                high = middle-1;\n            }\n        }\n        for(int j = i-1; j >= low; j--) {\n             //元素后移，为插入temp做准备\n            a[j+1] = a[j];\n        }\n        a[low] = temp;\n    }\n}\n```\n### 希尔排序\n```Java\n/**\n * 希尔排序，也称 递减增量排序，O(n*(logn)^2)\n * 对于n个元素的序列，假设增量为increment\n * 从第一个元素开始，每隔increment取一个元素组成一个子序列\n * 对每个子序列进行直接插入排序，increment /= 2\n * 重复上述过程，直至increment为1\n *\n * @param a 待排序序列\n */\npublic static void shellSort(int[] a) {\n    int length = a.length;\n\n    // increment为增量，每次减为原来的一半，直至为1\n    for (int increment = length / 2; increment > 0; increment /= 2) {\n\n        // 共increment个组，对每一组都执行直接插入排序\n        for (int i = 0; i < increment; i++) {\n\n            for (int j = i + increment; j < length; j += increment) {\n\n                // 如果a[j] < a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。\n                if (a[j] < a[j - increment]) {\n\n                    int temp = a[j];\n                    int k = j - increment;\n                    while (k >= 0 && a[k] > temp) {\n                        a[k + increment] = a[k];\n                        k -= increment;\n                    }\n                    a[k + increment] = temp;\n                }\n            }\n        }\n    }\n}\n```\n## 桶排序（基数排序）\n```Java\n/**\n * 基数排序，也称桶排序，O(d(k+n))\n * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。\n * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n *\n * @param a 待排序数组\n * @param d 位数，如果最大数为9527，则d为10000，如果为7，则d为10\n */\npublic static void radixSort(int[] a,int d) {\n    int n = 1;  //代表位数对应的数：1,10,100...\n    int k = 0;  //保存每一位排序后的结果用于下一位的排序输入\n    int length = a.length;\n\n    int[][] bucket = new int[10][length];  //排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n    int[] order = new int[length];  //用于保存每个桶里有多少个数字\n\n    while(n < d) {\n        for(int num : a) { //将数组array里的每个数字放在相应的桶里\n            int digit = (num/n)%10;\n            bucket[digit][order[digit]] = num;\n            order[digit]++;\n        }\n        int i = 0;\n        for( ; i<length; i++) { //将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            if(order[i] != 0) {  //这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                int j = 0;\n                for( ; j < order[i]; j++) {\n                    a[k] = bucket[i][j];\n                    k++;\n                }\n            }\n            order[i]=0;  //将桶里计数器置0，用于下一次位排序\n        }\n        n *= 10;\n        k = 0;  //将k置0，用于下一轮保存位排序结果\n    }\n}\n```\n\n## 归并排序\n```Java\n/**\n * 归并排序，O(nlog(n))\n * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1\n * 然合并以上序列\n *\n * @param array\n * @param left\n * @param right\n */\npublic static void mergeSort(int[] array, int left, int right) {\n   if (left < right) {\n       int center = (left + right) / 2;\n       mergeSort(array, left, center);\n       mergeSort(array, center+1, right);\n       merge(array, left, center, right);\n   }\n}\n\nstatic void merge(int[] array, int low, int mid, int high) {\n    int[] tempArray = new int[high - low + 1];\n    int temp = 0;\n    int i = low;\n    int j = mid + 1;\n\n    while (i <= mid && j <= high) {\n        if (array[i] <= array[j]) {\n            tempArray[temp++] = array[i++];\n        } else {\n            tempArray[temp++] = array[j++];\n        }\n    }\n\n    while (i <= mid) {  //此时右边已到底\n        tempArray[temp++] = array[i++];\n    }\n    while (j <= high) { //此时左边已到底\n        tempArray[temp++] = array[j++];\n    }\n    //将新数组中的数 覆盖原数组low之后的数据\n    for (int k = 0; k < tempArray.length; k++) {\n        array[k+low] = tempArray[k];\n    }\n}\n```\n\n## 选择排序\n```Java\n/**\n  * 选择排序，O(n^2)\n  * 遍历整个序列，将最小的数放在最前面\n  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程\n  *\n  * @param a 待排序序列\n  */\n public static void selectSort(int[] a){\n     int length = a.length;\n     int i = 0;\n\n     for( ; i < length; i++){  //外层循环\n         int temp = a[i];\n         int position = i;\n         int j = i+1;\n\n         for( ; j < length; j++) {  //往后遍历，找到最小的值以及其位置\n             if(a[j] < temp) {\n                 temp = a[j];\n                 position = j;\n             }\n         }\n         a[position]=a[i];  //进行交换\n         a[i] = temp;\n     }\n \n```\n\n## 快速排序\n```Java\n/**\n * 快速排序，O(nlog(n))\n * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分\n * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序\n *\n * @param a 待排序序列\n * @param start 序列开始值\n * @param end 序列结束值\n */\npublic static void quickSort(int[] a, int start, int end) {\n    int baseNum = a[start];\n    int temp;\n    int left = start;\n    int right = end;\n    do {\n        while (a[left] < baseNum && left < end) {\n            left++;\n        }\n        while (a[right] > baseNum && right > start) {\n            right--;\n        }\n\n        if (left <= right) {  //左边出现大于基准值或者右边出现小于基准值，且left<=right\n            temp = a[left];\n            a[left] = a[right];\n            a[right] = temp;\n            left++; right--;\n        }\n    } while (left <= right);\n\n    if (start < right) {\n        quickSort(a, start, right);\n    }\n    if (end > left) {\n        quickSort(a, left, end);\n    }\n}\n```\n\n## 二叉树排序\n通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$\n近似于折半查找。\n\n如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$\n```Java\npublic class BinarySortTree {\n    static class Node {\n        private Comparable data;\n        private Node left;\n        private Node right;\n\n        public Node(Comparable data) {\n            this.data = data;\n        }\n\n        public void addNode(Node newNode) {\n            if (newNode.data.compareTo(this.data) < 0) {\n                if (left == null) {\n                    left = newNode;\n                } else {\n                    left.addNode(newNode);\n                }\n            } else {\n                if (right == null) {\n                    right = newNode;\n                } else {\n                    right.addNode(newNode);\n                }\n            }\n        }\n\n        public void printNode() {   //中序遍历\n            if (left != null) {\n                left.printNode();\n            }\n            System.out.println(this.data);\n            if (right != null) {\n                right.printNode();\n            }\n        }\n    }\n\n    private Node root;\n\n    public void add(Comparable data) {  //向二叉树中插入元素\n        Node node = new Node(data);\n        if (root == null) {\n            root = node;\n        } else {\n            root.addNode(node);\n        }\n    }\n\n    public void print() {\n        root.printNode();\n    }\n}\n```\n调用如下\n```Java\npublic static void main(String[] args) {\n    int[] a = {12,0,34,5,2,8,456};\n    BinarySortTree tree = new BinarySortTree();\n    for (int i : a) {            \n        tree.add(i);\n    }\n    tree.print();\n}\n```\n\n## 查找算法\n\n### 二分查找\n只能对有序序列进行查找\n```Java\npublic static int binarySearch(int[] array, int low, int high, int target) {\n    if (low > high) return -1;\n    int mid = low + (high - low) / 2;\n    \n    if (array[mid] > target)\n        return binarySearch(array, low, mid - 1, target);\n\n    if (array[mid] < target)\n        return binarySearch(array, mid + 1, high, target);\n\n    return mid;\n}\n\npublic static int bSearchWithoutRecursion(int a[], int key) {\n    int low = 0;\n    int high = a.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (a[mid] > key)\n            high = mid - 1;\n        else if (a[mid] < key)\n            low = mid + 1;\n        else\n            return mid;\n    }\n    return -1;\n}\n```\n\n### 顺序查找\n实现较简单，略过\n\n### 二叉树查找\n可以通过构建一个二叉搜索树实现","slug":"Java-排序算法","published":1,"updated":"2019-06-02T05:01:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqwd001py4upte679ejp","content":"<p>排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。<a id=\"more\"></a></p>\n<h2 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h2><p>对于一个数组<code>a {6,2,4,6,1}</code>，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n</tr>\n</tbody>\n</table>\n<p>如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法</p>\n<blockquote>\n<p>冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等</p>\n</blockquote>\n<p>否则，属于不稳定的排序算法</p>\n<blockquote>\n<p>选择排序，希尔排序，堆排序，快速排序等</p>\n</blockquote>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 冒泡排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 每一次内层循环中，两两比较，将较大的数放到后面</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; i < length - <span class=\"number\">1</span>; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; j < length - <span class=\"number\">1</span> - i; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] > a[j+<span class=\"number\">1</span>]) {</span><br><span class=\"line\">                temp = a[j];</span><br><span class=\"line\">                a[j] = a[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序</p>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * i从第一个元素开始，默认i前面的序列已经排好序</span></span><br><span class=\"line\"><span class=\"comment\"> * 取出i的下一个元素，从后往前比较，找到适合的位置就插入</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < length; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j > <span class=\"number\">0</span>; j--) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] < a[j-<span class=\"number\">1</span>]) {</span><br><span class=\"line\">                a[j] = a[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对直接插入排序算法进行了改进</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序则使用了折半查找/二分查找</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Arrays类的binarySearch()方法便是折半查找的实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">binaryInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < length; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = i-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low <= high) {</span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (low+high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[middle] < temp) {</span><br><span class=\"line\">                low = middle+<span class=\"number\">1</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                high = middle-<span class=\"number\">1</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i-<span class=\"number\">1</span>; j >= low; j--) {</span><br><span class=\"line\">             <span class=\"comment\">//元素后移，为插入temp做准备</span></span><br><span class=\"line\">            a[j+<span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        a[low] = temp;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 希尔排序，也称 递减增量排序，O(n*(logn)^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于n个元素的序列，假设增量为increment</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第一个元素开始，每隔increment取一个元素组成一个子序列</span></span><br><span class=\"line\"><span class=\"comment\"> * 对每个子序列进行直接插入排序，increment /= 2</span></span><br><span class=\"line\"><span class=\"comment\"> * 重复上述过程，直至increment为1</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increment为增量，每次减为原来的一半，直至为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> increment = length / <span class=\"number\">2</span>; increment > <span class=\"number\">0</span>; increment /= <span class=\"number\">2</span>) {</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 共increment个组，对每一组都执行直接插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < increment; i++) {</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + increment; j < length; j += increment) {</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果a[j] < a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[j] < a[j - increment]) {</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = a[j];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> k = j - increment;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (k >= <span class=\"number\">0</span> && a[k] > temp) {</span><br><span class=\"line\">                        a[k + increment] = a[k];</span><br><span class=\"line\">                        k -= increment;</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                    a[k + increment] = temp;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"桶排序（基数排序）\"><a href=\"#桶排序（基数排序）\" class=\"headerlink\" title=\"桶排序（基数排序）\"></a>桶排序（基数排序）</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基数排序，也称桶排序，O(d(k+n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。</span></span><br><span class=\"line\"><span class=\"comment\"> * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> d 位数，如果最大数为9527，则d为10000，如果为7，则d为10</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a,<span class=\"keyword\">int</span> d)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">1</span>;  <span class=\"comment\">//代表位数对应的数：1,10,100...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;  <span class=\"comment\">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] bucket = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][length];  <span class=\"comment\">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] order = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];  <span class=\"comment\">//用于保存每个桶里有多少个数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n < d) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : a) { <span class=\"comment\">//将数组array里的每个数字放在相应的桶里</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> digit = (num/n)%<span class=\"number\">10</span>;</span><br><span class=\"line\">            bucket[digit][order[digit]] = num;</span><br><span class=\"line\">            order[digit]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( ; i<length; i++) { <span class=\"comment\">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(order[i] != <span class=\"number\">0</span>) {  <span class=\"comment\">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>( ; j < order[i]; j++) {</span><br><span class=\"line\">                    a[k] = bucket[i][j];</span><br><span class=\"line\">                    k++;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">            order[i]=<span class=\"number\">0</span>;  <span class=\"comment\">//将桶里计数器置0，用于下一次位排序</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">        n *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        k = <span class=\"number\">0</span>;  <span class=\"comment\">//将k置0，用于下一轮保存位排序结果</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 归并排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1</span></span><br><span class=\"line\"><span class=\"comment\"> * 然合并以上序列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> left</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> right</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>{</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (left < right) {</span><br><span class=\"line\">       <span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">       mergeSort(array, left, center);</span><br><span class=\"line\">       mergeSort(array, center+<span class=\"number\">1</span>, right);</span><br><span class=\"line\">       merge(array, left, center, right);</span><br><span class=\"line\">   }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> high)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] tempArray = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[high - low + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i <= mid && j <= high) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] <= array[j]) {</span><br><span class=\"line\">            tempArray[temp++] = array[i++];</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            tempArray[temp++] = array[j++];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i <= mid) {  <span class=\"comment\">//此时右边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[i++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j <= high) { <span class=\"comment\">//此时左边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[j++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//将新数组中的数 覆盖原数组low之后的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k < tempArray.length; k++) {</span><br><span class=\"line\">        array[k+low] = tempArray[k];</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 选择排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历整个序列，将最小的数放在最前面</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span></span>{</span><br><span class=\"line\">     <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>( ; i < length; i++){  <span class=\"comment\">//外层循环</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">         <span class=\"keyword\">int</span> position = i;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span>( ; j < length; j++) {  <span class=\"comment\">//往后遍历，找到最小的值以及其位置</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span>(a[j] < temp) {</span><br><span class=\"line\">                 temp = a[j];</span><br><span class=\"line\">                 position = j;</span><br><span class=\"line\">             }</span><br><span class=\"line\">         }</span><br><span class=\"line\">         a[position]=a[i];  <span class=\"comment\">//进行交换</span></span><br><span class=\"line\">         a[i] = temp;</span><br><span class=\"line\">     }</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分</span></span><br><span class=\"line\"><span class=\"comment\"> * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 序列开始值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end 序列结束值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> baseNum = a[start];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = end;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[left] < baseNum && left < end) {</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[right] > baseNum && right > start) {</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left <= right) {  <span class=\"comment\">//左边出现大于基准值或者右边出现小于基准值，且left<=right</span></span><br><span class=\"line\">            temp = a[left];</span><br><span class=\"line\">            a[left] = a[right];</span><br><span class=\"line\">            a[right] = temp;</span><br><span class=\"line\">            left++; right--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    } <span class=\"keyword\">while</span> (left <= right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start < right) {</span><br><span class=\"line\">        quickSort(a, start, right);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end > left) {</span><br><span class=\"line\">        quickSort(a, left, end);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"二叉树排序\"><a href=\"#二叉树排序\" class=\"headerlink\" title=\"二叉树排序\"></a>二叉树排序</h2><p>通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$<br>近似于折半查找。</p>\n<p>如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySortTree</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Comparable data;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node left;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(Comparable data)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(Node newNode)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newNode.data.compareTo(<span class=\"keyword\">this</span>.data) < <span class=\"number\">0</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                    left = newNode;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                    left.addNode(newNode);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                    right = newNode;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                    right.addNode(newNode);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printNode</span><span class=\"params\">()</span> </span>{   <span class=\"comment\">//中序遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                left.printNode();</span><br><span class=\"line\">            }</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                right.printNode();</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Comparable data)</span> </span>{  <span class=\"comment\">//向二叉树中插入元素</span></span><br><span class=\"line\">        Node node = <span class=\"keyword\">new</span> Node(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            root = node;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            root.addNode(node);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        root.printNode();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>调用如下<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = {<span class=\"number\">12</span>,<span class=\"number\">0</span>,<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">456</span>};</span><br><span class=\"line\">    BinarySortTree tree = <span class=\"keyword\">new</span> BinarySortTree();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : a) {            </span><br><span class=\"line\">        tree.add(i);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    tree.print();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"查找算法\"><a href=\"#查找算法\" class=\"headerlink\" title=\"查找算法\"></a>查找算法</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>只能对有序序列进行查找<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high, <span class=\"keyword\">int</span> target)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low > high) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] > target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, low, mid - <span class=\"number\">1</span>, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] < target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, mid + <span class=\"number\">1</span>, high, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bSearchWithoutRecursion</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> key)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = a.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low <= high) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[mid] > key)</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[mid] < key)</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"顺序查找\"><a href=\"#顺序查找\" class=\"headerlink\" title=\"顺序查找\"></a>顺序查找</h3><p>实现较简单，略过</p>\n<h3 id=\"二叉树查找\"><a href=\"#二叉树查找\" class=\"headerlink\" title=\"二叉树查找\"></a>二叉树查找</h3><p>可以通过构建一个二叉搜索树实现</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":9242,"excerpt":"<p>排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。</p>","more":"<p></p>\n<h2 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h2><p>对于一个数组<code>a {6,2,4,6,1}</code>，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n</tr>\n</tbody>\n</table>\n<p>如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法</p>\n<blockquote>\n<p>冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等</p>\n</blockquote>\n<p>否则，属于不稳定的排序算法</p>\n<blockquote>\n<p>选择排序，希尔排序，堆排序，快速排序等</p>\n</blockquote>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 冒泡排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 每一次内层循环中，两两比较，将较大的数放到后面</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &gt; a[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                temp = a[j];</span><br><span class=\"line\">                a[j] = a[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序</p>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * i从第一个元素开始，默认i前面的序列已经排好序</span></span><br><span class=\"line\"><span class=\"comment\"> * 取出i的下一个元素，从后往前比较，找到适合的位置就插入</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &lt; a[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                a[j] = a[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对直接插入排序算法进行了改进</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序则使用了折半查找/二分查找</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Arrays类的binarySearch()方法便是折半查找的实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">binaryInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = i-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (low+high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[middle] &lt; temp) &#123;</span><br><span class=\"line\">                low = middle+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                high = middle-<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i-<span class=\"number\">1</span>; j &gt;= low; j--) &#123;</span><br><span class=\"line\">             <span class=\"comment\">//元素后移，为插入temp做准备</span></span><br><span class=\"line\">            a[j+<span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[low] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 希尔排序，也称 递减增量排序，O(n*(logn)^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于n个元素的序列，假设增量为increment</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第一个元素开始，每隔increment取一个元素组成一个子序列</span></span><br><span class=\"line\"><span class=\"comment\"> * 对每个子序列进行直接插入排序，increment /= 2</span></span><br><span class=\"line\"><span class=\"comment\"> * 重复上述过程，直至increment为1</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increment为增量，每次减为原来的一半，直至为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> increment = length / <span class=\"number\">2</span>; increment &gt; <span class=\"number\">0</span>; increment /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 共increment个组，对每一组都执行直接插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; increment; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + increment; j &lt; length; j += increment) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果a[j] &lt; a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[j] &lt; a[j - increment]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = a[j];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> k = j - increment;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span> &amp;&amp; a[k] &gt; temp) &#123;</span><br><span class=\"line\">                        a[k + increment] = a[k];</span><br><span class=\"line\">                        k -= increment;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    a[k + increment] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"桶排序（基数排序）\"><a href=\"#桶排序（基数排序）\" class=\"headerlink\" title=\"桶排序（基数排序）\"></a>桶排序（基数排序）</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基数排序，也称桶排序，O(d(k+n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。</span></span><br><span class=\"line\"><span class=\"comment\"> * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> d 位数，如果最大数为9527，则d为10000，如果为7，则d为10</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a,<span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">1</span>;  <span class=\"comment\">//代表位数对应的数：1,10,100...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;  <span class=\"comment\">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] bucket = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][length];  <span class=\"comment\">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] order = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];  <span class=\"comment\">//用于保存每个桶里有多少个数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &lt; d) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : a) &#123; <span class=\"comment\">//将数组array里的每个数字放在相应的桶里</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> digit = (num/n)%<span class=\"number\">10</span>;</span><br><span class=\"line\">            bucket[digit][order[digit]] = num;</span><br><span class=\"line\">            order[digit]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( ; i&lt;length; i++) &#123; <span class=\"comment\">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(order[i] != <span class=\"number\">0</span>) &#123;  <span class=\"comment\">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>( ; j &lt; order[i]; j++) &#123;</span><br><span class=\"line\">                    a[k] = bucket[i][j];</span><br><span class=\"line\">                    k++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            order[i]=<span class=\"number\">0</span>;  <span class=\"comment\">//将桶里计数器置0，用于下一次位排序</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        k = <span class=\"number\">0</span>;  <span class=\"comment\">//将k置0，用于下一轮保存位排序结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 归并排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1</span></span><br><span class=\"line\"><span class=\"comment\"> * 然合并以上序列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> left</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> right</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">       mergeSort(array, left, center);</span><br><span class=\"line\">       mergeSort(array, center+<span class=\"number\">1</span>, right);</span><br><span class=\"line\">       merge(array, left, center, right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] tempArray = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[high - low + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class=\"line\">            tempArray[temp++] = array[i++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tempArray[temp++] = array[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= mid) &#123;  <span class=\"comment\">//此时右边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt;= high) &#123; <span class=\"comment\">//此时左边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将新数组中的数 覆盖原数组low之后的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; tempArray.length; k++) &#123;</span><br><span class=\"line\">        array[k+low] = tempArray[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 选择排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历整个序列，将最小的数放在最前面</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>( ; i &lt; length; i++)&#123;  <span class=\"comment\">//外层循环</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">         <span class=\"keyword\">int</span> position = i;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span>( ; j &lt; length; j++) &#123;  <span class=\"comment\">//往后遍历，找到最小的值以及其位置</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span>(a[j] &lt; temp) &#123;</span><br><span class=\"line\">                 temp = a[j];</span><br><span class=\"line\">                 position = j;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         a[position]=a[i];  <span class=\"comment\">//进行交换</span></span><br><span class=\"line\">         a[i] = temp;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分</span></span><br><span class=\"line\"><span class=\"comment\"> * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 序列开始值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end 序列结束值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> baseNum = a[start];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = end;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[left] &lt; baseNum &amp;&amp; left &lt; end) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[right] &gt; baseNum &amp;&amp; right &gt; start) &#123;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= right) &#123;  <span class=\"comment\">//左边出现大于基准值或者右边出现小于基准值，且left&lt;=right</span></span><br><span class=\"line\">            temp = a[left];</span><br><span class=\"line\">            a[left] = a[right];</span><br><span class=\"line\">            a[right] = temp;</span><br><span class=\"line\">            left++; right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (left &lt;= right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; right) &#123;</span><br><span class=\"line\">        quickSort(a, start, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt; left) &#123;</span><br><span class=\"line\">        quickSort(a, left, end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树排序\"><a href=\"#二叉树排序\" class=\"headerlink\" title=\"二叉树排序\"></a>二叉树排序</h2><p>通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$<br>近似于折半查找。</p>\n<p>如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySortTree</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Comparable data;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node left;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(Comparable data)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(Node newNode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newNode.data.compareTo(<span class=\"keyword\">this</span>.data) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    left = newNode;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    left.addNode(newNode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    right = newNode;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    right.addNode(newNode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printNode</span><span class=\"params\">()</span> </span>&#123;   <span class=\"comment\">//中序遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                left.printNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                right.printNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Comparable data)</span> </span>&#123;  <span class=\"comment\">//向二叉树中插入元素</span></span><br><span class=\"line\">        Node node = <span class=\"keyword\">new</span> Node(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root = node;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root.addNode(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        root.printNode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用如下<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">12</span>,<span class=\"number\">0</span>,<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">    BinarySortTree tree = <span class=\"keyword\">new</span> BinarySortTree();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : a) &#123;            </span><br><span class=\"line\">        tree.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree.print();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"查找算法\"><a href=\"#查找算法\" class=\"headerlink\" title=\"查找算法\"></a>查找算法</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>只能对有序序列进行查找<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; high) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] &gt; target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, low, mid - <span class=\"number\">1</span>, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] &lt; target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, mid + <span class=\"number\">1</span>, high, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bSearchWithoutRecursion</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = a.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[mid] &gt; key)</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[mid] &lt; key)</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"顺序查找\"><a href=\"#顺序查找\" class=\"headerlink\" title=\"顺序查找\"></a>顺序查找</h3><p>实现较简单，略过</p>\n<h3 id=\"二叉树查找\"><a href=\"#二叉树查找\" class=\"headerlink\" title=\"二叉树查找\"></a>二叉树查找</h3><p>可以通过构建一个二叉搜索树实现</p>"},{"title":"Java设计模式：创建型模式","date":"2019-01-20T16:58:21.000Z","_content":"## 设计模式及其分类\n\n### 设计模式\n设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<!--more-->\n\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n- 对接口编程而不是对实现编程。\n- 优先使用对象组合而不是继承。\n\n### 分类\n<html>\n<table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr>\n</table>\n</html>\n\n可以使用一张图来展示设计模式之间的关系：\n\n![设计模式之间的关系](Java设计模式：创建型模式/设计模式之间的关系.jpg)\n\n### 六个原则：\n\n- 开闭原则（Open Close Principle）\n> 对扩展开放，对修改关闭。\n\n\n- 里氏代换原则（Liskov Substitution Principle）\n> 基类可以出现的任何地方，子类一定可以出现。\n\n- 依赖倒转原则（Dependence Inversion Principle）\n> 针对接口编程，依赖于抽象而不依赖于具体。\n\n- 接口隔离原则（Interface Segregation Principle）\n> 降低类之间的耦合度。\n\n- 迪米特法则，又称最少知道原则（Demeter Principle）\n> 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。\n\n- 合成复用原则（Composite Reuse Principle）\n> 尽量使用合成/聚合的方式，而不是使用继承。\n\n三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。\n\n## 创建者模式\n\n### 工厂模式\n创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。\n\n工厂模式可分为简单工厂、工厂方法、抽象工厂。\n\n#### 简单工厂\n工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。\n\n![简单工厂](Java设计模式：创建型模式/简单工厂.jpg)\n\n简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。\n\n#### 工厂方法\n工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。\n\n![工厂方法](Java设计模式：创建型模式/工厂方法.jpg)\n\n从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。\n\n#### 抽象工厂\n工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。\n\n![抽象工厂](Java设计模式：创建型模式/抽象工厂.jpg)\n\n\n以上介绍的三种工厂方法各有优缺点\n>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  \n\n### 单例模式\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。\n\n单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。\n\n#### 懒汉式\n支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n要支持多线程，可以给`getInstance`方法加锁`synchronized`，但是效率会变得很低。\n\n#### 饿汉式\n不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}  \n```\n\n#### 双检式\n双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。`getInstance` 的性能对应用程序很关键。\n\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n\n该方法使用了关键字`volatile`，关于该关键字的分析：[Java并发编程：volatile关键字解析\n](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n> 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。\nvolatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。\n\n\n#### 静态内部类式\n能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n与双检式方式一样利用`ClassLoder`机制来保证初始化`instance`时只有一个线程。\n关于 ClassLoader：[一看你就懂，超详细java中的ClassLoader详解](https://blog.csdn.net/briblue/article/details/54973413)\n\n```Java\npublic class Singleton {  \n\n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n} \n```\n\n相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用`getInstance`之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。\n\n#### 枚举\n实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。\n\n```Java\npublic enum Singleton {  \n\n    INSTANCE;  \n    public void whateverMethod() {}  \n    \n}  \n```\n\n### 建造者模式\n使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。\n\n```Java\npublic class Human {\n\n    private final String name;\n    private final int height;\n    private final int weight;\n\n    public static class Builder {\n        // 必要参数\n        private final int name;\n\n        // 可选参数\n        private int height = 170;\n        private int weight = 60;\n\n        public Builder(String name) {\n            this.name = name\n        }\n\n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n\n        public Builder weight(int weight) {\n            this.weight = weight;\n            return this;\n        }\n\n        public Human build() {\n            return new Human(this);\n        }\n    }\n\n    private Human(Builder builder) {\n        name = builder.name;\n        height = builder.height;\n        weight = builder.weight;\n    }\n\n    public static void main(String[] args) {\n        Human human = new Human.Builder(\"Jack\")\n                    .height(175)\n                    .weight(60)\n                    .build();\n    }\n}\n```\n\n### 原型模式\n当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。\n\nJava的`clone`方法便是使用了这种方法，关于该方法：[java对象克隆以及深拷贝和浅拷贝](https://www.cnblogs.com/xuanxufeng/p/6558330.html)\n\n```Java\npublic inteface Prototype {\n    Prototype clone();\n}\n\npublic class ConcretePrototype implement Prototype {\n    \n    public override Prototype clone() {\n        Prototype prototype = new ConcretePrototype();\n        return prototype;\n    }\n    \n    public static void main(String[] args) {\n        Prototype p1 = new ConcretePrototype();\n        Prototype p2 = p1.clone();\n    }\n}\n```","source":"_posts/Java设计模式：创建型模式.md","raw":"---\ntitle: Java设计模式：创建型模式\ndate: 2019-01-21 00:58:21\ntags:\n- 设计模式\n- Java\ncategories: \n- Java\n---\n## 设计模式及其分类\n\n### 设计模式\n设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<!--more-->\n\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n- 对接口编程而不是对实现编程。\n- 优先使用对象组合而不是继承。\n\n### 分类\n<html>\n<table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr>\n</table>\n</html>\n\n可以使用一张图来展示设计模式之间的关系：\n\n![设计模式之间的关系](Java设计模式：创建型模式/设计模式之间的关系.jpg)\n\n### 六个原则：\n\n- 开闭原则（Open Close Principle）\n> 对扩展开放，对修改关闭。\n\n\n- 里氏代换原则（Liskov Substitution Principle）\n> 基类可以出现的任何地方，子类一定可以出现。\n\n- 依赖倒转原则（Dependence Inversion Principle）\n> 针对接口编程，依赖于抽象而不依赖于具体。\n\n- 接口隔离原则（Interface Segregation Principle）\n> 降低类之间的耦合度。\n\n- 迪米特法则，又称最少知道原则（Demeter Principle）\n> 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。\n\n- 合成复用原则（Composite Reuse Principle）\n> 尽量使用合成/聚合的方式，而不是使用继承。\n\n三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。\n\n## 创建者模式\n\n### 工厂模式\n创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。\n\n工厂模式可分为简单工厂、工厂方法、抽象工厂。\n\n#### 简单工厂\n工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。\n\n![简单工厂](Java设计模式：创建型模式/简单工厂.jpg)\n\n简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。\n\n#### 工厂方法\n工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。\n\n![工厂方法](Java设计模式：创建型模式/工厂方法.jpg)\n\n从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。\n\n#### 抽象工厂\n工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。\n\n![抽象工厂](Java设计模式：创建型模式/抽象工厂.jpg)\n\n\n以上介绍的三种工厂方法各有优缺点\n>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  \n\n### 单例模式\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。\n\n单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。\n\n#### 懒汉式\n支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n要支持多线程，可以给`getInstance`方法加锁`synchronized`，但是效率会变得很低。\n\n#### 饿汉式\n不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}  \n```\n\n#### 双检式\n双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。`getInstance` 的性能对应用程序很关键。\n\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n\n该方法使用了关键字`volatile`，关于该关键字的分析：[Java并发编程：volatile关键字解析\n](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n> 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。\nvolatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。\n\n\n#### 静态内部类式\n能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n与双检式方式一样利用`ClassLoder`机制来保证初始化`instance`时只有一个线程。\n关于 ClassLoader：[一看你就懂，超详细java中的ClassLoader详解](https://blog.csdn.net/briblue/article/details/54973413)\n\n```Java\npublic class Singleton {  \n\n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n} \n```\n\n相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用`getInstance`之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。\n\n#### 枚举\n实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。\n\n```Java\npublic enum Singleton {  \n\n    INSTANCE;  \n    public void whateverMethod() {}  \n    \n}  \n```\n\n### 建造者模式\n使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。\n\n```Java\npublic class Human {\n\n    private final String name;\n    private final int height;\n    private final int weight;\n\n    public static class Builder {\n        // 必要参数\n        private final int name;\n\n        // 可选参数\n        private int height = 170;\n        private int weight = 60;\n\n        public Builder(String name) {\n            this.name = name\n        }\n\n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n\n        public Builder weight(int weight) {\n            this.weight = weight;\n            return this;\n        }\n\n        public Human build() {\n            return new Human(this);\n        }\n    }\n\n    private Human(Builder builder) {\n        name = builder.name;\n        height = builder.height;\n        weight = builder.weight;\n    }\n\n    public static void main(String[] args) {\n        Human human = new Human.Builder(\"Jack\")\n                    .height(175)\n                    .weight(60)\n                    .build();\n    }\n}\n```\n\n### 原型模式\n当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。\n\nJava的`clone`方法便是使用了这种方法，关于该方法：[java对象克隆以及深拷贝和浅拷贝](https://www.cnblogs.com/xuanxufeng/p/6558330.html)\n\n```Java\npublic inteface Prototype {\n    Prototype clone();\n}\n\npublic class ConcretePrototype implement Prototype {\n    \n    public override Prototype clone() {\n        Prototype prototype = new ConcretePrototype();\n        return prototype;\n    }\n    \n    public static void main(String[] args) {\n        Prototype p1 = new ConcretePrototype();\n        Prototype p2 = p1.clone();\n    }\n}\n```","slug":"Java设计模式：创建型模式","published":1,"updated":"2019-03-15T15:27:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqwi001ty4upusfyycyp","content":"<h2 id=\"设计模式及其分类\"><a href=\"#设计模式及其分类\" class=\"headerlink\" title=\"设计模式及其分类\"></a>设计模式及其分类</h2><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p>设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n<p>1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<a id=\"more\"></a></p>\n<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>\n<ul>\n<li>对接口编程而不是对实现编程。</li>\n<li>优先使用对象组合而不是继承。</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><br><br><table class=\"tg\"><tbody><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"></td><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr></tbody></table><br>\n\n<p>可以使用一张图来展示设计模式之间的关系：</p>\n<p><img src=\"/Java设计模式：创建型模式/设计模式之间的关系.jpg\" alt=\"设计模式之间的关系\"></p>\n<h3 id=\"六个原则：\"><a href=\"#六个原则：\" class=\"headerlink\" title=\"六个原则：\"></a>六个原则：</h3><ul>\n<li>开闭原则（Open Close Principle）<blockquote>\n<p>对扩展开放，对修改关闭。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>里氏代换原则（Liskov Substitution Principle）</p>\n<blockquote>\n<p>基类可以出现的任何地方，子类一定可以出现。</p>\n</blockquote>\n</li>\n<li><p>依赖倒转原则（Dependence Inversion Principle）</p>\n<blockquote>\n<p>针对接口编程，依赖于抽象而不依赖于具体。</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则（Interface Segregation Principle）</p>\n<blockquote>\n<p>降低类之间的耦合度。</p>\n</blockquote>\n</li>\n<li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p>\n<blockquote>\n<p>实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。</p>\n</blockquote>\n</li>\n<li><p>合成复用原则（Composite Reuse Principle）</p>\n<blockquote>\n<p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n</blockquote>\n</li>\n</ul>\n<p>三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。</p>\n<h2 id=\"创建者模式\"><a href=\"#创建者模式\" class=\"headerlink\" title=\"创建者模式\"></a>创建者模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。</p>\n<p>工厂模式可分为简单工厂、工厂方法、抽象工厂。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。</p>\n<p><img src=\"/Java设计模式：创建型模式/简单工厂.jpg\" alt=\"简单工厂\"></p>\n<p>简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。</p>\n<p><img src=\"/Java设计模式：创建型模式/工厂方法.jpg\" alt=\"工厂方法\"></p>\n<p>从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。</p>\n<p><img src=\"/Java设计模式：创建型模式/抽象工厂.jpg\" alt=\"抽象工厂\"></p>\n<p>以上介绍的三种工厂方法各有优缺点</p>\n<blockquote>\n<p>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  </p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。</p>\n<p>单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>{}  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>{  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) {  </span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        }  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>要支持多线程，可以给<code>getInstance</code>方法加锁<code>synchronized</code>，但是效率会变得很低。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>{}  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>{  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"双检式\"><a href=\"#双检式\" class=\"headerlink\" title=\"双检式\"></a>双检式</h4><p>双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。<code>getInstance</code> 的性能对应用程序很关键。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>{}  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>{  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) {  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) {  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) {  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                }  </span><br><span class=\"line\">            }  </span><br><span class=\"line\">        }  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该方法使用了关键字<code>volatile</code>，关于该关键字的分析：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：volatile关键字解析\n</a></p>\n<blockquote>\n<p>在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。<br>volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。</p>\n</blockquote>\n<h4 id=\"静态内部类式\"><a href=\"#静态内部类式\" class=\"headerlink\" title=\"静态内部类式\"></a>静态内部类式</h4><p>能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<p>与双检式方式一样利用<code>ClassLoder</code>机制来保证初始化<code>instance</code>时只有一个线程。<br>关于 ClassLoader：<a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener\">一看你就懂，超详细java中的ClassLoader详解</a></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>{  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>{}  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>{  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用<code>getInstance</code>之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton {  </span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>{}  </span><br><span class=\"line\">    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>{</span><br><span class=\"line\">        <span class=\"comment\">// 必要参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height = <span class=\"number\">170</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> weight = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String name)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">weight</span><span class=\"params\">(<span class=\"keyword\">int</span> weight)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Human <span class=\"title\">build</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Human(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Human</span><span class=\"params\">(Builder builder)</span> </span>{</span><br><span class=\"line\">        name = builder.name;</span><br><span class=\"line\">        height = builder.height;</span><br><span class=\"line\">        weight = builder.weight;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">        Human human = <span class=\"keyword\">new</span> Human.Builder(<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">                    .height(<span class=\"number\">175</span>)</span><br><span class=\"line\">                    .weight(<span class=\"number\">60</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。</p>\n<p>Java的<code>clone</code>方法便是使用了这种方法，关于该方法：<a href=\"https://www.cnblogs.com/xuanxufeng/p/6558330.html\" target=\"_blank\" rel=\"noopener\">java对象克隆以及深拷贝和浅拷贝</a></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> inteface Prototype {</span><br><span class=\"line\">    <span class=\"function\">Prototype <span class=\"title\">clone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"title\">implement</span> <span class=\"title\">Prototype</span> </span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override Prototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">        Prototype p1 = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        Prototype p2 = p1.clone();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":6136,"excerpt":"<h2 id=\"设计模式及其分类\"><a href=\"#设计模式及其分类\" class=\"headerlink\" title=\"设计模式及其分类\"></a>设计模式及其分类</h2><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p>设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n<p>1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。</p>","more":"<p></p>\n<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>\n<ul>\n<li>对接口编程而不是对实现编程。</li>\n<li>优先使用对象组合而不是继承。</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><html><br><table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"></td><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><br></table><br></html>\n\n<p>可以使用一张图来展示设计模式之间的关系：</p>\n<p><img src=\"/Java设计模式：创建型模式/设计模式之间的关系.jpg\" alt=\"设计模式之间的关系\"></p>\n<h3 id=\"六个原则：\"><a href=\"#六个原则：\" class=\"headerlink\" title=\"六个原则：\"></a>六个原则：</h3><ul>\n<li>开闭原则（Open Close Principle）<blockquote>\n<p>对扩展开放，对修改关闭。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>里氏代换原则（Liskov Substitution Principle）</p>\n<blockquote>\n<p>基类可以出现的任何地方，子类一定可以出现。</p>\n</blockquote>\n</li>\n<li><p>依赖倒转原则（Dependence Inversion Principle）</p>\n<blockquote>\n<p>针对接口编程，依赖于抽象而不依赖于具体。</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则（Interface Segregation Principle）</p>\n<blockquote>\n<p>降低类之间的耦合度。</p>\n</blockquote>\n</li>\n<li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p>\n<blockquote>\n<p>实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。</p>\n</blockquote>\n</li>\n<li><p>合成复用原则（Composite Reuse Principle）</p>\n<blockquote>\n<p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n</blockquote>\n</li>\n</ul>\n<p>三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。</p>\n<h2 id=\"创建者模式\"><a href=\"#创建者模式\" class=\"headerlink\" title=\"创建者模式\"></a>创建者模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。</p>\n<p>工厂模式可分为简单工厂、工厂方法、抽象工厂。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。</p>\n<p><img src=\"/Java设计模式：创建型模式/简单工厂.jpg\" alt=\"简单工厂\"></p>\n<p>简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。</p>\n<p><img src=\"/Java设计模式：创建型模式/工厂方法.jpg\" alt=\"工厂方法\"></p>\n<p>从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。</p>\n<p><img src=\"/Java设计模式：创建型模式/抽象工厂.jpg\" alt=\"抽象工厂\"></p>\n<p>以上介绍的三种工厂方法各有优缺点</p>\n<blockquote>\n<p>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  </p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。</p>\n<p>单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要支持多线程，可以给<code>getInstance</code>方法加锁<code>synchronized</code>，但是效率会变得很低。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双检式\"><a href=\"#双检式\" class=\"headerlink\" title=\"双检式\"></a>双检式</h4><p>双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。<code>getInstance</code> 的性能对应用程序很关键。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法使用了关键字<code>volatile</code>，关于该关键字的分析：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：volatile关键字解析\n</a></p>\n<blockquote>\n<p>在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。<br>volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。</p>\n</blockquote>\n<h4 id=\"静态内部类式\"><a href=\"#静态内部类式\" class=\"headerlink\" title=\"静态内部类式\"></a>静态内部类式</h4><p>能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<p>与双检式方式一样利用<code>ClassLoder</code>机制来保证初始化<code>instance</code>时只有一个线程。<br>关于 ClassLoader：<a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener\">一看你就懂，超详细java中的ClassLoader详解</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用<code>getInstance</code>之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 必要参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height = <span class=\"number\">170</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> weight = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">weight</span><span class=\"params\">(<span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Human <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Human(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Human</span><span class=\"params\">(Builder builder)</span> </span>&#123;</span><br><span class=\"line\">        name = builder.name;</span><br><span class=\"line\">        height = builder.height;</span><br><span class=\"line\">        weight = builder.weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human human = <span class=\"keyword\">new</span> Human.Builder(<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">                    .height(<span class=\"number\">175</span>)</span><br><span class=\"line\">                    .weight(<span class=\"number\">60</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。</p>\n<p>Java的<code>clone</code>方法便是使用了这种方法，关于该方法：<a href=\"https://www.cnblogs.com/xuanxufeng/p/6558330.html\" target=\"_blank\" rel=\"noopener\">java对象克隆以及深拷贝和浅拷贝</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> inteface Prototype &#123;</span><br><span class=\"line\">    <span class=\"function\">Prototype <span class=\"title\">clone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"title\">implement</span> <span class=\"title\">Prototype</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override Prototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Prototype p1 = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        Prototype p2 = p1.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java设计模式：行为型模式","date":"2019-01-20T16:57:00.000Z","_content":"\n## 责任链模式\n责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<!--more-->\n\n创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。\n\n```Java\nabstract class AbstractLogger {\n    public static int INFO = 1;\n    public static int DEBUG = 2;\n    public static int ERROR = 3;\n\n    protected int level;\n\n    //责任链中的下一个元素\n    protected AbstractLogger nextLogger;\n\n    public void setNextLogger(AbstractLogger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    public void logMessage(int level, String message) {\n        if (this.level <= level) {\n            write(message);\n        }\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    abstract protected void write(String message);\n}\n```\n在 DebugLogger 中\n```Java\nclass DebugLogger extends AbstractLogger {\n\n    public DebugLogger() {\n        super();\n        level = 2;\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"DebugLogger: \" + message);\n    }\n}\n```\n调用\n```Java\n    static AbstractLogger getChainOfLogger() {\n        AbstractLogger infoLogger = new InfoLogger();\n        AbstractLogger debugLogger = new DebugLogger();\n        AbstractLogger errorLogger = new ErrorLogger();\n        \n        infoLogger.setNextLogger(debugLogger);\n        debugLogger.setNextLogger(errorLogger);\n        return infoLogger;\n    }\n    \n    public static void main(String[] args) {\n        AbstractLogger logger = getChainOfLogger();\n\n        logger.logMessage(AbstractLogger.INFO, \"an info msg\");\n        logger.logMessage(AbstractLogger.DEBUG, \"a debug msg\");\n        logger.logMessage(AbstractLogger.ERROR, \"an error msg\");\n    }\n```\n控制台输出结果为\n```\nInfoLogger: an info msg\nInfoLogger: a debug msg\nDebugLogger: a debug msg\nInfoLogger: an error msg\nDebugLogger: an error msg\nErrorLogger: an error msg\n```\n\n## 其他\n\n### 命令模式\n一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：[Java设计模式--命令模式（以管理智能家电为例）](http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&p=8b2a971c87dd11a05db0e63c49&newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&user=baidu&fm=sc&query=java%C3%FC%C1%EE%C4%A3%CA%BD&qid=c0e757ac00089354&p1=5)\n","source":"_posts/Java设计模式：行为型模式.md","raw":"---\ntitle: Java设计模式：行为型模式\ndate: 2019-01-21 00:57:00\ntags:\n- 设计模式\n- Java\ncategories:\n- Java\n---\n\n## 责任链模式\n责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<!--more-->\n\n创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。\n\n```Java\nabstract class AbstractLogger {\n    public static int INFO = 1;\n    public static int DEBUG = 2;\n    public static int ERROR = 3;\n\n    protected int level;\n\n    //责任链中的下一个元素\n    protected AbstractLogger nextLogger;\n\n    public void setNextLogger(AbstractLogger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    public void logMessage(int level, String message) {\n        if (this.level <= level) {\n            write(message);\n        }\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    abstract protected void write(String message);\n}\n```\n在 DebugLogger 中\n```Java\nclass DebugLogger extends AbstractLogger {\n\n    public DebugLogger() {\n        super();\n        level = 2;\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"DebugLogger: \" + message);\n    }\n}\n```\n调用\n```Java\n    static AbstractLogger getChainOfLogger() {\n        AbstractLogger infoLogger = new InfoLogger();\n        AbstractLogger debugLogger = new DebugLogger();\n        AbstractLogger errorLogger = new ErrorLogger();\n        \n        infoLogger.setNextLogger(debugLogger);\n        debugLogger.setNextLogger(errorLogger);\n        return infoLogger;\n    }\n    \n    public static void main(String[] args) {\n        AbstractLogger logger = getChainOfLogger();\n\n        logger.logMessage(AbstractLogger.INFO, \"an info msg\");\n        logger.logMessage(AbstractLogger.DEBUG, \"a debug msg\");\n        logger.logMessage(AbstractLogger.ERROR, \"an error msg\");\n    }\n```\n控制台输出结果为\n```\nInfoLogger: an info msg\nInfoLogger: a debug msg\nDebugLogger: a debug msg\nInfoLogger: an error msg\nDebugLogger: an error msg\nErrorLogger: an error msg\n```\n\n## 其他\n\n### 命令模式\n一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：[Java设计模式--命令模式（以管理智能家电为例）](http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&p=8b2a971c87dd11a05db0e63c49&newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&user=baidu&fm=sc&query=java%C3%FC%C1%EE%C4%A3%CA%BD&qid=c0e757ac00089354&p1=5)\n","slug":"Java设计模式：行为型模式","published":1,"updated":"2019-03-15T15:27:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqwl001wy4uprq3tbvwe","content":"<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<a id=\"more\"></a></p>\n<p>创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLogger</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> INFO = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> DEBUG = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> ERROR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//责任链中的下一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AbstractLogger nextLogger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextLogger</span><span class=\"params\">(AbstractLogger nextLogger)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextLogger = nextLogger;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String message)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.level <= level) {</span><br><span class=\"line\">            write(message);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLogger != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            nextLogger.logMessage(level, message);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>在 DebugLogger 中<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLogger</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugLogger</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        level = <span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span> </span>{</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DebugLogger: \"</span> + message);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>调用<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> AbstractLogger <span class=\"title\">getChainOfLogger</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    AbstractLogger infoLogger = <span class=\"keyword\">new</span> InfoLogger();</span><br><span class=\"line\">    AbstractLogger debugLogger = <span class=\"keyword\">new</span> DebugLogger();</span><br><span class=\"line\">    AbstractLogger errorLogger = <span class=\"keyword\">new</span> ErrorLogger();</span><br><span class=\"line\">    </span><br><span class=\"line\">    infoLogger.setNextLogger(debugLogger);</span><br><span class=\"line\">    debugLogger.setNextLogger(errorLogger);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> infoLogger;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    AbstractLogger logger = getChainOfLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.logMessage(AbstractLogger.INFO, <span class=\"string\">\"an info msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.DEBUG, <span class=\"string\">\"a debug msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.ERROR, <span class=\"string\">\"an error msg\"</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>控制台输出结果为<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">InfoLogger: an info msg</span><br><span class=\"line\">InfoLogger: a debug msg</span><br><span class=\"line\">DebugLogger: a debug msg</span><br><span class=\"line\">InfoLogger: an error msg</span><br><span class=\"line\">DebugLogger: an error msg</span><br><span class=\"line\">ErrorLogger: an error msg</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：<a href=\"http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&p=8b2a971c87dd11a05db0e63c49&newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&user=baidu&fm=sc&query=java%C3%FC%C1%EE%C4%A3%CA%BD&qid=c0e757ac00089354&p1=5\" target=\"_blank\" rel=\"noopener\">Java设计模式–命令模式（以管理智能家电为例）</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":2099,"excerpt":"<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。</p>","more":"<p></p>\n<p>创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> INFO = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> DEBUG = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> ERROR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//责任链中的下一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AbstractLogger nextLogger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextLogger</span><span class=\"params\">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextLogger = nextLogger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.level &lt;= level) &#123;</span><br><span class=\"line\">            write(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLogger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nextLogger.logMessage(level, message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 DebugLogger 中<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        level = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DebugLogger: \"</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> AbstractLogger <span class=\"title\">getChainOfLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger infoLogger = <span class=\"keyword\">new</span> InfoLogger();</span><br><span class=\"line\">    AbstractLogger debugLogger = <span class=\"keyword\">new</span> DebugLogger();</span><br><span class=\"line\">    AbstractLogger errorLogger = <span class=\"keyword\">new</span> ErrorLogger();</span><br><span class=\"line\">    </span><br><span class=\"line\">    infoLogger.setNextLogger(debugLogger);</span><br><span class=\"line\">    debugLogger.setNextLogger(errorLogger);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> infoLogger;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger logger = getChainOfLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.logMessage(AbstractLogger.INFO, <span class=\"string\">\"an info msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.DEBUG, <span class=\"string\">\"a debug msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.ERROR, <span class=\"string\">\"an error msg\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">InfoLogger: an info msg</span><br><span class=\"line\">InfoLogger: a debug msg</span><br><span class=\"line\">DebugLogger: a debug msg</span><br><span class=\"line\">InfoLogger: an error msg</span><br><span class=\"line\">DebugLogger: an error msg</span><br><span class=\"line\">ErrorLogger: an error msg</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：<a href=\"http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&amp;p=8b2a971c87dd11a05db0e63c49&amp;newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&amp;user=baidu&amp;fm=sc&amp;query=java%C3%FC%C1%EE%C4%A3%CA%BD&amp;qid=c0e757ac00089354&amp;p1=5\" target=\"_blank\" rel=\"noopener\">Java设计模式–命令模式（以管理智能家电为例）</a></p>"},{"title":"Github Pages+Hexo搭建个人博客","date":"2019-01-11T15:22:07.000Z","_content":"\n上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<!--more-->\n\n作者的环境基于Windows，其他环境的搭建过程大同小异。\n\n## 准备工作\n\n### Github Pages\n\n创建 Github Pages，首先需要一个 Github 帐号，新建一个仓库，仓库名为`{账户名}.github.io`，系统会自动识别并将其设为 Github Pages。注意的是仓库权限要设置为`public`。之后浏览器打开：`https://{账户名}.github.io`便可以看到缺省的界面。\n\n### Hexo\n\nHexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：\n- 安装Git客户端，前往Git主页下载，安装后登录帐号。\n- 安装Node.js环境，前往Node主页下载。\n- 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：\n```bash\nnpm install -g hexo-cli\n```\n\n- 初始化Hexo，`projectname`省略时，要求当前文件夹为空。\n```bash\nhexo init [projectname]\n```\n\n## 关联\n\n经过前面的过程，已经获得了 Github Pages 和本地的 Hexo 环境，接下来就是关联两者。\n在博客的文件夹中有`_config.yml`文件，为 Hexo 的配置文件，打开并将相应位置设置为：\n\n```yaml\ndeploy: \ntype: git\nrepo: 该处填写仓库的完整路径\nbranch: master\n```\n该过程其实是给`hexo d`这一命令做相应的配置，让 hexo 知道 blog 部署的位置，显然部署在 GitHub 的仓库里。\n保存文件之后，安装 Git 部署插件，在 Git Bash 中键入命令：\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n接下来就是清除 hexo 缓存：\n```bash\nhexo clean \n```\n\n生成静态文件\n```bash\nhexo g\n```\n\n部署网站，d 的意思是 deploy\n\n```bash\nhexo d\n```\n\n后两个命令可以合并为一条，关于 Hexo 的命令请访问：[Hexo指令](https://hexo.io/zh-cn/docs/commands.html)。\n\n```bash\nhexo g -d\n```\n\n至此，博客已经搭建完毕，浏览器键入`https://{账户名}.github.io`，发现打开了一个使用 Hexo 搭建的 Github Pages 博客。\n\n## 配置\n\n博客文件夹下的`_config.yml`文件可以配置整个博客的名称、主题等基本功能，`/theme/`文件夹下的`_config.yml`文件则用于配置具体的主题配置。\n\n### 发表与删除\n\n在博客文件夹打开 Git Bash，键入\n\n```\nhexo n \"文章的标题\"\n```\n\n之后便会生成一个md文件，在md文件中编辑文章保存，然后键入`hexo g -d`便会发布文章。\n\n如果要删除文章，直接删除对应的 md 文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。\n\n### 主题\n\n网络上有很多优秀的 Hexo 主题，关于主题选择，可以查看这个知乎问答：[有哪些好看的 Hexo主题](https://www.zhihu.com/question/24422335)。笔者使用的是[NexT](https://github.com/iissnan/hexo-theme-next)。\n\n在博客文件夹下的`_config.yml`文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客`_config.yml`文件的更改，保存片刻即生效。\n\n### 域名绑定\n\n具体过程如下：\n- 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github 的 IP 地址，`{账户名}.github.io`的 IP 地址，还有一个的记录类型为`CNAME`，记录值为：`{账户名}.github.io`。\n- 进入 GitHub Pages 的仓库，点击 settings，设置 Custom domain，输入购买的域名，保存。\n- 进入博客文件夹中的`/source/`，新建一个记事本文件，只需填写域名即可。如果在域名前填了 www，则每次浏览器访问都要填入 www，不填则没这个必要。之后将该文件保存为**所有文件**，名称为**CNAME**。\n\n## 备份与恢复\n\n由于在 Github Pages 的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。\n\n### 备份\n\n创建一个分支，用来保存网站源文件，具体步骤如下:\n- 新建一个分支，如 hexo，并将其设置为默认\n- 本地 clone 你的 Github Pages 仓库，得到一个 io 文件夹：`{账户名}.github.io`的文件夹。\n- 将原来博客文件夹中的`_config.yml，themes/，source/，scffolds/，package.json，.gitignore`复制到 clone 下来的文件夹，注意要将`theme/`主题的`.git/`删除。\n- 在 clone 下的文件夹执行`npm install`，`npm install hexo-deployer-git`。\n\n此时`{账户名}.github.io`文件夹已经成为包含你博客所有文件的工作文件夹，在部署(`hexo g -d`)之前，执行下面三条命令，以使用 hexo 分支更新 git 上的源文件:\n```bash\ngit add .\ngit commit -m \"更新源文件\"\ngit push origin hexo\n```\n\n这样一来，达到了在 master 分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。\n\n### 恢复\n\n当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js 的安装，步骤如下:\n- clone 你的 Github Pages 仓库，得到一个 io 文件夹。\n- 在文件夹中打开 Git Bash，键入以下命令:\n```bash\nnpm install hexo-cli -g\nnpm install \nnpm install hexo-deployer-git \n```\n现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用 pull 命令更新本地文件，且分支始终为 hexo。\n\n如果在拉取过程中提示本地分支与远程仓库冲突，可以使用`git reset --hard`命令重置之后再次 pull。如果提示\n> The following untracked working tree files would be overwritten by merge\n\n可以使用`git clean -d -fx`，关于该命令\n\n> git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。\n git clean -f            //该命令会移除所有上一条命令中显示的文件。\n git clean -fd           //移除文件夹，使用选项-d。\n git clean -fX           //只想移除已被忽略的文件，使用选项-X。\n git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。\n\n## Hexo各文件（夹）说明\n\n- _config.yml：站点的配置文件，备份过程中需要拷贝；\n- themes/：主题文件夹，需要拷贝；\n- source：博客文章的.md文件，需要拷贝；\n- scaffolds/：文章的模板，需要拷贝；\n- package.json：安装包的名称，需要拷贝；\n-  .gitignore：限定在push时哪些文件可以忽略，需要拷贝；\n-  .git/：主题和站点都有，标志这是一个git项目，不需要拷贝；\n- node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；\n- public：hexo g生成的静态网页，不需要拷贝；\n-  .deploy_git：同上，hexo g也会生成，不需要拷贝；\n- db.json：文件，不需要拷贝。","source":"_posts/Github-Pages-Hexo搭建个人博客.md","raw":"---\ntitle: Github Pages+Hexo搭建个人博客\ndate: 2019-01-11 23:22:07\ntags:\n- GitHub\n- Hexo\ncategories: \n- 互联网\n---\n\n上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<!--more-->\n\n作者的环境基于Windows，其他环境的搭建过程大同小异。\n\n## 准备工作\n\n### Github Pages\n\n创建 Github Pages，首先需要一个 Github 帐号，新建一个仓库，仓库名为`{账户名}.github.io`，系统会自动识别并将其设为 Github Pages。注意的是仓库权限要设置为`public`。之后浏览器打开：`https://{账户名}.github.io`便可以看到缺省的界面。\n\n### Hexo\n\nHexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：\n- 安装Git客户端，前往Git主页下载，安装后登录帐号。\n- 安装Node.js环境，前往Node主页下载。\n- 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：\n```bash\nnpm install -g hexo-cli\n```\n\n- 初始化Hexo，`projectname`省略时，要求当前文件夹为空。\n```bash\nhexo init [projectname]\n```\n\n## 关联\n\n经过前面的过程，已经获得了 Github Pages 和本地的 Hexo 环境，接下来就是关联两者。\n在博客的文件夹中有`_config.yml`文件，为 Hexo 的配置文件，打开并将相应位置设置为：\n\n```yaml\ndeploy: \ntype: git\nrepo: 该处填写仓库的完整路径\nbranch: master\n```\n该过程其实是给`hexo d`这一命令做相应的配置，让 hexo 知道 blog 部署的位置，显然部署在 GitHub 的仓库里。\n保存文件之后，安装 Git 部署插件，在 Git Bash 中键入命令：\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n接下来就是清除 hexo 缓存：\n```bash\nhexo clean \n```\n\n生成静态文件\n```bash\nhexo g\n```\n\n部署网站，d 的意思是 deploy\n\n```bash\nhexo d\n```\n\n后两个命令可以合并为一条，关于 Hexo 的命令请访问：[Hexo指令](https://hexo.io/zh-cn/docs/commands.html)。\n\n```bash\nhexo g -d\n```\n\n至此，博客已经搭建完毕，浏览器键入`https://{账户名}.github.io`，发现打开了一个使用 Hexo 搭建的 Github Pages 博客。\n\n## 配置\n\n博客文件夹下的`_config.yml`文件可以配置整个博客的名称、主题等基本功能，`/theme/`文件夹下的`_config.yml`文件则用于配置具体的主题配置。\n\n### 发表与删除\n\n在博客文件夹打开 Git Bash，键入\n\n```\nhexo n \"文章的标题\"\n```\n\n之后便会生成一个md文件，在md文件中编辑文章保存，然后键入`hexo g -d`便会发布文章。\n\n如果要删除文章，直接删除对应的 md 文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。\n\n### 主题\n\n网络上有很多优秀的 Hexo 主题，关于主题选择，可以查看这个知乎问答：[有哪些好看的 Hexo主题](https://www.zhihu.com/question/24422335)。笔者使用的是[NexT](https://github.com/iissnan/hexo-theme-next)。\n\n在博客文件夹下的`_config.yml`文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客`_config.yml`文件的更改，保存片刻即生效。\n\n### 域名绑定\n\n具体过程如下：\n- 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github 的 IP 地址，`{账户名}.github.io`的 IP 地址，还有一个的记录类型为`CNAME`，记录值为：`{账户名}.github.io`。\n- 进入 GitHub Pages 的仓库，点击 settings，设置 Custom domain，输入购买的域名，保存。\n- 进入博客文件夹中的`/source/`，新建一个记事本文件，只需填写域名即可。如果在域名前填了 www，则每次浏览器访问都要填入 www，不填则没这个必要。之后将该文件保存为**所有文件**，名称为**CNAME**。\n\n## 备份与恢复\n\n由于在 Github Pages 的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。\n\n### 备份\n\n创建一个分支，用来保存网站源文件，具体步骤如下:\n- 新建一个分支，如 hexo，并将其设置为默认\n- 本地 clone 你的 Github Pages 仓库，得到一个 io 文件夹：`{账户名}.github.io`的文件夹。\n- 将原来博客文件夹中的`_config.yml，themes/，source/，scffolds/，package.json，.gitignore`复制到 clone 下来的文件夹，注意要将`theme/`主题的`.git/`删除。\n- 在 clone 下的文件夹执行`npm install`，`npm install hexo-deployer-git`。\n\n此时`{账户名}.github.io`文件夹已经成为包含你博客所有文件的工作文件夹，在部署(`hexo g -d`)之前，执行下面三条命令，以使用 hexo 分支更新 git 上的源文件:\n```bash\ngit add .\ngit commit -m \"更新源文件\"\ngit push origin hexo\n```\n\n这样一来，达到了在 master 分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。\n\n### 恢复\n\n当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js 的安装，步骤如下:\n- clone 你的 Github Pages 仓库，得到一个 io 文件夹。\n- 在文件夹中打开 Git Bash，键入以下命令:\n```bash\nnpm install hexo-cli -g\nnpm install \nnpm install hexo-deployer-git \n```\n现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用 pull 命令更新本地文件，且分支始终为 hexo。\n\n如果在拉取过程中提示本地分支与远程仓库冲突，可以使用`git reset --hard`命令重置之后再次 pull。如果提示\n> The following untracked working tree files would be overwritten by merge\n\n可以使用`git clean -d -fx`，关于该命令\n\n> git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。\n git clean -f            //该命令会移除所有上一条命令中显示的文件。\n git clean -fd           //移除文件夹，使用选项-d。\n git clean -fX           //只想移除已被忽略的文件，使用选项-X。\n git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。\n\n## Hexo各文件（夹）说明\n\n- _config.yml：站点的配置文件，备份过程中需要拷贝；\n- themes/：主题文件夹，需要拷贝；\n- source：博客文章的.md文件，需要拷贝；\n- scaffolds/：文章的模板，需要拷贝；\n- package.json：安装包的名称，需要拷贝；\n-  .gitignore：限定在push时哪些文件可以忽略，需要拷贝；\n-  .git/：主题和站点都有，标志这是一个git项目，不需要拷贝；\n- node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；\n- public：hexo g生成的静态网页，不需要拷贝；\n-  .deploy_git：同上，hexo g也会生成，不需要拷贝；\n- db.json：文件，不需要拷贝。","slug":"Github-Pages-Hexo搭建个人博客","published":1,"updated":"2019-06-02T05:00:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqwm001zy4upghesgt27","content":"<p>上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<a id=\"more\"></a></p>\n<p>作者的环境基于Windows，其他环境的搭建过程大同小异。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>创建 Github Pages，首先需要一个 Github 帐号，新建一个仓库，仓库名为<code>{账户名}.github.io</code>，系统会自动识别并将其设为 Github Pages。注意的是仓库权限要设置为<code>public</code>。之后浏览器打开：<code>https://{账户名}.github.io</code>便可以看到缺省的界面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：</p>\n<ul>\n<li>安装Git客户端，前往Git主页下载，安装后登录帐号。</li>\n<li>安装Node.js环境，前往Node主页下载。</li>\n<li><p>安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>初始化Hexo，<code>projectname</code>省略时，要求当前文件夹为空。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo init [projectname]</span><br></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<h2 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h2><p>经过前面的过程，已经获得了 Github Pages 和本地的 Hexo 环境，接下来就是关联两者。<br>在博客的文件夹中有<code>_config.yml</code>文件，为 Hexo 的配置文件，打开并将相应位置设置为：</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span> </span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">repo:</span> <span class=\"string\">该处填写仓库的完整路径</span></span><br><span class=\"line\"><span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></tbody></table></figure>\n<p>该过程其实是给<code>hexo d</code>这一命令做相应的配置，让 hexo 知道 blog 部署的位置，显然部署在 GitHub 的仓库里。<br>保存文件之后，安装 Git 部署插件，在 Git Bash 中键入命令：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>\n<p>接下来就是清除 hexo 缓存：<br></p><figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>生成静态文件<br></p><figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>部署网站，d 的意思是 deploy</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></tbody></table></figure>\n<p>后两个命令可以合并为一条，关于 Hexo 的命令请访问：<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">Hexo指令</a>。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></tbody></table></figure>\n<p>至此，博客已经搭建完毕，浏览器键入<code>https://{账户名}.github.io</code>，发现打开了一个使用 Hexo 搭建的 Github Pages 博客。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>博客文件夹下的<code>_config.yml</code>文件可以配置整个博客的名称、主题等基本功能，<code>/theme/</code>文件夹下的<code>_config.yml</code>文件则用于配置具体的主题配置。</p>\n<h3 id=\"发表与删除\"><a href=\"#发表与删除\" class=\"headerlink\" title=\"发表与删除\"></a>发表与删除</h3><p>在博客文件夹打开 Git Bash，键入</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo n \"文章的标题\"</span><br></pre></td></tr></tbody></table></figure>\n<p>之后便会生成一个md文件，在md文件中编辑文章保存，然后键入<code>hexo g -d</code>便会发布文章。</p>\n<p>如果要删除文章，直接删除对应的 md 文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>网络上有很多优秀的 Hexo 主题，关于主题选择，可以查看这个知乎问答：<a href=\"https://www.zhihu.com/question/24422335\" target=\"_blank\" rel=\"noopener\">有哪些好看的 Hexo主题</a>。笔者使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>。</p>\n<p>在博客文件夹下的<code>_config.yml</code>文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客<code>_config.yml</code>文件的更改，保存片刻即生效。</p>\n<h3 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h3><p>具体过程如下：</p>\n<ul>\n<li>需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github 的 IP 地址，<code>{账户名}.github.io</code>的 IP 地址，还有一个的记录类型为<code>CNAME</code>，记录值为：<code>{账户名}.github.io</code>。</li>\n<li>进入 GitHub Pages 的仓库，点击 settings，设置 Custom domain，输入购买的域名，保存。</li>\n<li>进入博客文件夹中的<code>/source/</code>，新建一个记事本文件，只需填写域名即可。如果在域名前填了 www，则每次浏览器访问都要填入 www，不填则没这个必要。之后将该文件保存为<strong>所有文件</strong>，名称为<strong>CNAME</strong>。</li>\n</ul>\n<h2 id=\"备份与恢复\"><a href=\"#备份与恢复\" class=\"headerlink\" title=\"备份与恢复\"></a>备份与恢复</h2><p>由于在 Github Pages 的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>创建一个分支，用来保存网站源文件，具体步骤如下:</p>\n<ul>\n<li>新建一个分支，如 hexo，并将其设置为默认</li>\n<li>本地 clone 你的 Github Pages 仓库，得到一个 io 文件夹：<code>{账户名}.github.io</code>的文件夹。</li>\n<li>将原来博客文件夹中的<code>_config.yml，themes/，source/，scffolds/，package.json，.gitignore</code>复制到 clone 下来的文件夹，注意要将<code>theme/</code>主题的<code>.git/</code>删除。</li>\n<li>在 clone 下的文件夹执行<code>npm install</code>，<code>npm install hexo-deployer-git</code>。</li>\n</ul>\n<p>此时<code>{账户名}.github.io</code>文件夹已经成为包含你博客所有文件的工作文件夹，在部署(<code>hexo g -d</code>)之前，执行下面三条命令，以使用 hexo 分支更新 git 上的源文件:<br></p><figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"更新源文件\"</span></span><br><span class=\"line\">git push origin hexo</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>这样一来，达到了在 master 分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js 的安装，步骤如下:</p>\n<ul>\n<li>clone 你的 Github Pages 仓库，得到一个 io 文件夹。</li>\n<li>在文件夹中打开 Git Bash，键入以下命令:<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install </span><br><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<p>现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用 pull 命令更新本地文件，且分支始终为 hexo。</p>\n<p>如果在拉取过程中提示本地分支与远程仓库冲突，可以使用<code>git reset --hard</code>命令重置之后再次 pull。如果提示</p>\n<blockquote>\n<p>The following untracked working tree files would be overwritten by merge</p>\n</blockquote>\n<p>可以使用<code>git clean -d -fx</code>，关于该命令</p>\n<blockquote>\n<p>git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。<br> git clean -f            //该命令会移除所有上一条命令中显示的文件。<br> git clean -fd           //移除文件夹，使用选项-d。<br> git clean -fX           //只想移除已被忽略的文件，使用选项-X。<br> git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。</p>\n</blockquote>\n<h2 id=\"Hexo各文件（夹）说明\"><a href=\"#Hexo各文件（夹）说明\" class=\"headerlink\" title=\"Hexo各文件（夹）说明\"></a>Hexo各文件（夹）说明</h2><ul>\n<li>_config.yml：站点的配置文件，备份过程中需要拷贝；</li>\n<li>themes/：主题文件夹，需要拷贝；</li>\n<li>source：博客文章的.md文件，需要拷贝；</li>\n<li>scaffolds/：文章的模板，需要拷贝；</li>\n<li>package.json：安装包的名称，需要拷贝；</li>\n<li>.gitignore：限定在push时哪些文件可以忽略，需要拷贝；</li>\n<li>.git/：主题和站点都有，标志这是一个git项目，不需要拷贝；</li>\n<li>node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li>\n<li>public：hexo g生成的静态网页，不需要拷贝；</li>\n<li>.deploy_git：同上，hexo g也会生成，不需要拷贝；</li>\n<li>db.json：文件，不需要拷贝。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":3285,"excerpt":"<p>上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。</p>","more":"<p></p>\n<p>作者的环境基于Windows，其他环境的搭建过程大同小异。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>创建 Github Pages，首先需要一个 Github 帐号，新建一个仓库，仓库名为<code>{账户名}.github.io</code>，系统会自动识别并将其设为 Github Pages。注意的是仓库权限要设置为<code>public</code>。之后浏览器打开：<code>https://{账户名}.github.io</code>便可以看到缺省的界面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：</p>\n<ul>\n<li>安装Git客户端，前往Git主页下载，安装后登录帐号。</li>\n<li>安装Node.js环境，前往Node主页下载。</li>\n<li><p>安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化Hexo，<code>projectname</code>省略时，要求当前文件夹为空。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init [projectname]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h2><p>经过前面的过程，已经获得了 Github Pages 和本地的 Hexo 环境，接下来就是关联两者。<br>在博客的文件夹中有<code>_config.yml</code>文件，为 Hexo 的配置文件，打开并将相应位置设置为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span> </span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">repo:</span> <span class=\"string\">该处填写仓库的完整路径</span></span><br><span class=\"line\"><span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n<p>该过程其实是给<code>hexo d</code>这一命令做相应的配置，让 hexo 知道 blog 部署的位置，显然部署在 GitHub 的仓库里。<br>保存文件之后，安装 Git 部署插件，在 Git Bash 中键入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>接下来就是清除 hexo 缓存：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure></p>\n<p>生成静态文件<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<p>部署网站，d 的意思是 deploy</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>后两个命令可以合并为一条，关于 Hexo 的命令请访问：<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">Hexo指令</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n<p>至此，博客已经搭建完毕，浏览器键入<code>https://{账户名}.github.io</code>，发现打开了一个使用 Hexo 搭建的 Github Pages 博客。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>博客文件夹下的<code>_config.yml</code>文件可以配置整个博客的名称、主题等基本功能，<code>/theme/</code>文件夹下的<code>_config.yml</code>文件则用于配置具体的主题配置。</p>\n<h3 id=\"发表与删除\"><a href=\"#发表与删除\" class=\"headerlink\" title=\"发表与删除\"></a>发表与删除</h3><p>在博客文件夹打开 Git Bash，键入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo n &quot;文章的标题&quot;</span><br></pre></td></tr></table></figure>\n<p>之后便会生成一个md文件，在md文件中编辑文章保存，然后键入<code>hexo g -d</code>便会发布文章。</p>\n<p>如果要删除文章，直接删除对应的 md 文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>网络上有很多优秀的 Hexo 主题，关于主题选择，可以查看这个知乎问答：<a href=\"https://www.zhihu.com/question/24422335\" target=\"_blank\" rel=\"noopener\">有哪些好看的 Hexo主题</a>。笔者使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>。</p>\n<p>在博客文件夹下的<code>_config.yml</code>文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客<code>_config.yml</code>文件的更改，保存片刻即生效。</p>\n<h3 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h3><p>具体过程如下：</p>\n<ul>\n<li>需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github 的 IP 地址，<code>{账户名}.github.io</code>的 IP 地址，还有一个的记录类型为<code>CNAME</code>，记录值为：<code>{账户名}.github.io</code>。</li>\n<li>进入 GitHub Pages 的仓库，点击 settings，设置 Custom domain，输入购买的域名，保存。</li>\n<li>进入博客文件夹中的<code>/source/</code>，新建一个记事本文件，只需填写域名即可。如果在域名前填了 www，则每次浏览器访问都要填入 www，不填则没这个必要。之后将该文件保存为<strong>所有文件</strong>，名称为<strong>CNAME</strong>。</li>\n</ul>\n<h2 id=\"备份与恢复\"><a href=\"#备份与恢复\" class=\"headerlink\" title=\"备份与恢复\"></a>备份与恢复</h2><p>由于在 Github Pages 的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>创建一个分支，用来保存网站源文件，具体步骤如下:</p>\n<ul>\n<li>新建一个分支，如 hexo，并将其设置为默认</li>\n<li>本地 clone 你的 Github Pages 仓库，得到一个 io 文件夹：<code>{账户名}.github.io</code>的文件夹。</li>\n<li>将原来博客文件夹中的<code>_config.yml，themes/，source/，scffolds/，package.json，.gitignore</code>复制到 clone 下来的文件夹，注意要将<code>theme/</code>主题的<code>.git/</code>删除。</li>\n<li>在 clone 下的文件夹执行<code>npm install</code>，<code>npm install hexo-deployer-git</code>。</li>\n</ul>\n<p>此时<code>{账户名}.github.io</code>文件夹已经成为包含你博客所有文件的工作文件夹，在部署(<code>hexo g -d</code>)之前，执行下面三条命令，以使用 hexo 分支更新 git 上的源文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"更新源文件\"</span></span><br><span class=\"line\">git push origin hexo</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，达到了在 master 分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js 的安装，步骤如下:</p>\n<ul>\n<li>clone 你的 Github Pages 仓库，得到一个 io 文件夹。</li>\n<li>在文件夹中打开 Git Bash，键入以下命令:<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install </span><br><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用 pull 命令更新本地文件，且分支始终为 hexo。</p>\n<p>如果在拉取过程中提示本地分支与远程仓库冲突，可以使用<code>git reset --hard</code>命令重置之后再次 pull。如果提示</p>\n<blockquote>\n<p>The following untracked working tree files would be overwritten by merge</p>\n</blockquote>\n<p>可以使用<code>git clean -d -fx</code>，关于该命令</p>\n<blockquote>\n<p>git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。<br> git clean -f            //该命令会移除所有上一条命令中显示的文件。<br> git clean -fd           //移除文件夹，使用选项-d。<br> git clean -fX           //只想移除已被忽略的文件，使用选项-X。<br> git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。</p>\n</blockquote>\n<h2 id=\"Hexo各文件（夹）说明\"><a href=\"#Hexo各文件（夹）说明\" class=\"headerlink\" title=\"Hexo各文件（夹）说明\"></a>Hexo各文件（夹）说明</h2><ul>\n<li>_config.yml：站点的配置文件，备份过程中需要拷贝；</li>\n<li>themes/：主题文件夹，需要拷贝；</li>\n<li>source：博客文章的.md文件，需要拷贝；</li>\n<li>scaffolds/：文章的模板，需要拷贝；</li>\n<li>package.json：安装包的名称，需要拷贝；</li>\n<li>.gitignore：限定在push时哪些文件可以忽略，需要拷贝；</li>\n<li>.git/：主题和站点都有，标志这是一个git项目，不需要拷贝；</li>\n<li>node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li>\n<li>public：hexo g生成的静态网页，不需要拷贝；</li>\n<li>.deploy_git：同上，hexo g也会生成，不需要拷贝；</li>\n<li>db.json：文件，不需要拷贝。</li>\n</ul>"},{"title":"LeetCode：最长回文子串（Longest Palindromic Substring）的解法","date":"2019-01-12T06:32:23.000Z","_content":"\n## 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n\n> Input: \"babcd\"\nOutput: \"bab\"\n\n<!--more-->\n\n本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。\n\n## O(n^3)算法\n\n### 思路\n- 从最长的子串开始，遍历所有该原字符串的子串；\n- 每找出一个字符串，就判断该字符串是否为回文；\n- 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。\n\n### 时间复杂度\n- 遍历字符串子串：嵌套一个循环：O(n^2)；   \n- 判断是否为回文：再次嵌套一个循环：O(n^3)。\n\n### 代码\n\n```java\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n    for(int i = s.length();i > 0; i--) {//子串长度\n        for(int j = 0; j <= s.length() - i; j++) {\n            String sub = s.substring(j , i + j);//子串位置\n            int count = 0;//计数，用来判断是否对称\n            for (int k = 0; k < sub.length() / 2; k++) {//左右对称判断\n                if (sub.charAt(k) == sub.charAt(sub.length() - k - 1))\n                    count++;\n            }\n            if (count == sub.length() / 2)\n                return sub;\n        }\n    }\n    return \"\";//表示字符串中无回文子串\n}\n```\n\n## O(n^2)算法\n\n### 思路\n\n- 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；\n- 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；\n- 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；\n- 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。\n\n### 时间复杂度\n\n- 遍历字符：一层循环——O(n-1)；\n\n- 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)\n\n\n### 代码\n```java\nprivate static int maxLen = 0;\n\nprivate static String sub = \"\";\n\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n\n    for(int i = 0;i < s.length()-1;i++){\n        findLongestPalindrome(s,i,i);//单核回文\n        findLongestPalindrome(s,i,i+1);//双核回文\n    }\n    return sub;\n}\n\npublic static void findLongestPalindrome(String s,int low,int high) {\n    while (low >= 0 && high <= s.length()-1){\n        if(s.charAt(low) == s.charAt(high)){\n            if(high - low + 1 > maxLen){\n                maxLen = high - low + 1;\n                sub = s.substring(low , high+1);\n            }\n            low --;//向两边扩散找当前字符为中心的最大回文子串\n            high ++;\n        } else\n            break;\n    }\n}\n```\n\n## O(n)算法——Manacher算法\n\n### 思路\nManacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br>\n这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以`＃`号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：\n\n> a -> #a# \nabaf -> #a#b#a#f#\n\n可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。\n\n借助两个变量center、right分别记录回文子串对应的中心点和右端点\n\n![你想输入的替代文字](LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png)\n\n可以直接看出，right就是`2*center-i`（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br>\n反之，就只能从1个长度开始匹配了，就是下面的这行代码:\n\n```\nr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1\n```\n\n这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br>\n进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。\n\n### 时间复杂度\n只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。\n\n### 代码\n```java\npublic static String longestPalindrome(String s) {\n\tif(s == null || s.length() < 1) {\n\t\treturn s;\n\t}\n\tStringBuilder builder = new StringBuilder();\n\t// 防止左端点越界\n\tbuilder.append(\"&#\");\n\tchar[] c = s.toCharArray();\n\tfor (char a : c) {\n\t\tbuilder.append(a).append(\"#\");\n\t}\n\tString newStr = builder.toString();\n\tc = newStr.toCharArray();\n\t// 回文半径\n\tint[] r = new int[newStr.length()];\n\t// 回文子串最大右端点、中心点\n\tint right=0, center=0;\n\t// 最大回文半径、最大中心点\n\tint maxR=0, maxC=0;\n\tfor (int i=1;i < c.length;i++) {\n\t\t// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径\n\t\tr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1;\n\t\twhile (i+r[i]<c.length && c[i+r[i]]==c[i-r[i]]) {\n\t\t\t++r[i];\n\t\t}\n\t\t// 更新右端点和中心点\n\t\tif (right < i+r[i]) {\n\t\t\tright = i+r[i];\n\t\t\tcenter = i;\n\t\t}\n\t\t// 更新最大半径和最大中心点\n\t\tif (maxR < r[i]) {\n\t\t\tmaxR = r[i];\n\t\t\tmaxC = i;\n\t\t}\n\t}\n    //计算在原字符串中的起始点\n\tint start = (maxC-maxR)/2;\n\treturn s.substring(start, start+maxR-1);\n}\n```","source":"_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法.md","raw":"---\ntitle: LeetCode：最长回文子串（Longest Palindromic Substring）的解法\ndate: 2019-01-12 14:32:23\ntags:\n- 算法\n- LeetCode\ncategories:\n- 算法\n---\n\n## 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n\n> Input: \"babcd\"\nOutput: \"bab\"\n\n<!--more-->\n\n本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。\n\n## O(n^3)算法\n\n### 思路\n- 从最长的子串开始，遍历所有该原字符串的子串；\n- 每找出一个字符串，就判断该字符串是否为回文；\n- 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。\n\n### 时间复杂度\n- 遍历字符串子串：嵌套一个循环：O(n^2)；   \n- 判断是否为回文：再次嵌套一个循环：O(n^3)。\n\n### 代码\n\n```java\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n    for(int i = s.length();i > 0; i--) {//子串长度\n        for(int j = 0; j <= s.length() - i; j++) {\n            String sub = s.substring(j , i + j);//子串位置\n            int count = 0;//计数，用来判断是否对称\n            for (int k = 0; k < sub.length() / 2; k++) {//左右对称判断\n                if (sub.charAt(k) == sub.charAt(sub.length() - k - 1))\n                    count++;\n            }\n            if (count == sub.length() / 2)\n                return sub;\n        }\n    }\n    return \"\";//表示字符串中无回文子串\n}\n```\n\n## O(n^2)算法\n\n### 思路\n\n- 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；\n- 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；\n- 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；\n- 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。\n\n### 时间复杂度\n\n- 遍历字符：一层循环——O(n-1)；\n\n- 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)\n\n\n### 代码\n```java\nprivate static int maxLen = 0;\n\nprivate static String sub = \"\";\n\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n\n    for(int i = 0;i < s.length()-1;i++){\n        findLongestPalindrome(s,i,i);//单核回文\n        findLongestPalindrome(s,i,i+1);//双核回文\n    }\n    return sub;\n}\n\npublic static void findLongestPalindrome(String s,int low,int high) {\n    while (low >= 0 && high <= s.length()-1){\n        if(s.charAt(low) == s.charAt(high)){\n            if(high - low + 1 > maxLen){\n                maxLen = high - low + 1;\n                sub = s.substring(low , high+1);\n            }\n            low --;//向两边扩散找当前字符为中心的最大回文子串\n            high ++;\n        } else\n            break;\n    }\n}\n```\n\n## O(n)算法——Manacher算法\n\n### 思路\nManacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br>\n这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以`＃`号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：\n\n> a -> #a# \nabaf -> #a#b#a#f#\n\n可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。\n\n借助两个变量center、right分别记录回文子串对应的中心点和右端点\n\n![你想输入的替代文字](LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png)\n\n可以直接看出，right就是`2*center-i`（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br>\n反之，就只能从1个长度开始匹配了，就是下面的这行代码:\n\n```\nr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1\n```\n\n这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br>\n进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。\n\n### 时间复杂度\n只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。\n\n### 代码\n```java\npublic static String longestPalindrome(String s) {\n\tif(s == null || s.length() < 1) {\n\t\treturn s;\n\t}\n\tStringBuilder builder = new StringBuilder();\n\t// 防止左端点越界\n\tbuilder.append(\"&#\");\n\tchar[] c = s.toCharArray();\n\tfor (char a : c) {\n\t\tbuilder.append(a).append(\"#\");\n\t}\n\tString newStr = builder.toString();\n\tc = newStr.toCharArray();\n\t// 回文半径\n\tint[] r = new int[newStr.length()];\n\t// 回文子串最大右端点、中心点\n\tint right=0, center=0;\n\t// 最大回文半径、最大中心点\n\tint maxR=0, maxC=0;\n\tfor (int i=1;i < c.length;i++) {\n\t\t// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径\n\t\tr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1;\n\t\twhile (i+r[i]<c.length && c[i+r[i]]==c[i-r[i]]) {\n\t\t\t++r[i];\n\t\t}\n\t\t// 更新右端点和中心点\n\t\tif (right < i+r[i]) {\n\t\t\tright = i+r[i];\n\t\t\tcenter = i;\n\t\t}\n\t\t// 更新最大半径和最大中心点\n\t\tif (maxR < r[i]) {\n\t\t\tmaxR = r[i];\n\t\t\tmaxC = i;\n\t\t}\n\t}\n    //计算在原字符串中的起始点\n\tint start = (maxC-maxR)/2;\n\treturn s.substring(start, start+maxR-1);\n}\n```","slug":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法","published":1,"updated":"2019-03-15T15:26:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqwo0021y4ups0ns4b4l","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>\n<blockquote>\n<p>Input: “babcd”<br>Output: “bab”</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。</p>\n<h2 id=\"O-n-3-算法\"><a href=\"#O-n-3-算法\" class=\"headerlink\" title=\"O(n^3)算法\"></a>O(n^3)算法</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>从最长的子串开始，遍历所有该原字符串的子串；</li>\n<li>每找出一个字符串，就判断该字符串是否为回文；</li>\n<li>子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li>遍历字符串子串：嵌套一个循环：O(n^2)；   </li>\n<li>判断是否为回文：再次嵌套一个循环：O(n^3)。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() <= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length();i > <span class=\"number\">0</span>; i--) {<span class=\"comment\">//子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j <= s.length() - i; j++) {</span><br><span class=\"line\">            String sub = s.substring(j , i + j);<span class=\"comment\">//子串位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//计数，用来判断是否对称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k < sub.length() / <span class=\"number\">2</span>; k++) {<span class=\"comment\">//左右对称判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sub.charAt(k) == sub.charAt(sub.length() - k - <span class=\"number\">1</span>))</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == sub.length() / <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;<span class=\"comment\">//表示字符串中无回文子串</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"O-n-2-算法\"><a href=\"#O-n-2-算法\" class=\"headerlink\" title=\"O(n^2)算法\"></a>O(n^2)算法</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；</li>\n<li>遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；</li>\n<li>每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；</li>\n<li>重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。</li>\n</ul>\n<h3 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li><p>遍历字符：一层循环——O(n-1)；</p>\n</li>\n<li><p>找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)</p>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() <= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i < s.length()-<span class=\"number\">1</span>;i++){</span><br><span class=\"line\">        findLongestPalindrome(s,i,i);<span class=\"comment\">//单核回文</span></span><br><span class=\"line\">        findLongestPalindrome(s,i,i+<span class=\"number\">1</span>);<span class=\"comment\">//双核回文</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">findLongestPalindrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low >= <span class=\"number\">0</span> && high <= s.length()-<span class=\"number\">1</span>){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(low) == s.charAt(high)){</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(high - low + <span class=\"number\">1</span> > maxLen){</span><br><span class=\"line\">                maxLen = high - low + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub = s.substring(low , high+<span class=\"number\">1</span>);</span><br><span class=\"line\">            }</span><br><span class=\"line\">            low --;<span class=\"comment\">//向两边扩散找当前字符为中心的最大回文子串</span></span><br><span class=\"line\">            high ++;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"O-n-算法——Manacher算法\"><a href=\"#O-n-算法——Manacher算法\" class=\"headerlink\" title=\"O(n)算法——Manacher算法\"></a>O(n)算法——Manacher算法</h2><h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br><br>这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以<code>＃</code>号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：</p>\n<blockquote>\n<p>a -> #a#<br>abaf -> #a#b#a#f#</p>\n</blockquote>\n<p>可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。</p>\n<p>借助两个变量center、right分别记录回文子串对应的中心点和右端点</p>\n<p><img src=\"/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png\" alt=\"你想输入的替代文字\"></p>\n<p>可以直接看出，right就是<code>2*center-i</code>（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br><br>反之，就只能从1个长度开始匹配了，就是下面的这行代码:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">r[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1</span><br></pre></td></tr></tbody></table></figure>\n<p>这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br><br>进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。</p>\n<h3 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span> || s.length() < <span class=\"number\">1</span>) {</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\tStringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t<span class=\"comment\">// 防止左端点越界</span></span><br><span class=\"line\">\tbuilder.append(<span class=\"string\">\"&#\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] c = s.toCharArray();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a : c) {</span><br><span class=\"line\">\t\tbuilder.append(a).append(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\tString newStr = builder.toString();</span><br><span class=\"line\">\tc = newStr.toCharArray();</span><br><span class=\"line\">\t<span class=\"comment\">// 回文半径</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[newStr.length()];</span><br><span class=\"line\">\t<span class=\"comment\">// 回文子串最大右端点、中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> right=<span class=\"number\">0</span>, center=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 最大回文半径、最大中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxR=<span class=\"number\">0</span>, maxC=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i < c.length;i++) {</span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径</span></span><br><span class=\"line\">\t\tr[i] = right > i ? (Math.min(r[<span class=\"number\">2</span>*center-i], right-i)) : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i+r[i]<c.length && c[i+r[i]]==c[i-r[i]]) {</span><br><span class=\"line\">\t\t\t++r[i];</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新右端点和中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (right < i+r[i]) {</span><br><span class=\"line\">\t\t\tright = i+r[i];</span><br><span class=\"line\">\t\t\tcenter = i;</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大半径和最大中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxR < r[i]) {</span><br><span class=\"line\">\t\t\tmaxR = r[i];</span><br><span class=\"line\">\t\t\tmaxC = i;</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t}</span><br><span class=\"line\">    <span class=\"comment\">//计算在原字符串中的起始点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = (maxC-maxR)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.substring(start, start+maxR-<span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":4017,"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>\n<blockquote>\n<p>Input: “babcd”<br>Output: “bab”</p>\n</blockquote>","more":"<p>本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。</p>\n<h2 id=\"O-n-3-算法\"><a href=\"#O-n-3-算法\" class=\"headerlink\" title=\"O(n^3)算法\"></a>O(n^3)算法</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>从最长的子串开始，遍历所有该原字符串的子串；</li>\n<li>每找出一个字符串，就判断该字符串是否为回文；</li>\n<li>子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li>遍历字符串子串：嵌套一个循环：O(n^2)；   </li>\n<li>判断是否为回文：再次嵌套一个循环：O(n^3)。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length();i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">//子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= s.length() - i; j++) &#123;</span><br><span class=\"line\">            String sub = s.substring(j , i + j);<span class=\"comment\">//子串位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//计数，用来判断是否对称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; sub.length() / <span class=\"number\">2</span>; k++) &#123;<span class=\"comment\">//左右对称判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sub.charAt(k) == sub.charAt(sub.length() - k - <span class=\"number\">1</span>))</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == sub.length() / <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;<span class=\"comment\">//表示字符串中无回文子串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-2-算法\"><a href=\"#O-n-2-算法\" class=\"headerlink\" title=\"O(n^2)算法\"></a>O(n^2)算法</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；</li>\n<li>遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；</li>\n<li>每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；</li>\n<li>重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。</li>\n</ul>\n<h3 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li><p>遍历字符：一层循环——O(n-1)；</p>\n</li>\n<li><p>找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)</p>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.length()-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">        findLongestPalindrome(s,i,i);<span class=\"comment\">//单核回文</span></span><br><span class=\"line\">        findLongestPalindrome(s,i,i+<span class=\"number\">1</span>);<span class=\"comment\">//双核回文</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">findLongestPalindrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &gt;= <span class=\"number\">0</span> &amp;&amp; high &lt;= s.length()-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(low) == s.charAt(high))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(high - low + <span class=\"number\">1</span> &gt; maxLen)&#123;</span><br><span class=\"line\">                maxLen = high - low + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub = s.substring(low , high+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            low --;<span class=\"comment\">//向两边扩散找当前字符为中心的最大回文子串</span></span><br><span class=\"line\">            high ++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-算法——Manacher算法\"><a href=\"#O-n-算法——Manacher算法\" class=\"headerlink\" title=\"O(n)算法——Manacher算法\"></a>O(n)算法——Manacher算法</h2><h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br><br>这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以<code>＃</code>号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：</p>\n<blockquote>\n<p>a -&gt; #a#<br>abaf -&gt; #a#b#a#f#</p>\n</blockquote>\n<p>可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。</p>\n<p>借助两个变量center、right分别记录回文子串对应的中心点和右端点</p>\n<p><img src=\"/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png\" alt=\"你想输入的替代文字\"></p>\n<p>可以直接看出，right就是<code>2*center-i</code>（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br><br>反之，就只能从1个长度开始匹配了，就是下面的这行代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1</span><br></pre></td></tr></table></figure>\n<p>这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br><br>进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。</p>\n<h3 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span> || s.length() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tStringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t<span class=\"comment\">// 防止左端点越界</span></span><br><span class=\"line\">\tbuilder.append(<span class=\"string\">\"&amp;#\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] c = s.toCharArray();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a : c) &#123;</span><br><span class=\"line\">\t\tbuilder.append(a).append(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tString newStr = builder.toString();</span><br><span class=\"line\">\tc = newStr.toCharArray();</span><br><span class=\"line\">\t<span class=\"comment\">// 回文半径</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[newStr.length()];</span><br><span class=\"line\">\t<span class=\"comment\">// 回文子串最大右端点、中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> right=<span class=\"number\">0</span>, center=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 最大回文半径、最大中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxR=<span class=\"number\">0</span>, maxC=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i &lt; c.length;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径</span></span><br><span class=\"line\">\t\tr[i] = right &gt; i ? (Math.min(r[<span class=\"number\">2</span>*center-i], right-i)) : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123;</span><br><span class=\"line\">\t\t\t++r[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新右端点和中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (right &lt; i+r[i]) &#123;</span><br><span class=\"line\">\t\t\tright = i+r[i];</span><br><span class=\"line\">\t\t\tcenter = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大半径和最大中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxR &lt; r[i]) &#123;</span><br><span class=\"line\">\t\t\tmaxR = r[i];</span><br><span class=\"line\">\t\t\tmaxC = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//计算在原字符串中的起始点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = (maxC-maxR)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.substring(start, start+maxR-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Spring 学习笔记（四）：构建 Web 应用程序","date":"2019-06-03T10:56:48.000Z","_content":"\nSpring MVC 基于模型-视图-控制器（ Model-View-Controller，MVC ）模式实现，用以构建灵活和松耦合的 Web 应用程序。本文将通过一个社交网站`Spittr`的实例，介绍 Spring MVC 框架，并在其基础上构建处理各种 Web 请求、参数和表单输入的控制器。\n\n## Spring MVC\n\n### 跟踪请求\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\spring-mvc-request.jpeg)\n\n当用户在 Web 浏览器点击链接或提交表格的时候，发出的请求将通过一系列的路径，直到获取响应返回浏览器，这一过程在 Spring MVC 中的过程可以由上图展现\n\n- 请求首先到达 DispatcherServlet，相当于一个前端控制器，其作用是查询处理器映射（Handler Mapping）后将请求发送给不同的 Spring MVC 控制器（Controller）\n- 到达具体的控制器之后请求会卸下其负载信息，并等待控制器的处理结果\n- 控制器完成逻辑处理后返回原始模型（Model）和视图名（View）\n- DispatcherServlet 通过视图解析器（View Resolver）解析视图名得到匹配结果\n- 请求最后到达视图实现（比如 JSP），交付模型数据\n- 视图实现渲染输出模型并通过响应对象传递给客户端\n\n### 搭建 Spring MVC\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\项目结构.png)\n\n项目的结构图如上\n\nSpring MVC 的核心是 DispatcherServlet，此处通过 Java 代码实现其配置，web.xml 文件的配置方式省略\n\n```kotlin\nclass SpittrWebApplicationInitializer: AbstractAnnotationConfigDispatcherServletInitializer() {\n\n    override fun getServletMappings(): Array<String> = arrayOf(\"/\")\n    \n    override fun getRootConfigClasses(): Array<Class<*>> = arrayOf(RootConfig::class.java)\n\n    override fun getServletConfigClasses(): Array<Class<*>> = arrayOf(WebConfig::class.java)\n}\n```\n\n> 原理（特别绕）：拓展 AbstractAnnotationConfigDispatcherServletInitializer 的类都会自动配置 DispatcherServlet 和 Spring 应用上下文（由 ContextLoaderListener 实现），因为容器会在类路径中查找实现 ServletContainerInitializer 接口的实现并为其配置，而Spring 中的实现为 SpringServletContainerInitializer，这个实现又会查找 WebApplicationInitializer——关于这个接口的继承关系为\n>\n> > public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer\n> >\n> >\n> > public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer\n> >\n> > public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer\n\n我们重写了三个方法\n\n- `getServletMappings`：将“/”路径映射到 DispatcherServlet 上，这也让其成为默认 Servlet\n- `getRootConfigClasses`：该方法返回的带有`@Configuration`注解的类将会用来配置应用上下文中的 bean\n- `getServletConfigClasses`：要求 DispatcherServlet 加载应用上下文时，使用定义在 WebConfig 中的 bean\n\nRootConfig 和 WebConfig 的实现如下\n\n```kotlin\n@Configuration\n@ComponentScan(basePackages = [\"spittr\"], excludeFilters = [ComponentScan.Filter(type = FilterType.ANNOTATION, value = [EnableWebMvc::class])])\nopen class RootConfig\n\n@EnableWebMvc\n@Configuration\n@ComponentScan(value = [\"spittr.web\"])\nopen class WebConfig: WebMvcConfigurerAdapter() {\n\n    @Bean\n    open fun viewResolver(): ViewResolver = InternalResourceViewResolver().apply {\n        setPrefix(\"/WEB-INF/views/\")\n        setSuffix(\".jsp\")\n        setExposeContextBeansAsAttributes(true)\n    }\n\n    override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer?) {\n        configurer?.enable()\n    }\n}\n```\n\nRootConfig 使用`@ComponentScan`以实现对非 Web 组件的调用。\n\nWebConfig 使用`@EnableWebMvc`启动 Spring MVC，使用`@ComponentScan`启用组件扫描，并继承 WebMvcConfigurerAdapter 重写其`configureDefaultServletHandling`方法以实现将静态资源的转发给默认 Servlet （貌似是多余的），同时添加一个 ViewResolver bean 查找对应的视图文件\n\n## 编写控制器\n\n在 Spring MVC 中，控制器是方法或者类添加了`@RequestMapping`注解的类，其本身所带的`@Controller`影响不大，如下面的代码。当然我们也可以将`@RequestMapping`放在类上。注解上的参数为数组，说明可以映射多个路径。`home`返回的字符串将配合上面 WebConfig 的`viewResolver`方法寻找网页视图\n\n```kotlin\n@Controller\nclass HomeController {\n\n    @RequestMapping(value = [\"/\"], method = [RequestMethod.GET])\n    fun home(): String {\n        return \"home\"\n    }\n}\n```\n\n现在就可以通过配置 Tomcat 运行本地服务器检验项目了，首先需要下载 Tomcat 包并解压，在 IDEA 中`EDIT Configurations`，添加一个 local 的 Tomcat，添加完成之后大概如下\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\tomcat_server.png)\n\n接下来还有最重要的一部，否则会出现一个很奇怪的错误\n\n```\njava.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener\n```\n\n这是因为项目中通过 Maven 引入的库并没有被 Tomcat 识别，需要手动添加，如下图，点击左下角的编辑图标\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\tomcat_deploy.png)\n\n在右侧的`Available Elements`中右键项目`spittr`，选择`Put into Output Root`，成功之后左侧的`WEB-INF/lib`下应该有需要的库\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\tomcat_put.jpg)\n\n配置结束，需要注意的是不要导入 IDEA 生成的 Spring Web 框架，因为我们已经使用了 Maven 导入所有项目需要的类库，而且配置文件都是通过 Java 代码而没有引入任何的 XML 文件（除了 Maven 的`pom.xml`）。成功运行项目之后，浏览器打开`http://localhost:8080/spittr_war_exploded/`即可看到`home.jsp`中的网页视图\n\n## 传递数据到视图中\n\n## 接受视图数据输入\n\n","source":"_posts/Spring-学习笔记（四）：构建-Web-应用程序.md","raw":"---\ntitle: Spring 学习笔记（四）：构建 Web 应用程序\ndate: 2019-06-03 18:56:48\ntags:\n- Spring\n- Web\ncategories:\n- Spring \n---\n\nSpring MVC 基于模型-视图-控制器（ Model-View-Controller，MVC ）模式实现，用以构建灵活和松耦合的 Web 应用程序。本文将通过一个社交网站`Spittr`的实例，介绍 Spring MVC 框架，并在其基础上构建处理各种 Web 请求、参数和表单输入的控制器。\n\n## Spring MVC\n\n### 跟踪请求\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\spring-mvc-request.jpeg)\n\n当用户在 Web 浏览器点击链接或提交表格的时候，发出的请求将通过一系列的路径，直到获取响应返回浏览器，这一过程在 Spring MVC 中的过程可以由上图展现\n\n- 请求首先到达 DispatcherServlet，相当于一个前端控制器，其作用是查询处理器映射（Handler Mapping）后将请求发送给不同的 Spring MVC 控制器（Controller）\n- 到达具体的控制器之后请求会卸下其负载信息，并等待控制器的处理结果\n- 控制器完成逻辑处理后返回原始模型（Model）和视图名（View）\n- DispatcherServlet 通过视图解析器（View Resolver）解析视图名得到匹配结果\n- 请求最后到达视图实现（比如 JSP），交付模型数据\n- 视图实现渲染输出模型并通过响应对象传递给客户端\n\n### 搭建 Spring MVC\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\项目结构.png)\n\n项目的结构图如上\n\nSpring MVC 的核心是 DispatcherServlet，此处通过 Java 代码实现其配置，web.xml 文件的配置方式省略\n\n```kotlin\nclass SpittrWebApplicationInitializer: AbstractAnnotationConfigDispatcherServletInitializer() {\n\n    override fun getServletMappings(): Array<String> = arrayOf(\"/\")\n    \n    override fun getRootConfigClasses(): Array<Class<*>> = arrayOf(RootConfig::class.java)\n\n    override fun getServletConfigClasses(): Array<Class<*>> = arrayOf(WebConfig::class.java)\n}\n```\n\n> 原理（特别绕）：拓展 AbstractAnnotationConfigDispatcherServletInitializer 的类都会自动配置 DispatcherServlet 和 Spring 应用上下文（由 ContextLoaderListener 实现），因为容器会在类路径中查找实现 ServletContainerInitializer 接口的实现并为其配置，而Spring 中的实现为 SpringServletContainerInitializer，这个实现又会查找 WebApplicationInitializer——关于这个接口的继承关系为\n>\n> > public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer\n> >\n> >\n> > public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer\n> >\n> > public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer\n\n我们重写了三个方法\n\n- `getServletMappings`：将“/”路径映射到 DispatcherServlet 上，这也让其成为默认 Servlet\n- `getRootConfigClasses`：该方法返回的带有`@Configuration`注解的类将会用来配置应用上下文中的 bean\n- `getServletConfigClasses`：要求 DispatcherServlet 加载应用上下文时，使用定义在 WebConfig 中的 bean\n\nRootConfig 和 WebConfig 的实现如下\n\n```kotlin\n@Configuration\n@ComponentScan(basePackages = [\"spittr\"], excludeFilters = [ComponentScan.Filter(type = FilterType.ANNOTATION, value = [EnableWebMvc::class])])\nopen class RootConfig\n\n@EnableWebMvc\n@Configuration\n@ComponentScan(value = [\"spittr.web\"])\nopen class WebConfig: WebMvcConfigurerAdapter() {\n\n    @Bean\n    open fun viewResolver(): ViewResolver = InternalResourceViewResolver().apply {\n        setPrefix(\"/WEB-INF/views/\")\n        setSuffix(\".jsp\")\n        setExposeContextBeansAsAttributes(true)\n    }\n\n    override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer?) {\n        configurer?.enable()\n    }\n}\n```\n\nRootConfig 使用`@ComponentScan`以实现对非 Web 组件的调用。\n\nWebConfig 使用`@EnableWebMvc`启动 Spring MVC，使用`@ComponentScan`启用组件扫描，并继承 WebMvcConfigurerAdapter 重写其`configureDefaultServletHandling`方法以实现将静态资源的转发给默认 Servlet （貌似是多余的），同时添加一个 ViewResolver bean 查找对应的视图文件\n\n## 编写控制器\n\n在 Spring MVC 中，控制器是方法或者类添加了`@RequestMapping`注解的类，其本身所带的`@Controller`影响不大，如下面的代码。当然我们也可以将`@RequestMapping`放在类上。注解上的参数为数组，说明可以映射多个路径。`home`返回的字符串将配合上面 WebConfig 的`viewResolver`方法寻找网页视图\n\n```kotlin\n@Controller\nclass HomeController {\n\n    @RequestMapping(value = [\"/\"], method = [RequestMethod.GET])\n    fun home(): String {\n        return \"home\"\n    }\n}\n```\n\n现在就可以通过配置 Tomcat 运行本地服务器检验项目了，首先需要下载 Tomcat 包并解压，在 IDEA 中`EDIT Configurations`，添加一个 local 的 Tomcat，添加完成之后大概如下\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\tomcat_server.png)\n\n接下来还有最重要的一部，否则会出现一个很奇怪的错误\n\n```\njava.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener\n```\n\n这是因为项目中通过 Maven 引入的库并没有被 Tomcat 识别，需要手动添加，如下图，点击左下角的编辑图标\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\tomcat_deploy.png)\n\n在右侧的`Available Elements`中右键项目`spittr`，选择`Put into Output Root`，成功之后左侧的`WEB-INF/lib`下应该有需要的库\n\n![](Spring-学习笔记（四）：构建-Web-应用程序\\tomcat_put.jpg)\n\n配置结束，需要注意的是不要导入 IDEA 生成的 Spring Web 框架，因为我们已经使用了 Maven 导入所有项目需要的类库，而且配置文件都是通过 Java 代码而没有引入任何的 XML 文件（除了 Maven 的`pom.xml`）。成功运行项目之后，浏览器打开`http://localhost:8080/spittr_war_exploded/`即可看到`home.jsp`中的网页视图\n\n## 传递数据到视图中\n\n## 接受视图数据输入\n\n","slug":"Spring-学习笔记（四）：构建-Web-应用程序","published":1,"updated":"2019-06-03T16:24:44.000Z","_id":"cjwgkzqwq0026y4uppseh97dx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Spring MVC 基于模型-视图-控制器（ Model-View-Controller，MVC ）模式实现，用以构建灵活和松耦合的 Web 应用程序。本文将通过一个社交网站<code>Spittr</code>的实例，介绍 Spring MVC 框架，并在其基础上构建处理各种 Web 请求、参数和表单输入的控制器。</p>\n<h2 id=\"Spring-MVC\"><a href=\"#Spring-MVC\" class=\"headerlink\" title=\"Spring MVC\"></a>Spring MVC</h2><h3 id=\"跟踪请求\"><a href=\"#跟踪请求\" class=\"headerlink\" title=\"跟踪请求\"></a>跟踪请求</h3><p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/spring-mvc-request.jpeg\" alt></p>\n<p>当用户在 Web 浏览器点击链接或提交表格的时候，发出的请求将通过一系列的路径，直到获取响应返回浏览器，这一过程在 Spring MVC 中的过程可以由上图展现</p>\n<ul>\n<li>请求首先到达 DispatcherServlet，相当于一个前端控制器，其作用是查询处理器映射（Handler Mapping）后将请求发送给不同的 Spring MVC 控制器（Controller）</li>\n<li>到达具体的控制器之后请求会卸下其负载信息，并等待控制器的处理结果</li>\n<li>控制器完成逻辑处理后返回原始模型（Model）和视图名（View）</li>\n<li>DispatcherServlet 通过视图解析器（View Resolver）解析视图名得到匹配结果</li>\n<li>请求最后到达视图实现（比如 JSP），交付模型数据</li>\n<li>视图实现渲染输出模型并通过响应对象传递给客户端</li>\n</ul>\n<h3 id=\"搭建-Spring-MVC\"><a href=\"#搭建-Spring-MVC\" class=\"headerlink\" title=\"搭建 Spring MVC\"></a>搭建 Spring MVC</h3><p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/项目结构.png\" alt></p>\n<p>项目的结构图如上</p>\n<p>Spring MVC 的核心是 DispatcherServlet，此处通过 Java 代码实现其配置，web.xml 文件的配置方式省略</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpittrWebApplicationInitializer</span>: <span class=\"type\">AbstractAnnotationConfigDispatcherServletInitializer</span></span>() {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getServletMappings</span><span class=\"params\">()</span></span>: Array<String> = arrayOf(<span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getRootConfigClasses</span><span class=\"params\">()</span></span>: Array<Class<*>> = arrayOf(RootConfig::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getServletConfigClasses</span><span class=\"params\">()</span></span>: Array<Class<*>> = arrayOf(WebConfig::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>原理（特别绕）：拓展 AbstractAnnotationConfigDispatcherServletInitializer 的类都会自动配置 DispatcherServlet 和 Spring 应用上下文（由 ContextLoaderListener 实现），因为容器会在类路径中查找实现 ServletContainerInitializer 接口的实现并为其配置，而Spring 中的实现为 SpringServletContainerInitializer，这个实现又会查找 WebApplicationInitializer——关于这个接口的继承关系为</p>\n<blockquote>\n<p>public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer</p>\n<p>public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer</p>\n<p>public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer</p>\n</blockquote>\n</blockquote>\n<p>我们重写了三个方法</p>\n<ul>\n<li><code>getServletMappings</code>：将“/”路径映射到 DispatcherServlet 上，这也让其成为默认 Servlet</li>\n<li><code>getRootConfigClasses</code>：该方法返回的带有<code>@Configuration</code>注解的类将会用来配置应用上下文中的 bean</li>\n<li><code>getServletConfigClasses</code>：要求 DispatcherServlet 加载应用上下文时，使用定义在 WebConfig 中的 bean</li>\n</ul>\n<p>RootConfig 和 WebConfig 的实现如下</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = [<span class=\"meta-string\">\"spittr\"</span>], excludeFilters = [ComponentScan.Filter(type = FilterType.ANNOTATION, value = [EnableWebMvc::class])</span>])</span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootConfig</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(value = [<span class=\"meta-string\">\"spittr.web\"</span>])</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfig</span>: <span class=\"type\">WebMvcConfigurerAdapter</span></span>() {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">viewResolver</span><span class=\"params\">()</span></span>: ViewResolver = InternalResourceViewResolver().apply {</span><br><span class=\"line\">        setPrefix(<span class=\"string\">\"/WEB-INF/views/\"</span>)</span><br><span class=\"line\">        setSuffix(<span class=\"string\">\".jsp\"</span>)</span><br><span class=\"line\">        setExposeContextBeansAsAttributes(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">configureDefaultServletHandling</span><span class=\"params\">(configurer: <span class=\"type\">DefaultServletHandlerConfigurer</span>?)</span></span> {</span><br><span class=\"line\">        configurer?.enable()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>RootConfig 使用<code>@ComponentScan</code>以实现对非 Web 组件的调用。</p>\n<p>WebConfig 使用<code>@EnableWebMvc</code>启动 Spring MVC，使用<code>@ComponentScan</code>启用组件扫描，并继承 WebMvcConfigurerAdapter 重写其<code>configureDefaultServletHandling</code>方法以实现将静态资源的转发给默认 Servlet （貌似是多余的），同时添加一个 ViewResolver bean 查找对应的视图文件</p>\n<h2 id=\"编写控制器\"><a href=\"#编写控制器\" class=\"headerlink\" title=\"编写控制器\"></a>编写控制器</h2><p>在 Spring MVC 中，控制器是方法或者类添加了<code>@RequestMapping</code>注解的类，其本身所带的<code>@Controller</code>影响不大，如下面的代码。当然我们也可以将<code>@RequestMapping</code>放在类上。注解上的参数为数组，说明可以映射多个路径。<code>home</code>返回的字符串将配合上面 WebConfig 的<code>viewResolver</code>方法寻找网页视图</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeController</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = [<span class=\"meta-string\">\"/\"</span>], method = [RequestMethod.GET])</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">home</span><span class=\"params\">()</span></span>: String {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"home\"</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>现在就可以通过配置 Tomcat 运行本地服务器检验项目了，首先需要下载 Tomcat 包并解压，在 IDEA 中<code>EDIT Configurations</code>，添加一个 local 的 Tomcat，添加完成之后大概如下</p>\n<p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_server.png\" alt></p>\n<p>接下来还有最重要的一部，否则会出现一个很奇怪的错误</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener</span><br></pre></td></tr></tbody></table></figure>\n<p>这是因为项目中通过 Maven 引入的库并没有被 Tomcat 识别，需要手动添加，如下图，点击左下角的编辑图标</p>\n<p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_deploy.png\" alt></p>\n<p>在右侧的<code>Available Elements</code>中右键项目<code>spittr</code>，选择<code>Put into Output Root</code>，成功之后左侧的<code>WEB-INF/lib</code>下应该有需要的库</p>\n<p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_put.jpg\" alt></p>\n<p>配置结束，需要注意的是不要导入 IDEA 生成的 Spring Web 框架，因为我们已经使用了 Maven 导入所有项目需要的类库，而且配置文件都是通过 Java 代码而没有引入任何的 XML 文件（除了 Maven 的<code>pom.xml</code>）。成功运行项目之后，浏览器打开<code>http://localhost:8080/spittr_war_exploded/</code>即可看到<code>home.jsp</code>中的网页视图</p>\n<h2 id=\"传递数据到视图中\"><a href=\"#传递数据到视图中\" class=\"headerlink\" title=\"传递数据到视图中\"></a>传递数据到视图中</h2><h2 id=\"接受视图数据输入\"><a href=\"#接受视图数据输入\" class=\"headerlink\" title=\"接受视图数据输入\"></a>接受视图数据输入</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":3670,"excerpt":"","more":"<p>Spring MVC 基于模型-视图-控制器（ Model-View-Controller，MVC ）模式实现，用以构建灵活和松耦合的 Web 应用程序。本文将通过一个社交网站<code>Spittr</code>的实例，介绍 Spring MVC 框架，并在其基础上构建处理各种 Web 请求、参数和表单输入的控制器。</p>\n<h2 id=\"Spring-MVC\"><a href=\"#Spring-MVC\" class=\"headerlink\" title=\"Spring MVC\"></a>Spring MVC</h2><h3 id=\"跟踪请求\"><a href=\"#跟踪请求\" class=\"headerlink\" title=\"跟踪请求\"></a>跟踪请求</h3><p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/spring-mvc-request.jpeg\" alt=\"\"></p>\n<p>当用户在 Web 浏览器点击链接或提交表格的时候，发出的请求将通过一系列的路径，直到获取响应返回浏览器，这一过程在 Spring MVC 中的过程可以由上图展现</p>\n<ul>\n<li>请求首先到达 DispatcherServlet，相当于一个前端控制器，其作用是查询处理器映射（Handler Mapping）后将请求发送给不同的 Spring MVC 控制器（Controller）</li>\n<li>到达具体的控制器之后请求会卸下其负载信息，并等待控制器的处理结果</li>\n<li>控制器完成逻辑处理后返回原始模型（Model）和视图名（View）</li>\n<li>DispatcherServlet 通过视图解析器（View Resolver）解析视图名得到匹配结果</li>\n<li>请求最后到达视图实现（比如 JSP），交付模型数据</li>\n<li>视图实现渲染输出模型并通过响应对象传递给客户端</li>\n</ul>\n<h3 id=\"搭建-Spring-MVC\"><a href=\"#搭建-Spring-MVC\" class=\"headerlink\" title=\"搭建 Spring MVC\"></a>搭建 Spring MVC</h3><p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/项目结构.png\" alt=\"\"></p>\n<p>项目的结构图如上</p>\n<p>Spring MVC 的核心是 DispatcherServlet，此处通过 Java 代码实现其配置，web.xml 文件的配置方式省略</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpittrWebApplicationInitializer</span>: <span class=\"type\">AbstractAnnotationConfigDispatcherServletInitializer</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getServletMappings</span><span class=\"params\">()</span></span>: Array&lt;String&gt; = arrayOf(<span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getRootConfigClasses</span><span class=\"params\">()</span></span>: Array&lt;Class&lt;*&gt;&gt; = arrayOf(RootConfig::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getServletConfigClasses</span><span class=\"params\">()</span></span>: Array&lt;Class&lt;*&gt;&gt; = arrayOf(WebConfig::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原理（特别绕）：拓展 AbstractAnnotationConfigDispatcherServletInitializer 的类都会自动配置 DispatcherServlet 和 Spring 应用上下文（由 ContextLoaderListener 实现），因为容器会在类路径中查找实现 ServletContainerInitializer 接口的实现并为其配置，而Spring 中的实现为 SpringServletContainerInitializer，这个实现又会查找 WebApplicationInitializer——关于这个接口的继承关系为</p>\n<blockquote>\n<p>public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer</p>\n<p>public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer</p>\n<p>public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer</p>\n</blockquote>\n</blockquote>\n<p>我们重写了三个方法</p>\n<ul>\n<li><code>getServletMappings</code>：将“/”路径映射到 DispatcherServlet 上，这也让其成为默认 Servlet</li>\n<li><code>getRootConfigClasses</code>：该方法返回的带有<code>@Configuration</code>注解的类将会用来配置应用上下文中的 bean</li>\n<li><code>getServletConfigClasses</code>：要求 DispatcherServlet 加载应用上下文时，使用定义在 WebConfig 中的 bean</li>\n</ul>\n<p>RootConfig 和 WebConfig 的实现如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = [<span class=\"meta-string\">\"spittr\"</span>], excludeFilters = [ComponentScan.Filter(type = FilterType.ANNOTATION, value = [EnableWebMvc::class])</span>])</span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootConfig</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(value = [<span class=\"meta-string\">\"spittr.web\"</span>])</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfig</span>: <span class=\"type\">WebMvcConfigurerAdapter</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">viewResolver</span><span class=\"params\">()</span></span>: ViewResolver = InternalResourceViewResolver().apply &#123;</span><br><span class=\"line\">        setPrefix(<span class=\"string\">\"/WEB-INF/views/\"</span>)</span><br><span class=\"line\">        setSuffix(<span class=\"string\">\".jsp\"</span>)</span><br><span class=\"line\">        setExposeContextBeansAsAttributes(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">configureDefaultServletHandling</span><span class=\"params\">(configurer: <span class=\"type\">DefaultServletHandlerConfigurer</span>?)</span></span> &#123;</span><br><span class=\"line\">        configurer?.enable()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RootConfig 使用<code>@ComponentScan</code>以实现对非 Web 组件的调用。</p>\n<p>WebConfig 使用<code>@EnableWebMvc</code>启动 Spring MVC，使用<code>@ComponentScan</code>启用组件扫描，并继承 WebMvcConfigurerAdapter 重写其<code>configureDefaultServletHandling</code>方法以实现将静态资源的转发给默认 Servlet （貌似是多余的），同时添加一个 ViewResolver bean 查找对应的视图文件</p>\n<h2 id=\"编写控制器\"><a href=\"#编写控制器\" class=\"headerlink\" title=\"编写控制器\"></a>编写控制器</h2><p>在 Spring MVC 中，控制器是方法或者类添加了<code>@RequestMapping</code>注解的类，其本身所带的<code>@Controller</code>影响不大，如下面的代码。当然我们也可以将<code>@RequestMapping</code>放在类上。注解上的参数为数组，说明可以映射多个路径。<code>home</code>返回的字符串将配合上面 WebConfig 的<code>viewResolver</code>方法寻找网页视图</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = [<span class=\"meta-string\">\"/\"</span>], method = [RequestMethod.GET])</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">home</span><span class=\"params\">()</span></span>: String &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"home\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在就可以通过配置 Tomcat 运行本地服务器检验项目了，首先需要下载 Tomcat 包并解压，在 IDEA 中<code>EDIT Configurations</code>，添加一个 local 的 Tomcat，添加完成之后大概如下</p>\n<p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_server.png\" alt=\"\"></p>\n<p>接下来还有最重要的一部，否则会出现一个很奇怪的错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener</span><br></pre></td></tr></table></figure>\n<p>这是因为项目中通过 Maven 引入的库并没有被 Tomcat 识别，需要手动添加，如下图，点击左下角的编辑图标</p>\n<p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_deploy.png\" alt=\"\"></p>\n<p>在右侧的<code>Available Elements</code>中右键项目<code>spittr</code>，选择<code>Put into Output Root</code>，成功之后左侧的<code>WEB-INF/lib</code>下应该有需要的库</p>\n<p><img src=\"/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_put.jpg\" alt=\"\"></p>\n<p>配置结束，需要注意的是不要导入 IDEA 生成的 Spring Web 框架，因为我们已经使用了 Maven 导入所有项目需要的类库，而且配置文件都是通过 Java 代码而没有引入任何的 XML 文件（除了 Maven 的<code>pom.xml</code>）。成功运行项目之后，浏览器打开<code>http://localhost:8080/spittr_war_exploded/</code>即可看到<code>home.jsp</code>中的网页视图</p>\n<h2 id=\"传递数据到视图中\"><a href=\"#传递数据到视图中\" class=\"headerlink\" title=\"传递数据到视图中\"></a>传递数据到视图中</h2><h2 id=\"接受视图数据输入\"><a href=\"#接受视图数据输入\" class=\"headerlink\" title=\"接受视图数据输入\"></a>接受视图数据输入</h2>"},{"title":"坐过山车的人","date":"2019-01-10T09:57:55.000Z","_content":"\n距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<!--more-->\n\n前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。\n\n> 我们乘坐过山车飞向未来，  \n> 他和我的手里各捏着一张票，  \n> 那是飞向未来的小舢板，  \n> 起伏的波浪是我无畏的想象力。  \n> 乘坐我的想象力，\n> 他们尽情蹂躏  \n> 这些无辜的女孩和男孩，  \n> 这些无辜的小狗和小猫。  \n> 在波浪之下，在波浪的下面  \n> 一直匍匐着衰弱的故事人， \n> 他曾经是最伟大的创造者，  \n> 匍匐在最下面的飞得最高，  \n> 全是痛苦，全部都是痛苦。  \n> 那些与我耳语者，个个聪明无比， \n> 他们说智慧来自痛苦，他们说：  \n> 来，给你智慧之路。  \n> 哦，每一个坐过山车的人  \n> 都是过山车建造厂的工人，  \n> 每一双手都充满智慧，是痛苦的 \n> 工艺匠。他们也制造不同的心灵，  \n> 这些心灵里孕育着奖励，  \n> 那些渴望奖励的人，那些最智慧的人，  \n> 他们总在沉默，不停地被从过山车上 \n> 推下去，在空中飘荡，在飘荡中，  \n> 我们接吻，就像那些恋人，  \n> 那些被压缩在词典册页中的爱情故事，  \n> 还有家庭，人间的互相拯救。 \n> 如果存在一个空间，漂浮着  \n> 无数列过山车，痛苦的过山车…… \n>\n> ——马雁：《我们乘坐着过山车飞向未来》\n\n元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。\n\n在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。\n\n武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。\n\n这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。\n\n等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。\n\n生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。\n\n和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","source":"_posts/坐过山车的人.md","raw":"---\ntitle: 坐过山车的人\ndate: 2019-01-10 17:57:55\ntags:\n- 随笔\n- 诗歌\ncategories: \n- 随笔\n---\n\n距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<!--more-->\n\n前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。\n\n> 我们乘坐过山车飞向未来，  \n> 他和我的手里各捏着一张票，  \n> 那是飞向未来的小舢板，  \n> 起伏的波浪是我无畏的想象力。  \n> 乘坐我的想象力，\n> 他们尽情蹂躏  \n> 这些无辜的女孩和男孩，  \n> 这些无辜的小狗和小猫。  \n> 在波浪之下，在波浪的下面  \n> 一直匍匐着衰弱的故事人， \n> 他曾经是最伟大的创造者，  \n> 匍匐在最下面的飞得最高，  \n> 全是痛苦，全部都是痛苦。  \n> 那些与我耳语者，个个聪明无比， \n> 他们说智慧来自痛苦，他们说：  \n> 来，给你智慧之路。  \n> 哦，每一个坐过山车的人  \n> 都是过山车建造厂的工人，  \n> 每一双手都充满智慧，是痛苦的 \n> 工艺匠。他们也制造不同的心灵，  \n> 这些心灵里孕育着奖励，  \n> 那些渴望奖励的人，那些最智慧的人，  \n> 他们总在沉默，不停地被从过山车上 \n> 推下去，在空中飘荡，在飘荡中，  \n> 我们接吻，就像那些恋人，  \n> 那些被压缩在词典册页中的爱情故事，  \n> 还有家庭，人间的互相拯救。 \n> 如果存在一个空间，漂浮着  \n> 无数列过山车，痛苦的过山车…… \n>\n> ——马雁：《我们乘坐着过山车飞向未来》\n\n元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。\n\n在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。\n\n武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。\n\n这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。\n\n等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。\n\n生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。\n\n和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","slug":"坐过山车的人","published":1,"updated":"2019-06-02T05:06:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqws0029y4upzxcg01qz","content":"<p>距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<a id=\"more\"></a></p>\n<p>前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。</p>\n<blockquote>\n<p>我们乘坐过山车飞向未来，<br>他和我的手里各捏着一张票，<br>那是飞向未来的小舢板，<br>起伏的波浪是我无畏的想象力。<br>乘坐我的想象力，<br>他们尽情蹂躏<br>这些无辜的女孩和男孩，<br>这些无辜的小狗和小猫。<br>在波浪之下，在波浪的下面<br>一直匍匐着衰弱的故事人，<br>他曾经是最伟大的创造者，<br>匍匐在最下面的飞得最高，<br>全是痛苦，全部都是痛苦。<br>那些与我耳语者，个个聪明无比，<br>他们说智慧来自痛苦，他们说：<br>来，给你智慧之路。<br>哦，每一个坐过山车的人<br>都是过山车建造厂的工人，<br>每一双手都充满智慧，是痛苦的<br>工艺匠。他们也制造不同的心灵，<br>这些心灵里孕育着奖励，<br>那些渴望奖励的人，那些最智慧的人，<br>他们总在沉默，不停地被从过山车上<br>推下去，在空中飘荡，在飘荡中，<br>我们接吻，就像那些恋人，<br>那些被压缩在词典册页中的爱情故事，<br>还有家庭，人间的互相拯救。<br>如果存在一个空间，漂浮着<br>无数列过山车，痛苦的过山车…… </p>\n<p>——马雁：《我们乘坐着过山车飞向未来》</p>\n</blockquote>\n<p>元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。</p>\n<p>在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。</p>\n<p>武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。</p>\n<p>这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。</p>\n<p>等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。</p>\n<p>生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。</p>\n<p>和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":1841,"excerpt":"<p>距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。</p>","more":"<p></p>\n<p>前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。</p>\n<blockquote>\n<p>我们乘坐过山车飞向未来，<br>他和我的手里各捏着一张票，<br>那是飞向未来的小舢板，<br>起伏的波浪是我无畏的想象力。<br>乘坐我的想象力，<br>他们尽情蹂躏<br>这些无辜的女孩和男孩，<br>这些无辜的小狗和小猫。<br>在波浪之下，在波浪的下面<br>一直匍匐着衰弱的故事人，<br>他曾经是最伟大的创造者，<br>匍匐在最下面的飞得最高，<br>全是痛苦，全部都是痛苦。<br>那些与我耳语者，个个聪明无比，<br>他们说智慧来自痛苦，他们说：<br>来，给你智慧之路。<br>哦，每一个坐过山车的人<br>都是过山车建造厂的工人，<br>每一双手都充满智慧，是痛苦的<br>工艺匠。他们也制造不同的心灵，<br>这些心灵里孕育着奖励，<br>那些渴望奖励的人，那些最智慧的人，<br>他们总在沉默，不停地被从过山车上<br>推下去，在空中飘荡，在飘荡中，<br>我们接吻，就像那些恋人，<br>那些被压缩在词典册页中的爱情故事，<br>还有家庭，人间的互相拯救。<br>如果存在一个空间，漂浮着<br>无数列过山车，痛苦的过山车…… </p>\n<p>——马雁：《我们乘坐着过山车飞向未来》</p>\n</blockquote>\n<p>元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。</p>\n<p>在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。</p>\n<p>武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。</p>\n<p>这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。</p>\n<p>等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。</p>\n<p>生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。</p>\n<p>和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。</p>"},{"title":"Java设计模式：结构型模式","date":"2019-01-20T16:56:04.000Z","_content":"\n## 适配器模式\n在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<!--more-->\n\n用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此`Volt5V`称为`Target`，而不兼容的220V电压称之为`Adaptee`，我们的目的是适配设计一个`Adpater`，方法有两种。\n\n### 类适配器模式\n\n```Java\ninterface Volt5V {\n    int get5V();\n}\n\nclass Volt220V {\n    public int get220V() {\n        return 220;\n    }\n}\n\nclass Adapter extends Volt220V implements Volt5V {\n    @Override\n    public int get5V() {\n        return 5;\n    }\n}\n\npublic static void main(String[] args) {\n    Adapter adapter = new Adapter();\n    System.out.println(\"获取需要的5V电源：\" + adapter.get5V());\n}\n\n```\n\n### 对象适配器模式\n与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 \n　　 \n```Java\nclass ObjectAdapter implements Volt5V {\n\n    private Volt220V volt220V;\n\n    public ObjectAdapter(Volt220V adaptee) {\n        volt220V = adaptee;\n    }\n\n    @Override\n    public int get5V() {\n        return 5;\n    }\n        \n    public int get220V() {\n        return volt220V.get220V();\n    }  \n}\n```\n关于 Android 中 ListView 中的 Adapter，可以参考：[Android源码之ListView的适配器模式](https://blog.csdn.net/bboyfeiyu/article/details/43950185)\n\n## 组合模式\n将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。\n\n- 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。\n- 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。\n- 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。\n\n对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。\n\n```Java\n//抽象构件，声明一个接口用于访问和管理Component的子部件\nabstract class Component {\n\n    public Component() { }\n\n    public abstract void add(Component component);\n\n    public abstract void remove(Component component);\n\n    //显示层级结构\n    public abstract void Display(int level);\n}\n\n//叶子节点\nclass Leaf extends Component {\n\n    public Leaf() {\n        super();\n    }\n\n    //无意义的实现\n    @Override\n    public void add(Component component) { }\n\n    //无意义的实现\n    @Override\n    public void remove(Component component) { }\n\n    @Override\n    public void Display(int level) {\n        System.out.println(\"-\" + level);\n    }\n}\n\n//枝节点\nclass Composite extends Component {\n\n    public Composite() {\n        super();\n    }\n\n    private List<Component> children = new ArrayList<>();\n\n    @Override\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    @Override\n    public void Display(int level) {\n        children.forEach(\n                component -> component.Display(level + 2)\n        );\n    }\n}\n\n```\n对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。\n\n## 装饰器模式\n向一个现有的对象添加新的功能，同时又不改变其结构。<br>\n创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。\n\n```Java\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Draw a circle\");\n    }\n}\n\n//实现了 Shape 接口的抽象装饰类。\nabstract class ShapeDecorator implements Shape {\n\n    Shape decoratedShape;\n\n    public ShapeDecorator(Shape decoratedShape) {\n        this.decoratedShape = decoratedShape;\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n    }\n}\n\n//具体的装饰类\nclass RedShapeDecorator extends ShapeDecorator {\n\n    public RedShapeDecorator(Shape decoratedShape) {\n        super(decoratedShape);\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n        setRedBorder(decoratedShape);\n    }\n\n    private void setRedBorder(Shape decoratedShape) {\n        System.out.println(\"Border color: Red\");\n    }\n}\n```\n\n## 代理模式\n下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\n```Java\ninterface Image {\n    void display();\n}\n\nclass RealImage implements Image {\n\n    private String fileName;\n\n    public RealImage(String fileName){\n        this.fileName = fileName;\n        loadFromDisk(fileName);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Displaying \" + fileName);\n    }\n\n    private void loadFromDisk(String fileName){\n        System.out.println(\"Loading \" + fileName);\n    }\n}\n\nclass ProxyImage implements Image {\n\n    private RealImage realImage;\n    private String fileName;\n\n    public ProxyImage(String fileName){\n        this.fileName = fileName;\n    }\n\n    @Override\n    public void display() {\n        if(realImage == null){\n            realImage = new RealImage(fileName);\n        }\n        realImage.display();\n    }\n}\n```\n\n静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br>\nJava中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。\n\n```Java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DisplayHandler implements InvocationHandler {\n\n    //要代理的真实对象\n    private Object obj;\n\n    public DisplayHandler(Object obj) {\n        this.obj = obj;\n    }\n\n    /**\n     *\n     * @param proxy 代理类代理的真实代理对象\n     * @param method 所要调用某个对象真实的方法的Method对象\n     * @param args 指代代理对象方法传递的参数\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //真实的对象执行之前\n        System.out.println(\"Before invoke...\");\n\n        Object invoke = method.invoke(obj, args);\n\n        //真实的对象执行之后\n        System.out.println(\"After invoke...\");\n        return invoke;\n    }\n}\n\npublic static void main(String[] args) {\n    Image image = new RealImage(\"hello.jpg\");\n    InvocationHandler handler = new DisplayHandler(image);\n\n    /*\n     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象\n     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法\n     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上\n     */\n    Image proxy = (Image) Proxy.newProxyInstance(\n            handler.getClass().getClassLoader(),\n            image.getClass().getInterfaces(),\n            handler);\n    proxy.display();\n}\n```\n控制台输出结果为 \n```\nLoading hello.jpg\nBefore invoke...\nDisplaying hello.jpg\nAfter invoke...\n```\n\n代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。\n\n## 其他\n\n### 过滤器模式\n简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。\n\n### 桥接模式\n桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。\n\n举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。\n\n### 外观模式\n外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。\n\n简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。\n\n\n### 享元模式\n所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点\n\n```Java\npublic class FlyweightFactory{\n\n    static Map<String, Shape> shapes = new HashMap<String, Shape>();\n    \n    public static Shape getShape(String key){\n        Shape shape = shapes.get(key);\n        if(shape == null){\n            shape = new Circle(key);\n            shapes.put(key, shape);\n        }\n        return shape;\n    }\n    \n    public static int getSum(){\n        return shapes.size();\n    }\n}\n```\n\n### 补充\n从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是\"转换行为\"，外观模式是一种\"简化行为\"。","source":"_posts/Java设计模式：结构型模式.md","raw":"---\ntitle: Java设计模式：结构型模式\ndate: 2019-01-21 00:56:04\ntags:\n- 设计模式\n- Java\ncategories:\n- Java\n---\n\n## 适配器模式\n在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<!--more-->\n\n用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此`Volt5V`称为`Target`，而不兼容的220V电压称之为`Adaptee`，我们的目的是适配设计一个`Adpater`，方法有两种。\n\n### 类适配器模式\n\n```Java\ninterface Volt5V {\n    int get5V();\n}\n\nclass Volt220V {\n    public int get220V() {\n        return 220;\n    }\n}\n\nclass Adapter extends Volt220V implements Volt5V {\n    @Override\n    public int get5V() {\n        return 5;\n    }\n}\n\npublic static void main(String[] args) {\n    Adapter adapter = new Adapter();\n    System.out.println(\"获取需要的5V电源：\" + adapter.get5V());\n}\n\n```\n\n### 对象适配器模式\n与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 \n　　 \n```Java\nclass ObjectAdapter implements Volt5V {\n\n    private Volt220V volt220V;\n\n    public ObjectAdapter(Volt220V adaptee) {\n        volt220V = adaptee;\n    }\n\n    @Override\n    public int get5V() {\n        return 5;\n    }\n        \n    public int get220V() {\n        return volt220V.get220V();\n    }  \n}\n```\n关于 Android 中 ListView 中的 Adapter，可以参考：[Android源码之ListView的适配器模式](https://blog.csdn.net/bboyfeiyu/article/details/43950185)\n\n## 组合模式\n将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。\n\n- 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。\n- 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。\n- 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。\n\n对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。\n\n```Java\n//抽象构件，声明一个接口用于访问和管理Component的子部件\nabstract class Component {\n\n    public Component() { }\n\n    public abstract void add(Component component);\n\n    public abstract void remove(Component component);\n\n    //显示层级结构\n    public abstract void Display(int level);\n}\n\n//叶子节点\nclass Leaf extends Component {\n\n    public Leaf() {\n        super();\n    }\n\n    //无意义的实现\n    @Override\n    public void add(Component component) { }\n\n    //无意义的实现\n    @Override\n    public void remove(Component component) { }\n\n    @Override\n    public void Display(int level) {\n        System.out.println(\"-\" + level);\n    }\n}\n\n//枝节点\nclass Composite extends Component {\n\n    public Composite() {\n        super();\n    }\n\n    private List<Component> children = new ArrayList<>();\n\n    @Override\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    @Override\n    public void Display(int level) {\n        children.forEach(\n                component -> component.Display(level + 2)\n        );\n    }\n}\n\n```\n对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。\n\n## 装饰器模式\n向一个现有的对象添加新的功能，同时又不改变其结构。<br>\n创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。\n\n```Java\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Draw a circle\");\n    }\n}\n\n//实现了 Shape 接口的抽象装饰类。\nabstract class ShapeDecorator implements Shape {\n\n    Shape decoratedShape;\n\n    public ShapeDecorator(Shape decoratedShape) {\n        this.decoratedShape = decoratedShape;\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n    }\n}\n\n//具体的装饰类\nclass RedShapeDecorator extends ShapeDecorator {\n\n    public RedShapeDecorator(Shape decoratedShape) {\n        super(decoratedShape);\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n        setRedBorder(decoratedShape);\n    }\n\n    private void setRedBorder(Shape decoratedShape) {\n        System.out.println(\"Border color: Red\");\n    }\n}\n```\n\n## 代理模式\n下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\n```Java\ninterface Image {\n    void display();\n}\n\nclass RealImage implements Image {\n\n    private String fileName;\n\n    public RealImage(String fileName){\n        this.fileName = fileName;\n        loadFromDisk(fileName);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Displaying \" + fileName);\n    }\n\n    private void loadFromDisk(String fileName){\n        System.out.println(\"Loading \" + fileName);\n    }\n}\n\nclass ProxyImage implements Image {\n\n    private RealImage realImage;\n    private String fileName;\n\n    public ProxyImage(String fileName){\n        this.fileName = fileName;\n    }\n\n    @Override\n    public void display() {\n        if(realImage == null){\n            realImage = new RealImage(fileName);\n        }\n        realImage.display();\n    }\n}\n```\n\n静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br>\nJava中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。\n\n```Java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DisplayHandler implements InvocationHandler {\n\n    //要代理的真实对象\n    private Object obj;\n\n    public DisplayHandler(Object obj) {\n        this.obj = obj;\n    }\n\n    /**\n     *\n     * @param proxy 代理类代理的真实代理对象\n     * @param method 所要调用某个对象真实的方法的Method对象\n     * @param args 指代代理对象方法传递的参数\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //真实的对象执行之前\n        System.out.println(\"Before invoke...\");\n\n        Object invoke = method.invoke(obj, args);\n\n        //真实的对象执行之后\n        System.out.println(\"After invoke...\");\n        return invoke;\n    }\n}\n\npublic static void main(String[] args) {\n    Image image = new RealImage(\"hello.jpg\");\n    InvocationHandler handler = new DisplayHandler(image);\n\n    /*\n     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象\n     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法\n     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上\n     */\n    Image proxy = (Image) Proxy.newProxyInstance(\n            handler.getClass().getClassLoader(),\n            image.getClass().getInterfaces(),\n            handler);\n    proxy.display();\n}\n```\n控制台输出结果为 \n```\nLoading hello.jpg\nBefore invoke...\nDisplaying hello.jpg\nAfter invoke...\n```\n\n代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。\n\n## 其他\n\n### 过滤器模式\n简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。\n\n### 桥接模式\n桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。\n\n举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。\n\n### 外观模式\n外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。\n\n简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。\n\n\n### 享元模式\n所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点\n\n```Java\npublic class FlyweightFactory{\n\n    static Map<String, Shape> shapes = new HashMap<String, Shape>();\n    \n    public static Shape getShape(String key){\n        Shape shape = shapes.get(key);\n        if(shape == null){\n            shape = new Circle(key);\n            shapes.put(key, shape);\n        }\n        return shape;\n    }\n    \n    public static int getSum(){\n        return shapes.size();\n    }\n}\n```\n\n### 补充\n从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是\"转换行为\"，外观模式是一种\"简化行为\"。","slug":"Java设计模式：结构型模式","published":1,"updated":"2019-03-15T15:27:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxj003ay4up6ghy4259","content":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<a id=\"more\"></a></p>\n<p>用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此<code>Volt5V</code>称为<code>Target</code>，而不兼容的220V电压称之为<code>Adaptee</code>，我们的目的是适配设计一个<code>Adpater</code>，方法有两种。</p>\n<h3 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Volt5V</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volt220V</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Volt220V</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>{</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    Adapter adapter = <span class=\"keyword\">new</span> Adapter();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"获取需要的5V电源：\"</span> + adapter.get5V());</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h3><p>与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。<br>　　<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Volt220V volt220V;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObjectAdapter</span><span class=\"params\">(Volt220V adaptee)</span> </span>{</span><br><span class=\"line\">        volt220V = adaptee;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> volt220V.get220V();</span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>关于 Android 中 ListView 中的 Adapter，可以参考：<a href=\"https://blog.csdn.net/bboyfeiyu/article/details/43950185\" target=\"_blank\" rel=\"noopener\">Android源码之ListView的适配器模式</a></p>\n<h2 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h2><p>将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。</p>\n<ul>\n<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>\n<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>\n<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。</li>\n</ul>\n<p>对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象构件，声明一个接口用于访问和管理Component的子部件</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">()</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示层级结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//叶子节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>{</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-\"</span> + level);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枝节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List<Component> children = <span class=\"keyword\">new</span> ArrayList<>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>{</span><br><span class=\"line\">        children.add(component);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>{</span><br><span class=\"line\">        children.remove(component);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>{</span><br><span class=\"line\">        children.forEach(</span><br><span class=\"line\">                component -> component.Display(level + <span class=\"number\">2</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。</p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>向一个现有的对象添加新的功能，同时又不改变其结构。<br><br>创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Shape</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>{</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Draw a circle\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现了 Shape 接口的抽象装饰类。</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeDecorator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    Shape decoratedShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.decoratedShape = decoratedShape;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//具体的装饰类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedShapeDecorator</span> <span class=\"keyword\">extends</span> <span class=\"title\">ShapeDecorator</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(decoratedShape);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">        setRedBorder(decoratedShape);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedBorder</span><span class=\"params\">(Shape decoratedShape)</span> </span>{</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Border color: Red\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Image</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RealImage</span><span class=\"params\">(String fileName)</span></span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">        loadFromDisk(fileName);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Displaying \"</span> + fileName);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromDisk</span><span class=\"params\">(String fileName)</span></span>{</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Loading \"</span> + fileName);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealImage realImage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyImage</span><span class=\"params\">(String fileName)</span></span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(realImage == <span class=\"keyword\">null</span>){</span><br><span class=\"line\">            realImage = <span class=\"keyword\">new</span> RealImage(fileName);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        realImage.display();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br><br>Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisplayHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//要代理的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DisplayHandler</span><span class=\"params\">(Object obj)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类代理的真实代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 所要调用某个对象真实的方法的Method对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 指代代理对象方法传递的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>{</span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Before invoke...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object invoke = method.invoke(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After invoke...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    Image image = <span class=\"keyword\">new</span> RealImage(<span class=\"string\">\"hello.jpg\"</span>);</span><br><span class=\"line\">    InvocationHandler handler = <span class=\"keyword\">new</span> DisplayHandler(image);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Image proxy = (Image) Proxy.newProxyInstance(</span><br><span class=\"line\">            handler.getClass().getClassLoader(),</span><br><span class=\"line\">            image.getClass().getInterfaces(),</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    proxy.display();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出结果为<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Loading hello.jpg</span><br><span class=\"line\">Before invoke...</span><br><span class=\"line\">Displaying hello.jpg</span><br><span class=\"line\">After invoke...</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"过滤器模式\"><a href=\"#过滤器模式\" class=\"headerlink\" title=\"过滤器模式\"></a>过滤器模式</h3><p>简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。</p>\n<h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。</p>\n<p>举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。</p>\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>\n<p>简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。</p>\n<h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><p>所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlyweightFactory</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map<String, Shape> shapes = <span class=\"keyword\">new</span> HashMap<String, Shape>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">getShape</span><span class=\"params\">(String key)</span></span>{</span><br><span class=\"line\">        Shape shape = shapes.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shape == <span class=\"keyword\">null</span>){</span><br><span class=\"line\">            shape = <span class=\"keyword\">new</span> Circle(key);</span><br><span class=\"line\">            shapes.put(key, shape);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shape;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shapes.size();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":7591,"excerpt":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>","more":"<p></p>\n<p>用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此<code>Volt5V</code>称为<code>Target</code>，而不兼容的220V电压称之为<code>Adaptee</code>，我们的目的是适配设计一个<code>Adpater</code>，方法有两种。</p>\n<h3 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volt220V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Volt220V</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Adapter adapter = <span class=\"keyword\">new</span> Adapter();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"获取需要的5V电源：\"</span> + adapter.get5V());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h3><p>与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。<br>　　<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Volt220V volt220V;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObjectAdapter</span><span class=\"params\">(Volt220V adaptee)</span> </span>&#123;</span><br><span class=\"line\">        volt220V = adaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> volt220V.get220V();</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 Android 中 ListView 中的 Adapter，可以参考：<a href=\"https://blog.csdn.net/bboyfeiyu/article/details/43950185\" target=\"_blank\" rel=\"noopener\">Android源码之ListView的适配器模式</a></p>\n<h2 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h2><p>将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。</p>\n<ul>\n<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>\n<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>\n<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。</li>\n</ul>\n<p>对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象构件，声明一个接口用于访问和管理Component的子部件</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示层级结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//叶子节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-\"</span> + level);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枝节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Component&gt; children = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.add(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.remove(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        children.forEach(</span><br><span class=\"line\">                component -&gt; component.Display(level + <span class=\"number\">2</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。</p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>向一个现有的对象添加新的功能，同时又不改变其结构。<br><br>创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Draw a circle\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现了 Shape 接口的抽象装饰类。</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeDecorator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Shape decoratedShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.decoratedShape = decoratedShape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//具体的装饰类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedShapeDecorator</span> <span class=\"keyword\">extends</span> <span class=\"title\">ShapeDecorator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">        setRedBorder(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedBorder</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Border color: Red\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RealImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">        loadFromDisk(fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Displaying \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromDisk</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Loading \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealImage realImage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(realImage == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            realImage = <span class=\"keyword\">new</span> RealImage(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        realImage.display();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br><br>Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisplayHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//要代理的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DisplayHandler</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类代理的真实代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 所要调用某个对象真实的方法的Method对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 指代代理对象方法传递的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Before invoke...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object invoke = method.invoke(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After invoke...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Image image = <span class=\"keyword\">new</span> RealImage(<span class=\"string\">\"hello.jpg\"</span>);</span><br><span class=\"line\">    InvocationHandler handler = <span class=\"keyword\">new</span> DisplayHandler(image);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Image proxy = (Image) Proxy.newProxyInstance(</span><br><span class=\"line\">            handler.getClass().getClassLoader(),</span><br><span class=\"line\">            image.getClass().getInterfaces(),</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    proxy.display();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Loading hello.jpg</span><br><span class=\"line\">Before invoke...</span><br><span class=\"line\">Displaying hello.jpg</span><br><span class=\"line\">After invoke...</span><br></pre></td></tr></table></figure></p>\n<p>代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"过滤器模式\"><a href=\"#过滤器模式\" class=\"headerlink\" title=\"过滤器模式\"></a>过滤器模式</h3><p>简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。</p>\n<h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。</p>\n<p>举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。</p>\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>\n<p>简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。</p>\n<h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><p>所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlyweightFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;String, Shape&gt; shapes = <span class=\"keyword\">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">getShape</span><span class=\"params\">(String key)</span></span>&#123;</span><br><span class=\"line\">        Shape shape = shapes.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shape == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            shape = <span class=\"keyword\">new</span> Circle(key);</span><br><span class=\"line\">            shapes.put(key, shape);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shapes.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。</p>"},{"title":"Android IPC 机制详解","date":"2019-02-23T11:12:35.000Z","_content":"\nIPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。<!--more-->\n\n## 应用场景\n只有在多进程场景下才需要 IPC 机制。\n\n多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。\n\n使用多进程会造成如下的问题：\n- 静态成员和单例模式完全失效\n- 线程同步机制完全失效\n- SharedPreferences 可靠性下降\n- Application 会多次创建\n\n对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。\n\n## 基础概念\n\n### Serializable 接口\nJava 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个`seriaVersionUID`即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。\n\n```Java\npublic class User implements Serializable {\n    private static final long seriaVersionUID = 519067123721295773L\n    ...\n}\n\n//序列化过程\nUser user = new User(\"name\", 18);\nObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"file.txt\"));\nout.writeObject(user);\nout.close\n\n//反序列化过程\nObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"file.txt\"));\nUser user = (User) in.readObject();\nin.close\n```\n使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。\n\nJava 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。\n\n### Parcelable 接口\nAndroid 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。\n\n其与 Serializable 的区别在于\n- Parcelable 使用更复杂，后者如上面的代码，足够简洁。\n- 使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。\n- 使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。\n\n标准写法如下\n```Java\npublic class User implements Parcelable {\n\n    private String name;\n    private int id;\n\n    protected User(Parcel in) {\n        name = in.readString();\n        id = in.readInt();\n    }\n\n    /*\n        实例化静态变量CREATOR\n        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法\n     */\n    public static final Creator<User> CREATOR = new Creator<User>() {\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(name);\n        dest.writeInt(id);\n    }\n}\n```\n\n通过 Intent 传递和获取数据\n```Java\n//传递\nUser user = new User(\"Name\", 18);\nIntent intent = new Intent();\nintent.putExtra(\"data\", user);\n\n//使用\nUser user = getIntent().getParcelableExtra(\"data\");\n```\n\n### Binder\nBinder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。\n\n- 从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。\n- 从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。\n\n更多关于 Binder：[图解Android - Binder 和 Service](https://www.cnblogs.com/samchen2009/p/3316001.html)\n\n## 实现方式\n\n### Bundle\nBundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。\n\n### 文件共享\n利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。\n\n缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。\n\n### Socket\nSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。\n\n### AIDL\n\n#### 概念\nAndroid Interface Definition Language，Android 接口定义语言。\n\n- 数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下\n\n  > Java 中的八种基本数据类型、String、CharSequence。<br>\n  >\n  > List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br>\n  >\n  > Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br>\n\n- 定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。\n\n  > in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。\n\n关于更多：[你真的理解AIDL中的in，out，inout么?](https://blog.csdn.net/luoyanglizi/article/details/51958091)\n\n- 两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。 \n  注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。\n\n#### 实现\n第一类 AIDL 文件：\n```Java\n// Book.aidl\n// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用\n// 注意：Book.aidl 与 Book.java的包名应当是一样的\npackage com.febers.aidldemo;\n\n//注意parcelable是小写\nparcelable Book;\n```\n\n> 自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 `writeToParcel`方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现`readFromParcel`方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。\n\n第二类 AIDL 文件：\n```Java\n// BookManager.aidl\npackage com.lypeer.ipcclient;\n//导入所需要使用的非默认支持数据类型的包\nimport com.febers.aidldemo.Book;\n\ninterface BookManager {\n\n    //所有的返回值前都不需要加任何东西，不管是什么数据类型\n    List<Book> getBooks();\n    Book getBook();\n    int getBookCount();\n\n    //传参时，Java基本数据类型、String 以及 CharSequence 之外的类型\n    //都需要在前面加上定向tag，具体加什么量需而定\n    void setBookPrice(in Book book , int price)\n    void setBookName(in Book book , String name)\n    void addBookIn(in Book book);\n    void addBookOut(out Book book);\n    void addBookInout(inout Book book);\n}\n```\n完成上面的步骤之后，`build`项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。\n\n服务端\n```Java\n\npublic class AIDLService extends Service {\n\n    public final String TAG = this.getClass().getSimpleName();\n\n    //包含Book对象的list\n    private List<Book> mBooks = new ArrayList<>();\n\n    //由AIDL文件生成的BookManager\n    private final BookManager.Stub mBookManager = new BookManager.Stub() {\n        @Override\n        public List<Book> getBooks() throws RemoteException {\n            synchronized (this) {\n                Log.e(TAG, \"invoking getBooks() method , now the list is : \" + mBooks.toString());\n                if (mBooks != null) {\n                    return mBooks;\n                }\n                return new ArrayList<>();\n            }\n        }\n\n        @Override\n        public void addBook(Book book) throws RemoteException {\n            synchronized (this) {\n                if (mBooks == null) {\n                    mBooks = new ArrayList<>();\n                }\n                if (book == null) {\n                    Log.e(TAG, \"Book is null in In\");\n                    book = new Book();\n                }\n                //尝试修改book的参数，主要是为了观察其到客户端的反馈\n                book.setPrice(2333);\n                if (!mBooks.contains(book)) {\n                    mBooks.add(book);\n                }\n                //打印mBooks列表，观察客户端传过来的值\n                Log.e(TAG, \"invoking addBooks() method , now the list is : \" + mBooks.toString());\n            }\n        }\n    };\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Book book = new Book();\n        book.setName(\"Android开发艺术探索\");\n        book.setPrice(28);\n        mBooks.add(book);   \n    }\n\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.e(getClass().getSimpleName(), String.format(\"on bind,intent = %s\", intent.toString()));\n        return mBookManager;\n    }\n}\n```\n\n客户端\n```Java\npublic class AIDLActivity extends AppCompatActivity {\n\n    //由AIDL文件生成的 Java 类\n    private BookManager mBookManager = null;\n\n    //标志当前与服务端连接状况的布尔值，false为未连接，true为连接中\n    private boolean mBound = false;\n\n    //包含Book对象的list\n    private List<Book> mBooks;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_aidl);\n    }\n\n    /**\n     * 按钮的点击事件，点击之后调用服务端的addBookIn方法\n     *\n     * @param view\n     */\n    public void addBook(View view) {\n        //如果与服务端的连接处于未连接状态，则尝试连接\n        if (!mBound) {\n            attemptToBindService();\n            Toast.makeText(this, \"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\", Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (mBookManager == null) return;\n\n        Book book = new Book();\n        book.setName(\"APP研发录In\");\n        book.setPrice(30);\n        try {\n            mBookManager.addBook(book);\n            Log.e(getLocalClassName(), book.toString());\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 尝试与服务端建立连接\n     */\n    private void attemptToBindService() {\n        Intent intent = new Intent();\n        intent.setAction(\"com.febers.aidl\");\n        intent.setPackage(\"com.febers.aidldemo\");\n        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        if (!mBound) {\n            attemptToBindService();\n        }\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (mBound) {\n            unbindService(mServiceConnection);\n            mBound = false;\n        }\n    }\n\n    private ServiceConnection mServiceConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            Log.e(getLocalClassName(), \"service connected\");\n            mBookManager = BookManager.Stub.asInterface(service);\n            mBound = true;\n\n            if (mBookManager != null) {\n                try {\n                    mBooks = mBookManager.getBooks();\n                    Log.e(getLocalClassName(), mBooks.toString());\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            Log.e(getLocalClassName(), \"service disconnected\");\n            mBound = false;\n        }\n    };\n}\n```\n当然不要忘记在 Manifest 文件中注册 Service。\n控制台显示信息如下：\n> //服务端的 log 信息<br>\n> 1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br>\n> 2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br>\n> 3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]\n\n> //客户端的 log 信息<br>\n> 1，service connected<br>\n> 2，[name : Android开发艺术探索 , price : 28]<br>\n> 3，name : APP研发录In , price : 2333\n\n### Messager\nMessager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。\n\n#### 概念\nMessenger 有两个构造函数，分贝以 Handler 和 Binder 为参数\n```Java\nprivate final IMessenger mTarget;\npublic Messenger(Handler target) {\n    mTarget = target.getIMessenger();\n}\npublic Messenger(IBinder target) {\n    mTarget = IMessenger.Stub.asInterface(target);    //和前面的 AIDL 很相似吧\n}\n```\n\n`Handler.getIMessenger`源码：\n```Java\nfinal IMessenger getIMessenger() {\n    synchronized (mQueue) {\n        if (mMessenger != null) {\n            return mMessenger;\n        }\n        mMessenger = new MessengerImpl();\n        return mMessenger;\n    }\n}\n```\nIMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法`send(android.os.Message msg)`。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：\n```Java\nprivate final class MessengerImpl extends IMessenger.Stub {\n    public void send(Message msg) {\n        msg.sendingUid = Binder.getCallingUid();\n        Handler.this.sendMessage(msg);\n    }\n}\n```\n所以可以使用`Handler.handlerMessage`接收消息。Messenger 中对`send`的实现如下：\n```Java\npublic void send(Message message) throws RemoteException {\n    mTarget.send(message);\n}\n```\nMessenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部`send`方法实际上是调用 IMessenger 实现的`send`方法。\n\nMessenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。\n\n#### 实现\n服务端\n```Java\npublic class MessengerService extends Service {\n\n    private final String TAG = this.getClass().getSimpleName();\n\n    Messenger mMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9527) {\n                if (msg.getData() == null) {\n                    return;\n                }\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");  //接收客户端的消息\n                Log.e(TAG, \"Message from client: \" + content);\n\n                //回复消息给客户端\n                Message replyMsg = Message.obtain();\n                replyMsg.arg1 = 9528;\n                Bundle bundle = new Bundle();\n                bundle.putString(\"MSG_CONTENT\", \"已收到消息\");\n                replyMsg.setData(bundle);\n\n                try {\n                    msg.replyTo.send(replyMsg);     //回信\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n\n    @Nullable\n    @Override\n    public IBinder onBind(final Intent intent) {\n        return mMessenger.getBinder();\n    }\n}\n\n```\n\n客户端代码片段\n```Java\npublic class MessagerActivity extends AppCompatActivity {\n\n    Messenger mClientMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9528){\n                if (msg.getData() == null){\n                    return;\n                }\n\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");\n                Log.e(TAG, \"Message from server: \" + content);\n            }\n        }\n    });\n\n    //服务端的 Messenger\n    private Messenger mServerMessenger;\n\n    private ServiceConnection mMessengerConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(final ComponentName name, final IBinder service) {\n            mServerMessenger = new Messenger(service);\n        }\n\n        @Override\n        public void onServiceDisconnected(final ComponentName name) {\n            mServerMessenger = null;\n        }\n    };\n    \n    //发送消息\n    public void sendMsg() {\n        String msgContent = \"消息\"；\n\n        Message message = Message.obtain();\n        message.arg1 = 9527;\n        Bundle bundle = new Bundle();\n        bundle.putString(\"MSG_CONTENT\", msgContent);\n        message.setData(bundle);\n        message.replyTo = mClientMessenger;     //指定回信人是客户端定义的\n\n        try {\n            mServerMessenger.send(message);\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### ContentProvider\n主要用于不同的应用程序之间实现数据共享功能","source":"_posts/Android-IPC-机制详解.md","raw":"---\ntitle: Android IPC 机制详解\ndate: 2019-02-23 19:12:35\ntags:\n- Android\n- 多进程通信\ncategories:\n- Android\n---\n\nIPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。<!--more-->\n\n## 应用场景\n只有在多进程场景下才需要 IPC 机制。\n\n多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。\n\n使用多进程会造成如下的问题：\n- 静态成员和单例模式完全失效\n- 线程同步机制完全失效\n- SharedPreferences 可靠性下降\n- Application 会多次创建\n\n对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。\n\n## 基础概念\n\n### Serializable 接口\nJava 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个`seriaVersionUID`即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。\n\n```Java\npublic class User implements Serializable {\n    private static final long seriaVersionUID = 519067123721295773L\n    ...\n}\n\n//序列化过程\nUser user = new User(\"name\", 18);\nObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"file.txt\"));\nout.writeObject(user);\nout.close\n\n//反序列化过程\nObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"file.txt\"));\nUser user = (User) in.readObject();\nin.close\n```\n使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。\n\nJava 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。\n\n### Parcelable 接口\nAndroid 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。\n\n其与 Serializable 的区别在于\n- Parcelable 使用更复杂，后者如上面的代码，足够简洁。\n- 使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。\n- 使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。\n\n标准写法如下\n```Java\npublic class User implements Parcelable {\n\n    private String name;\n    private int id;\n\n    protected User(Parcel in) {\n        name = in.readString();\n        id = in.readInt();\n    }\n\n    /*\n        实例化静态变量CREATOR\n        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法\n     */\n    public static final Creator<User> CREATOR = new Creator<User>() {\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(name);\n        dest.writeInt(id);\n    }\n}\n```\n\n通过 Intent 传递和获取数据\n```Java\n//传递\nUser user = new User(\"Name\", 18);\nIntent intent = new Intent();\nintent.putExtra(\"data\", user);\n\n//使用\nUser user = getIntent().getParcelableExtra(\"data\");\n```\n\n### Binder\nBinder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。\n\n- 从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。\n- 从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。\n\n更多关于 Binder：[图解Android - Binder 和 Service](https://www.cnblogs.com/samchen2009/p/3316001.html)\n\n## 实现方式\n\n### Bundle\nBundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。\n\n### 文件共享\n利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。\n\n缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。\n\n### Socket\nSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。\n\n### AIDL\n\n#### 概念\nAndroid Interface Definition Language，Android 接口定义语言。\n\n- 数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下\n\n  > Java 中的八种基本数据类型、String、CharSequence。<br>\n  >\n  > List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br>\n  >\n  > Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br>\n\n- 定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。\n\n  > in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。\n\n关于更多：[你真的理解AIDL中的in，out，inout么?](https://blog.csdn.net/luoyanglizi/article/details/51958091)\n\n- 两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。 \n  注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。\n\n#### 实现\n第一类 AIDL 文件：\n```Java\n// Book.aidl\n// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用\n// 注意：Book.aidl 与 Book.java的包名应当是一样的\npackage com.febers.aidldemo;\n\n//注意parcelable是小写\nparcelable Book;\n```\n\n> 自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 `writeToParcel`方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现`readFromParcel`方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。\n\n第二类 AIDL 文件：\n```Java\n// BookManager.aidl\npackage com.lypeer.ipcclient;\n//导入所需要使用的非默认支持数据类型的包\nimport com.febers.aidldemo.Book;\n\ninterface BookManager {\n\n    //所有的返回值前都不需要加任何东西，不管是什么数据类型\n    List<Book> getBooks();\n    Book getBook();\n    int getBookCount();\n\n    //传参时，Java基本数据类型、String 以及 CharSequence 之外的类型\n    //都需要在前面加上定向tag，具体加什么量需而定\n    void setBookPrice(in Book book , int price)\n    void setBookName(in Book book , String name)\n    void addBookIn(in Book book);\n    void addBookOut(out Book book);\n    void addBookInout(inout Book book);\n}\n```\n完成上面的步骤之后，`build`项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。\n\n服务端\n```Java\n\npublic class AIDLService extends Service {\n\n    public final String TAG = this.getClass().getSimpleName();\n\n    //包含Book对象的list\n    private List<Book> mBooks = new ArrayList<>();\n\n    //由AIDL文件生成的BookManager\n    private final BookManager.Stub mBookManager = new BookManager.Stub() {\n        @Override\n        public List<Book> getBooks() throws RemoteException {\n            synchronized (this) {\n                Log.e(TAG, \"invoking getBooks() method , now the list is : \" + mBooks.toString());\n                if (mBooks != null) {\n                    return mBooks;\n                }\n                return new ArrayList<>();\n            }\n        }\n\n        @Override\n        public void addBook(Book book) throws RemoteException {\n            synchronized (this) {\n                if (mBooks == null) {\n                    mBooks = new ArrayList<>();\n                }\n                if (book == null) {\n                    Log.e(TAG, \"Book is null in In\");\n                    book = new Book();\n                }\n                //尝试修改book的参数，主要是为了观察其到客户端的反馈\n                book.setPrice(2333);\n                if (!mBooks.contains(book)) {\n                    mBooks.add(book);\n                }\n                //打印mBooks列表，观察客户端传过来的值\n                Log.e(TAG, \"invoking addBooks() method , now the list is : \" + mBooks.toString());\n            }\n        }\n    };\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Book book = new Book();\n        book.setName(\"Android开发艺术探索\");\n        book.setPrice(28);\n        mBooks.add(book);   \n    }\n\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.e(getClass().getSimpleName(), String.format(\"on bind,intent = %s\", intent.toString()));\n        return mBookManager;\n    }\n}\n```\n\n客户端\n```Java\npublic class AIDLActivity extends AppCompatActivity {\n\n    //由AIDL文件生成的 Java 类\n    private BookManager mBookManager = null;\n\n    //标志当前与服务端连接状况的布尔值，false为未连接，true为连接中\n    private boolean mBound = false;\n\n    //包含Book对象的list\n    private List<Book> mBooks;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_aidl);\n    }\n\n    /**\n     * 按钮的点击事件，点击之后调用服务端的addBookIn方法\n     *\n     * @param view\n     */\n    public void addBook(View view) {\n        //如果与服务端的连接处于未连接状态，则尝试连接\n        if (!mBound) {\n            attemptToBindService();\n            Toast.makeText(this, \"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\", Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (mBookManager == null) return;\n\n        Book book = new Book();\n        book.setName(\"APP研发录In\");\n        book.setPrice(30);\n        try {\n            mBookManager.addBook(book);\n            Log.e(getLocalClassName(), book.toString());\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 尝试与服务端建立连接\n     */\n    private void attemptToBindService() {\n        Intent intent = new Intent();\n        intent.setAction(\"com.febers.aidl\");\n        intent.setPackage(\"com.febers.aidldemo\");\n        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        if (!mBound) {\n            attemptToBindService();\n        }\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (mBound) {\n            unbindService(mServiceConnection);\n            mBound = false;\n        }\n    }\n\n    private ServiceConnection mServiceConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            Log.e(getLocalClassName(), \"service connected\");\n            mBookManager = BookManager.Stub.asInterface(service);\n            mBound = true;\n\n            if (mBookManager != null) {\n                try {\n                    mBooks = mBookManager.getBooks();\n                    Log.e(getLocalClassName(), mBooks.toString());\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            Log.e(getLocalClassName(), \"service disconnected\");\n            mBound = false;\n        }\n    };\n}\n```\n当然不要忘记在 Manifest 文件中注册 Service。\n控制台显示信息如下：\n> //服务端的 log 信息<br>\n> 1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br>\n> 2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br>\n> 3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]\n\n> //客户端的 log 信息<br>\n> 1，service connected<br>\n> 2，[name : Android开发艺术探索 , price : 28]<br>\n> 3，name : APP研发录In , price : 2333\n\n### Messager\nMessager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。\n\n#### 概念\nMessenger 有两个构造函数，分贝以 Handler 和 Binder 为参数\n```Java\nprivate final IMessenger mTarget;\npublic Messenger(Handler target) {\n    mTarget = target.getIMessenger();\n}\npublic Messenger(IBinder target) {\n    mTarget = IMessenger.Stub.asInterface(target);    //和前面的 AIDL 很相似吧\n}\n```\n\n`Handler.getIMessenger`源码：\n```Java\nfinal IMessenger getIMessenger() {\n    synchronized (mQueue) {\n        if (mMessenger != null) {\n            return mMessenger;\n        }\n        mMessenger = new MessengerImpl();\n        return mMessenger;\n    }\n}\n```\nIMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法`send(android.os.Message msg)`。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：\n```Java\nprivate final class MessengerImpl extends IMessenger.Stub {\n    public void send(Message msg) {\n        msg.sendingUid = Binder.getCallingUid();\n        Handler.this.sendMessage(msg);\n    }\n}\n```\n所以可以使用`Handler.handlerMessage`接收消息。Messenger 中对`send`的实现如下：\n```Java\npublic void send(Message message) throws RemoteException {\n    mTarget.send(message);\n}\n```\nMessenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部`send`方法实际上是调用 IMessenger 实现的`send`方法。\n\nMessenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。\n\n#### 实现\n服务端\n```Java\npublic class MessengerService extends Service {\n\n    private final String TAG = this.getClass().getSimpleName();\n\n    Messenger mMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9527) {\n                if (msg.getData() == null) {\n                    return;\n                }\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");  //接收客户端的消息\n                Log.e(TAG, \"Message from client: \" + content);\n\n                //回复消息给客户端\n                Message replyMsg = Message.obtain();\n                replyMsg.arg1 = 9528;\n                Bundle bundle = new Bundle();\n                bundle.putString(\"MSG_CONTENT\", \"已收到消息\");\n                replyMsg.setData(bundle);\n\n                try {\n                    msg.replyTo.send(replyMsg);     //回信\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n\n    @Nullable\n    @Override\n    public IBinder onBind(final Intent intent) {\n        return mMessenger.getBinder();\n    }\n}\n\n```\n\n客户端代码片段\n```Java\npublic class MessagerActivity extends AppCompatActivity {\n\n    Messenger mClientMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9528){\n                if (msg.getData() == null){\n                    return;\n                }\n\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");\n                Log.e(TAG, \"Message from server: \" + content);\n            }\n        }\n    });\n\n    //服务端的 Messenger\n    private Messenger mServerMessenger;\n\n    private ServiceConnection mMessengerConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(final ComponentName name, final IBinder service) {\n            mServerMessenger = new Messenger(service);\n        }\n\n        @Override\n        public void onServiceDisconnected(final ComponentName name) {\n            mServerMessenger = null;\n        }\n    };\n    \n    //发送消息\n    public void sendMsg() {\n        String msgContent = \"消息\"；\n\n        Message message = Message.obtain();\n        message.arg1 = 9527;\n        Bundle bundle = new Bundle();\n        bundle.putString(\"MSG_CONTENT\", msgContent);\n        message.setData(bundle);\n        message.replyTo = mClientMessenger;     //指定回信人是客户端定义的\n\n        try {\n            mServerMessenger.send(message);\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### ContentProvider\n主要用于不同的应用程序之间实现数据共享功能","slug":"Android-IPC-机制详解","published":1,"updated":"2019-06-02T04:53:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxk003by4upk9fk9wgr","content":"<p>IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。<a id=\"more\"></a></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>只有在多进程场景下才需要 IPC 机制。</p>\n<p>多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。</p>\n<p>使用多进程会造成如下的问题：</p>\n<ul>\n<li>静态成员和单例模式完全失效</li>\n<li>线程同步机制完全失效</li>\n<li>SharedPreferences 可靠性下降</li>\n<li>Application 会多次创建</li>\n</ul>\n<p>对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"Serializable-接口\"><a href=\"#Serializable-接口\" class=\"headerlink\" title=\"Serializable 接口\"></a>Serializable 接口</h3><p>Java 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个<code>seriaVersionUID</code>即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> seriaVersionUID = <span class=\"number\">519067123721295773L</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//序列化过程</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">out.writeObject(user);</span><br><span class=\"line\">out.close</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//反序列化过程</span></span><br><span class=\"line\">ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">User user = (User) in.readObject();</span><br><span class=\"line\">in.close</span><br></pre></td></tr></tbody></table></figure>\n<p>使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。</p>\n<p>Java 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。</p>\n<h3 id=\"Parcelable-接口\"><a href=\"#Parcelable-接口\" class=\"headerlink\" title=\"Parcelable 接口\"></a>Parcelable 接口</h3><p>Android 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。</p>\n<p>其与 Serializable 的区别在于</p>\n<ul>\n<li>Parcelable 使用更复杂，后者如上面的代码，足够简洁。</li>\n<li>使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。</li>\n<li>使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。</li>\n</ul>\n<p>标准写法如下<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">User</span><span class=\"params\">(Parcel in)</span> </span>{</span><br><span class=\"line\">        name = in.readString();</span><br><span class=\"line\">        id = in.readInt();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        实例化静态变量CREATOR</span></span><br><span class=\"line\"><span class=\"comment\">        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Creator<User> CREATOR = <span class=\"keyword\">new</span> Creator<User>() {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">createFromParcel</span><span class=\"params\">(Parcel in)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(in);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> User[] newArray(<span class=\"keyword\">int</span> size) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User[size];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">describeContents</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeToParcel</span><span class=\"params\">(Parcel dest, <span class=\"keyword\">int</span> flags)</span> </span>{</span><br><span class=\"line\">        dest.writeString(name);</span><br><span class=\"line\">        dest.writeInt(id);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>通过 Intent 传递和获取数据<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传递</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">User user = getIntent().getParcelableExtra(<span class=\"string\">\"data\"</span>);</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h3><p>Binder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。</p>\n<ul>\n<li>从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。</li>\n<li>从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。</li>\n</ul>\n<p>更多关于 Binder：<a href=\"https://www.cnblogs.com/samchen2009/p/3316001.html\" target=\"_blank\" rel=\"noopener\">图解Android - Binder 和 Service</a></p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><h3 id=\"Bundle\"><a href=\"#Bundle\" class=\"headerlink\" title=\"Bundle\"></a>Bundle</h3><p>Bundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。</p>\n<h3 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h3><p>利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。</p>\n<p>缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。</p>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。</p>\n<h3 id=\"AIDL\"><a href=\"#AIDL\" class=\"headerlink\" title=\"AIDL\"></a>AIDL</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Android Interface Definition Language，Android 接口定义语言。</p>\n<ul>\n<li><p>数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下</p>\n<blockquote>\n<p>Java 中的八种基本数据类型、String、CharSequence。<br></p>\n<p>List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br></p>\n<p>Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br></p>\n</blockquote>\n</li>\n<li><p>定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。</p>\n<blockquote>\n<p>in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于更多：<a href=\"https://blog.csdn.net/luoyanglizi/article/details/51958091\" target=\"_blank\" rel=\"noopener\">你真的理解AIDL中的in，out，inout么?</a></p>\n<ul>\n<li>两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。<br>注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。</li>\n</ul>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>第一类 AIDL 文件：<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Book.aidl</span></span><br><span class=\"line\"><span class=\"comment\">// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：Book.aidl 与 Book.java的包名应当是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.febers.aidldemo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意parcelable是小写</span></span><br><span class=\"line\">parcelable Book;</span><br></pre></td></tr></tbody></table></figure><p></p>\n<blockquote>\n<p>自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 <code>writeToParcel</code>方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现<code>readFromParcel</code>方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。</p>\n</blockquote>\n<p>第二类 AIDL 文件：<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BookManager.aidl</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</span><br><span class=\"line\"><span class=\"comment\">//导入所需要使用的非默认支持数据类型的包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.febers.aidldemo.Book;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BookManager</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所有的返回值前都不需要加任何东西，不管是什么数据类型</span></span><br><span class=\"line\">    <span class=\"function\">List<Book> <span class=\"title\">getBooks</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Book <span class=\"title\">getBook</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBookCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传参时，Java基本数据类型、String 以及 CharSequence 之外的类型</span></span><br><span class=\"line\">    <span class=\"comment\">//都需要在前面加上定向tag，具体加什么量需而定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBookPrice</span><span class=\"params\">(in Book book , <span class=\"keyword\">int</span> price)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">setBookName</span><span class=\"params\">(in Book book , String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">addBookIn</span><span class=\"params\">(in Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookOut</span><span class=\"params\">(out Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookInout</span><span class=\"params\">(inout Book book)</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>完成上面的步骤之后，<code>build</code>项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。</p>\n<p>服务端<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List<Book> mBooks = <span class=\"keyword\">new</span> ArrayList<>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的BookManager</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BookManager.Stub mBookManager = <span class=\"keyword\">new</span> BookManager.Stub() {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List<Book> <span class=\"title\">getBooks</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>{</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking getBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> mBooks;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList<>();</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(Book book)</span> <span class=\"keyword\">throws</span> RemoteException </span>{</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                    mBooks = <span class=\"keyword\">new</span> ArrayList<>();</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (book == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                    Log.e(TAG, <span class=\"string\">\"Book is null in In\"</span>);</span><br><span class=\"line\">                    book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"comment\">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class=\"line\">                book.setPrice(<span class=\"number\">2333</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mBooks.contains(book)) {</span><br><span class=\"line\">                    mBooks.add(book);</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"comment\">//打印mBooks列表，观察客户端传过来的值</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking addBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"Android开发艺术探索\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">28</span>);</span><br><span class=\"line\">        mBooks.add(book);   </span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{</span><br><span class=\"line\">        Log.e(getClass().getSimpleName(), String.format(<span class=\"string\">\"on bind,intent = %s\"</span>, intent.toString()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mBookManager;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>客户端<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的 Java 类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BookManager mBookManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//标志当前与服务端连接状况的布尔值，false为未连接，true为连接中</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List<Book> mBooks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_aidl);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮的点击事件，点击之后调用服务端的addBookIn方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> view</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(View view)</span> </span>{</span><br><span class=\"line\">        <span class=\"comment\">//如果与服务端的连接处于未连接状态，则尝试连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) {</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBookManager == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"APP研发录In\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">30</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            mBookManager.addBook(book);</span><br><span class=\"line\">            Log.e(getLocalClassName(), book.toString());</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (RemoteException e) {</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试与服务端建立连接</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attemptToBindService</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">        intent.setAction(<span class=\"string\">\"com.febers.aidl\"</span>);</span><br><span class=\"line\">        intent.setPackage(<span class=\"string\">\"com.febers.aidldemo\"</span>);</span><br><span class=\"line\">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) {</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBound) {</span><br><span class=\"line\">            unbindService(mServiceConnection);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mServiceConnection = <span class=\"keyword\">new</span> ServiceConnection() {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>{</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service connected\"</span>);</span><br><span class=\"line\">            mBookManager = BookManager.Stub.asInterface(service);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mBookManager != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                    mBooks = mBookManager.getBooks();</span><br><span class=\"line\">                    Log.e(getLocalClassName(), mBooks.toString());</span><br><span class=\"line\">                } <span class=\"keyword\">catch</span> (RemoteException e) {</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>{</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service disconnected\"</span>);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    };</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>当然不要忘记在 Manifest 文件中注册 Service。<br>控制台显示信息如下：</p>\n<blockquote>\n<p>//服务端的 log 信息<br><br>1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br><br>2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br><br>3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]</p>\n</blockquote>\n<blockquote>\n<p>//客户端的 log 信息<br><br>1，service connected<br><br>2，[name : Android开发艺术探索 , price : 28]<br><br>3，name : APP研发录In , price : 2333</p>\n</blockquote>\n<h3 id=\"Messager\"><a href=\"#Messager\" class=\"headerlink\" title=\"Messager\"></a>Messager</h3><p>Messager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。</p>\n<h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Messenger 有两个构造函数，分贝以 Handler 和 Binder 为参数<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IMessenger mTarget;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(Handler target)</span> </span>{</span><br><span class=\"line\">    mTarget = target.getIMessenger();</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(IBinder target)</span> </span>{</span><br><span class=\"line\">    mTarget = IMessenger.Stub.asInterface(target);    <span class=\"comment\">//和前面的 AIDL 很相似吧</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p><code>Handler.getIMessenger</code>源码：<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> IMessenger <span class=\"title\">getIMessenger</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mQueue) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mMessenger != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        mMessenger = <span class=\"keyword\">new</span> MessengerImpl();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>IMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法<code>send(android.os.Message msg)</code>。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>{</span><br><span class=\"line\">        msg.sendingUid = Binder.getCallingUid();</span><br><span class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>所以可以使用<code>Handler.handlerMessage</code>接收消息。Messenger 中对<code>send</code>的实现如下：<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> RemoteException </span>{</span><br><span class=\"line\">    mTarget.send(message);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>Messenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部<code>send</code>方法实际上是调用 IMessenger 实现的<code>send</code>方法。</p>\n<p>Messenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。</p>\n<h4 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>服务端<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> && msg.arg1 == <span class=\"number\">9527</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);  <span class=\"comment\">//接收客户端的消息</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from client: \"</span> + content);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//回复消息给客户端</span></span><br><span class=\"line\">                Message replyMsg = Message.obtain();</span><br><span class=\"line\">                replyMsg.arg1 = <span class=\"number\">9528</span>;</span><br><span class=\"line\">                Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">                bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, <span class=\"string\">\"已收到消息\"</span>);</span><br><span class=\"line\">                replyMsg.setData(bundle);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                    msg.replyTo.send(replyMsg);     <span class=\"comment\">//回信</span></span><br><span class=\"line\">                } <span class=\"keyword\">catch</span> (RemoteException e) {</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    });</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(<span class=\"keyword\">final</span> Intent intent)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger.getBinder();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>客户端代码片段<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessagerActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mClientMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> && msg.arg1 == <span class=\"number\">9528</span>){</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>){</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\"></span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from server: \"</span> + content);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    });</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//服务端的 Messenger</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger mServerMessenger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mMessengerConnection = <span class=\"keyword\">new</span> ServiceConnection() {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name, <span class=\"keyword\">final</span> IBinder service)</span> </span>{</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">new</span> Messenger(service);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name)</span> </span>{</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    };</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//发送消息</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        String msgContent = <span class=\"string\">\"消息\"</span>；</span><br><span class=\"line\"></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        message.arg1 = <span class=\"number\">9527</span>;</span><br><span class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">        bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, msgContent);</span><br><span class=\"line\">        message.setData(bundle);</span><br><span class=\"line\">        message.replyTo = mClientMessenger;     <span class=\"comment\">//指定回信人是客户端定义的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            mServerMessenger.send(message);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (RemoteException e) {</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"ContentProvider\"><a href=\"#ContentProvider\" class=\"headerlink\" title=\"ContentProvider\"></a>ContentProvider</h3><p>主要用于不同的应用程序之间实现数据共享功能</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":14281,"excerpt":"<p>IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。</p>","more":"<p></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>只有在多进程场景下才需要 IPC 机制。</p>\n<p>多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。</p>\n<p>使用多进程会造成如下的问题：</p>\n<ul>\n<li>静态成员和单例模式完全失效</li>\n<li>线程同步机制完全失效</li>\n<li>SharedPreferences 可靠性下降</li>\n<li>Application 会多次创建</li>\n</ul>\n<p>对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"Serializable-接口\"><a href=\"#Serializable-接口\" class=\"headerlink\" title=\"Serializable 接口\"></a>Serializable 接口</h3><p>Java 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个<code>seriaVersionUID</code>即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> seriaVersionUID = <span class=\"number\">519067123721295773L</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//序列化过程</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">out.writeObject(user);</span><br><span class=\"line\">out.close</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//反序列化过程</span></span><br><span class=\"line\">ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">User user = (User) in.readObject();</span><br><span class=\"line\">in.close</span><br></pre></td></tr></table></figure>\n<p>使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。</p>\n<p>Java 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。</p>\n<h3 id=\"Parcelable-接口\"><a href=\"#Parcelable-接口\" class=\"headerlink\" title=\"Parcelable 接口\"></a>Parcelable 接口</h3><p>Android 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。</p>\n<p>其与 Serializable 的区别在于</p>\n<ul>\n<li>Parcelable 使用更复杂，后者如上面的代码，足够简洁。</li>\n<li>使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。</li>\n<li>使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。</li>\n</ul>\n<p>标准写法如下<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">User</span><span class=\"params\">(Parcel in)</span> </span>&#123;</span><br><span class=\"line\">        name = in.readString();</span><br><span class=\"line\">        id = in.readInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        实例化静态变量CREATOR</span></span><br><span class=\"line\"><span class=\"comment\">        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Creator&lt;User&gt; CREATOR = <span class=\"keyword\">new</span> Creator&lt;User&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">createFromParcel</span><span class=\"params\">(Parcel in)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(in);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> User[] newArray(<span class=\"keyword\">int</span> size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User[size];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">describeContents</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeToParcel</span><span class=\"params\">(Parcel dest, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">        dest.writeString(name);</span><br><span class=\"line\">        dest.writeInt(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过 Intent 传递和获取数据<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传递</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">User user = getIntent().getParcelableExtra(<span class=\"string\">\"data\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h3><p>Binder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。</p>\n<ul>\n<li>从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。</li>\n<li>从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。</li>\n</ul>\n<p>更多关于 Binder：<a href=\"https://www.cnblogs.com/samchen2009/p/3316001.html\" target=\"_blank\" rel=\"noopener\">图解Android - Binder 和 Service</a></p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><h3 id=\"Bundle\"><a href=\"#Bundle\" class=\"headerlink\" title=\"Bundle\"></a>Bundle</h3><p>Bundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。</p>\n<h3 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h3><p>利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。</p>\n<p>缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。</p>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。</p>\n<h3 id=\"AIDL\"><a href=\"#AIDL\" class=\"headerlink\" title=\"AIDL\"></a>AIDL</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Android Interface Definition Language，Android 接口定义语言。</p>\n<ul>\n<li><p>数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下</p>\n<blockquote>\n<p>Java 中的八种基本数据类型、String、CharSequence。<br></p>\n<p>List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br></p>\n<p>Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br></p>\n</blockquote>\n</li>\n<li><p>定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。</p>\n<blockquote>\n<p>in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于更多：<a href=\"https://blog.csdn.net/luoyanglizi/article/details/51958091\" target=\"_blank\" rel=\"noopener\">你真的理解AIDL中的in，out，inout么?</a></p>\n<ul>\n<li>两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。<br>注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。</li>\n</ul>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>第一类 AIDL 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Book.aidl</span></span><br><span class=\"line\"><span class=\"comment\">// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：Book.aidl 与 Book.java的包名应当是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.febers.aidldemo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意parcelable是小写</span></span><br><span class=\"line\">parcelable Book;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 <code>writeToParcel</code>方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现<code>readFromParcel</code>方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。</p>\n</blockquote>\n<p>第二类 AIDL 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BookManager.aidl</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</span><br><span class=\"line\"><span class=\"comment\">//导入所需要使用的非默认支持数据类型的包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.febers.aidldemo.Book;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BookManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所有的返回值前都不需要加任何东西，不管是什么数据类型</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Book <span class=\"title\">getBook</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBookCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传参时，Java基本数据类型、String 以及 CharSequence 之外的类型</span></span><br><span class=\"line\">    <span class=\"comment\">//都需要在前面加上定向tag，具体加什么量需而定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBookPrice</span><span class=\"params\">(in Book book , <span class=\"keyword\">int</span> price)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">setBookName</span><span class=\"params\">(in Book book , String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">addBookIn</span><span class=\"params\">(in Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookOut</span><span class=\"params\">(out Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookInout</span><span class=\"params\">(inout Book book)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完成上面的步骤之后，<code>build</code>项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。</p>\n<p>服务端<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Book&gt; mBooks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的BookManager</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BookManager.Stub mBookManager = <span class=\"keyword\">new</span> BookManager.Stub() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking getBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> mBooks;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(Book book)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mBooks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (book == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    Log.e(TAG, <span class=\"string\">\"Book is null in In\"</span>);</span><br><span class=\"line\">                    book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class=\"line\">                book.setPrice(<span class=\"number\">2333</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mBooks.contains(book)) &#123;</span><br><span class=\"line\">                    mBooks.add(book);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//打印mBooks列表，观察客户端传过来的值</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking addBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"Android开发艺术探索\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">28</span>);</span><br><span class=\"line\">        mBooks.add(book);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(getClass().getSimpleName(), String.format(<span class=\"string\">\"on bind,intent = %s\"</span>, intent.toString()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mBookManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的 Java 类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BookManager mBookManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//标志当前与服务端连接状况的布尔值，false为未连接，true为连接中</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Book&gt; mBooks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_aidl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮的点击事件，点击之后调用服务端的addBookIn方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> view</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果与服务端的连接处于未连接状态，则尝试连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) &#123;</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBookManager == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"APP研发录In\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">30</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mBookManager.addBook(book);</span><br><span class=\"line\">            Log.e(getLocalClassName(), book.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试与服务端建立连接</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attemptToBindService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">        intent.setAction(<span class=\"string\">\"com.febers.aidl\"</span>);</span><br><span class=\"line\">        intent.setPackage(<span class=\"string\">\"com.febers.aidldemo\"</span>);</span><br><span class=\"line\">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) &#123;</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBound) &#123;</span><br><span class=\"line\">            unbindService(mServiceConnection);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mServiceConnection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service connected\"</span>);</span><br><span class=\"line\">            mBookManager = BookManager.Stub.asInterface(service);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mBookManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    mBooks = mBookManager.getBooks();</span><br><span class=\"line\">                    Log.e(getLocalClassName(), mBooks.toString());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service disconnected\"</span>);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然不要忘记在 Manifest 文件中注册 Service。<br>控制台显示信息如下：</p>\n<blockquote>\n<p>//服务端的 log 信息<br><br>1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br><br>2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br><br>3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]</p>\n</blockquote>\n<blockquote>\n<p>//客户端的 log 信息<br><br>1，service connected<br><br>2，[name : Android开发艺术探索 , price : 28]<br><br>3，name : APP研发录In , price : 2333</p>\n</blockquote>\n<h3 id=\"Messager\"><a href=\"#Messager\" class=\"headerlink\" title=\"Messager\"></a>Messager</h3><p>Messager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。</p>\n<h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Messenger 有两个构造函数，分贝以 Handler 和 Binder 为参数<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IMessenger mTarget;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(Handler target)</span> </span>&#123;</span><br><span class=\"line\">    mTarget = target.getIMessenger();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(IBinder target)</span> </span>&#123;</span><br><span class=\"line\">    mTarget = IMessenger.Stub.asInterface(target);    <span class=\"comment\">//和前面的 AIDL 很相似吧</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Handler.getIMessenger</code>源码：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> IMessenger <span class=\"title\">getIMessenger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mQueue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mMessenger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mMessenger = <span class=\"keyword\">new</span> MessengerImpl();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>IMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法<code>send(android.os.Message msg)</code>。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        msg.sendingUid = Binder.getCallingUid();</span><br><span class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以可以使用<code>Handler.handlerMessage</code>接收消息。Messenger 中对<code>send</code>的实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    mTarget.send(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Messenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部<code>send</code>方法实际上是调用 IMessenger 实现的<code>send</code>方法。</p>\n<p>Messenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。</p>\n<h4 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>服务端<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.arg1 == <span class=\"number\">9527</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);  <span class=\"comment\">//接收客户端的消息</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from client: \"</span> + content);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//回复消息给客户端</span></span><br><span class=\"line\">                Message replyMsg = Message.obtain();</span><br><span class=\"line\">                replyMsg.arg1 = <span class=\"number\">9528</span>;</span><br><span class=\"line\">                Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">                bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, <span class=\"string\">\"已收到消息\"</span>);</span><br><span class=\"line\">                replyMsg.setData(bundle);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    msg.replyTo.send(replyMsg);     <span class=\"comment\">//回信</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(<span class=\"keyword\">final</span> Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger.getBinder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端代码片段<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessagerActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mClientMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.arg1 == <span class=\"number\">9528</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from server: \"</span> + content);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//服务端的 Messenger</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger mServerMessenger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mMessengerConnection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name, <span class=\"keyword\">final</span> IBinder service)</span> </span>&#123;</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">new</span> Messenger(service);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name)</span> </span>&#123;</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//发送消息</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String msgContent = <span class=\"string\">\"消息\"</span>；</span><br><span class=\"line\"></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        message.arg1 = <span class=\"number\">9527</span>;</span><br><span class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">        bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, msgContent);</span><br><span class=\"line\">        message.setData(bundle);</span><br><span class=\"line\">        message.replyTo = mClientMessenger;     <span class=\"comment\">//指定回信人是客户端定义的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mServerMessenger.send(message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ContentProvider\"><a href=\"#ContentProvider\" class=\"headerlink\" title=\"ContentProvider\"></a>ContentProvider</h3><p>主要用于不同的应用程序之间实现数据共享功能</p>"},{"title":"Android View 的工作原理","date":"2019-03-01T05:10:14.000Z","_content":"\n在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。\n\n<!--more-->\n\n## 整体过程\n\n### Window\n\n首先简单认识 Window，其表示一个窗口，属于一个抽象类，具体的实现为 PhoneWindow。通过 WindowManager 向 WindowManagerService 发起请求，WMS 负责 Window 的具体生成。\n\n实际上每一个 Window 对应一个 View 和 ViewRootImpl，  因此 Window 不是实际存在的，它通过 ViewRootImpl 以 View 的形式存在。\n\n### ViewRoot 和 DecorView\n\nViewRoot 的具体实现就是上一节所提及的 ViewRootImpl，View 的三大流程（measure、layout、draw）都是通过它来实现的。\n\n在 ActivityThread 中，当 Activity 对象被创建后，会将一个 DecorView 添加到 Window，然后创建 ViewRootImpl 对象，并将 DecorView 和 ViewRootImpl 建立关联，这也验证了上一节的观点。\n\n```java\nroot = new ViewRootImpl(view.getContext(), display);\nroot.setView(view, vparams, panelParentView);\n```\n\nView 的绘制流程是从 ViewRoot 的 `performTraversals` 开始的，经过`measure`（测量 View 的宽高）、`layout`（确定 View 在父容器的位置）、`draw`（将 View 绘制在屏幕上）三个过程，呈现出一个 View。\n\n\n\n![performTraversals](Android-View-的工作原理\\performTraversals.png)\n\n\n\n如图所示，`performTraversals`会依次调用`performMeasure`、`performLayout`、`performDraw`，然后这三个方法分别完成顶级 View 的三大流程。而后，`measure`又会调用`onMeasure`，在其中对所有子元素进行 measure 过程，此时 measure 流程就从父容器传递到子元素了，接着子元素重复上述过程。如此完成整个 View 树的遍历。\n\nmeasure 过程决定了 View 的宽高，可以通过`getMeasuredWidth`和`getMeasuredHeight`获得 View 测量后的宽高，在几乎所有情况下都可以得到 View 最终的数值。\n\nlayout 过程决定了 View 的四个顶点的坐标和实际的 View 的宽高，可以通过`getTop`、`getBottom`、`getLeft`、`getRight`拿到四个顶点的位置，通过`getWidth`、`getHeight`获得 View 的最终宽高。只有 draw 过程完成之后才能呈现 View。\n\n---\n\n![整体布局.webp](Android-View-的工作原理\\整体布局.webp.jpg)\n\n\n\n由上图我们可以看出，一般 DecorView 会包含一个 LinearLayout，其中上面是标题栏，下面是内容栏。在创建 Activity 的时候需要`setContentView`而不是`setView`的原因便是如此。我们的布局加到了  id 为`android.R.id.content`的 FrameLayout 中。\n\n```java\n//得到 content\nViewGroup content = (ViewGroup) findViewById(android.R.id.content)；\n\n//得到开发者设置的 View\nView view = content.getChildAt(0);\n```\n\n## 具体流程\n\n### MeasureSpec\n\n“测量规格”，是 View 测量过程中非常重要的参数。measure 时系统会将 View 的 LayoutParams 根据父容器施加的规则转换成对应的 MeasureSpec，然后再根据 该 MeasureSpec 测量出 View 的宽高。\n\nMeasureSpec 代表一个32位的 int 值，其中高2位代表 SpecMode（测量模式），低30位代表 SpecSize（某种测量模式下的规格大小）。将两个参数打包成一个 int 值的原因是避免过多的对象内存分配。\n\nSpecMode 有三类\n\n| SpecMode    | 含义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| UNSPECIFIED | 父容器不限制 View，一般用于系统内部                          |\n| EXACTLY     | 父容器已检测 VIew 的精确大小，对应参数为`match_parent`和具体的数值 |\n| AT_MOST     | 父容器指定了 View 的最大值，具体大小由 View 决定，对应参数为`wrap_content` |\n\n### MeasureSpec 和 LayoutParams \n\n对于 DecorView，其 MeasureSpec 由窗口尺寸和其自身 LayoutParams 决定，对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和 自身的LayoutParams 共同决定。一旦 MeasureSpec 确定，onMeasure 中就可以确定 View 的测量宽高。\n\n\n\nViewRootImpl 的源码地址：[ViewRootImpl.java](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewRootImpl.java)。查阅源码，得到 DecorView 的测量规则如下\n\n- LayoutParams.MATCH_PARENT：精确模式，大小为窗口大小\n\n- LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口\n\n- 固定大小：精确模式，大小为 LayoutParams 指定的大小\n\n\n\nViewGroup  的源码地址：[ViewGroup.java](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewGroup.java)。查看 ViewGroup 的`measureChildWithMargins`方法\n\n```java\nprotected void measureChildWithMargins(View child,\n            int parentWidthMeasureSpec, int widthUsed,\n            int parentHeightMeasureSpec, int heightUsed) {\n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                        + widthUsed, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                        + heightUsed, lp.height);\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n\n可以看到在调用子元素的`measure`之前，会先得到子元素的 MeasureSpec，很显然其和父容器的 MeasureSpec 以及子元素自身的 LayoutParams 包括 margin、padding 参数有关。具体的逻辑在 ViewGroup 中的 `getChildMeasureSpec` 中实现。\n\n`getChildMeasureSpec`方法清楚展示了 普通 View 的 MeasureSpec 的创建规则，下表是该方法的直观展示（表中 parentSize 指父容器中目前可使用的大小）\n\n![MeasureSpec创建规则](Android-View-的工作原理\\MeasureSpec创建规则.png)\n\n由此可以看出\n\n- 当 View 采用固定宽高时，View 的 MeasureSpec 与父容器无关，为精确模式、大小为 LayoutParams 设定的值\n- 当 View 的宽高为`match_parent`时，如果父容器为精确模式/最大模式，则其也为精确模式/最大模式，且大小为父容器的剩余空间\n- 当 View 的宽高为`wrap_content`时，View 的模式总是最大化模式，且大小不超过父容器的剩余空间\n-  UNSPECIFIED 模式主要用于系统内部多次 Measure 的情形，一般情况下无需关注 \n\n### measure 过程\n\n#### View\n\n对于 View，measure 完成其自身的测量过程；对于 ViewGroup，除了完成自己的测量过程，还会遍历调用所有子元素的`measure`方法，各子元素再递归执行这一过程。`measure` 是一个`final`方法（[View.java](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/View.java) 第 23267 行），这意味着子类不能重写该方法。在`measure`中会调用 View 的`onMeasure`，所以开发者只需要重写该方法即可。\n\n```java\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),\n                         getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));\n}\n```\n\n`setMeasuredDimension`会设置 View 宽高的测量值，`getDefaultSize`返回 View 测量后的大小。\n\n对于`getSuggestedMinimumWidth`，如果 View 没有设置背景，那么宽度为`mMinWidth`，其对应`android:minWidth`属性，如果不指定属性，则`mMinWidth`默认为0；如果 View 设置了背景，则 View 的宽度为`max(mMinWidth, mBackground.getMinimumWidth())`。那么`mBackground.getMinimumWidth()`所为何物？\n\n观察 Drawable 的`getMinimumWidth`方法（[Drawable.java](https://android.googlesource.com/platform/frameworks/base/+/c80ad99a33ee49d0bac994c1749ff24d243c3862/graphics/java/android/graphics/drawable/Drawable.java) 第 798 行）\n\n```java\npublic int getMinimumWidth() {\n    final int intrinsicWidth = getIntrinsicWidth();\n    return intrinsicWidth > 0 ? intrinsicWidth : 0;\n}\n```\n\n可以发现该方法返回 Drawable 的原始宽度（如果存在，否则返回0 —— 比如 ShapeDrawable 就无原始宽高）。\n\n直接继承 View 的自定义控件需要重写`onMeasure`方法并设置`wrap_content`时的自身大小，否则在布局中使用`wrap_content`就相当于使用`match_parent`。原因在于，由上面的表格我们知道，当使用`wrap_content`时，View 的 SpecMode 为 AT_MOST，此时宽高等于 SpecSize，SpecSize 此时又等于 parentSize，效果跟使用`match_parent`是一样的。\n\n解决该问题的方法很简单，给 View 指定一个默认的内部宽高（mWidth 和 mHeight），并在`wrap_content`时设置此宽高即可\n\n```java\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(int widthMeasureSpec, int heightMeasureSpec);\n    \n    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n    int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n    int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n    \n    if (widthSpecMode == MeasureSpec.AT_MOST \n        \t&& heightSpecMode == MeasureSpec.AT_MOST) {\n        setMeasuredDimension(mWidth, mHeight);\n    } else if (widthSpecMode == MeasureSpec.AT_MOST) {\n        setMeasuredDimension(mWidth, heightSpecSize);\n    } else if (heightSpecMode == MeasureSpec.AT_MOST) {\n        setMeasuredDimension(widthSpecSize, mHeight);\n    }\n}\n```\n\n#### ViewGroup\n\n对于 ViewGroup 来说，其属于 View 的子类，但同时也是抽象的，它没有重写 View 的`onMeasure`，而是提供了`measureChildren`的方法用于测量子元素\n\n```java\nprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {\n    final int size = mChildrenCount;\n    final View[] children = mChildren;\n    for (int i = 0; i < size; ++i) {\n        final View child = children[i];\n        if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {\n            measureChild(child, widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n}\n```\n\n其中调用了`measureChild`\n\n```java\nprotected void measureChild(View child, int parentWidthMeasureSpec,\n        int parentHeightMeasureSpec) {\n    final LayoutParams lp = child.getLayoutParams();\n    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n            mPaddingLeft + mPaddingRight, lp.width);\n    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n            mPaddingTop + mPaddingBottom, lp.height);\n    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n}\n```\n\n显然该方法的思想是取出子元素的 LayoutParams 然后通过`getChildMeasureSpec`（如 MeasureSpec 小节的分析）创建子元素的 MeasureSpec，接着将 MeasureSpec 传递给 View 的`measure`方法进行测量。\n\nViewGroup 并没有测量的具体过程，而是交给其子类实现，比如 [LinearLayout](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/LinearLayout.java)、[RelativeLayout](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/RelativeLayout.java) 等。\n\n#### 宽高的获取\n\n一般情况下，measure 完成后即可通过`getMeasuredWidth/height`获得 View 的测量宽高，但是极端情况下系统可能需要多次 measure 才能确定最终的宽高，所以最好是在`onLayout`中获取宽高，而不是在`onMeasure`中。\n\n考虑 View 外部，比如当我们在 Activity 的`onCreate`或者`onResume`中获取 View 的宽高时，会发现结果是不正确的，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步的，因此无法保证在 Activity 执行`onCreate`、`onResume`时某个 View 已经测量完毕。有四种方法解决该问题：\n\n- Activity/View.onWindowFocusChanged，此时 View 已经初始化完毕。注意该方法可能会被调用多次，比如每次 Activity 的窗口获得/失去焦点\n\n  ```java\n  public void onWindowFocusChanged(boolean hasFocus) {\n      super.onWindowFocusChanged(hasFocus);\n      if (hasFocus) {\n          int width = view.getMeasuredWidth();\n          int height = view.getMeasuredHeigth();\n      }\n  }\n  ```\n\n  \n\n- view.post(Runnable runnable)，通过 post 将一个 Runnable 投递到消息队列尾部，当 Looper 调用此 Runnable 时，View 已经被初始化\n\n  ```java\n  view.post(() -> {\n      int width = view.getMeasuredWidth();\n      int height = view.getMeasuredHeigth();\n  })\n  ```\n\n  \n\n- ViewTreeObserver，该类拥有一系列回调方法，比如使用 OnGlobalLayoutListener 接口监听 View 树的状态，同样接口方法会被调用多次\n\n  ```java\n  ViewTreeObserver observer = view.getViewTreeObserver();\n  observer.addOnGlobalLayoutListener(() -> {\n      int width = view.getMeasuredWidth();\n      int height = view.getMeasuredHeigth();\n  })\n  ```\n\n  \n\n- view.measure(int widthMeasureSpec, int heightMeasureSpec)，手动 measure，较为复杂，不再赘述。\n\n### layout 过程\n\nView / ViewGroup 使用`layout`过程确定自身位置，然后在`onLayout`中遍历所有的子元素并调用其`layout`方法，重复上述过程。\n\nView 中的`layout`方法\n\n```java\npublic void layout(int l, int t, int r, int b) {\n        ......\n        int oldL = mLeft;\n        int oldT = mTop;\n        int oldB = mBottom;\n        int oldR = mRight;\n\n        boolean changed = isLayoutModeOptical(mParent) ?\n                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);\n\n        if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n            onLayout(changed, l, t, r, b);\n            ......\n            mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;\n\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnLayoutChangeListeners != null) {\n                ArrayList<OnLayoutChangeListener> listenersCopy =\n                        (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();\n                int numListeners = listenersCopy.size();\n                for (int i = 0; i < numListeners; ++i) {\n                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);\n                }\n            }\n        }\n    ......\n}\n```\n\n首先通过`setFrame`设定 View 的四个顶点（mLeft、mTop、mBottom、mRight）的值，以此确定 View 在父容器中的位置。接着调用`onLayout`确定子元素的位置，和`onMeasure`类似，View / ViewGroup 都没有提供该方法的实现，而是交给具体的布局。\n\n在 **ViewRoot 和 DecorView** 小节，提及了在 View 的 layout 之后通过`getWidth`、`getHeight`获得 View 的“最终宽高”，那么`getMeasuredWidth`和`getWidth`的区别到底是什么？\n\n```java\n    public final int getWidth() {\n        return mRight - mLeft;\n    }\n    \n    public final int getHeight() {\n        return mBottom - mTop;\n    }\n```\n\n从上面的代码可以看出，`getWidth`的返回值刚好就是 View 的测量宽度，也就是说，View 的测量宽高等于最终宽高，只不过测量宽高形成与 measure 过程，而最终宽高形成与 layout 过程 —— 赋值时机不同。但是如果重写 View 的`layout`方法，改变了`super`的参数值，比如\n\n```java\npublic void layout(int l, int t, int r, int b) {\n    super.layout(l, t, r + 100, b + 100);\n}\n```\n\n就会导致 View 的最终宽高总是比测量宽高大 100px。\n\n### draw 过程\n\n将 View 绘制到屏幕上，具体步骤\n\n- 绘制背景 background.draw(canvas)\n- 绘制自身 onDraw\n- 绘制子元素 dispatchDraw\n- 绘制装饰 onDrawScrollBars\n\n\n\n## 其他\n\nAndroid 提供了一些 API 供开发调用，实现对 View 绘制过程的操纵\n\n- `requestLayout`\n\n  调用此方法会导致 View 树调用 layout 和 measure 过程，但不会触发 draw 流程\n\n- `invalidate`\n\n  请求重绘 View 树，即 draw 过程。在子线程中可以通过`postInvalidate`实现\n\n当开发者调用 View 的`setVisibility`方法实现 VISIBLE / INVISIBLE -> GONE 时，相当于间接调用 `requestLayout` 和 `invalidate`。 \n\n当开发者调用 View 的`setVisibility`方法实现  INVISIBLE -> VISIBLE 时，相当于间接调用 `invalidate`。 \n\n---\n\n*本文主要参考了《Android 开发艺术探索》——任玉刚 著*","source":"_posts/Android-View-的工作原理.md","raw":"---\ntitle: Android View 的工作原理\ndate: 2019-03-01 13:10:14\ntags:\n- Android \n- View\ncategories:\n- Android\n---\n\n在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。\n\n<!--more-->\n\n## 整体过程\n\n### Window\n\n首先简单认识 Window，其表示一个窗口，属于一个抽象类，具体的实现为 PhoneWindow。通过 WindowManager 向 WindowManagerService 发起请求，WMS 负责 Window 的具体生成。\n\n实际上每一个 Window 对应一个 View 和 ViewRootImpl，  因此 Window 不是实际存在的，它通过 ViewRootImpl 以 View 的形式存在。\n\n### ViewRoot 和 DecorView\n\nViewRoot 的具体实现就是上一节所提及的 ViewRootImpl，View 的三大流程（measure、layout、draw）都是通过它来实现的。\n\n在 ActivityThread 中，当 Activity 对象被创建后，会将一个 DecorView 添加到 Window，然后创建 ViewRootImpl 对象，并将 DecorView 和 ViewRootImpl 建立关联，这也验证了上一节的观点。\n\n```java\nroot = new ViewRootImpl(view.getContext(), display);\nroot.setView(view, vparams, panelParentView);\n```\n\nView 的绘制流程是从 ViewRoot 的 `performTraversals` 开始的，经过`measure`（测量 View 的宽高）、`layout`（确定 View 在父容器的位置）、`draw`（将 View 绘制在屏幕上）三个过程，呈现出一个 View。\n\n\n\n![performTraversals](Android-View-的工作原理\\performTraversals.png)\n\n\n\n如图所示，`performTraversals`会依次调用`performMeasure`、`performLayout`、`performDraw`，然后这三个方法分别完成顶级 View 的三大流程。而后，`measure`又会调用`onMeasure`，在其中对所有子元素进行 measure 过程，此时 measure 流程就从父容器传递到子元素了，接着子元素重复上述过程。如此完成整个 View 树的遍历。\n\nmeasure 过程决定了 View 的宽高，可以通过`getMeasuredWidth`和`getMeasuredHeight`获得 View 测量后的宽高，在几乎所有情况下都可以得到 View 最终的数值。\n\nlayout 过程决定了 View 的四个顶点的坐标和实际的 View 的宽高，可以通过`getTop`、`getBottom`、`getLeft`、`getRight`拿到四个顶点的位置，通过`getWidth`、`getHeight`获得 View 的最终宽高。只有 draw 过程完成之后才能呈现 View。\n\n---\n\n![整体布局.webp](Android-View-的工作原理\\整体布局.webp.jpg)\n\n\n\n由上图我们可以看出，一般 DecorView 会包含一个 LinearLayout，其中上面是标题栏，下面是内容栏。在创建 Activity 的时候需要`setContentView`而不是`setView`的原因便是如此。我们的布局加到了  id 为`android.R.id.content`的 FrameLayout 中。\n\n```java\n//得到 content\nViewGroup content = (ViewGroup) findViewById(android.R.id.content)；\n\n//得到开发者设置的 View\nView view = content.getChildAt(0);\n```\n\n## 具体流程\n\n### MeasureSpec\n\n“测量规格”，是 View 测量过程中非常重要的参数。measure 时系统会将 View 的 LayoutParams 根据父容器施加的规则转换成对应的 MeasureSpec，然后再根据 该 MeasureSpec 测量出 View 的宽高。\n\nMeasureSpec 代表一个32位的 int 值，其中高2位代表 SpecMode（测量模式），低30位代表 SpecSize（某种测量模式下的规格大小）。将两个参数打包成一个 int 值的原因是避免过多的对象内存分配。\n\nSpecMode 有三类\n\n| SpecMode    | 含义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| UNSPECIFIED | 父容器不限制 View，一般用于系统内部                          |\n| EXACTLY     | 父容器已检测 VIew 的精确大小，对应参数为`match_parent`和具体的数值 |\n| AT_MOST     | 父容器指定了 View 的最大值，具体大小由 View 决定，对应参数为`wrap_content` |\n\n### MeasureSpec 和 LayoutParams \n\n对于 DecorView，其 MeasureSpec 由窗口尺寸和其自身 LayoutParams 决定，对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和 自身的LayoutParams 共同决定。一旦 MeasureSpec 确定，onMeasure 中就可以确定 View 的测量宽高。\n\n\n\nViewRootImpl 的源码地址：[ViewRootImpl.java](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewRootImpl.java)。查阅源码，得到 DecorView 的测量规则如下\n\n- LayoutParams.MATCH_PARENT：精确模式，大小为窗口大小\n\n- LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口\n\n- 固定大小：精确模式，大小为 LayoutParams 指定的大小\n\n\n\nViewGroup  的源码地址：[ViewGroup.java](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewGroup.java)。查看 ViewGroup 的`measureChildWithMargins`方法\n\n```java\nprotected void measureChildWithMargins(View child,\n            int parentWidthMeasureSpec, int widthUsed,\n            int parentHeightMeasureSpec, int heightUsed) {\n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                        + widthUsed, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                        + heightUsed, lp.height);\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n\n可以看到在调用子元素的`measure`之前，会先得到子元素的 MeasureSpec，很显然其和父容器的 MeasureSpec 以及子元素自身的 LayoutParams 包括 margin、padding 参数有关。具体的逻辑在 ViewGroup 中的 `getChildMeasureSpec` 中实现。\n\n`getChildMeasureSpec`方法清楚展示了 普通 View 的 MeasureSpec 的创建规则，下表是该方法的直观展示（表中 parentSize 指父容器中目前可使用的大小）\n\n![MeasureSpec创建规则](Android-View-的工作原理\\MeasureSpec创建规则.png)\n\n由此可以看出\n\n- 当 View 采用固定宽高时，View 的 MeasureSpec 与父容器无关，为精确模式、大小为 LayoutParams 设定的值\n- 当 View 的宽高为`match_parent`时，如果父容器为精确模式/最大模式，则其也为精确模式/最大模式，且大小为父容器的剩余空间\n- 当 View 的宽高为`wrap_content`时，View 的模式总是最大化模式，且大小不超过父容器的剩余空间\n-  UNSPECIFIED 模式主要用于系统内部多次 Measure 的情形，一般情况下无需关注 \n\n### measure 过程\n\n#### View\n\n对于 View，measure 完成其自身的测量过程；对于 ViewGroup，除了完成自己的测量过程，还会遍历调用所有子元素的`measure`方法，各子元素再递归执行这一过程。`measure` 是一个`final`方法（[View.java](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/View.java) 第 23267 行），这意味着子类不能重写该方法。在`measure`中会调用 View 的`onMeasure`，所以开发者只需要重写该方法即可。\n\n```java\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),\n                         getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));\n}\n```\n\n`setMeasuredDimension`会设置 View 宽高的测量值，`getDefaultSize`返回 View 测量后的大小。\n\n对于`getSuggestedMinimumWidth`，如果 View 没有设置背景，那么宽度为`mMinWidth`，其对应`android:minWidth`属性，如果不指定属性，则`mMinWidth`默认为0；如果 View 设置了背景，则 View 的宽度为`max(mMinWidth, mBackground.getMinimumWidth())`。那么`mBackground.getMinimumWidth()`所为何物？\n\n观察 Drawable 的`getMinimumWidth`方法（[Drawable.java](https://android.googlesource.com/platform/frameworks/base/+/c80ad99a33ee49d0bac994c1749ff24d243c3862/graphics/java/android/graphics/drawable/Drawable.java) 第 798 行）\n\n```java\npublic int getMinimumWidth() {\n    final int intrinsicWidth = getIntrinsicWidth();\n    return intrinsicWidth > 0 ? intrinsicWidth : 0;\n}\n```\n\n可以发现该方法返回 Drawable 的原始宽度（如果存在，否则返回0 —— 比如 ShapeDrawable 就无原始宽高）。\n\n直接继承 View 的自定义控件需要重写`onMeasure`方法并设置`wrap_content`时的自身大小，否则在布局中使用`wrap_content`就相当于使用`match_parent`。原因在于，由上面的表格我们知道，当使用`wrap_content`时，View 的 SpecMode 为 AT_MOST，此时宽高等于 SpecSize，SpecSize 此时又等于 parentSize，效果跟使用`match_parent`是一样的。\n\n解决该问题的方法很简单，给 View 指定一个默认的内部宽高（mWidth 和 mHeight），并在`wrap_content`时设置此宽高即可\n\n```java\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(int widthMeasureSpec, int heightMeasureSpec);\n    \n    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n    int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n    int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n    \n    if (widthSpecMode == MeasureSpec.AT_MOST \n        \t&& heightSpecMode == MeasureSpec.AT_MOST) {\n        setMeasuredDimension(mWidth, mHeight);\n    } else if (widthSpecMode == MeasureSpec.AT_MOST) {\n        setMeasuredDimension(mWidth, heightSpecSize);\n    } else if (heightSpecMode == MeasureSpec.AT_MOST) {\n        setMeasuredDimension(widthSpecSize, mHeight);\n    }\n}\n```\n\n#### ViewGroup\n\n对于 ViewGroup 来说，其属于 View 的子类，但同时也是抽象的，它没有重写 View 的`onMeasure`，而是提供了`measureChildren`的方法用于测量子元素\n\n```java\nprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {\n    final int size = mChildrenCount;\n    final View[] children = mChildren;\n    for (int i = 0; i < size; ++i) {\n        final View child = children[i];\n        if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {\n            measureChild(child, widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n}\n```\n\n其中调用了`measureChild`\n\n```java\nprotected void measureChild(View child, int parentWidthMeasureSpec,\n        int parentHeightMeasureSpec) {\n    final LayoutParams lp = child.getLayoutParams();\n    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n            mPaddingLeft + mPaddingRight, lp.width);\n    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n            mPaddingTop + mPaddingBottom, lp.height);\n    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n}\n```\n\n显然该方法的思想是取出子元素的 LayoutParams 然后通过`getChildMeasureSpec`（如 MeasureSpec 小节的分析）创建子元素的 MeasureSpec，接着将 MeasureSpec 传递给 View 的`measure`方法进行测量。\n\nViewGroup 并没有测量的具体过程，而是交给其子类实现，比如 [LinearLayout](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/LinearLayout.java)、[RelativeLayout](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/RelativeLayout.java) 等。\n\n#### 宽高的获取\n\n一般情况下，measure 完成后即可通过`getMeasuredWidth/height`获得 View 的测量宽高，但是极端情况下系统可能需要多次 measure 才能确定最终的宽高，所以最好是在`onLayout`中获取宽高，而不是在`onMeasure`中。\n\n考虑 View 外部，比如当我们在 Activity 的`onCreate`或者`onResume`中获取 View 的宽高时，会发现结果是不正确的，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步的，因此无法保证在 Activity 执行`onCreate`、`onResume`时某个 View 已经测量完毕。有四种方法解决该问题：\n\n- Activity/View.onWindowFocusChanged，此时 View 已经初始化完毕。注意该方法可能会被调用多次，比如每次 Activity 的窗口获得/失去焦点\n\n  ```java\n  public void onWindowFocusChanged(boolean hasFocus) {\n      super.onWindowFocusChanged(hasFocus);\n      if (hasFocus) {\n          int width = view.getMeasuredWidth();\n          int height = view.getMeasuredHeigth();\n      }\n  }\n  ```\n\n  \n\n- view.post(Runnable runnable)，通过 post 将一个 Runnable 投递到消息队列尾部，当 Looper 调用此 Runnable 时，View 已经被初始化\n\n  ```java\n  view.post(() -> {\n      int width = view.getMeasuredWidth();\n      int height = view.getMeasuredHeigth();\n  })\n  ```\n\n  \n\n- ViewTreeObserver，该类拥有一系列回调方法，比如使用 OnGlobalLayoutListener 接口监听 View 树的状态，同样接口方法会被调用多次\n\n  ```java\n  ViewTreeObserver observer = view.getViewTreeObserver();\n  observer.addOnGlobalLayoutListener(() -> {\n      int width = view.getMeasuredWidth();\n      int height = view.getMeasuredHeigth();\n  })\n  ```\n\n  \n\n- view.measure(int widthMeasureSpec, int heightMeasureSpec)，手动 measure，较为复杂，不再赘述。\n\n### layout 过程\n\nView / ViewGroup 使用`layout`过程确定自身位置，然后在`onLayout`中遍历所有的子元素并调用其`layout`方法，重复上述过程。\n\nView 中的`layout`方法\n\n```java\npublic void layout(int l, int t, int r, int b) {\n        ......\n        int oldL = mLeft;\n        int oldT = mTop;\n        int oldB = mBottom;\n        int oldR = mRight;\n\n        boolean changed = isLayoutModeOptical(mParent) ?\n                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);\n\n        if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n            onLayout(changed, l, t, r, b);\n            ......\n            mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;\n\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnLayoutChangeListeners != null) {\n                ArrayList<OnLayoutChangeListener> listenersCopy =\n                        (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();\n                int numListeners = listenersCopy.size();\n                for (int i = 0; i < numListeners; ++i) {\n                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);\n                }\n            }\n        }\n    ......\n}\n```\n\n首先通过`setFrame`设定 View 的四个顶点（mLeft、mTop、mBottom、mRight）的值，以此确定 View 在父容器中的位置。接着调用`onLayout`确定子元素的位置，和`onMeasure`类似，View / ViewGroup 都没有提供该方法的实现，而是交给具体的布局。\n\n在 **ViewRoot 和 DecorView** 小节，提及了在 View 的 layout 之后通过`getWidth`、`getHeight`获得 View 的“最终宽高”，那么`getMeasuredWidth`和`getWidth`的区别到底是什么？\n\n```java\n    public final int getWidth() {\n        return mRight - mLeft;\n    }\n    \n    public final int getHeight() {\n        return mBottom - mTop;\n    }\n```\n\n从上面的代码可以看出，`getWidth`的返回值刚好就是 View 的测量宽度，也就是说，View 的测量宽高等于最终宽高，只不过测量宽高形成与 measure 过程，而最终宽高形成与 layout 过程 —— 赋值时机不同。但是如果重写 View 的`layout`方法，改变了`super`的参数值，比如\n\n```java\npublic void layout(int l, int t, int r, int b) {\n    super.layout(l, t, r + 100, b + 100);\n}\n```\n\n就会导致 View 的最终宽高总是比测量宽高大 100px。\n\n### draw 过程\n\n将 View 绘制到屏幕上，具体步骤\n\n- 绘制背景 background.draw(canvas)\n- 绘制自身 onDraw\n- 绘制子元素 dispatchDraw\n- 绘制装饰 onDrawScrollBars\n\n\n\n## 其他\n\nAndroid 提供了一些 API 供开发调用，实现对 View 绘制过程的操纵\n\n- `requestLayout`\n\n  调用此方法会导致 View 树调用 layout 和 measure 过程，但不会触发 draw 流程\n\n- `invalidate`\n\n  请求重绘 View 树，即 draw 过程。在子线程中可以通过`postInvalidate`实现\n\n当开发者调用 View 的`setVisibility`方法实现 VISIBLE / INVISIBLE -> GONE 时，相当于间接调用 `requestLayout` 和 `invalidate`。 \n\n当开发者调用 View 的`setVisibility`方法实现  INVISIBLE -> VISIBLE 时，相当于间接调用 `invalidate`。 \n\n---\n\n*本文主要参考了《Android 开发艺术探索》——任玉刚 著*","slug":"Android-View-的工作原理","published":1,"updated":"2019-06-02T04:54:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxm003dy4upg5p3y5bb","content":"<p>在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。</p>\n<a id=\"more\"></a>\n<h2 id=\"整体过程\"><a href=\"#整体过程\" class=\"headerlink\" title=\"整体过程\"></a>整体过程</h2><h3 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h3><p>首先简单认识 Window，其表示一个窗口，属于一个抽象类，具体的实现为 PhoneWindow。通过 WindowManager 向 WindowManagerService 发起请求，WMS 负责 Window 的具体生成。</p>\n<p>实际上每一个 Window 对应一个 View 和 ViewRootImpl，  因此 Window 不是实际存在的，它通过 ViewRootImpl 以 View 的形式存在。</p>\n<h3 id=\"ViewRoot-和-DecorView\"><a href=\"#ViewRoot-和-DecorView\" class=\"headerlink\" title=\"ViewRoot 和 DecorView\"></a>ViewRoot 和 DecorView</h3><p>ViewRoot 的具体实现就是上一节所提及的 ViewRootImpl，View 的三大流程（measure、layout、draw）都是通过它来实现的。</p>\n<p>在 ActivityThread 中，当 Activity 对象被创建后，会将一个 DecorView 添加到 Window，然后创建 ViewRootImpl 对象，并将 DecorView 和 ViewRootImpl 建立关联，这也验证了上一节的观点。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">root.setView(view, vparams, panelParentView);</span><br></pre></td></tr></tbody></table></figure>\n<p>View 的绘制流程是从 ViewRoot 的 <code>performTraversals</code> 开始的，经过<code>measure</code>（测量 View 的宽高）、<code>layout</code>（确定 View 在父容器的位置）、<code>draw</code>（将 View 绘制在屏幕上）三个过程，呈现出一个 View。</p>\n<p><img src=\"/Android-View-的工作原理/performTraversals.png\" alt=\"performTraversals\"></p>\n<p>如图所示，<code>performTraversals</code>会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>，然后这三个方法分别完成顶级 View 的三大流程。而后，<code>measure</code>又会调用<code>onMeasure</code>，在其中对所有子元素进行 measure 过程，此时 measure 流程就从父容器传递到子元素了，接着子元素重复上述过程。如此完成整个 View 树的遍历。</p>\n<p>measure 过程决定了 View 的宽高，可以通过<code>getMeasuredWidth</code>和<code>getMeasuredHeight</code>获得 View 测量后的宽高，在几乎所有情况下都可以得到 View 最终的数值。</p>\n<p>layout 过程决定了 View 的四个顶点的坐标和实际的 View 的宽高，可以通过<code>getTop</code>、<code>getBottom</code>、<code>getLeft</code>、<code>getRight</code>拿到四个顶点的位置，通过<code>getWidth</code>、<code>getHeight</code>获得 View 的最终宽高。只有 draw 过程完成之后才能呈现 View。</p>\n<hr>\n<p><img src=\"/Android-View-的工作原理/整体布局.webp.jpg\" alt=\"整体布局.webp\"></p>\n<p>由上图我们可以看出，一般 DecorView 会包含一个 LinearLayout，其中上面是标题栏，下面是内容栏。在创建 Activity 的时候需要<code>setContentView</code>而不是<code>setView</code>的原因便是如此。我们的布局加到了  id 为<code>android.R.id.content</code>的 FrameLayout 中。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到 content</span></span><br><span class=\"line\">ViewGroup content = (ViewGroup) findViewById(android.R.id.content)；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//得到开发者设置的 View</span></span><br><span class=\"line\">View view = content.getChildAt(<span class=\"number\">0</span>);</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h2><h3 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h3><p>“测量规格”，是 View 测量过程中非常重要的参数。measure 时系统会将 View 的 LayoutParams 根据父容器施加的规则转换成对应的 MeasureSpec，然后再根据 该 MeasureSpec 测量出 View 的宽高。</p>\n<p>MeasureSpec 代表一个32位的 int 值，其中高2位代表 SpecMode（测量模式），低30位代表 SpecSize（某种测量模式下的规格大小）。将两个参数打包成一个 int 值的原因是避免过多的对象内存分配。</p>\n<p>SpecMode 有三类</p>\n<table>\n<thead>\n<tr>\n<th>SpecMode</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UNSPECIFIED</td>\n<td>父容器不限制 View，一般用于系统内部</td>\n</tr>\n<tr>\n<td>EXACTLY</td>\n<td>父容器已检测 VIew 的精确大小，对应参数为<code>match_parent</code>和具体的数值</td>\n</tr>\n<tr>\n<td>AT_MOST</td>\n<td>父容器指定了 View 的最大值，具体大小由 View 决定，对应参数为<code>wrap_content</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"MeasureSpec-和-LayoutParams\"><a href=\"#MeasureSpec-和-LayoutParams\" class=\"headerlink\" title=\"MeasureSpec 和 LayoutParams\"></a>MeasureSpec 和 LayoutParams</h3><p>对于 DecorView，其 MeasureSpec 由窗口尺寸和其自身 LayoutParams 决定，对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和 自身的LayoutParams 共同决定。一旦 MeasureSpec 确定，onMeasure 中就可以确定 View 的测量宽高。</p>\n<p>ViewRootImpl 的源码地址：<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewRootImpl.java\" target=\"_blank\" rel=\"noopener\">ViewRootImpl.java</a>。查阅源码，得到 DecorView 的测量规则如下</p>\n<ul>\n<li><p>LayoutParams.MATCH_PARENT：精确模式，大小为窗口大小</p>\n</li>\n<li><p>LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口</p>\n</li>\n<li><p>固定大小：精确模式，大小为 LayoutParams 指定的大小</p>\n</li>\n</ul>\n<p>ViewGroup  的源码地址：<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewGroup.java\" target=\"_blank\" rel=\"noopener\">ViewGroup.java</a>。查看 ViewGroup 的<code>measureChildWithMargins</code>方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildWithMargins</span><span class=\"params\">(View child,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> parentWidthMeasureSpec, <span class=\"keyword\">int</span> widthUsed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> parentHeightMeasureSpec, <span class=\"keyword\">int</span> heightUsed)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class=\"line\">                        + widthUsed, lp.width);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class=\"line\">                        + heightUsed, lp.height);</span><br><span class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到在调用子元素的<code>measure</code>之前，会先得到子元素的 MeasureSpec，很显然其和父容器的 MeasureSpec 以及子元素自身的 LayoutParams 包括 margin、padding 参数有关。具体的逻辑在 ViewGroup 中的 <code>getChildMeasureSpec</code> 中实现。</p>\n<p><code>getChildMeasureSpec</code>方法清楚展示了 普通 View 的 MeasureSpec 的创建规则，下表是该方法的直观展示（表中 parentSize 指父容器中目前可使用的大小）</p>\n<p><img src=\"/Android-View-的工作原理/MeasureSpec创建规则.png\" alt=\"MeasureSpec创建规则\"></p>\n<p>由此可以看出</p>\n<ul>\n<li>当 View 采用固定宽高时，View 的 MeasureSpec 与父容器无关，为精确模式、大小为 LayoutParams 设定的值</li>\n<li>当 View 的宽高为<code>match_parent</code>时，如果父容器为精确模式/最大模式，则其也为精确模式/最大模式，且大小为父容器的剩余空间</li>\n<li>当 View 的宽高为<code>wrap_content</code>时，View 的模式总是最大化模式，且大小不超过父容器的剩余空间</li>\n<li>UNSPECIFIED 模式主要用于系统内部多次 Measure 的情形，一般情况下无需关注 </li>\n</ul>\n<h3 id=\"measure-过程\"><a href=\"#measure-过程\" class=\"headerlink\" title=\"measure 过程\"></a>measure 过程</h3><h4 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h4><p>对于 View，measure 完成其自身的测量过程；对于 ViewGroup，除了完成自己的测量过程，还会遍历调用所有子元素的<code>measure</code>方法，各子元素再递归执行这一过程。<code>measure</code> 是一个<code>final</code>方法（<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/View.java\" target=\"_blank\" rel=\"noopener\">View.java</a> 第 23267 行），这意味着子类不能重写该方法。在<code>measure</code>中会调用 View 的<code>onMeasure</code>，所以开发者只需要重写该方法即可。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>{</span><br><span class=\"line\">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),</span><br><span class=\"line\">                         getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p><code>setMeasuredDimension</code>会设置 View 宽高的测量值，<code>getDefaultSize</code>返回 View 测量后的大小。</p>\n<p>对于<code>getSuggestedMinimumWidth</code>，如果 View 没有设置背景，那么宽度为<code>mMinWidth</code>，其对应<code>android:minWidth</code>属性，如果不指定属性，则<code>mMinWidth</code>默认为0；如果 View 设置了背景，则 View 的宽度为<code>max(mMinWidth, mBackground.getMinimumWidth())</code>。那么<code>mBackground.getMinimumWidth()</code>所为何物？</p>\n<p>观察 Drawable 的<code>getMinimumWidth</code>方法（<a href=\"https://android.googlesource.com/platform/frameworks/base/+/c80ad99a33ee49d0bac994c1749ff24d243c3862/graphics/java/android/graphics/drawable/Drawable.java\" target=\"_blank\" rel=\"noopener\">Drawable.java</a> 第 798 行）</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMinimumWidth</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> intrinsicWidth = getIntrinsicWidth();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> intrinsicWidth > <span class=\"number\">0</span> ? intrinsicWidth : <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>可以发现该方法返回 Drawable 的原始宽度（如果存在，否则返回0 —— 比如 ShapeDrawable 就无原始宽高）。</p>\n<p>直接继承 View 的自定义控件需要重写<code>onMeasure</code>方法并设置<code>wrap_content</code>时的自身大小，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。原因在于，由上面的表格我们知道，当使用<code>wrap_content</code>时，View 的 SpecMode 为 AT_MOST，此时宽高等于 SpecSize，SpecSize 此时又等于 parentSize，效果跟使用<code>match_parent</code>是一样的。</p>\n<p>解决该问题的方法很简单，给 View 指定一个默认的内部宽高（mWidth 和 mHeight），并在<code>wrap_content</code>时设置此宽高即可</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST </span><br><span class=\"line\">        \t&& heightSpecMode == MeasureSpec.AT_MOST) {</span><br><span class=\"line\">        setMeasuredDimension(mWidth, mHeight);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST) {</span><br><span class=\"line\">        setMeasuredDimension(mWidth, heightSpecSize);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heightSpecMode == MeasureSpec.AT_MOST) {</span><br><span class=\"line\">        setMeasuredDimension(widthSpecSize, mHeight);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"ViewGroup\"><a href=\"#ViewGroup\" class=\"headerlink\" title=\"ViewGroup\"></a>ViewGroup</h4><p>对于 ViewGroup 来说，其属于 View 的子类，但同时也是抽象的，它没有重写 View 的<code>onMeasure</code>，而是提供了<code>measureChildren</code>的方法用于测量子元素</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildren</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = mChildrenCount;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> View[] children = mChildren;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < size; ++i) {</span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = children[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((child.mViewFlags & VISIBILITY_MASK) != GONE) {</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>其中调用了<code>measureChild</code></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChild</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> parentWidthMeasureSpec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> parentHeightMeasureSpec)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class=\"line\">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>显然该方法的思想是取出子元素的 LayoutParams 然后通过<code>getChildMeasureSpec</code>（如 MeasureSpec 小节的分析）创建子元素的 MeasureSpec，接着将 MeasureSpec 传递给 View 的<code>measure</code>方法进行测量。</p>\n<p>ViewGroup 并没有测量的具体过程，而是交给其子类实现，比如 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/LinearLayout.java\" target=\"_blank\" rel=\"noopener\">LinearLayout</a>、<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/RelativeLayout.java\" target=\"_blank\" rel=\"noopener\">RelativeLayout</a> 等。</p>\n<h4 id=\"宽高的获取\"><a href=\"#宽高的获取\" class=\"headerlink\" title=\"宽高的获取\"></a>宽高的获取</h4><p>一般情况下，measure 完成后即可通过<code>getMeasuredWidth/height</code>获得 View 的测量宽高，但是极端情况下系统可能需要多次 measure 才能确定最终的宽高，所以最好是在<code>onLayout</code>中获取宽高，而不是在<code>onMeasure</code>中。</p>\n<p>考虑 View 外部，比如当我们在 Activity 的<code>onCreate</code>或者<code>onResume</code>中获取 View 的宽高时，会发现结果是不正确的，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步的，因此无法保证在 Activity 执行<code>onCreate</code>、<code>onResume</code>时某个 View 已经测量完毕。有四种方法解决该问题：</p>\n<ul>\n<li><p>Activity/View.onWindowFocusChanged，此时 View 已经初始化完毕。注意该方法可能会被调用多次，比如每次 Activity 的窗口获得/失去焦点</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onWindowFocusChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> hasFocus)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasFocus) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = view.getMeasuredWidth();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> height = view.getMeasuredHeigth();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>view.post(Runnable runnable)，通过 post 将一个 Runnable 投递到消息队列尾部，当 Looper 调用此 Runnable 时，View 已经被初始化</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">view.post(() -> {</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width = view.getMeasuredWidth();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> height = view.getMeasuredHeigth();</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ViewTreeObserver，该类拥有一系列回调方法，比如使用 OnGlobalLayoutListener 接口监听 View 树的状态，同样接口方法会被调用多次</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ViewTreeObserver observer = view.getViewTreeObserver();</span><br><span class=\"line\">observer.addOnGlobalLayoutListener(() -> {</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width = view.getMeasuredWidth();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> height = view.getMeasuredHeigth();</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<ul>\n<li>view.measure(int widthMeasureSpec, int heightMeasureSpec)，手动 measure，较为复杂，不再赘述。</li>\n</ul>\n<h3 id=\"layout-过程\"><a href=\"#layout-过程\" class=\"headerlink\" title=\"layout 过程\"></a>layout 过程</h3><p>View / ViewGroup 使用<code>layout</code>过程确定自身位置，然后在<code>onLayout</code>中遍历所有的子元素并调用其<code>layout</code>方法，重复上述过程。</p>\n<p>View 中的<code>layout</code>方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>{</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldL = mLeft;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldT = mTop;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldB = mBottom;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldR = mRight;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class=\"line\">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {</span><br><span class=\"line\">            onLayout(changed, l, t, r, b);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> && li.mOnLayoutChangeListeners != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                ArrayList<OnLayoutChangeListener> listenersCopy =</span><br><span class=\"line\">                        (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> numListeners = listenersCopy.size();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < numListeners; ++i) {</span><br><span class=\"line\">                    listenersCopy.get(i).onLayoutChange(<span class=\"keyword\">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    ......</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>首先通过<code>setFrame</code>设定 View 的四个顶点（mLeft、mTop、mBottom、mRight）的值，以此确定 View 在父容器中的位置。接着调用<code>onLayout</code>确定子元素的位置，和<code>onMeasure</code>类似，View / ViewGroup 都没有提供该方法的实现，而是交给具体的布局。</p>\n<p>在 <strong>ViewRoot 和 DecorView</strong> 小节，提及了在 View 的 layout 之后通过<code>getWidth</code>、<code>getHeight</code>获得 View 的“最终宽高”，那么<code>getMeasuredWidth</code>和<code>getWidth</code>的区别到底是什么？</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getWidth</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mRight - mLeft;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getHeight</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mBottom - mTop;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>从上面的代码可以看出，<code>getWidth</code>的返回值刚好就是 View 的测量宽度，也就是说，View 的测量宽高等于最终宽高，只不过测量宽高形成与 measure 过程，而最终宽高形成与 layout 过程 —— 赋值时机不同。但是如果重写 View 的<code>layout</code>方法，改变了<code>super</code>的参数值，比如</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.layout(l, t, r + <span class=\"number\">100</span>, b + <span class=\"number\">100</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>就会导致 View 的最终宽高总是比测量宽高大 100px。</p>\n<h3 id=\"draw-过程\"><a href=\"#draw-过程\" class=\"headerlink\" title=\"draw 过程\"></a>draw 过程</h3><p>将 View 绘制到屏幕上，具体步骤</p>\n<ul>\n<li>绘制背景 background.draw(canvas)</li>\n<li>绘制自身 onDraw</li>\n<li>绘制子元素 dispatchDraw</li>\n<li>绘制装饰 onDrawScrollBars</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>Android 提供了一些 API 供开发调用，实现对 View 绘制过程的操纵</p>\n<ul>\n<li><p><code>requestLayout</code></p>\n<p>调用此方法会导致 View 树调用 layout 和 measure 过程，但不会触发 draw 流程</p>\n</li>\n<li><p><code>invalidate</code></p>\n<p>请求重绘 View 树，即 draw 过程。在子线程中可以通过<code>postInvalidate</code>实现</p>\n</li>\n</ul>\n<p>当开发者调用 View 的<code>setVisibility</code>方法实现 VISIBLE / INVISIBLE -> GONE 时，相当于间接调用 <code>requestLayout</code> 和 <code>invalidate</code>。 </p>\n<p>当开发者调用 View 的<code>setVisibility</code>方法实现  INVISIBLE -> VISIBLE 时，相当于间接调用 <code>invalidate</code>。 </p>\n<hr>\n<p><em>本文主要参考了《Android 开发艺术探索》——任玉刚 著</em></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":10588,"excerpt":"<p>在 Android 开发中，View 扮演了很重要的角色，是 Android 在视觉上的呈现。不满足于既有控件的开发者，会自定义 View 实现各种效果。但自定义复杂的 View 具有一定的难度，需要开发者掌握 View 的底层工作原理，比如 View 的测量、布局和绘制等流程。</p>","more":"<h2 id=\"整体过程\"><a href=\"#整体过程\" class=\"headerlink\" title=\"整体过程\"></a>整体过程</h2><h3 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h3><p>首先简单认识 Window，其表示一个窗口，属于一个抽象类，具体的实现为 PhoneWindow。通过 WindowManager 向 WindowManagerService 发起请求，WMS 负责 Window 的具体生成。</p>\n<p>实际上每一个 Window 对应一个 View 和 ViewRootImpl，  因此 Window 不是实际存在的，它通过 ViewRootImpl 以 View 的形式存在。</p>\n<h3 id=\"ViewRoot-和-DecorView\"><a href=\"#ViewRoot-和-DecorView\" class=\"headerlink\" title=\"ViewRoot 和 DecorView\"></a>ViewRoot 和 DecorView</h3><p>ViewRoot 的具体实现就是上一节所提及的 ViewRootImpl，View 的三大流程（measure、layout、draw）都是通过它来实现的。</p>\n<p>在 ActivityThread 中，当 Activity 对象被创建后，会将一个 DecorView 添加到 Window，然后创建 ViewRootImpl 对象，并将 DecorView 和 ViewRootImpl 建立关联，这也验证了上一节的观点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">root.setView(view, vparams, panelParentView);</span><br></pre></td></tr></table></figure>\n<p>View 的绘制流程是从 ViewRoot 的 <code>performTraversals</code> 开始的，经过<code>measure</code>（测量 View 的宽高）、<code>layout</code>（确定 View 在父容器的位置）、<code>draw</code>（将 View 绘制在屏幕上）三个过程，呈现出一个 View。</p>\n<p><img src=\"/Android-View-的工作原理/performTraversals.png\" alt=\"performTraversals\"></p>\n<p>如图所示，<code>performTraversals</code>会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>，然后这三个方法分别完成顶级 View 的三大流程。而后，<code>measure</code>又会调用<code>onMeasure</code>，在其中对所有子元素进行 measure 过程，此时 measure 流程就从父容器传递到子元素了，接着子元素重复上述过程。如此完成整个 View 树的遍历。</p>\n<p>measure 过程决定了 View 的宽高，可以通过<code>getMeasuredWidth</code>和<code>getMeasuredHeight</code>获得 View 测量后的宽高，在几乎所有情况下都可以得到 View 最终的数值。</p>\n<p>layout 过程决定了 View 的四个顶点的坐标和实际的 View 的宽高，可以通过<code>getTop</code>、<code>getBottom</code>、<code>getLeft</code>、<code>getRight</code>拿到四个顶点的位置，通过<code>getWidth</code>、<code>getHeight</code>获得 View 的最终宽高。只有 draw 过程完成之后才能呈现 View。</p>\n<hr>\n<p><img src=\"/Android-View-的工作原理/整体布局.webp.jpg\" alt=\"整体布局.webp\"></p>\n<p>由上图我们可以看出，一般 DecorView 会包含一个 LinearLayout，其中上面是标题栏，下面是内容栏。在创建 Activity 的时候需要<code>setContentView</code>而不是<code>setView</code>的原因便是如此。我们的布局加到了  id 为<code>android.R.id.content</code>的 FrameLayout 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到 content</span></span><br><span class=\"line\">ViewGroup content = (ViewGroup) findViewById(android.R.id.content)；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//得到开发者设置的 View</span></span><br><span class=\"line\">View view = content.getChildAt(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h2><h3 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h3><p>“测量规格”，是 View 测量过程中非常重要的参数。measure 时系统会将 View 的 LayoutParams 根据父容器施加的规则转换成对应的 MeasureSpec，然后再根据 该 MeasureSpec 测量出 View 的宽高。</p>\n<p>MeasureSpec 代表一个32位的 int 值，其中高2位代表 SpecMode（测量模式），低30位代表 SpecSize（某种测量模式下的规格大小）。将两个参数打包成一个 int 值的原因是避免过多的对象内存分配。</p>\n<p>SpecMode 有三类</p>\n<table>\n<thead>\n<tr>\n<th>SpecMode</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UNSPECIFIED</td>\n<td>父容器不限制 View，一般用于系统内部</td>\n</tr>\n<tr>\n<td>EXACTLY</td>\n<td>父容器已检测 VIew 的精确大小，对应参数为<code>match_parent</code>和具体的数值</td>\n</tr>\n<tr>\n<td>AT_MOST</td>\n<td>父容器指定了 View 的最大值，具体大小由 View 决定，对应参数为<code>wrap_content</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"MeasureSpec-和-LayoutParams\"><a href=\"#MeasureSpec-和-LayoutParams\" class=\"headerlink\" title=\"MeasureSpec 和 LayoutParams\"></a>MeasureSpec 和 LayoutParams</h3><p>对于 DecorView，其 MeasureSpec 由窗口尺寸和其自身 LayoutParams 决定，对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和 自身的LayoutParams 共同决定。一旦 MeasureSpec 确定，onMeasure 中就可以确定 View 的测量宽高。</p>\n<p>ViewRootImpl 的源码地址：<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewRootImpl.java\" target=\"_blank\" rel=\"noopener\">ViewRootImpl.java</a>。查阅源码，得到 DecorView 的测量规则如下</p>\n<ul>\n<li><p>LayoutParams.MATCH_PARENT：精确模式，大小为窗口大小</p>\n</li>\n<li><p>LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口</p>\n</li>\n<li><p>固定大小：精确模式，大小为 LayoutParams 指定的大小</p>\n</li>\n</ul>\n<p>ViewGroup  的源码地址：<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewGroup.java\" target=\"_blank\" rel=\"noopener\">ViewGroup.java</a>。查看 ViewGroup 的<code>measureChildWithMargins</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildWithMargins</span><span class=\"params\">(View child,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> parentWidthMeasureSpec, <span class=\"keyword\">int</span> widthUsed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> parentHeightMeasureSpec, <span class=\"keyword\">int</span> heightUsed)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class=\"line\">                        + widthUsed, lp.width);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class=\"line\">                        + heightUsed, lp.height);</span><br><span class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到在调用子元素的<code>measure</code>之前，会先得到子元素的 MeasureSpec，很显然其和父容器的 MeasureSpec 以及子元素自身的 LayoutParams 包括 margin、padding 参数有关。具体的逻辑在 ViewGroup 中的 <code>getChildMeasureSpec</code> 中实现。</p>\n<p><code>getChildMeasureSpec</code>方法清楚展示了 普通 View 的 MeasureSpec 的创建规则，下表是该方法的直观展示（表中 parentSize 指父容器中目前可使用的大小）</p>\n<p><img src=\"/Android-View-的工作原理/MeasureSpec创建规则.png\" alt=\"MeasureSpec创建规则\"></p>\n<p>由此可以看出</p>\n<ul>\n<li>当 View 采用固定宽高时，View 的 MeasureSpec 与父容器无关，为精确模式、大小为 LayoutParams 设定的值</li>\n<li>当 View 的宽高为<code>match_parent</code>时，如果父容器为精确模式/最大模式，则其也为精确模式/最大模式，且大小为父容器的剩余空间</li>\n<li>当 View 的宽高为<code>wrap_content</code>时，View 的模式总是最大化模式，且大小不超过父容器的剩余空间</li>\n<li>UNSPECIFIED 模式主要用于系统内部多次 Measure 的情形，一般情况下无需关注 </li>\n</ul>\n<h3 id=\"measure-过程\"><a href=\"#measure-过程\" class=\"headerlink\" title=\"measure 过程\"></a>measure 过程</h3><h4 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h4><p>对于 View，measure 完成其自身的测量过程；对于 ViewGroup，除了完成自己的测量过程，还会遍历调用所有子元素的<code>measure</code>方法，各子元素再递归执行这一过程。<code>measure</code> 是一个<code>final</code>方法（<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/View.java\" target=\"_blank\" rel=\"noopener\">View.java</a> 第 23267 行），这意味着子类不能重写该方法。在<code>measure</code>中会调用 View 的<code>onMeasure</code>，所以开发者只需要重写该方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),</span><br><span class=\"line\">                         getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>setMeasuredDimension</code>会设置 View 宽高的测量值，<code>getDefaultSize</code>返回 View 测量后的大小。</p>\n<p>对于<code>getSuggestedMinimumWidth</code>，如果 View 没有设置背景，那么宽度为<code>mMinWidth</code>，其对应<code>android:minWidth</code>属性，如果不指定属性，则<code>mMinWidth</code>默认为0；如果 View 设置了背景，则 View 的宽度为<code>max(mMinWidth, mBackground.getMinimumWidth())</code>。那么<code>mBackground.getMinimumWidth()</code>所为何物？</p>\n<p>观察 Drawable 的<code>getMinimumWidth</code>方法（<a href=\"https://android.googlesource.com/platform/frameworks/base/+/c80ad99a33ee49d0bac994c1749ff24d243c3862/graphics/java/android/graphics/drawable/Drawable.java\" target=\"_blank\" rel=\"noopener\">Drawable.java</a> 第 798 行）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMinimumWidth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> intrinsicWidth = getIntrinsicWidth();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> intrinsicWidth &gt; <span class=\"number\">0</span> ? intrinsicWidth : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现该方法返回 Drawable 的原始宽度（如果存在，否则返回0 —— 比如 ShapeDrawable 就无原始宽高）。</p>\n<p>直接继承 View 的自定义控件需要重写<code>onMeasure</code>方法并设置<code>wrap_content</code>时的自身大小，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。原因在于，由上面的表格我们知道，当使用<code>wrap_content</code>时，View 的 SpecMode 为 AT_MOST，此时宽高等于 SpecSize，SpecSize 此时又等于 parentSize，效果跟使用<code>match_parent</code>是一样的。</p>\n<p>解决该问题的方法很简单，给 View 指定一个默认的内部宽高（mWidth 和 mHeight），并在<code>wrap_content</code>时设置此宽高即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST </span><br><span class=\"line\">        \t&amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class=\"line\">        setMeasuredDimension(mWidth, mHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class=\"line\">        setMeasuredDimension(mWidth, heightSpecSize);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class=\"line\">        setMeasuredDimension(widthSpecSize, mHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ViewGroup\"><a href=\"#ViewGroup\" class=\"headerlink\" title=\"ViewGroup\"></a>ViewGroup</h4><p>对于 ViewGroup 来说，其属于 View 的子类，但同时也是抽象的，它没有重写 View 的<code>onMeasure</code>，而是提供了<code>measureChildren</code>的方法用于测量子元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildren</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = mChildrenCount;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> View[] children = mChildren;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = children[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中调用了<code>measureChild</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChild</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> parentWidthMeasureSpec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class=\"line\">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然该方法的思想是取出子元素的 LayoutParams 然后通过<code>getChildMeasureSpec</code>（如 MeasureSpec 小节的分析）创建子元素的 MeasureSpec，接着将 MeasureSpec 传递给 View 的<code>measure</code>方法进行测量。</p>\n<p>ViewGroup 并没有测量的具体过程，而是交给其子类实现，比如 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/LinearLayout.java\" target=\"_blank\" rel=\"noopener\">LinearLayout</a>、<a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/RelativeLayout.java\" target=\"_blank\" rel=\"noopener\">RelativeLayout</a> 等。</p>\n<h4 id=\"宽高的获取\"><a href=\"#宽高的获取\" class=\"headerlink\" title=\"宽高的获取\"></a>宽高的获取</h4><p>一般情况下，measure 完成后即可通过<code>getMeasuredWidth/height</code>获得 View 的测量宽高，但是极端情况下系统可能需要多次 measure 才能确定最终的宽高，所以最好是在<code>onLayout</code>中获取宽高，而不是在<code>onMeasure</code>中。</p>\n<p>考虑 View 外部，比如当我们在 Activity 的<code>onCreate</code>或者<code>onResume</code>中获取 View 的宽高时，会发现结果是不正确的，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步的，因此无法保证在 Activity 执行<code>onCreate</code>、<code>onResume</code>时某个 View 已经测量完毕。有四种方法解决该问题：</p>\n<ul>\n<li><p>Activity/View.onWindowFocusChanged，此时 View 已经初始化完毕。注意该方法可能会被调用多次，比如每次 Activity 的窗口获得/失去焦点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onWindowFocusChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasFocus) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = view.getMeasuredWidth();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> height = view.getMeasuredHeigth();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>view.post(Runnable runnable)，通过 post 将一个 Runnable 投递到消息队列尾部，当 Looper 调用此 Runnable 时，View 已经被初始化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">view.post(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width = view.getMeasuredWidth();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> height = view.getMeasuredHeigth();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ViewTreeObserver，该类拥有一系列回调方法，比如使用 OnGlobalLayoutListener 接口监听 View 树的状态，同样接口方法会被调用多次</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ViewTreeObserver observer = view.getViewTreeObserver();</span><br><span class=\"line\">observer.addOnGlobalLayoutListener(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width = view.getMeasuredWidth();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> height = view.getMeasuredHeigth();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>view.measure(int widthMeasureSpec, int heightMeasureSpec)，手动 measure，较为复杂，不再赘述。</li>\n</ul>\n<h3 id=\"layout-过程\"><a href=\"#layout-过程\" class=\"headerlink\" title=\"layout 过程\"></a>layout 过程</h3><p>View / ViewGroup 使用<code>layout</code>过程确定自身位置，然后在<code>onLayout</code>中遍历所有的子元素并调用其<code>layout</code>方法，重复上述过程。</p>\n<p>View 中的<code>layout</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldL = mLeft;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldT = mTop;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldB = mBottom;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldR = mRight;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class=\"line\">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class=\"line\">            onLayout(changed, l, t, r, b);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class=\"line\">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> numListeners = listenersCopy.size();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class=\"line\">                    listenersCopy.get(i).onLayoutChange(<span class=\"keyword\">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先通过<code>setFrame</code>设定 View 的四个顶点（mLeft、mTop、mBottom、mRight）的值，以此确定 View 在父容器中的位置。接着调用<code>onLayout</code>确定子元素的位置，和<code>onMeasure</code>类似，View / ViewGroup 都没有提供该方法的实现，而是交给具体的布局。</p>\n<p>在 <strong>ViewRoot 和 DecorView</strong> 小节，提及了在 View 的 layout 之后通过<code>getWidth</code>、<code>getHeight</code>获得 View 的“最终宽高”，那么<code>getMeasuredWidth</code>和<code>getWidth</code>的区别到底是什么？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getWidth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mRight - mLeft;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getHeight</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mBottom - mTop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，<code>getWidth</code>的返回值刚好就是 View 的测量宽度，也就是说，View 的测量宽高等于最终宽高，只不过测量宽高形成与 measure 过程，而最终宽高形成与 layout 过程 —— 赋值时机不同。但是如果重写 View 的<code>layout</code>方法，改变了<code>super</code>的参数值，比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.layout(l, t, r + <span class=\"number\">100</span>, b + <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就会导致 View 的最终宽高总是比测量宽高大 100px。</p>\n<h3 id=\"draw-过程\"><a href=\"#draw-过程\" class=\"headerlink\" title=\"draw 过程\"></a>draw 过程</h3><p>将 View 绘制到屏幕上，具体步骤</p>\n<ul>\n<li>绘制背景 background.draw(canvas)</li>\n<li>绘制自身 onDraw</li>\n<li>绘制子元素 dispatchDraw</li>\n<li>绘制装饰 onDrawScrollBars</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>Android 提供了一些 API 供开发调用，实现对 View 绘制过程的操纵</p>\n<ul>\n<li><p><code>requestLayout</code></p>\n<p>调用此方法会导致 View 树调用 layout 和 measure 过程，但不会触发 draw 流程</p>\n</li>\n<li><p><code>invalidate</code></p>\n<p>请求重绘 View 树，即 draw 过程。在子线程中可以通过<code>postInvalidate</code>实现</p>\n</li>\n</ul>\n<p>当开发者调用 View 的<code>setVisibility</code>方法实现 VISIBLE / INVISIBLE -&gt; GONE 时，相当于间接调用 <code>requestLayout</code> 和 <code>invalidate</code>。 </p>\n<p>当开发者调用 View 的<code>setVisibility</code>方法实现  INVISIBLE -&gt; VISIBLE 时，相当于间接调用 <code>invalidate</code>。 </p>\n<hr>\n<p><em>本文主要参考了《Android 开发艺术探索》——任玉刚 著</em></p>"},{"title":"Android 动画详解","date":"2019-02-18T11:12:22.000Z","_content":"\nAndroid 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。<!--more-->\n\n## View Animation \n视图动画的作用对象是 View，可分为补间动画和帧动画。\n\n### 补间动画\n动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。\n\n#### XML 方式\n创建一个 set.xml 文件，通过动画集合标签`<set>`将四种效果结合起来\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<--动画集合\ninterpolator 表示所采用的的差值器，其影响动画的速度，可以不指定\nshareInterpolator 表示集合中的动画是否和集合共享同一个差值器-->\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fillAfter=\"true\"\n    android:shareInterpolator=\"true\"\n    android:repeatMode=\"reverse\">\n    \n    <!-- 缩放动画\n    fromXScale 表示水平方向缩放的起始值\n    toXScale 表示水平方向的结束值\n    fillAfter 表示动画显示结束保持最后一帧-->\n    <scale  \n        android:duration=\"1000\"\n        android:fillAfter=\"true\"\n        android:fromXScale=\"0.5\"\n        android:fromYScale=\"0.5\"\n        android:toXScale=\"1\"\n        android:toYScale=\"1\"\n        android:repeatCount=\"infinite\"/><!--次数 ,infinite 为无线循环播放-->\n        \n    <!-- 透明度动画\n        fromAlpha 表示起始透明度\n        toAlpha 表示结束透明度-->\n    <alpha\n        android:duration=\"2000\"\n        android:fillAfter=\"true\"\n        android:fromAlpha=\"0.7\"\n        android:toAlpha=\"1\"/>\n        \n    <!--旋转动画\n    fromDegrees 表示起始角度\n    toDegrees 表示结束角度-->\n    <rotate\n        android:fromDegrees=\"0\"\n        android:toDegrees=\"90\"\n        android:fillAfter=\"true\"\n        android:duration=\"1000\"/>\n    \n    <!--平移动画-->\n    <translate\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:toXDelta=\"100%\"\n        android:toYDelta=\"-100%\"\n        android:fillAfter=\"true\"\n        android:duration=\"2000\"\n        />\n</set>\n```\n使用以上动画的方式如下\n```Java\nAnimation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);\nview.startAnimation(anim);\n```\n\n#### Java 代码方式\n使用 Java 代码实现动画的方式如下\n```Java\npublic void startAnimationSet() {\n    //创建动画，参数表示他的子动画是否共用一个插值器\n    AnimationSet animationSet = new AnimationSet(true);\n    //添加动画\n    animationSet.addAnimation(new AlphaAnimation(1.0f, 0.0f));\n    //设置插值器\n    animationSet.setInterpolator(new LinearInterpolator());\n    //设置动画持续时长\n    animationSet.setDuration(3000);\n    //设置动画结束之后是否保持动画的目标状态\n    animationSet.setFillAfter(true);\n    //设置动画结束之后是否保持动画开始时的状态\n    animationSet.setFillBefore(false);\n    //设置重复模式\n    animationSet.setRepeatMode(AnimationSet.REVERSE);\n    //设置重复次数\n    animationSet.setRepeatCount(AnimationSet.INFINITE);\n    //设置动画延时时间\n    animationSet.setStartOffset(2000);\n    //取消动画\n    animationSet.cancel();\n    //释放资源\n    animationSet.reset();\n    //开始动画\n    view.startAnimation(animationSet);\n}\n```\n\n#### 自定义\n除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的`initialize`和`applyTransformation`方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 \n\n#### 特殊使用\nView 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。\n\n### 帧动画\n帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。\n\n首先需要定义一个 XML 文件`frame_animation.xml`\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"false\">\n    <item\n        android:drawable=\"@mipmap/image1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/image2\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/iamge2\"\n        android:duration=\"100\" />\n</animation-list>\n```\n然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可\n```Java\nview.setBackgroundResource(R.drawable.frame_animation)；\nAnimationDrawable drawable = (AnimationDrawable) view.getBackground();\ndrawable.start();\n```\n\n## Property Animation\n属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：\n- 补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。\n- 补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。\n\n与补间动画类似，属性动画也需要定义几个方面的属性：\n- 动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。\n- 动画插值方式。通过 android:interploator 指定。\n- 动画重复次数。通过 android:repeatCount 指定。\n- 重复行为。通过 android:repeatMode 指定。\n- 动画集。在属性资源文件中通过 `<set>` 来组合。\n- 帧刷新率。指定多长时间播放一帧。默认为 10 ms。\n\n### API\n- ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。\n- ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。\n- AnimatorSet：Animator 的子类，用于组合多个 Animator。\n\n属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。\n- IntEvaluator：计算 int 类型属性值的计算器。\n- FloatEvaluator：用于计算 float 类型属性值的计算器。\n- ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。\n- TypeEvaluator：可以自定义计算器。\n\n### ValueAniamtor\nValueAnimator 类中有3个重要方法：\n> ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)\n\n#### ofInt\n将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator\n\n下面的代码将实现按钮的宽度从 150px 放大到 500px\n```Java\n    Button mButton = (Button) findViewById(R.id.Button);\n    // 设置属性数值的初始值 & 结束值\n    // ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500\n    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, 500);\n  \n    // 设置动画的播放各种属性\n    valueAnimator.setDuration(2000);\n\n    // 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度\n    // 设置更新监听器，数值每次变化更新都会调用该方法\n    valueAnimator.addUpdateListener(new AnimatorUpdateListener() {\n    \n        @Override\n        public void onAnimationUpdate(ValueAnimator animator) {\n            // 获得每次变化后的属性值\n            int currentValue = (Integer) animator.getAnimatedValue();\n            // 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化\n            mButton.getLayoutParams().width = currentValue;\n            \n            // 刷新视图，即重新绘制\n            mButton.requestLayout();\n        }\n    });\n    valueAnimator.start();  // 启动动画\n}\n```\n\n#### ofFloat\n其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）\n```Java\npublic class FloatEvaluator implements TypeEvaluator {  \n\n    /**\n     * 重写evaluate()\n     *\n     * @param fraction 动画完成度（根据它来计算当前动画的值）\n     * @param startValue 动画的初始值\n     * @param endValue 动画的结束值\n     * @return \n     */\n    public Object evaluate(float fraction, Object startValue, Object endValue) {  \n\n        float startFloat = ((Number) startValue).floatValue();  \n        \n        // 初始值过渡到结束值的算法\n        // 1. 用结束值减去初始值，算出它们之间的差值\n        // 2. 用上述差值乘以 fraction 系数\n        // 3. 加上初始值，得到当前动画的值\n        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  \n    }  \n}  \n```\n\n#### ofObject\n对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。\n\n但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。\n\n自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。\n\n```Java\npublic class PointEvaluator implements TypeEvaluator {\n\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        // 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n\n        // 根据fraction来计算当前动画的x和y的值\n        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());\n        \n        // 将计算后的坐标封装到一个新的Point对象中并返回\n        Point point = new Point(x, y);\n        return point;\n    }\n}\n```\n将属性动画作用到自定义View当中\n```Java\npublic class MyView extends View {\n\n    public static final float RADIUS = 70f;// 圆的半径\n    private Point currentPoint;// 当前点坐标\n    private Paint mPaint;// 绘图画笔\n    \n    // 构造方法，初始化画笔\n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    // 实现绘制逻辑\n    // 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果\n    @Override\n    protected void onDraw(Canvas canvas) {\n        // 如果当前点坐标为空(即第一次)\n        if (currentPoint == null) {\n            currentPoint = new Point(RADIUS, RADIUS);  // 创建一个点对象(坐标是(70,70))\n\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n\n            // 将属性动画作用到View中\n            Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70)\n            Point endPoint = new Point(700, 1000);// 结束点为(700,1000)\n\n            ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);\n            anim.setDuration(5000);\n    \n            anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override\n                public void onAnimationUpdate(ValueAnimator animation) {\n                    currentPoint = (Point) animation.getAnimatedValue();\n                    // 每次赋值后就重新绘制，从而实现动画效果\n                    // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次\n                    invalidate();  \n                }\n            });\n            anim.start();\n        } else {\n            // 如果坐标值不为0,则画圆\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n        }\n    }\n}\n```\n\n### ObjectAnimator\n继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。\nObjectAnimator 与 ValueAnimator类的区别在于\n- ValueAnimator 类是先改变值，然后**手动赋值**给对象的属性从而实现动画，属于**间接**对对象属性进行操作\n- ObjectAnimator 类是先改变值，然后**自动赋值**给对象的属性从而实现动画，属于**直接**对对象属性进行操作\n\n#### 具体使用\n对于\n> ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ....values); \n\n其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值\n\n对 Button 进行变换\n```Java\n\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  // 效果:常规->全透明->常规\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);\n......\nanimator.setDuration(5000);\nanimator.start();\n```\n\n#### 自定义\n在上面的例子中，我们给`ObjectAnimator.ofFloat`的第二个参数`String property`传入`alpha`、`rotation`、`translationX` 和`scaleY`等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的`get/set`方法进行的。\n\n所以自定义属性就可以通过为对象设置需要操作属性的`set/get`方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。\n\n还是对一个球做变换\n```Java\npublic class MyView2 extends View {\n    public static final float RADIUS = 100f;\n    private Paint mPaint;\n\n    private String color;  // 设置背景颜色属性\n\n    // 设置背景颜色的get() & set()方法\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n        mPaint.setColor(Color.parseColor(color));  // 将画笔的颜色设置成方法参数传入的颜色\n        invalidate();\n    }\n\n    public MyView2(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        canvas.drawCircle(500, 500, RADIUS, mPaint);\n    }\n}\n```\n实现自定义估值器，完成颜色过渡的逻辑\n```Java\npublic class ColorEvaluator implements TypeEvaluator {\n\n    private int mCurrentRed;\n\n    private int mCurrentGreen ;\n\n    private int mCurrentBlue ;\n\n    // 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        String startColor = (String) startValue;\n        String endColor = (String) endValue;\n\n        // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字\n        // 那么每个颜色的取值范围是0-255\n        int startRed = Integer.parseInt(startColor.substring(1, 3), 16);\n        int startGreen = Integer.parseInt(startColor.substring(3, 5), 16);\n        int startBlue = Integer.parseInt(startColor.substring(5, 7), 16);\n\n        int endRed = Integer.parseInt(endColor.substring(1, 3), 16);\n        int endGreen = Integer.parseInt(endColor.substring(3, 5), 16);\n        int endBlue = Integer.parseInt(endColor.substring(5, 7), 16);\n\n        // 将初始化颜色的值定义为当前需要操作的颜色值\n        mCurrentRed = startRed;\n        mCurrentGreen = startGreen;\n        mCurrentBlue = startBlue;\n\n\n        // 计算初始颜色和结束颜色之间的差值\n        // 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢\n        int redDiff = Math.abs(startRed - endRed);\n        int greenDiff = Math.abs(startGreen - endGreen);\n        int blueDiff = Math.abs(startBlue - endBlue);\n        int colorDiff = redDiff + greenDiff + blueDiff;\n        \n        if (mCurrentRed != endRed) {\n            // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1\n            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0, fraction);\n        \n        } else if (mCurrentGreen != endGreen) {\n            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);\n            \n        } else if (mCurrentBlue != endBlue) {\n            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);\n        }\n        // 将计算出的当前颜色的值组装返回\n        String currentColor = \"#\" + getHexString(mCurrentRed)\n                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);\n        return currentColor;\n    }\n\n\n\n    // 根据fraction值来计算当前的颜色。\n    private int getCurrentColor(int startColor, int endColor, int colorDiff,\n                                int offset, float fraction) {\n        int currentColor;\n        if (startColor > endColor) {\n            currentColor = (int) (startColor - (fraction * colorDiff - offset));\n            if (currentColor < endColor) {\n                currentColor = endColor;\n            }\n        } else {\n            currentColor = (int) (startColor + (fraction * colorDiff - offset));\n            if (currentColor > endColor) {\n                currentColor = endColor;\n            }\n        }\n        return currentColor;\n    }\n\n    // 将10进制颜色值转换成16进制。\n    private String getHexString(int value) {\n        String hexString = Integer.toHexString(value);\n        if (hexString.length() == 1) {\n            hexString = \"0\" + hexString;\n        }\n        return hexString;\n    }\n}\n```\n具体调用\n```Java\nObjectAnimator anim = ObjectAnimator.ofObject(myView2, \"color\", new ColorEvaluator(), \"#0000FF\", \"#FF0000\");\nanim.setDuration(2000);\nanim.start();\n```\n\n此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中`setWidth`并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过`get/set`无法改变控件的宽度，也就无法实现动画效果。\n\n解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的`get/set`方法。\n```Java\nButtonWrapper wrapper = new ViewWrapper(button);\nObjectAnimator.ofInt(wrapper, \"width\", 500)\n        .setDuration(3000)\n        .start();\n\nprivate static class ViewWrapper {\n    private View mTarget;\n\n    public ViewWrapper(View target) {\n        mTarget = target;\n    }\n    \n    // 为宽度设置get/set\n    public int getWidth() {\n            return mTarget.getLayoutParams().width;\n    }\n    \n    public void setWidth(int width) {\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n```\n\n### AnimatorSet\n最后介绍组合动画类，仅展示用法\n```Java\n\nObjectAnimator translation = ObjectAnimator.ofFloat(mButton, \"translationX\", curTranslationX, 300,curTranslationX);  \nObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);  \nObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  \n\nAnimatorSet animSet = new AnimatorSet();  \n\nanimSet.play(translation).with(rotate).before(alpha);  \nanimSet.setDuration(5000);  \nanimSet.start();  \n```\n## Spring Animation\nSpringAnimation，弹簧动画，位于`android.support.animation`包中，属性动画位于`android.animation.Animator`包中，其实通过 [BounceInterpolator](https://developer.android.com/reference/android/view/animation/BounceInterpolator.html) 或者 [OvershootInterpolator](https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html) 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。\n\n使用之前需要导入`com.android.support:support-dynamic-animation`包\n\n### API\n```Java\npublic SpringAnimation(View v, ViewProperty property)\npublic SpringAnimation(View v, ViewProperty property, float finalPosition)\n```\n参数分别是操作对应的View，对应的变化属性及最终的位置。\n\nViewProperty 包括(Z轴支持需要API >= 21)：\n>TRANSLATION_X\n>TRANSLATION_Y\n>TRANSLATION_Z\n>SCALE_X\n>SCALE_Y\n>ROTATION\n>ROTATION_X\n>ROTATION_Y\n>X\n>Y\n>Z\n>ALPHA\n>SCROLL_X\n>SCROLL_Y\n\n在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量\n- Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快\n- DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ > 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 < ζ <1)。\n\n### 简单使用\n```Java\nSpringAnimation btnAnim = new SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, 0);\n\nbtnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);\nbtnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);\n\nbtnAnim.setStartVelocity(10000);  //开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反\nbtnAnim.start();\n```","source":"_posts/Android-动画详解.md","raw":"---\ntitle: Android 动画详解\ndate: 2019-02-18 19:12:22\ntags:\n- Android\n- 动画开发\ncategories:\n- Android\n---\n\nAndroid 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。<!--more-->\n\n## View Animation \n视图动画的作用对象是 View，可分为补间动画和帧动画。\n\n### 补间动画\n动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。\n\n#### XML 方式\n创建一个 set.xml 文件，通过动画集合标签`<set>`将四种效果结合起来\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<--动画集合\ninterpolator 表示所采用的的差值器，其影响动画的速度，可以不指定\nshareInterpolator 表示集合中的动画是否和集合共享同一个差值器-->\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fillAfter=\"true\"\n    android:shareInterpolator=\"true\"\n    android:repeatMode=\"reverse\">\n    \n    <!-- 缩放动画\n    fromXScale 表示水平方向缩放的起始值\n    toXScale 表示水平方向的结束值\n    fillAfter 表示动画显示结束保持最后一帧-->\n    <scale  \n        android:duration=\"1000\"\n        android:fillAfter=\"true\"\n        android:fromXScale=\"0.5\"\n        android:fromYScale=\"0.5\"\n        android:toXScale=\"1\"\n        android:toYScale=\"1\"\n        android:repeatCount=\"infinite\"/><!--次数 ,infinite 为无线循环播放-->\n        \n    <!-- 透明度动画\n        fromAlpha 表示起始透明度\n        toAlpha 表示结束透明度-->\n    <alpha\n        android:duration=\"2000\"\n        android:fillAfter=\"true\"\n        android:fromAlpha=\"0.7\"\n        android:toAlpha=\"1\"/>\n        \n    <!--旋转动画\n    fromDegrees 表示起始角度\n    toDegrees 表示结束角度-->\n    <rotate\n        android:fromDegrees=\"0\"\n        android:toDegrees=\"90\"\n        android:fillAfter=\"true\"\n        android:duration=\"1000\"/>\n    \n    <!--平移动画-->\n    <translate\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:toXDelta=\"100%\"\n        android:toYDelta=\"-100%\"\n        android:fillAfter=\"true\"\n        android:duration=\"2000\"\n        />\n</set>\n```\n使用以上动画的方式如下\n```Java\nAnimation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);\nview.startAnimation(anim);\n```\n\n#### Java 代码方式\n使用 Java 代码实现动画的方式如下\n```Java\npublic void startAnimationSet() {\n    //创建动画，参数表示他的子动画是否共用一个插值器\n    AnimationSet animationSet = new AnimationSet(true);\n    //添加动画\n    animationSet.addAnimation(new AlphaAnimation(1.0f, 0.0f));\n    //设置插值器\n    animationSet.setInterpolator(new LinearInterpolator());\n    //设置动画持续时长\n    animationSet.setDuration(3000);\n    //设置动画结束之后是否保持动画的目标状态\n    animationSet.setFillAfter(true);\n    //设置动画结束之后是否保持动画开始时的状态\n    animationSet.setFillBefore(false);\n    //设置重复模式\n    animationSet.setRepeatMode(AnimationSet.REVERSE);\n    //设置重复次数\n    animationSet.setRepeatCount(AnimationSet.INFINITE);\n    //设置动画延时时间\n    animationSet.setStartOffset(2000);\n    //取消动画\n    animationSet.cancel();\n    //释放资源\n    animationSet.reset();\n    //开始动画\n    view.startAnimation(animationSet);\n}\n```\n\n#### 自定义\n除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的`initialize`和`applyTransformation`方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 \n\n#### 特殊使用\nView 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。\n\n### 帧动画\n帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。\n\n首先需要定义一个 XML 文件`frame_animation.xml`\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"false\">\n    <item\n        android:drawable=\"@mipmap/image1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/image2\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/iamge2\"\n        android:duration=\"100\" />\n</animation-list>\n```\n然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可\n```Java\nview.setBackgroundResource(R.drawable.frame_animation)；\nAnimationDrawable drawable = (AnimationDrawable) view.getBackground();\ndrawable.start();\n```\n\n## Property Animation\n属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：\n- 补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。\n- 补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。\n\n与补间动画类似，属性动画也需要定义几个方面的属性：\n- 动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。\n- 动画插值方式。通过 android:interploator 指定。\n- 动画重复次数。通过 android:repeatCount 指定。\n- 重复行为。通过 android:repeatMode 指定。\n- 动画集。在属性资源文件中通过 `<set>` 来组合。\n- 帧刷新率。指定多长时间播放一帧。默认为 10 ms。\n\n### API\n- ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。\n- ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。\n- AnimatorSet：Animator 的子类，用于组合多个 Animator。\n\n属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。\n- IntEvaluator：计算 int 类型属性值的计算器。\n- FloatEvaluator：用于计算 float 类型属性值的计算器。\n- ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。\n- TypeEvaluator：可以自定义计算器。\n\n### ValueAniamtor\nValueAnimator 类中有3个重要方法：\n> ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)\n\n#### ofInt\n将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator\n\n下面的代码将实现按钮的宽度从 150px 放大到 500px\n```Java\n    Button mButton = (Button) findViewById(R.id.Button);\n    // 设置属性数值的初始值 & 结束值\n    // ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500\n    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, 500);\n  \n    // 设置动画的播放各种属性\n    valueAnimator.setDuration(2000);\n\n    // 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度\n    // 设置更新监听器，数值每次变化更新都会调用该方法\n    valueAnimator.addUpdateListener(new AnimatorUpdateListener() {\n    \n        @Override\n        public void onAnimationUpdate(ValueAnimator animator) {\n            // 获得每次变化后的属性值\n            int currentValue = (Integer) animator.getAnimatedValue();\n            // 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化\n            mButton.getLayoutParams().width = currentValue;\n            \n            // 刷新视图，即重新绘制\n            mButton.requestLayout();\n        }\n    });\n    valueAnimator.start();  // 启动动画\n}\n```\n\n#### ofFloat\n其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）\n```Java\npublic class FloatEvaluator implements TypeEvaluator {  \n\n    /**\n     * 重写evaluate()\n     *\n     * @param fraction 动画完成度（根据它来计算当前动画的值）\n     * @param startValue 动画的初始值\n     * @param endValue 动画的结束值\n     * @return \n     */\n    public Object evaluate(float fraction, Object startValue, Object endValue) {  \n\n        float startFloat = ((Number) startValue).floatValue();  \n        \n        // 初始值过渡到结束值的算法\n        // 1. 用结束值减去初始值，算出它们之间的差值\n        // 2. 用上述差值乘以 fraction 系数\n        // 3. 加上初始值，得到当前动画的值\n        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  \n    }  \n}  \n```\n\n#### ofObject\n对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。\n\n但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。\n\n自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。\n\n```Java\npublic class PointEvaluator implements TypeEvaluator {\n\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        // 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n\n        // 根据fraction来计算当前动画的x和y的值\n        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());\n        \n        // 将计算后的坐标封装到一个新的Point对象中并返回\n        Point point = new Point(x, y);\n        return point;\n    }\n}\n```\n将属性动画作用到自定义View当中\n```Java\npublic class MyView extends View {\n\n    public static final float RADIUS = 70f;// 圆的半径\n    private Point currentPoint;// 当前点坐标\n    private Paint mPaint;// 绘图画笔\n    \n    // 构造方法，初始化画笔\n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    // 实现绘制逻辑\n    // 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果\n    @Override\n    protected void onDraw(Canvas canvas) {\n        // 如果当前点坐标为空(即第一次)\n        if (currentPoint == null) {\n            currentPoint = new Point(RADIUS, RADIUS);  // 创建一个点对象(坐标是(70,70))\n\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n\n            // 将属性动画作用到View中\n            Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70)\n            Point endPoint = new Point(700, 1000);// 结束点为(700,1000)\n\n            ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);\n            anim.setDuration(5000);\n    \n            anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override\n                public void onAnimationUpdate(ValueAnimator animation) {\n                    currentPoint = (Point) animation.getAnimatedValue();\n                    // 每次赋值后就重新绘制，从而实现动画效果\n                    // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次\n                    invalidate();  \n                }\n            });\n            anim.start();\n        } else {\n            // 如果坐标值不为0,则画圆\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n        }\n    }\n}\n```\n\n### ObjectAnimator\n继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。\nObjectAnimator 与 ValueAnimator类的区别在于\n- ValueAnimator 类是先改变值，然后**手动赋值**给对象的属性从而实现动画，属于**间接**对对象属性进行操作\n- ObjectAnimator 类是先改变值，然后**自动赋值**给对象的属性从而实现动画，属于**直接**对对象属性进行操作\n\n#### 具体使用\n对于\n> ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ....values); \n\n其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值\n\n对 Button 进行变换\n```Java\n\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  // 效果:常规->全透明->常规\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);\n......\nanimator.setDuration(5000);\nanimator.start();\n```\n\n#### 自定义\n在上面的例子中，我们给`ObjectAnimator.ofFloat`的第二个参数`String property`传入`alpha`、`rotation`、`translationX` 和`scaleY`等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的`get/set`方法进行的。\n\n所以自定义属性就可以通过为对象设置需要操作属性的`set/get`方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。\n\n还是对一个球做变换\n```Java\npublic class MyView2 extends View {\n    public static final float RADIUS = 100f;\n    private Paint mPaint;\n\n    private String color;  // 设置背景颜色属性\n\n    // 设置背景颜色的get() & set()方法\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n        mPaint.setColor(Color.parseColor(color));  // 将画笔的颜色设置成方法参数传入的颜色\n        invalidate();\n    }\n\n    public MyView2(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        canvas.drawCircle(500, 500, RADIUS, mPaint);\n    }\n}\n```\n实现自定义估值器，完成颜色过渡的逻辑\n```Java\npublic class ColorEvaluator implements TypeEvaluator {\n\n    private int mCurrentRed;\n\n    private int mCurrentGreen ;\n\n    private int mCurrentBlue ;\n\n    // 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        String startColor = (String) startValue;\n        String endColor = (String) endValue;\n\n        // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字\n        // 那么每个颜色的取值范围是0-255\n        int startRed = Integer.parseInt(startColor.substring(1, 3), 16);\n        int startGreen = Integer.parseInt(startColor.substring(3, 5), 16);\n        int startBlue = Integer.parseInt(startColor.substring(5, 7), 16);\n\n        int endRed = Integer.parseInt(endColor.substring(1, 3), 16);\n        int endGreen = Integer.parseInt(endColor.substring(3, 5), 16);\n        int endBlue = Integer.parseInt(endColor.substring(5, 7), 16);\n\n        // 将初始化颜色的值定义为当前需要操作的颜色值\n        mCurrentRed = startRed;\n        mCurrentGreen = startGreen;\n        mCurrentBlue = startBlue;\n\n\n        // 计算初始颜色和结束颜色之间的差值\n        // 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢\n        int redDiff = Math.abs(startRed - endRed);\n        int greenDiff = Math.abs(startGreen - endGreen);\n        int blueDiff = Math.abs(startBlue - endBlue);\n        int colorDiff = redDiff + greenDiff + blueDiff;\n        \n        if (mCurrentRed != endRed) {\n            // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1\n            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0, fraction);\n        \n        } else if (mCurrentGreen != endGreen) {\n            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);\n            \n        } else if (mCurrentBlue != endBlue) {\n            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);\n        }\n        // 将计算出的当前颜色的值组装返回\n        String currentColor = \"#\" + getHexString(mCurrentRed)\n                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);\n        return currentColor;\n    }\n\n\n\n    // 根据fraction值来计算当前的颜色。\n    private int getCurrentColor(int startColor, int endColor, int colorDiff,\n                                int offset, float fraction) {\n        int currentColor;\n        if (startColor > endColor) {\n            currentColor = (int) (startColor - (fraction * colorDiff - offset));\n            if (currentColor < endColor) {\n                currentColor = endColor;\n            }\n        } else {\n            currentColor = (int) (startColor + (fraction * colorDiff - offset));\n            if (currentColor > endColor) {\n                currentColor = endColor;\n            }\n        }\n        return currentColor;\n    }\n\n    // 将10进制颜色值转换成16进制。\n    private String getHexString(int value) {\n        String hexString = Integer.toHexString(value);\n        if (hexString.length() == 1) {\n            hexString = \"0\" + hexString;\n        }\n        return hexString;\n    }\n}\n```\n具体调用\n```Java\nObjectAnimator anim = ObjectAnimator.ofObject(myView2, \"color\", new ColorEvaluator(), \"#0000FF\", \"#FF0000\");\nanim.setDuration(2000);\nanim.start();\n```\n\n此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中`setWidth`并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过`get/set`无法改变控件的宽度，也就无法实现动画效果。\n\n解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的`get/set`方法。\n```Java\nButtonWrapper wrapper = new ViewWrapper(button);\nObjectAnimator.ofInt(wrapper, \"width\", 500)\n        .setDuration(3000)\n        .start();\n\nprivate static class ViewWrapper {\n    private View mTarget;\n\n    public ViewWrapper(View target) {\n        mTarget = target;\n    }\n    \n    // 为宽度设置get/set\n    public int getWidth() {\n            return mTarget.getLayoutParams().width;\n    }\n    \n    public void setWidth(int width) {\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n```\n\n### AnimatorSet\n最后介绍组合动画类，仅展示用法\n```Java\n\nObjectAnimator translation = ObjectAnimator.ofFloat(mButton, \"translationX\", curTranslationX, 300,curTranslationX);  \nObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);  \nObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  \n\nAnimatorSet animSet = new AnimatorSet();  \n\nanimSet.play(translation).with(rotate).before(alpha);  \nanimSet.setDuration(5000);  \nanimSet.start();  \n```\n## Spring Animation\nSpringAnimation，弹簧动画，位于`android.support.animation`包中，属性动画位于`android.animation.Animator`包中，其实通过 [BounceInterpolator](https://developer.android.com/reference/android/view/animation/BounceInterpolator.html) 或者 [OvershootInterpolator](https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html) 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。\n\n使用之前需要导入`com.android.support:support-dynamic-animation`包\n\n### API\n```Java\npublic SpringAnimation(View v, ViewProperty property)\npublic SpringAnimation(View v, ViewProperty property, float finalPosition)\n```\n参数分别是操作对应的View，对应的变化属性及最终的位置。\n\nViewProperty 包括(Z轴支持需要API >= 21)：\n>TRANSLATION_X\n>TRANSLATION_Y\n>TRANSLATION_Z\n>SCALE_X\n>SCALE_Y\n>ROTATION\n>ROTATION_X\n>ROTATION_Y\n>X\n>Y\n>Z\n>ALPHA\n>SCROLL_X\n>SCROLL_Y\n\n在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量\n- Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快\n- DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ > 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 < ζ <1)。\n\n### 简单使用\n```Java\nSpringAnimation btnAnim = new SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, 0);\n\nbtnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);\nbtnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);\n\nbtnAnim.setStartVelocity(10000);  //开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反\nbtnAnim.start();\n```","slug":"Android-动画详解","published":1,"updated":"2019-06-02T04:54:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxo003gy4up15ydtx0p","content":"<p>Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。<a id=\"more\"></a></p>\n<h2 id=\"View-Animation\"><a href=\"#View-Animation\" class=\"headerlink\" title=\"View Animation\"></a>View Animation</h2><p>视图动画的作用对象是 View，可分为补间动画和帧动画。</p>\n<h3 id=\"补间动画\"><a href=\"#补间动画\" class=\"headerlink\" title=\"补间动画\"></a>补间动画</h3><p>动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。</p>\n<h4 id=\"XML-方式\"><a href=\"#XML-方式\" class=\"headerlink\" title=\"XML 方式\"></a>XML 方式</h4><p>创建一个 set.xml 文件，通过动画集合标签<code><set></code>将四种效果结合起来<br></p><figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"utf-8\"?></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">--动画集合</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">interpolator</span> 表示所采用的的差值器，其影响动画的速度，可以不指定</span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">shareInterpolator</span> 表示集合中的动画是否和集合共享同一个差值器<span class=\"attr\">--</span>></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">set</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shareInterpolator</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:repeatMode</span>=<span class=\"string\">\"reverse\"</span>></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"><!-- 缩放动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromXScale 表示水平方向缩放的起始值</span></span><br><span class=\"line\"><span class=\"comment\">    toXScale 表示水平方向的结束值</span></span><br><span class=\"line\"><span class=\"comment\">    fillAfter 表示动画显示结束保持最后一帧--></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">scale</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:repeatCount</span>=<span class=\"string\">\"infinite\"</span>/></span><span class=\"comment\"><!--次数 ,infinite 为无线循环播放--></span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\"><!-- 透明度动画</span></span><br><span class=\"line\"><span class=\"comment\">        fromAlpha 表示起始透明度</span></span><br><span class=\"line\"><span class=\"comment\">        toAlpha 表示结束透明度--></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">alpha</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromAlpha</span>=<span class=\"string\">\"0.7\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toAlpha</span>=<span class=\"string\">\"1\"</span>/></span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\"><!--旋转动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromDegrees 表示起始角度</span></span><br><span class=\"line\"><span class=\"comment\">    toDegrees 表示结束角度--></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">rotate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromDegrees</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toDegrees</span>=<span class=\"string\">\"90\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span>/></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"><!--平移动画--></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">translate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXDelta</span>=<span class=\"string\">\"100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYDelta</span>=<span class=\"string\">\"-100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">set</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>使用以上动画的方式如下<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Animation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);</span><br><span class=\"line\">view.startAnimation(anim);</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h4 id=\"Java-代码方式\"><a href=\"#Java-代码方式\" class=\"headerlink\" title=\"Java 代码方式\"></a>Java 代码方式</h4><p>使用 Java 代码实现动画的方式如下<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startAnimationSet</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">//创建动画，参数表示他的子动画是否共用一个插值器</span></span><br><span class=\"line\">    AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//添加动画</span></span><br><span class=\"line\">    animationSet.addAnimation(<span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>));</span><br><span class=\"line\">    <span class=\"comment\">//设置插值器</span></span><br><span class=\"line\">    animationSet.setInterpolator(<span class=\"keyword\">new</span> LinearInterpolator());</span><br><span class=\"line\">    <span class=\"comment\">//设置动画持续时长</span></span><br><span class=\"line\">    animationSet.setDuration(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画的目标状态</span></span><br><span class=\"line\">    animationSet.setFillAfter(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画开始时的状态</span></span><br><span class=\"line\">    animationSet.setFillBefore(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复模式</span></span><br><span class=\"line\">    animationSet.setRepeatMode(AnimationSet.REVERSE);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复次数</span></span><br><span class=\"line\">    animationSet.setRepeatCount(AnimationSet.INFINITE);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画延时时间</span></span><br><span class=\"line\">    animationSet.setStartOffset(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//取消动画</span></span><br><span class=\"line\">    animationSet.cancel();</span><br><span class=\"line\">    <span class=\"comment\">//释放资源</span></span><br><span class=\"line\">    animationSet.reset();</span><br><span class=\"line\">    <span class=\"comment\">//开始动画</span></span><br><span class=\"line\">    view.startAnimation(animationSet);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的<code>initialize</code>和<code>applyTransformation</code>方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 </p>\n<h4 id=\"特殊使用\"><a href=\"#特殊使用\" class=\"headerlink\" title=\"特殊使用\"></a>特殊使用</h4><p>View 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。</p>\n<h3 id=\"帧动画\"><a href=\"#帧动画\" class=\"headerlink\" title=\"帧动画\"></a>帧动画</h3><p>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。</p>\n<p>首先需要定义一个 XML 文件<code>frame_animation.xml</code><br></p><figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"utf-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">animation-list</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:oneshot</span>=<span class=\"string\">\"false\"</span>></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/iamge2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">animation-list</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">view.setBackgroundResource(R.drawable.frame_animation)；</span><br><span class=\"line\">AnimationDrawable drawable = (AnimationDrawable) view.getBackground();</span><br><span class=\"line\">drawable.start();</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"Property-Animation\"><a href=\"#Property-Animation\" class=\"headerlink\" title=\"Property Animation\"></a>Property Animation</h2><p>属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：</p>\n<ul>\n<li>补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。</li>\n<li>补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。</li>\n</ul>\n<p>与补间动画类似，属性动画也需要定义几个方面的属性：</p>\n<ul>\n<li>动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。</li>\n<li>动画插值方式。通过 android:interploator 指定。</li>\n<li>动画重复次数。通过 android:repeatCount 指定。</li>\n<li>重复行为。通过 android:repeatMode 指定。</li>\n<li>动画集。在属性资源文件中通过 <code><set></code> 来组合。</li>\n<li>帧刷新率。指定多长时间播放一帧。默认为 10 ms。</li>\n</ul>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。</li>\n<li>ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。</li>\n<li>AnimatorSet：Animator 的子类，用于组合多个 Animator。</li>\n</ul>\n<p>属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。</p>\n<ul>\n<li>IntEvaluator：计算 int 类型属性值的计算器。</li>\n<li>FloatEvaluator：用于计算 float 类型属性值的计算器。</li>\n<li>ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。</li>\n<li>TypeEvaluator：可以自定义计算器。</li>\n</ul>\n<h3 id=\"ValueAniamtor\"><a href=\"#ValueAniamtor\" class=\"headerlink\" title=\"ValueAniamtor\"></a>ValueAniamtor</h3><p>ValueAnimator 类中有3个重要方法：</p>\n<blockquote>\n<p>ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)</p>\n</blockquote>\n<h4 id=\"ofInt\"><a href=\"#ofInt\" class=\"headerlink\" title=\"ofInt\"></a>ofInt</h4><p>将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator</p>\n<p>下面的代码将实现按钮的宽度从 150px 放大到 500px<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">    Button mButton = (Button) findViewById(R.id.Button);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性数值的初始值 & 结束值</span></span><br><span class=\"line\">    <span class=\"comment\">// ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500</span></span><br><span class=\"line\">    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, <span class=\"number\">500</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置动画的播放各种属性</span></span><br><span class=\"line\">    valueAnimator.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置更新监听器，数值每次变化更新都会调用该方法</span></span><br><span class=\"line\">    valueAnimator.addUpdateListener(<span class=\"keyword\">new</span> AnimatorUpdateListener() {</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animator)</span> </span>{</span><br><span class=\"line\">            <span class=\"comment\">// 获得每次变化后的属性值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> currentValue = (Integer) animator.getAnimatedValue();</span><br><span class=\"line\">            <span class=\"comment\">// 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化</span></span><br><span class=\"line\">            mButton.getLayoutParams().width = currentValue;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 刷新视图，即重新绘制</span></span><br><span class=\"line\">            mButton.requestLayout();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    });</span><br><span class=\"line\">    valueAnimator.start();  <span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h4 id=\"ofFloat\"><a href=\"#ofFloat\" class=\"headerlink\" title=\"ofFloat\"></a>ofFloat</h4><p>其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FloatEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 重写evaluate()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fraction 动画完成度（根据它来计算当前动画的值）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> startValue 动画的初始值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> endValue 动画的结束值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> startFloat = ((Number) startValue).floatValue();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始值过渡到结束值的算法</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 用结束值减去初始值，算出它们之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 用上述差值乘以 fraction 系数</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 加上初始值，得到当前动画的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h4 id=\"ofObject\"><a href=\"#ofObject\" class=\"headerlink\" title=\"ofObject\"></a>ofObject</h4><p>对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。</p>\n<p>但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。</p>\n<p>自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PointEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象</span></span><br><span class=\"line\">        Point startPoint = (Point) startValue;</span><br><span class=\"line\">        Point endPoint = (Point) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据fraction来计算当前动画的x和y的值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());</span><br><span class=\"line\">        <span class=\"keyword\">float</span> y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将计算后的坐标封装到一个新的Point对象中并返回</span></span><br><span class=\"line\">        Point point = <span class=\"keyword\">new</span> Point(x, y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>将属性动画作用到自定义View当中<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">70f</span>;<span class=\"comment\">// 圆的半径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point currentPoint;<span class=\"comment\">// 当前点坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;<span class=\"comment\">// 绘图画笔</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造方法，初始化画笔</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现绘制逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>{</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前点坐标为空(即第一次)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentPoint == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            currentPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);  <span class=\"comment\">// 创建一个点对象(坐标是(70,70))</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将属性动画作用到View中</span></span><br><span class=\"line\">            Point startPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);<span class=\"comment\">// 初始点为圆心(70,70)</span></span><br><span class=\"line\">            Point endPoint = <span class=\"keyword\">new</span> Point(<span class=\"number\">700</span>, <span class=\"number\">1000</span>);<span class=\"comment\">// 结束点为(700,1000)</span></span><br><span class=\"line\"></span><br><span class=\"line\">            ValueAnimator anim = ValueAnimator.ofObject(<span class=\"keyword\">new</span> PointEvaluator(), startPoint, endPoint);</span><br><span class=\"line\">            anim.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">            anim.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() {</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>{</span><br><span class=\"line\">                    currentPoint = (Point) animation.getAnimatedValue();</span><br><span class=\"line\">                    <span class=\"comment\">// 每次赋值后就重新绘制，从而实现动画效果</span></span><br><span class=\"line\">                    <span class=\"comment\">// 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次</span></span><br><span class=\"line\">                    invalidate();  </span><br><span class=\"line\">                }</span><br><span class=\"line\">            });</span><br><span class=\"line\">            anim.start();</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"comment\">// 如果坐标值不为0,则画圆</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h3><p>继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。<br>ObjectAnimator 与 ValueAnimator类的区别在于</p>\n<ul>\n<li>ValueAnimator 类是先改变值，然后<strong>手动赋值</strong>给对象的属性从而实现动画，属于<strong>间接</strong>对对象属性进行操作</li>\n<li>ObjectAnimator 类是先改变值，然后<strong>自动赋值</strong>给对象的属性从而实现动画，属于<strong>直接</strong>对对象属性进行操作</li>\n</ul>\n<h4 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h4><p>对于</p>\n<blockquote>\n<p>ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ….values); </p>\n</blockquote>\n<p>其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值</p>\n<p>对 Button 进行变换<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  <span class=\"comment\">// 效果:常规->全透明->常规</span></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);</span><br><span class=\"line\">......</span><br><span class=\"line\">animator.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h4 id=\"自定义-1\"><a href=\"#自定义-1\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>在上面的例子中，我们给<code>ObjectAnimator.ofFloat</code>的第二个参数<code>String property</code>传入<code>alpha</code>、<code>rotation</code>、<code>translationX</code> 和<code>scaleY</code>等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的<code>get/set</code>方法进行的。</p>\n<p>所以自定义属性就可以通过为对象设置需要操作属性的<code>set/get</code>方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。</p>\n<p>还是对一个球做变换<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView2</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">100f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String color;  <span class=\"comment\">// 设置背景颜色属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置背景颜色的get() & set()方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getColor</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(String color)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">        mPaint.setColor(Color.parseColor(color));  <span class=\"comment\">// 将画笔的颜色设置成方法参数传入的颜色</span></span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView2</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>{</span><br><span class=\"line\">        canvas.drawCircle(<span class=\"number\">500</span>, <span class=\"number\">500</span>, RADIUS, mPaint);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>实现自定义估值器，完成颜色过渡的逻辑<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentRed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentGreen ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentBlue ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">        String startColor = (String) startValue;</span><br><span class=\"line\">        String endColor = (String) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么每个颜色的取值范围是0-255</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> startRed = Integer.parseInt(startColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startGreen = Integer.parseInt(startColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startBlue = Integer.parseInt(startColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> endRed = Integer.parseInt(endColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endGreen = Integer.parseInt(endColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endBlue = Integer.parseInt(endColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将初始化颜色的值定义为当前需要操作的颜色值</span></span><br><span class=\"line\">        mCurrentRed = startRed;</span><br><span class=\"line\">        mCurrentGreen = startGreen;</span><br><span class=\"line\">        mCurrentBlue = startBlue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算初始颜色和结束颜色之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> redDiff = Math.abs(startRed - endRed);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> greenDiff = Math.abs(startGreen - endGreen);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> blueDiff = Math.abs(startBlue - endBlue);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> colorDiff = redDiff + greenDiff + blueDiff;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCurrentRed != endRed) {</span><br><span class=\"line\">            <span class=\"comment\">// getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1</span></span><br><span class=\"line\">            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, <span class=\"number\">0</span>, fraction);</span><br><span class=\"line\">        </span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentGreen != endGreen) {</span><br><span class=\"line\">            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);</span><br><span class=\"line\">            </span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentBlue != endBlue) {</span><br><span class=\"line\">            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 将计算出的当前颜色的值组装返回</span></span><br><span class=\"line\">        String currentColor = <span class=\"string\">\"#\"</span> + getHexString(mCurrentRed)</span><br><span class=\"line\">                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据fraction值来计算当前的颜色。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getCurrentColor</span><span class=\"params\">(<span class=\"keyword\">int</span> startColor, <span class=\"keyword\">int</span> endColor, <span class=\"keyword\">int</span> colorDiff,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> offset, <span class=\"keyword\">float</span> fraction)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentColor;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startColor > endColor) {</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor - (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor < endColor) {</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor + (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor > endColor) {</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将10进制颜色值转换成16进制。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getHexString</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>{</span><br><span class=\"line\">        String hexString = Integer.toHexString(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hexString.length() == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            hexString = <span class=\"string\">\"0\"</span> + hexString;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hexString;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>具体调用<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ObjectAnimator anim = ObjectAnimator.ofObject(myView2, <span class=\"string\">\"color\"</span>, <span class=\"keyword\">new</span> ColorEvaluator(), <span class=\"string\">\"#0000FF\"</span>, <span class=\"string\">\"#FF0000\"</span>);</span><br><span class=\"line\">anim.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\">anim.start();</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中<code>setWidth</code>并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过<code>get/set</code>无法改变控件的宽度，也就无法实现动画效果。</p>\n<p>解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的<code>get/set</code>方法。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ButtonWrapper wrapper = <span class=\"keyword\">new</span> ViewWrapper(button);</span><br><span class=\"line\">ObjectAnimator.ofInt(wrapper, <span class=\"string\">\"width\"</span>, <span class=\"number\">500</span>)</span><br><span class=\"line\">        .setDuration(<span class=\"number\">3000</span>)</span><br><span class=\"line\">        .start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewWrapper</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewWrapper</span><span class=\"params\">(View target)</span> </span>{</span><br><span class=\"line\">        mTarget = target;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 为宽度设置get/set</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWidth</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mTarget.getLayoutParams().width;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> width)</span> </span>{</span><br><span class=\"line\">        mTarget.getLayoutParams().width = width;</span><br><span class=\"line\">        mTarget.requestLayout();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"AnimatorSet\"><a href=\"#AnimatorSet\" class=\"headerlink\" title=\"AnimatorSet\"></a>AnimatorSet</h3><p>最后介绍组合动画类，仅展示用法<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"translationX\"</span>, curTranslationX, <span class=\"number\">300</span>,curTranslationX);  </span><br><span class=\"line\">ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);  </span><br><span class=\"line\">ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">AnimatorSet animSet = <span class=\"keyword\">new</span> AnimatorSet();  </span><br><span class=\"line\"></span><br><span class=\"line\">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class=\"line\">animSet.setDuration(<span class=\"number\">5000</span>);  </span><br><span class=\"line\">animSet.start();</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"Spring-Animation\"><a href=\"#Spring-Animation\" class=\"headerlink\" title=\"Spring Animation\"></a>Spring Animation</h2><p>SpringAnimation，弹簧动画，位于<code>android.support.animation</code>包中，属性动画位于<code>android.animation.Animator</code>包中，其实通过 <a href=\"https://developer.android.com/reference/android/view/animation/BounceInterpolator.html\" target=\"_blank\" rel=\"noopener\">BounceInterpolator</a> 或者 <a href=\"https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html\" target=\"_blank\" rel=\"noopener\">OvershootInterpolator</a> 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。</p>\n<p>使用之前需要导入<code>com.android.support:support-dynamic-animation</code>包</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property, <span class=\"keyword\">float</span> finalPosition)</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>参数分别是操作对应的View，对应的变化属性及最终的位置。</p>\n<p>ViewProperty 包括(Z轴支持需要API >= 21)：</p>\n<blockquote>\n<p>TRANSLATION_X<br>TRANSLATION_Y<br>TRANSLATION_Z<br>SCALE_X<br>SCALE_Y<br>ROTATION<br>ROTATION_X<br>ROTATION_Y<br>X<br>Y<br>Z<br>ALPHA<br>SCROLL_X<br>SCROLL_Y</p>\n</blockquote>\n<p>在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量</p>\n<ul>\n<li>Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快</li>\n<li>DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ > 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 < ζ <1)。</li>\n</ul>\n<h3 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">SpringAnimation btnAnim = <span class=\"keyword\">new</span> SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);</span><br><span class=\"line\">btnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.setStartVelocity(<span class=\"number\">10000</span>);  <span class=\"comment\">//开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反</span></span><br><span class=\"line\">btnAnim.start();</span><br></pre></td></tr></tbody></table></figure><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":15879,"excerpt":"<p>Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。</p>","more":"<p></p>\n<h2 id=\"View-Animation\"><a href=\"#View-Animation\" class=\"headerlink\" title=\"View Animation\"></a>View Animation</h2><p>视图动画的作用对象是 View，可分为补间动画和帧动画。</p>\n<h3 id=\"补间动画\"><a href=\"#补间动画\" class=\"headerlink\" title=\"补间动画\"></a>补间动画</h3><p>动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。</p>\n<h4 id=\"XML-方式\"><a href=\"#XML-方式\" class=\"headerlink\" title=\"XML 方式\"></a>XML 方式</h4><p>创建一个 set.xml 文件，通过动画集合标签<code>&lt;set&gt;</code>将四种效果结合起来<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">--动画集合</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">interpolator</span> 表示所采用的的差值器，其影响动画的速度，可以不指定</span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">shareInterpolator</span> 表示集合中的动画是否和集合共享同一个差值器<span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">set</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shareInterpolator</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:repeatMode</span>=<span class=\"string\">\"reverse\"</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 缩放动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromXScale 表示水平方向缩放的起始值</span></span><br><span class=\"line\"><span class=\"comment\">    toXScale 表示水平方向的结束值</span></span><br><span class=\"line\"><span class=\"comment\">    fillAfter 表示动画显示结束保持最后一帧--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scale</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:repeatCount</span>=<span class=\"string\">\"infinite\"</span>/&gt;</span><span class=\"comment\">&lt;!--次数 ,infinite 为无线循环播放--&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 透明度动画</span></span><br><span class=\"line\"><span class=\"comment\">        fromAlpha 表示起始透明度</span></span><br><span class=\"line\"><span class=\"comment\">        toAlpha 表示结束透明度--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">alpha</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromAlpha</span>=<span class=\"string\">\"0.7\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toAlpha</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--旋转动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromDegrees 表示起始角度</span></span><br><span class=\"line\"><span class=\"comment\">    toDegrees 表示结束角度--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rotate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromDegrees</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toDegrees</span>=<span class=\"string\">\"90\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span>/&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--平移动画--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">translate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXDelta</span>=<span class=\"string\">\"100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYDelta</span>=<span class=\"string\">\"-100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用以上动画的方式如下<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Animation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);</span><br><span class=\"line\">view.startAnimation(anim);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Java-代码方式\"><a href=\"#Java-代码方式\" class=\"headerlink\" title=\"Java 代码方式\"></a>Java 代码方式</h4><p>使用 Java 代码实现动画的方式如下<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startAnimationSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建动画，参数表示他的子动画是否共用一个插值器</span></span><br><span class=\"line\">    AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//添加动画</span></span><br><span class=\"line\">    animationSet.addAnimation(<span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>));</span><br><span class=\"line\">    <span class=\"comment\">//设置插值器</span></span><br><span class=\"line\">    animationSet.setInterpolator(<span class=\"keyword\">new</span> LinearInterpolator());</span><br><span class=\"line\">    <span class=\"comment\">//设置动画持续时长</span></span><br><span class=\"line\">    animationSet.setDuration(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画的目标状态</span></span><br><span class=\"line\">    animationSet.setFillAfter(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画开始时的状态</span></span><br><span class=\"line\">    animationSet.setFillBefore(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复模式</span></span><br><span class=\"line\">    animationSet.setRepeatMode(AnimationSet.REVERSE);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复次数</span></span><br><span class=\"line\">    animationSet.setRepeatCount(AnimationSet.INFINITE);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画延时时间</span></span><br><span class=\"line\">    animationSet.setStartOffset(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//取消动画</span></span><br><span class=\"line\">    animationSet.cancel();</span><br><span class=\"line\">    <span class=\"comment\">//释放资源</span></span><br><span class=\"line\">    animationSet.reset();</span><br><span class=\"line\">    <span class=\"comment\">//开始动画</span></span><br><span class=\"line\">    view.startAnimation(animationSet);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的<code>initialize</code>和<code>applyTransformation</code>方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 </p>\n<h4 id=\"特殊使用\"><a href=\"#特殊使用\" class=\"headerlink\" title=\"特殊使用\"></a>特殊使用</h4><p>View 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。</p>\n<h3 id=\"帧动画\"><a href=\"#帧动画\" class=\"headerlink\" title=\"帧动画\"></a>帧动画</h3><p>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。</p>\n<p>首先需要定义一个 XML 文件<code>frame_animation.xml</code><br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">animation-list</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:oneshot</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/iamge2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">view.setBackgroundResource(R.drawable.frame_animation)；</span><br><span class=\"line\">AnimationDrawable drawable = (AnimationDrawable) view.getBackground();</span><br><span class=\"line\">drawable.start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Property-Animation\"><a href=\"#Property-Animation\" class=\"headerlink\" title=\"Property Animation\"></a>Property Animation</h2><p>属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：</p>\n<ul>\n<li>补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。</li>\n<li>补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。</li>\n</ul>\n<p>与补间动画类似，属性动画也需要定义几个方面的属性：</p>\n<ul>\n<li>动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。</li>\n<li>动画插值方式。通过 android:interploator 指定。</li>\n<li>动画重复次数。通过 android:repeatCount 指定。</li>\n<li>重复行为。通过 android:repeatMode 指定。</li>\n<li>动画集。在属性资源文件中通过 <code>&lt;set&gt;</code> 来组合。</li>\n<li>帧刷新率。指定多长时间播放一帧。默认为 10 ms。</li>\n</ul>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。</li>\n<li>ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。</li>\n<li>AnimatorSet：Animator 的子类，用于组合多个 Animator。</li>\n</ul>\n<p>属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。</p>\n<ul>\n<li>IntEvaluator：计算 int 类型属性值的计算器。</li>\n<li>FloatEvaluator：用于计算 float 类型属性值的计算器。</li>\n<li>ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。</li>\n<li>TypeEvaluator：可以自定义计算器。</li>\n</ul>\n<h3 id=\"ValueAniamtor\"><a href=\"#ValueAniamtor\" class=\"headerlink\" title=\"ValueAniamtor\"></a>ValueAniamtor</h3><p>ValueAnimator 类中有3个重要方法：</p>\n<blockquote>\n<p>ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)</p>\n</blockquote>\n<h4 id=\"ofInt\"><a href=\"#ofInt\" class=\"headerlink\" title=\"ofInt\"></a>ofInt</h4><p>将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator</p>\n<p>下面的代码将实现按钮的宽度从 150px 放大到 500px<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    Button mButton = (Button) findViewById(R.id.Button);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性数值的初始值 &amp; 结束值</span></span><br><span class=\"line\">    <span class=\"comment\">// ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500</span></span><br><span class=\"line\">    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, <span class=\"number\">500</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置动画的播放各种属性</span></span><br><span class=\"line\">    valueAnimator.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置更新监听器，数值每次变化更新都会调用该方法</span></span><br><span class=\"line\">    valueAnimator.addUpdateListener(<span class=\"keyword\">new</span> AnimatorUpdateListener() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animator)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得每次变化后的属性值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> currentValue = (Integer) animator.getAnimatedValue();</span><br><span class=\"line\">            <span class=\"comment\">// 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化</span></span><br><span class=\"line\">            mButton.getLayoutParams().width = currentValue;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 刷新视图，即重新绘制</span></span><br><span class=\"line\">            mButton.requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    valueAnimator.start();  <span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ofFloat\"><a href=\"#ofFloat\" class=\"headerlink\" title=\"ofFloat\"></a>ofFloat</h4><p>其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FloatEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 重写evaluate()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fraction 动画完成度（根据它来计算当前动画的值）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> startValue 动画的初始值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> endValue 动画的结束值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> startFloat = ((Number) startValue).floatValue();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始值过渡到结束值的算法</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 用结束值减去初始值，算出它们之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 用上述差值乘以 fraction 系数</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 加上初始值，得到当前动画的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ofObject\"><a href=\"#ofObject\" class=\"headerlink\" title=\"ofObject\"></a>ofObject</h4><p>对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。</p>\n<p>但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。</p>\n<p>自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PointEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象</span></span><br><span class=\"line\">        Point startPoint = (Point) startValue;</span><br><span class=\"line\">        Point endPoint = (Point) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据fraction来计算当前动画的x和y的值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());</span><br><span class=\"line\">        <span class=\"keyword\">float</span> y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将计算后的坐标封装到一个新的Point对象中并返回</span></span><br><span class=\"line\">        Point point = <span class=\"keyword\">new</span> Point(x, y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将属性动画作用到自定义View当中<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">70f</span>;<span class=\"comment\">// 圆的半径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point currentPoint;<span class=\"comment\">// 当前点坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;<span class=\"comment\">// 绘图画笔</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造方法，初始化画笔</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现绘制逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前点坐标为空(即第一次)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentPoint == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            currentPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);  <span class=\"comment\">// 创建一个点对象(坐标是(70,70))</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将属性动画作用到View中</span></span><br><span class=\"line\">            Point startPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);<span class=\"comment\">// 初始点为圆心(70,70)</span></span><br><span class=\"line\">            Point endPoint = <span class=\"keyword\">new</span> Point(<span class=\"number\">700</span>, <span class=\"number\">1000</span>);<span class=\"comment\">// 结束点为(700,1000)</span></span><br><span class=\"line\"></span><br><span class=\"line\">            ValueAnimator anim = ValueAnimator.ofObject(<span class=\"keyword\">new</span> PointEvaluator(), startPoint, endPoint);</span><br><span class=\"line\">            anim.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">            anim.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">                    currentPoint = (Point) animation.getAnimatedValue();</span><br><span class=\"line\">                    <span class=\"comment\">// 每次赋值后就重新绘制，从而实现动画效果</span></span><br><span class=\"line\">                    <span class=\"comment\">// 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次</span></span><br><span class=\"line\">                    invalidate();  </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            anim.start();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果坐标值不为0,则画圆</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h3><p>继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。<br>ObjectAnimator 与 ValueAnimator类的区别在于</p>\n<ul>\n<li>ValueAnimator 类是先改变值，然后<strong>手动赋值</strong>给对象的属性从而实现动画，属于<strong>间接</strong>对对象属性进行操作</li>\n<li>ObjectAnimator 类是先改变值，然后<strong>自动赋值</strong>给对象的属性从而实现动画，属于<strong>直接</strong>对对象属性进行操作</li>\n</ul>\n<h4 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h4><p>对于</p>\n<blockquote>\n<p>ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ….values); </p>\n</blockquote>\n<p>其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值</p>\n<p>对 Button 进行变换<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  <span class=\"comment\">// 效果:常规-&gt;全透明-&gt;常规</span></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);</span><br><span class=\"line\">......</span><br><span class=\"line\">animator.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自定义-1\"><a href=\"#自定义-1\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>在上面的例子中，我们给<code>ObjectAnimator.ofFloat</code>的第二个参数<code>String property</code>传入<code>alpha</code>、<code>rotation</code>、<code>translationX</code> 和<code>scaleY</code>等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的<code>get/set</code>方法进行的。</p>\n<p>所以自定义属性就可以通过为对象设置需要操作属性的<code>set/get</code>方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。</p>\n<p>还是对一个球做变换<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView2</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">100f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String color;  <span class=\"comment\">// 设置背景颜色属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置背景颜色的get() &amp; set()方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getColor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">        mPaint.setColor(Color.parseColor(color));  <span class=\"comment\">// 将画笔的颜色设置成方法参数传入的颜色</span></span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView2</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        canvas.drawCircle(<span class=\"number\">500</span>, <span class=\"number\">500</span>, RADIUS, mPaint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现自定义估值器，完成颜色过渡的逻辑<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentRed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentGreen ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentBlue ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String startColor = (String) startValue;</span><br><span class=\"line\">        String endColor = (String) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么每个颜色的取值范围是0-255</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> startRed = Integer.parseInt(startColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startGreen = Integer.parseInt(startColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startBlue = Integer.parseInt(startColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> endRed = Integer.parseInt(endColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endGreen = Integer.parseInt(endColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endBlue = Integer.parseInt(endColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将初始化颜色的值定义为当前需要操作的颜色值</span></span><br><span class=\"line\">        mCurrentRed = startRed;</span><br><span class=\"line\">        mCurrentGreen = startGreen;</span><br><span class=\"line\">        mCurrentBlue = startBlue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算初始颜色和结束颜色之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> redDiff = Math.abs(startRed - endRed);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> greenDiff = Math.abs(startGreen - endGreen);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> blueDiff = Math.abs(startBlue - endBlue);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> colorDiff = redDiff + greenDiff + blueDiff;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCurrentRed != endRed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// getCurrentColor()决定如何根据差值来决定颜色变化的快慢 -&gt;&gt;关注1</span></span><br><span class=\"line\">            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, <span class=\"number\">0</span>, fraction);</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentGreen != endGreen) &#123;</span><br><span class=\"line\">            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentBlue != endBlue) &#123;</span><br><span class=\"line\">            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将计算出的当前颜色的值组装返回</span></span><br><span class=\"line\">        String currentColor = <span class=\"string\">\"#\"</span> + getHexString(mCurrentRed)</span><br><span class=\"line\">                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据fraction值来计算当前的颜色。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getCurrentColor</span><span class=\"params\">(<span class=\"keyword\">int</span> startColor, <span class=\"keyword\">int</span> endColor, <span class=\"keyword\">int</span> colorDiff,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> offset, <span class=\"keyword\">float</span> fraction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentColor;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startColor &gt; endColor) &#123;</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor - (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor &lt; endColor) &#123;</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor + (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor &gt; endColor) &#123;</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将10进制颜色值转换成16进制。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getHexString</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        String hexString = Integer.toHexString(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hexString.length() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            hexString = <span class=\"string\">\"0\"</span> + hexString;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hexString;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体调用<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ObjectAnimator anim = ObjectAnimator.ofObject(myView2, <span class=\"string\">\"color\"</span>, <span class=\"keyword\">new</span> ColorEvaluator(), <span class=\"string\">\"#0000FF\"</span>, <span class=\"string\">\"#FF0000\"</span>);</span><br><span class=\"line\">anim.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\">anim.start();</span><br></pre></td></tr></table></figure></p>\n<p>此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中<code>setWidth</code>并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过<code>get/set</code>无法改变控件的宽度，也就无法实现动画效果。</p>\n<p>解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的<code>get/set</code>方法。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ButtonWrapper wrapper = <span class=\"keyword\">new</span> ViewWrapper(button);</span><br><span class=\"line\">ObjectAnimator.ofInt(wrapper, <span class=\"string\">\"width\"</span>, <span class=\"number\">500</span>)</span><br><span class=\"line\">        .setDuration(<span class=\"number\">3000</span>)</span><br><span class=\"line\">        .start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewWrapper</span><span class=\"params\">(View target)</span> </span>&#123;</span><br><span class=\"line\">        mTarget = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 为宽度设置get/set</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWidth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mTarget.getLayoutParams().width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> width)</span> </span>&#123;</span><br><span class=\"line\">        mTarget.getLayoutParams().width = width;</span><br><span class=\"line\">        mTarget.requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AnimatorSet\"><a href=\"#AnimatorSet\" class=\"headerlink\" title=\"AnimatorSet\"></a>AnimatorSet</h3><p>最后介绍组合动画类，仅展示用法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"translationX\"</span>, curTranslationX, <span class=\"number\">300</span>,curTranslationX);  </span><br><span class=\"line\">ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);  </span><br><span class=\"line\">ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">AnimatorSet animSet = <span class=\"keyword\">new</span> AnimatorSet();  </span><br><span class=\"line\"></span><br><span class=\"line\">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class=\"line\">animSet.setDuration(<span class=\"number\">5000</span>);  </span><br><span class=\"line\">animSet.start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Spring-Animation\"><a href=\"#Spring-Animation\" class=\"headerlink\" title=\"Spring Animation\"></a>Spring Animation</h2><p>SpringAnimation，弹簧动画，位于<code>android.support.animation</code>包中，属性动画位于<code>android.animation.Animator</code>包中，其实通过 <a href=\"https://developer.android.com/reference/android/view/animation/BounceInterpolator.html\" target=\"_blank\" rel=\"noopener\">BounceInterpolator</a> 或者 <a href=\"https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html\" target=\"_blank\" rel=\"noopener\">OvershootInterpolator</a> 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。</p>\n<p>使用之前需要导入<code>com.android.support:support-dynamic-animation</code>包</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property, <span class=\"keyword\">float</span> finalPosition)</span></span></span><br></pre></td></tr></table></figure>\n<p>参数分别是操作对应的View，对应的变化属性及最终的位置。</p>\n<p>ViewProperty 包括(Z轴支持需要API &gt;= 21)：</p>\n<blockquote>\n<p>TRANSLATION_X<br>TRANSLATION_Y<br>TRANSLATION_Z<br>SCALE_X<br>SCALE_Y<br>ROTATION<br>ROTATION_X<br>ROTATION_Y<br>X<br>Y<br>Z<br>ALPHA<br>SCROLL_X<br>SCROLL_Y</p>\n</blockquote>\n<p>在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量</p>\n<ul>\n<li>Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快</li>\n<li>DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ &gt; 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 &lt; ζ &lt;1)。</li>\n</ul>\n<h3 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SpringAnimation btnAnim = <span class=\"keyword\">new</span> SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);</span><br><span class=\"line\">btnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.setStartVelocity(<span class=\"number\">10000</span>);  <span class=\"comment\">//开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反</span></span><br><span class=\"line\">btnAnim.start();</span><br></pre></td></tr></table></figure>"},{"title":"Kotlin 委托属性详解","date":"2019-05-21T08:52:14.000Z","_content":"\n委托属性算是 Kotlin 语言中的高级特性，初次接触可能毫无头绪，再次接触还是一脸懵逼。只有在深入理解其语言特性和实现原理之后，才能对这一甜之又甜的“语法糖”有所认识，从而极大提高代码效率。在笔者的项目 [UESTC_BBS](https://github.com/Febers/UESTC_BBS) 中，对自带 SharedPreferences 的封装 [PreferenceUtils ](https://github.com/Febers/UESTC_BBS/blob/master/app/src/main/java/com/febers/uestc_bbs/utils/PreferenceUtils.kt)就使用了委托属性，故一直想找机会写一篇笔记类型的文章将其记录下来。委托属性的基础是**委托**，一种设计模式，操作的对象不用自己执行，而是委托给另一个辅助对象。<!--more-->\n\n## 委托\n\n### 基本使用\n\n定义一个委托属性的基本语法为 `val/var <属性名>: <类型> by <表达式>`，在 *by* 后面的表达式即为*委托*， 属性对应的 `get()`与`set()`会被委托给它的 `getValue()` 与 `setValue()` 方法。 \n\n```kotlin\nclass Example {\n    var p: String by Delegate()\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            var e = Example()\n            println(e.p)\n            e.p = \"newValue\"\n        }\n    }\n}\n\nclass Delegate {\n\n    operator fun getValue(thisRef: Any?, property: Any): String {\n        return \"$thisRef, thank you for delegating '$property' to me!\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: Any, value: String) {\n        println(\"$value has been assigned to '$property' in $thisRef.\")\n    }\n}\n```\n\n上述代码中，Delegate 内方法的参数 property 原本为 KProperty<*> 接口类型，为了手动调用其方法，改成 Any 以实现传参。\n\n控制台输出结果为\n\n```bash\nExample@1175e2db, thank you for delegating 'p' to me!\nnewValue has been assigned to 'p' in Example@1175e2db.\n```\n\n可以看到属性 p 委托给了 Delegate() 对象实例，按照约定，该对象必须声明具有`getValue`、`setValue`方法，且方法参数个数必须大于2、3。\n\n为了更清楚的了解这一过程，可以将代码改写成另一种形式\n\n```kotlin\nclass Example {\n\n    var delegate: Delegate = Delegate()\n    \n    var p: String\n        set(value) {\n            delegate.setValue(thisRef = this, property = delegate, value = value)\n        }\n        get() = delegate.getValue(thisRef = this, property = delegate)\n}\n```\n\n当我们使用 p 时调用其`get`方法，给 p 赋值时调用其`set`方法，并且都是通过委托对象 delegate 实现。\n\n## 标准委托\n\n### lazy\n\n函数`lazy`接收一个 lambda 表达式并返回一个 `Lazy <T>` 实例，默认情况下其线程安全\n\n```kotlin\n//方法签名\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)\n\n\nval s: String by lazy {\n\tprintln(\"get\")\n\t\"hello\"\n}\n\nprintln(s)\nprintln(s)\n```\n\n只有在第一次调用 s 时才会执行传递给 `lazy()` 的 lambda 表达式并返回一个记录下来的结果， 后续调用 `get()` 只会返回记录的结果。底层原理在于函数签名中的`SynchronizedLazyImpl`方法，其中会检查变量的值，判断其是否为默认值，如果是则执行初始化函数，否则直接返回结果，具体代码可以查阅`LazyJVM.kt`文件。\n\n控制台输出为\n\n```bash\nget\nhello\nhello\n```\n\n### observable\n\n字面意思，用委托的方式来定义一个可观察属性。该函数的方法签名为\n\n```kotlin\npublic inline fun <T> observable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit):\n            ReadWriteProperty<Any?, T>\n```\n\n其接收两个参数，第一个为默认值，第二个为 lambda 表达式，位于`Delegates.kt`，具体使用\n\n```kotlin\nvar name: String by Delegates.observable(\"initialValue\") {\n\tproperty, oldValue, newValue ->\n\tprintln(\"$oldValue -> $newValue\")\n}\nname = \"newValue0\"\nname = \"newValue1\"\n```\n\n控制台输出\n\n```bash\ninitialValue -> newValue0\nnewValue0 -> newValue1\n```\n\n### Storing\n\n将对象的属性委托值 map 中，用于解析 JSON 或者其他动态工作，不过应用较少\n\n```kotlin\nval user = User(mapOf(\"name\" to \"Jack\", \"age\" to 20))\nprintln(user.name)\nprintln(user.age)\n\nclass User(private val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int by map\n}\n```\n\n## 典型应用\n\n封装一个 SharedPreferences（简称 SP） 是 Android 开发中经常要做的事，因为直接调用 SP 足够繁琐。如果是 Java 代码，则代码基本如下\n\n```java\npublic final class PreferencesUtil {\n    private static PreferencesUtil sInstance;\n\n    public static void init(Context context) {\n        if (sInstance == null) {\n            sInstance = new PreferencesUtil(context);\n        }\n    }\n\n    public static PreferencesUtil getInstance() {\n        if (sInstance == null) throw new RuntimeException(\"Uninitialized.\");\n\n        return sInstance;\n    }\n\n    private final SharedPreferences mSp;\n\n    private PreferencesUtil(Context context) {\n        mSp = PreferenceManager.getDefaultSharedPreferences(context);\n    }\n\n    public String getString(String key, String defValue) {\n        return mSp.getString(key, defValue);\n    }\n\n    public void putString(String key, String value) {\n        mSp.edit().putString(key, value).apply();\n    }\n\n    public int getInt(String key, int defValue) {\n        return mSp.getInt(key, defValue);\n    }\n\n    public void putInt(String key, int value) {\n        mSp.edit().putInt(key, value).apply();\n    }\n\n    public long getLong(String key, long defValue) {\n        return mSp.getLong(key, defValue);\n    }\n\n    public void putLong(String key, long value) {\n        mSp.edit().putLong(key, value).apply();\n    }\n\n    public float getFloat(String key, float defValue) {\n        return mSp.getFloat(key, defValue);\n    }\n\n    public void putFloat(String key, float value) {\n        mSp.edit().putFloat(key, value).apply();\n    }\n\n    public boolean getBoolean(String key, boolean defValue) {\n        return mSp.getBoolean(key, defValue);\n    }\n\n    public void putBoolean(String key, boolean value) {\n        mSp.edit().putBoolean(key, value).apply();\n    }\n}\n```\n\n外部调用\n\n```java\nif (PreferencesUtil.getInstance().getBoolean(Constant.IS_FIRST_LAUNCH, Constant.DEF_IS_FIRST_LAUNCH)) {\n    // Do something first launch, like showing Welcome.\n    ...\n\n    PreferencesUtil.getInstance().putBoolean(Constant.IS_FIRST_LAUNCH, false);\n}\n```\n\n使用 Kotlin 的委托属性之后实现就简洁很多\n\n```kotlin\nclass PreferenceUtils<T>(val context: Context, val name: String, val default: T): ReadWriteProperty<Any?, T> {\n\n    val prefs: SharedPreferences by lazy { context.defaultSharedPreferences }\n\n    override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return findPreference(name, default)\n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        putPreference(name, value)\n    }\n\n    private fun <T> findPreference(name: String, default: T): T = with(prefs) {\n        val res: Any = when (default) {\n            is Long -> getLong(name, default)\n            is Int -> getInt(name, default)\n            is String -> getString(name, default)\n            is Boolean -> getBoolean(name, default)\n            is Float -> getFloat(name, default)\n            else -> throw IllegalArgumentException(\"This type can't be saved into Preferences\")\n        }\n        return@with res as T\n    }\n\n    private fun <T> putPreference(name: String, value: T) = with(prefs.edit()) {\n        when (value) {\n            is Long -> putLong(name, value)\n            is Int -> putInt(name, value)\n            is String -> putString(name, value)\n            is Boolean -> putBoolean(name, value)\n            is Float -> putFloat(name, value)\n            else -> throw IllegalArgumentException(\"This type can't be saved into Preferences\")\n        }.apply()\n    }\n}\n```\n\n其中接口`ReadWriteProperty`为系统提供的规范接口，其中定义了`getValue/setValue`方法。外部调用如下\n\n```kotlin\nvar themeCode by PreferenceUtils(context, Constant.theme_code, default = 1)\nthemeCode = 9527\n```\n\n\n\n","source":"_posts/Kotlin-委托属性详解.md","raw":"---\ntitle: Kotlin 委托属性详解\ndate: 2019-05-21 16:52:14\ntags:\n- Kotlin\n- 委托属性\ncategories: \n- Kotlin\n---\n\n委托属性算是 Kotlin 语言中的高级特性，初次接触可能毫无头绪，再次接触还是一脸懵逼。只有在深入理解其语言特性和实现原理之后，才能对这一甜之又甜的“语法糖”有所认识，从而极大提高代码效率。在笔者的项目 [UESTC_BBS](https://github.com/Febers/UESTC_BBS) 中，对自带 SharedPreferences 的封装 [PreferenceUtils ](https://github.com/Febers/UESTC_BBS/blob/master/app/src/main/java/com/febers/uestc_bbs/utils/PreferenceUtils.kt)就使用了委托属性，故一直想找机会写一篇笔记类型的文章将其记录下来。委托属性的基础是**委托**，一种设计模式，操作的对象不用自己执行，而是委托给另一个辅助对象。<!--more-->\n\n## 委托\n\n### 基本使用\n\n定义一个委托属性的基本语法为 `val/var <属性名>: <类型> by <表达式>`，在 *by* 后面的表达式即为*委托*， 属性对应的 `get()`与`set()`会被委托给它的 `getValue()` 与 `setValue()` 方法。 \n\n```kotlin\nclass Example {\n    var p: String by Delegate()\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            var e = Example()\n            println(e.p)\n            e.p = \"newValue\"\n        }\n    }\n}\n\nclass Delegate {\n\n    operator fun getValue(thisRef: Any?, property: Any): String {\n        return \"$thisRef, thank you for delegating '$property' to me!\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: Any, value: String) {\n        println(\"$value has been assigned to '$property' in $thisRef.\")\n    }\n}\n```\n\n上述代码中，Delegate 内方法的参数 property 原本为 KProperty<*> 接口类型，为了手动调用其方法，改成 Any 以实现传参。\n\n控制台输出结果为\n\n```bash\nExample@1175e2db, thank you for delegating 'p' to me!\nnewValue has been assigned to 'p' in Example@1175e2db.\n```\n\n可以看到属性 p 委托给了 Delegate() 对象实例，按照约定，该对象必须声明具有`getValue`、`setValue`方法，且方法参数个数必须大于2、3。\n\n为了更清楚的了解这一过程，可以将代码改写成另一种形式\n\n```kotlin\nclass Example {\n\n    var delegate: Delegate = Delegate()\n    \n    var p: String\n        set(value) {\n            delegate.setValue(thisRef = this, property = delegate, value = value)\n        }\n        get() = delegate.getValue(thisRef = this, property = delegate)\n}\n```\n\n当我们使用 p 时调用其`get`方法，给 p 赋值时调用其`set`方法，并且都是通过委托对象 delegate 实现。\n\n## 标准委托\n\n### lazy\n\n函数`lazy`接收一个 lambda 表达式并返回一个 `Lazy <T>` 实例，默认情况下其线程安全\n\n```kotlin\n//方法签名\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)\n\n\nval s: String by lazy {\n\tprintln(\"get\")\n\t\"hello\"\n}\n\nprintln(s)\nprintln(s)\n```\n\n只有在第一次调用 s 时才会执行传递给 `lazy()` 的 lambda 表达式并返回一个记录下来的结果， 后续调用 `get()` 只会返回记录的结果。底层原理在于函数签名中的`SynchronizedLazyImpl`方法，其中会检查变量的值，判断其是否为默认值，如果是则执行初始化函数，否则直接返回结果，具体代码可以查阅`LazyJVM.kt`文件。\n\n控制台输出为\n\n```bash\nget\nhello\nhello\n```\n\n### observable\n\n字面意思，用委托的方式来定义一个可观察属性。该函数的方法签名为\n\n```kotlin\npublic inline fun <T> observable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit):\n            ReadWriteProperty<Any?, T>\n```\n\n其接收两个参数，第一个为默认值，第二个为 lambda 表达式，位于`Delegates.kt`，具体使用\n\n```kotlin\nvar name: String by Delegates.observable(\"initialValue\") {\n\tproperty, oldValue, newValue ->\n\tprintln(\"$oldValue -> $newValue\")\n}\nname = \"newValue0\"\nname = \"newValue1\"\n```\n\n控制台输出\n\n```bash\ninitialValue -> newValue0\nnewValue0 -> newValue1\n```\n\n### Storing\n\n将对象的属性委托值 map 中，用于解析 JSON 或者其他动态工作，不过应用较少\n\n```kotlin\nval user = User(mapOf(\"name\" to \"Jack\", \"age\" to 20))\nprintln(user.name)\nprintln(user.age)\n\nclass User(private val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int by map\n}\n```\n\n## 典型应用\n\n封装一个 SharedPreferences（简称 SP） 是 Android 开发中经常要做的事，因为直接调用 SP 足够繁琐。如果是 Java 代码，则代码基本如下\n\n```java\npublic final class PreferencesUtil {\n    private static PreferencesUtil sInstance;\n\n    public static void init(Context context) {\n        if (sInstance == null) {\n            sInstance = new PreferencesUtil(context);\n        }\n    }\n\n    public static PreferencesUtil getInstance() {\n        if (sInstance == null) throw new RuntimeException(\"Uninitialized.\");\n\n        return sInstance;\n    }\n\n    private final SharedPreferences mSp;\n\n    private PreferencesUtil(Context context) {\n        mSp = PreferenceManager.getDefaultSharedPreferences(context);\n    }\n\n    public String getString(String key, String defValue) {\n        return mSp.getString(key, defValue);\n    }\n\n    public void putString(String key, String value) {\n        mSp.edit().putString(key, value).apply();\n    }\n\n    public int getInt(String key, int defValue) {\n        return mSp.getInt(key, defValue);\n    }\n\n    public void putInt(String key, int value) {\n        mSp.edit().putInt(key, value).apply();\n    }\n\n    public long getLong(String key, long defValue) {\n        return mSp.getLong(key, defValue);\n    }\n\n    public void putLong(String key, long value) {\n        mSp.edit().putLong(key, value).apply();\n    }\n\n    public float getFloat(String key, float defValue) {\n        return mSp.getFloat(key, defValue);\n    }\n\n    public void putFloat(String key, float value) {\n        mSp.edit().putFloat(key, value).apply();\n    }\n\n    public boolean getBoolean(String key, boolean defValue) {\n        return mSp.getBoolean(key, defValue);\n    }\n\n    public void putBoolean(String key, boolean value) {\n        mSp.edit().putBoolean(key, value).apply();\n    }\n}\n```\n\n外部调用\n\n```java\nif (PreferencesUtil.getInstance().getBoolean(Constant.IS_FIRST_LAUNCH, Constant.DEF_IS_FIRST_LAUNCH)) {\n    // Do something first launch, like showing Welcome.\n    ...\n\n    PreferencesUtil.getInstance().putBoolean(Constant.IS_FIRST_LAUNCH, false);\n}\n```\n\n使用 Kotlin 的委托属性之后实现就简洁很多\n\n```kotlin\nclass PreferenceUtils<T>(val context: Context, val name: String, val default: T): ReadWriteProperty<Any?, T> {\n\n    val prefs: SharedPreferences by lazy { context.defaultSharedPreferences }\n\n    override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return findPreference(name, default)\n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        putPreference(name, value)\n    }\n\n    private fun <T> findPreference(name: String, default: T): T = with(prefs) {\n        val res: Any = when (default) {\n            is Long -> getLong(name, default)\n            is Int -> getInt(name, default)\n            is String -> getString(name, default)\n            is Boolean -> getBoolean(name, default)\n            is Float -> getFloat(name, default)\n            else -> throw IllegalArgumentException(\"This type can't be saved into Preferences\")\n        }\n        return@with res as T\n    }\n\n    private fun <T> putPreference(name: String, value: T) = with(prefs.edit()) {\n        when (value) {\n            is Long -> putLong(name, value)\n            is Int -> putInt(name, value)\n            is String -> putString(name, value)\n            is Boolean -> putBoolean(name, value)\n            is Float -> putFloat(name, value)\n            else -> throw IllegalArgumentException(\"This type can't be saved into Preferences\")\n        }.apply()\n    }\n}\n```\n\n其中接口`ReadWriteProperty`为系统提供的规范接口，其中定义了`getValue/setValue`方法。外部调用如下\n\n```kotlin\nvar themeCode by PreferenceUtils(context, Constant.theme_code, default = 1)\nthemeCode = 9527\n```\n\n\n\n","slug":"Kotlin-委托属性详解","published":1,"updated":"2019-06-02T05:02:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxq003jy4updovqjxck","content":"<p>委托属性算是 Kotlin 语言中的高级特性，初次接触可能毫无头绪，再次接触还是一脸懵逼。只有在深入理解其语言特性和实现原理之后，才能对这一甜之又甜的“语法糖”有所认识，从而极大提高代码效率。在笔者的项目 <a href=\"https://github.com/Febers/UESTC_BBS\" target=\"_blank\" rel=\"noopener\">UESTC_BBS</a> 中，对自带 SharedPreferences 的封装 <a href=\"https://github.com/Febers/UESTC_BBS/blob/master/app/src/main/java/com/febers/uestc_bbs/utils/PreferenceUtils.kt\" target=\"_blank\" rel=\"noopener\">PreferenceUtils </a>就使用了委托属性，故一直想找机会写一篇笔记类型的文章将其记录下来。委托属性的基础是<strong>委托</strong>，一种设计模式，操作的对象不用自己执行，而是委托给另一个辅助对象。<a id=\"more\"></a></p>\n<h2 id=\"委托\"><a href=\"#委托\" class=\"headerlink\" title=\"委托\"></a>委托</h2><h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><p>定义一个委托属性的基本语法为 <code>val/var <属性名>: <类型> by <表达式></code>，在 <em>by</em> 后面的表达式即为<em>委托</em>， 属性对应的 <code>get()</code>与<code>set()</code>会被委托给它的 <code>getValue()</code> 与 <code>setValue()</code> 方法。 </p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p: String <span class=\"keyword\">by</span> Delegate()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> {</span><br><span class=\"line\">        <span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span><<span class=\"type\">String</span>>)</span></span> {</span><br><span class=\"line\">            <span class=\"keyword\">var</span> e = Example()</span><br><span class=\"line\">            println(e.p)</span><br><span class=\"line\">            e.p = <span class=\"string\">\"newValue\"</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Delegate</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">Any</span>)</span></span>: String {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"<span class=\"variable\">$thisRef</span>, thank you for delegating '<span class=\"variable\">$property</span>' to me!\"</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">Any</span>, value: <span class=\"type\">String</span>)</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"<span class=\"variable\">$value</span> has been assigned to '<span class=\"variable\">$property</span>' in <span class=\"variable\">$thisRef</span>.\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>上述代码中，Delegate 内方法的参数 property 原本为 KProperty<*> 接口类型，为了手动调用其方法，改成 Any 以实现传参。</p>\n<p>控制台输出结果为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Example@1175e2db, thank you <span class=\"keyword\">for</span> delegating <span class=\"string\">'p'</span> to me!</span><br><span class=\"line\">newValue has been assigned to <span class=\"string\">'p'</span> <span class=\"keyword\">in</span> Example@1175e2db.</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到属性 p 委托给了 Delegate() 对象实例，按照约定，该对象必须声明具有<code>getValue</code>、<code>setValue</code>方法，且方法参数个数必须大于2、3。</p>\n<p>为了更清楚的了解这一过程，可以将代码改写成另一种形式</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> delegate: Delegate = Delegate()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> p: String</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(value) {</span><br><span class=\"line\">            delegate.setValue(thisRef = <span class=\"keyword\">this</span>, property = delegate, value = value)</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = delegate.getValue(thisRef = <span class=\"keyword\">this</span>, property = delegate)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>当我们使用 p 时调用其<code>get</code>方法，给 p 赋值时调用其<code>set</code>方法，并且都是通过委托对象 delegate 实现。</p>\n<h2 id=\"标准委托\"><a href=\"#标准委托\" class=\"headerlink\" title=\"标准委托\"></a>标准委托</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\"lazy\"></a>lazy</h3><p>函数<code>lazy</code>接收一个 lambda 表达式并返回一个 <code>Lazy <T></code> 实例，默认情况下其线程安全</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法签名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">actual</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\"><T></span> <span class=\"title\">lazy</span><span class=\"params\">(initializer: ()</span></span> -> T): Lazy<T> = SynchronizedLazyImpl(initializer)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> s: String <span class=\"keyword\">by</span> lazy {</span><br><span class=\"line\">\tprintln(<span class=\"string\">\"get\"</span>)</span><br><span class=\"line\">\t<span class=\"string\">\"hello\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">println(s)</span><br><span class=\"line\">println(s)</span><br></pre></td></tr></tbody></table></figure>\n<p>只有在第一次调用 s 时才会执行传递给 <code>lazy()</code> 的 lambda 表达式并返回一个记录下来的结果， 后续调用 <code>get()</code> 只会返回记录的结果。底层原理在于函数签名中的<code>SynchronizedLazyImpl</code>方法，其中会检查变量的值，判断其是否为默认值，如果是则执行初始化函数，否则直接返回结果，具体代码可以查阅<code>LazyJVM.kt</code>文件。</p>\n<p>控制台输出为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">get</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"observable\"><a href=\"#observable\" class=\"headerlink\" title=\"observable\"></a>observable</h3><p>字面意思，用委托的方式来定义一个可观察属性。该函数的方法签名为</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\"><T></span> <span class=\"title\">observable</span><span class=\"params\">(initialValue: <span class=\"type\">T</span>, <span class=\"keyword\">crossinline</span> onChange: (<span class=\"type\">property</span>: <span class=\"type\">KProperty</span><*>, oldValue: <span class=\"type\">T</span>, newValue: <span class=\"type\">T</span>)</span></span> -> <span class=\"built_in\">Unit</span>):</span><br><span class=\"line\">            ReadWriteProperty<Any?, T></span><br></pre></td></tr></tbody></table></figure>\n<p>其接收两个参数，第一个为默认值，第二个为 lambda 表达式，位于<code>Delegates.kt</code>，具体使用</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String <span class=\"keyword\">by</span> Delegates.observable(<span class=\"string\">\"initialValue\"</span>) {</span><br><span class=\"line\">\tproperty, oldValue, newValue -></span><br><span class=\"line\">\tprintln(<span class=\"string\">\"<span class=\"variable\">$oldValue</span> -> <span class=\"variable\">$newValue</span>\"</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\">name = <span class=\"string\">\"newValue0\"</span></span><br><span class=\"line\">name = <span class=\"string\">\"newValue1\"</span></span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">initialValue -> newValue0</span><br><span class=\"line\">newValue0 -> newValue1</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Storing\"><a href=\"#Storing\" class=\"headerlink\" title=\"Storing\"></a>Storing</h3><p>将对象的属性委托值 map 中，用于解析 JSON 或者其他动态工作，不过应用较少</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> user = User(mapOf(<span class=\"string\">\"name\"</span> to <span class=\"string\">\"Jack\"</span>, <span class=\"string\">\"age\"</span> to <span class=\"number\">20</span>))</span><br><span class=\"line\">println(user.name)</span><br><span class=\"line\">println(user.age)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> map: Map<String, Any?>) {</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String <span class=\"keyword\">by</span> map</span><br><span class=\"line\">    <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> map</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"典型应用\"><a href=\"#典型应用\" class=\"headerlink\" title=\"典型应用\"></a>典型应用</h2><p>封装一个 SharedPreferences（简称 SP） 是 Android 开发中经常要做的事，因为直接调用 SP 足够繁琐。如果是 Java 代码，则代码基本如下</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PreferencesUtil</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> PreferencesUtil sInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            sInstance = <span class=\"keyword\">new</span> PreferencesUtil(context);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PreferencesUtil <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Uninitialized.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sInstance;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedPreferences mSp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">PreferencesUtil</span><span class=\"params\">(Context context)</span> </span>{</span><br><span class=\"line\">        mSp = PreferenceManager.getDefaultSharedPreferences(context);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getString</span><span class=\"params\">(String key, String defValue)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getString(key, defValue);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putString</span><span class=\"params\">(String key, String value)</span> </span>{</span><br><span class=\"line\">        mSp.edit().putString(key, value).apply();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getInt</span><span class=\"params\">(String key, <span class=\"keyword\">int</span> defValue)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getInt(key, defValue);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putInt</span><span class=\"params\">(String key, <span class=\"keyword\">int</span> value)</span> </span>{</span><br><span class=\"line\">        mSp.edit().putInt(key, value).apply();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getLong</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> defValue)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getLong(key, defValue);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putLong</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> value)</span> </span>{</span><br><span class=\"line\">        mSp.edit().putLong(key, value).apply();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getFloat</span><span class=\"params\">(String key, <span class=\"keyword\">float</span> defValue)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getFloat(key, defValue);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putFloat</span><span class=\"params\">(String key, <span class=\"keyword\">float</span> value)</span> </span>{</span><br><span class=\"line\">        mSp.edit().putFloat(key, value).apply();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">getBoolean</span><span class=\"params\">(String key, <span class=\"keyword\">boolean</span> defValue)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getBoolean(key, defValue);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putBoolean</span><span class=\"params\">(String key, <span class=\"keyword\">boolean</span> value)</span> </span>{</span><br><span class=\"line\">        mSp.edit().putBoolean(key, value).apply();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>外部调用</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (PreferencesUtil.getInstance().getBoolean(Constant.IS_FIRST_LAUNCH, Constant.DEF_IS_FIRST_LAUNCH)) {</span><br><span class=\"line\">    <span class=\"comment\">// Do something first launch, like showing Welcome.</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    PreferencesUtil.getInstance().putBoolean(Constant.IS_FIRST_LAUNCH, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>使用 Kotlin 的委托属性之后实现就简洁很多</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PreferenceUtils</span><<span class=\"type\">T</span>></span>(<span class=\"keyword\">val</span> context: Context, <span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> <span class=\"keyword\">default</span>: T): ReadWriteProperty<Any?, T> {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> prefs: SharedPreferences <span class=\"keyword\">by</span> lazy { context.defaultSharedPreferences }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span><*>)</span></span>: T {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findPreference(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span><*>, value: <span class=\"type\">T</span>)</span></span> {</span><br><span class=\"line\">        putPreference(name, value)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\"><T></span> <span class=\"title\">findPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, <span class=\"keyword\">default</span>: <span class=\"type\">T</span>)</span></span>: T = with(prefs) {</span><br><span class=\"line\">        <span class=\"keyword\">val</span> res: Any = <span class=\"keyword\">when</span> (<span class=\"keyword\">default</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Long</span> -> getLong(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Int</span> -> getInt(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -> getString(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Boolean</span> -> getBoolean(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Float</span> -> getFloat(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span> -> <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">\"This type can't be saved into Preferences\"</span>)</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span><span class=\"symbol\">@with</span> res <span class=\"keyword\">as</span> T</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\"><T></span> <span class=\"title\">putPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, value: <span class=\"type\">T</span>)</span></span> = with(prefs.edit()) {</span><br><span class=\"line\">        <span class=\"keyword\">when</span> (value) {</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Long</span> -> putLong(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Int</span> -> putInt(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -> putString(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Boolean</span> -> putBoolean(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Float</span> -> putFloat(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">else</span> -> <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">\"This type can't be saved into Preferences\"</span>)</span><br><span class=\"line\">        }.apply()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>其中接口<code>ReadWriteProperty</code>为系统提供的规范接口，其中定义了<code>getValue/setValue</code>方法。外部调用如下</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> themeCode <span class=\"keyword\">by</span> PreferenceUtils(context, Constant.theme_code, <span class=\"keyword\">default</span> = <span class=\"number\">1</span>)</span><br><span class=\"line\">themeCode = <span class=\"number\">9527</span></span><br></pre></td></tr></tbody></table></figure>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":6600,"excerpt":"<p>委托属性算是 Kotlin 语言中的高级特性，初次接触可能毫无头绪，再次接触还是一脸懵逼。只有在深入理解其语言特性和实现原理之后，才能对这一甜之又甜的“语法糖”有所认识，从而极大提高代码效率。在笔者的项目 <a href=\"https://github.com/Febers/UESTC_BBS\" target=\"_blank\" rel=\"noopener\">UESTC_BBS</a> 中，对自带 SharedPreferences 的封装 <a href=\"https://github.com/Febers/UESTC_BBS/blob/master/app/src/main/java/com/febers/uestc_bbs/utils/PreferenceUtils.kt\" target=\"_blank\" rel=\"noopener\">PreferenceUtils </a>就使用了委托属性，故一直想找机会写一篇笔记类型的文章将其记录下来。委托属性的基础是<strong>委托</strong>，一种设计模式，操作的对象不用自己执行，而是委托给另一个辅助对象。</p>","more":"<p></p>\n<h2 id=\"委托\"><a href=\"#委托\" class=\"headerlink\" title=\"委托\"></a>委托</h2><h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><p>定义一个委托属性的基本语法为 <code>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</code>，在 <em>by</em> 后面的表达式即为<em>委托</em>， 属性对应的 <code>get()</code>与<code>set()</code>会被委托给它的 <code>getValue()</code> 与 <code>setValue()</code> 方法。 </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p: String <span class=\"keyword\">by</span> Delegate()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> e = Example()</span><br><span class=\"line\">            println(e.p)</span><br><span class=\"line\">            e.p = <span class=\"string\">\"newValue\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Delegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">Any</span>)</span></span>: String &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"<span class=\"variable\">$thisRef</span>, thank you for delegating '<span class=\"variable\">$property</span>' to me!\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">Any</span>, value: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"<span class=\"variable\">$value</span> has been assigned to '<span class=\"variable\">$property</span>' in <span class=\"variable\">$thisRef</span>.\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，Delegate 内方法的参数 property 原本为 KProperty&lt;*&gt; 接口类型，为了手动调用其方法，改成 Any 以实现传参。</p>\n<p>控制台输出结果为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example@1175e2db, thank you <span class=\"keyword\">for</span> delegating <span class=\"string\">'p'</span> to me!</span><br><span class=\"line\">newValue has been assigned to <span class=\"string\">'p'</span> <span class=\"keyword\">in</span> Example@1175e2db.</span><br></pre></td></tr></table></figure>\n<p>可以看到属性 p 委托给了 Delegate() 对象实例，按照约定，该对象必须声明具有<code>getValue</code>、<code>setValue</code>方法，且方法参数个数必须大于2、3。</p>\n<p>为了更清楚的了解这一过程，可以将代码改写成另一种形式</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> delegate: Delegate = Delegate()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> p: String</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(value) &#123;</span><br><span class=\"line\">            delegate.setValue(thisRef = <span class=\"keyword\">this</span>, property = delegate, value = value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = delegate.getValue(thisRef = <span class=\"keyword\">this</span>, property = delegate)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们使用 p 时调用其<code>get</code>方法，给 p 赋值时调用其<code>set</code>方法，并且都是通过委托对象 delegate 实现。</p>\n<h2 id=\"标准委托\"><a href=\"#标准委托\" class=\"headerlink\" title=\"标准委托\"></a>标准委托</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\"lazy\"></a>lazy</h3><p>函数<code>lazy</code>接收一个 lambda 表达式并返回一个 <code>Lazy &lt;T&gt;</code> 实例，默认情况下其线程安全</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法签名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">actual</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">lazy</span><span class=\"params\">(initializer: ()</span></span> -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> s: String <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">\tprintln(<span class=\"string\">\"get\"</span>)</span><br><span class=\"line\">\t<span class=\"string\">\"hello\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println(s)</span><br><span class=\"line\">println(s)</span><br></pre></td></tr></table></figure>\n<p>只有在第一次调用 s 时才会执行传递给 <code>lazy()</code> 的 lambda 表达式并返回一个记录下来的结果， 后续调用 <code>get()</code> 只会返回记录的结果。底层原理在于函数签名中的<code>SynchronizedLazyImpl</code>方法，其中会检查变量的值，判断其是否为默认值，如果是则执行初始化函数，否则直接返回结果，具体代码可以查阅<code>LazyJVM.kt</code>文件。</p>\n<p>控制台输出为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">get</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n<h3 id=\"observable\"><a href=\"#observable\" class=\"headerlink\" title=\"observable\"></a>observable</h3><p>字面意思，用委托的方式来定义一个可观察属性。该函数的方法签名为</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">observable</span><span class=\"params\">(initialValue: <span class=\"type\">T</span>, <span class=\"keyword\">crossinline</span> onChange: (<span class=\"type\">property</span>: <span class=\"type\">KProperty</span>&lt;*&gt;, oldValue: <span class=\"type\">T</span>, newValue: <span class=\"type\">T</span>)</span></span> -&gt; <span class=\"built_in\">Unit</span>):</span><br><span class=\"line\">            ReadWriteProperty&lt;Any?, T&gt;</span><br></pre></td></tr></table></figure>\n<p>其接收两个参数，第一个为默认值，第二个为 lambda 表达式，位于<code>Delegates.kt</code>，具体使用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: String <span class=\"keyword\">by</span> Delegates.observable(<span class=\"string\">\"initialValue\"</span>) &#123;</span><br><span class=\"line\">\tproperty, oldValue, newValue -&gt;</span><br><span class=\"line\">\tprintln(<span class=\"string\">\"<span class=\"variable\">$oldValue</span> -&gt; <span class=\"variable\">$newValue</span>\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">name = <span class=\"string\">\"newValue0\"</span></span><br><span class=\"line\">name = <span class=\"string\">\"newValue1\"</span></span><br></pre></td></tr></table></figure>\n<p>控制台输出</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">initialValue -&gt; newValue0</span><br><span class=\"line\">newValue0 -&gt; newValue1</span><br></pre></td></tr></table></figure>\n<h3 id=\"Storing\"><a href=\"#Storing\" class=\"headerlink\" title=\"Storing\"></a>Storing</h3><p>将对象的属性委托值 map 中，用于解析 JSON 或者其他动态工作，不过应用较少</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> user = User(mapOf(<span class=\"string\">\"name\"</span> to <span class=\"string\">\"Jack\"</span>, <span class=\"string\">\"age\"</span> to <span class=\"number\">20</span>))</span><br><span class=\"line\">println(user.name)</span><br><span class=\"line\">println(user.age)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String <span class=\"keyword\">by</span> map</span><br><span class=\"line\">    <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"典型应用\"><a href=\"#典型应用\" class=\"headerlink\" title=\"典型应用\"></a>典型应用</h2><p>封装一个 SharedPreferences（简称 SP） 是 Android 开发中经常要做的事，因为直接调用 SP 足够繁琐。如果是 Java 代码，则代码基本如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PreferencesUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> PreferencesUtil sInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sInstance = <span class=\"keyword\">new</span> PreferencesUtil(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PreferencesUtil <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInstance == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Uninitialized.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedPreferences mSp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">PreferencesUtil</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mSp = PreferenceManager.getDefaultSharedPreferences(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getString</span><span class=\"params\">(String key, String defValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getString(key, defValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putString</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\">        mSp.edit().putString(key, value).apply();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getInt</span><span class=\"params\">(String key, <span class=\"keyword\">int</span> defValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getInt(key, defValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putInt</span><span class=\"params\">(String key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        mSp.edit().putInt(key, value).apply();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getLong</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> defValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getLong(key, defValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putLong</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">        mSp.edit().putLong(key, value).apply();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getFloat</span><span class=\"params\">(String key, <span class=\"keyword\">float</span> defValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getFloat(key, defValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putFloat</span><span class=\"params\">(String key, <span class=\"keyword\">float</span> value)</span> </span>&#123;</span><br><span class=\"line\">        mSp.edit().putFloat(key, value).apply();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">getBoolean</span><span class=\"params\">(String key, <span class=\"keyword\">boolean</span> defValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mSp.getBoolean(key, defValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putBoolean</span><span class=\"params\">(String key, <span class=\"keyword\">boolean</span> value)</span> </span>&#123;</span><br><span class=\"line\">        mSp.edit().putBoolean(key, value).apply();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>外部调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (PreferencesUtil.getInstance().getBoolean(Constant.IS_FIRST_LAUNCH, Constant.DEF_IS_FIRST_LAUNCH)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something first launch, like showing Welcome.</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    PreferencesUtil.getInstance().putBoolean(Constant.IS_FIRST_LAUNCH, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 Kotlin 的委托属性之后实现就简洁很多</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PreferenceUtils</span>&lt;<span class=\"type\">T</span>&gt;</span>(<span class=\"keyword\">val</span> context: Context, <span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> <span class=\"keyword\">default</span>: T): ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> prefs: SharedPreferences <span class=\"keyword\">by</span> lazy &#123; context.defaultSharedPreferences &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findPreference(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        putPreference(name, value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">findPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, <span class=\"keyword\">default</span>: <span class=\"type\">T</span>)</span></span>: T = with(prefs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> res: Any = <span class=\"keyword\">when</span> (<span class=\"keyword\">default</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Long</span> -&gt; getLong(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Int</span> -&gt; getInt(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -&gt; getString(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Boolean</span> -&gt; getBoolean(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Float</span> -&gt; getFloat(name, <span class=\"keyword\">default</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span> -&gt; <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">\"This type can't be saved into Preferences\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span><span class=\"symbol\">@with</span> res <span class=\"keyword\">as</span> T</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">putPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, value: <span class=\"type\">T</span>)</span></span> = with(prefs.edit()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">when</span> (value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Long</span> -&gt; putLong(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Int</span> -&gt; putInt(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -&gt; putString(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Boolean</span> -&gt; putBoolean(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">is</span> <span class=\"built_in\">Float</span> -&gt; putFloat(name, value)</span><br><span class=\"line\">            <span class=\"keyword\">else</span> -&gt; <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">\"This type can't be saved into Preferences\"</span>)</span><br><span class=\"line\">        &#125;.apply()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中接口<code>ReadWriteProperty</code>为系统提供的规范接口，其中定义了<code>getValue/setValue</code>方法。外部调用如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> themeCode <span class=\"keyword\">by</span> PreferenceUtils(context, Constant.theme_code, <span class=\"keyword\">default</span> = <span class=\"number\">1</span>)</span><br><span class=\"line\">themeCode = <span class=\"number\">9527</span></span><br></pre></td></tr></table></figure>"},{"title":"LeakCanary源码解析","date":"2019-02-13T05:28:31.000Z","_content":"\n内存泄漏是 Android 开发中无法避免的问题，[LeakCanary](https://github.com/square/leakcanary) 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<!--more-->\n\n## ActivityLifecycleCallbacks\nLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。\n\n### 接口方法\n可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。\n\n```Java\n    public interface ActivityLifecycleCallbacks {\n        void onActivityCreated(Activity activity, Bundle savedInstanceState);\n        void onActivityStarted(Activity activity);\n        void onActivityResumed(Activity activity);\n        void onActivityPaused(Activity activity);\n        void onActivityStopped(Activity activity);\n        void onActivitySaveInstanceState(Activity activity, Bundle outState);\n        void onActivityDestroyed(Activity activity);\n    }\n```\n\n### 简单用法\n开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。\n```Java\npublic class MyApplication extends Application {\n\n    public static List<Activity> activityList;\n    public static final int ACTIVITY_MAX_NUM = 10;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        activityList = new LinkedList<>();\n        registerActivityLifecycleCallbacks(new MyActivityCallbacks());\n    }\n\n    class MyActivityCallbacks implements ActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            if (activityList.size() >= ACTIVITY_MAX_NUM) {\n                activityList.remove(activityList.size()-1).finish();\n            }\n            activityList.add(activity);\n        }\n\n        @Override\n        public void onActivityStarted(Activity activity) { }\n\n        @Override\n        public void onActivityResumed(Activity activity) { }\n\n        @Override\n        public void onActivityPaused(Activity activity) { }\n\n        @Override\n        public void onActivityStopped(Activity activity) { }\n\n        @Override\n        public void onActivitySaveInstanceState(Activity activity, Bundle outState) { }\n\n        @Override\n        public void onActivityDestroyed(Activity activity) {\n            activityList.remove(activity);\n        }\n    }\n    \n    public static Activity getCurrentActivity() {\n        return activityList.get(0);\n    }\n}\n```\n\n## 引用类型\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。\n\n### 强引用\n强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的`A a = new A()`中的引用a。\n\n### 软引用\n软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。\n```Java\nSoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));\nSystem.out.println(sr.get());\n```\n\n### 弱引用\n弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n```Java\nWeakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n         \nSystem.out.println(sr.get());\nSystem.gc();                //通知JVM的gc进行垃圾回收\nSystem.out.println(sr.get());\n```\n打印的结果为\n> hello\n<br>null\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n```Java\nReferenceQueue queue = new ReferenceQueue();\nWeakReference pr = new WeakReference(object, queue);\n```\n\n### 虚引用\nPhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其`get()`永远返回`null`\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n```Java\npublic class PhantomReference<T> extends Reference<T> {\n\n    public T get() {\n        return null;\n    }\n\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n## LeakCanary源码\n实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。\n\n### 执行流程\n跟踪调用的入口方法`install`\n```Java\npublic static @NonNull RefWatcher install(@NonNull Application application) {\n    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n}\n```\n\n`listenerServiceClass`方法位于 AndroidRefWatcherBuilder\n\n```Java\npublic @NonNull AndroidRefWatcherBuilder listenerServiceClass(\n      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {\n      \n    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);\n    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));\n}\n```\n该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和`excludedRefs`方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：\n\n```Java\npublic @NonNull RefWatcher buildAndInstall() {\n    if (LeakCanaryInternals.installedRefWatcher != null) {\n        throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\");\n    }\n    RefWatcher refWatcher = build();\n    if (refWatcher != DISABLED) {\n        if (enableDisplayLeakActivity) {\n            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);\n        }\n        if (watchActivities) {\n            ActivityRefWatcher.install(context, refWatcher);\n        }\n        if (watchFragments) {\n            FragmentRefWatcher.Helper.install(context, refWatcher);\n        }\n    }\n    LeakCanaryInternals.installedRefWatcher = refWatcher;\n    return refWatcher;\n}\n```\n该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪`install`方法\n\n```Java\npublic static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {\n    Application application = (Application) context.getApplicationContext();\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n\n    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);\n}\n\n//成员变量 lifecycleCallbacks\nprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n    new ActivityLifecycleCallbacksAdapter  {\n        @Override public void onActivityDestroyed(Activity activity) {\n            refWatcher.watch(activity);\n        }\n    };\n```\n\n由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。\n\n`watch`方法由 RefWatcher 默认实现：\n\n```Java\npublic void watch(Object watchedReference, String referenceName) {\n    ......  \n    retainedKeys.add(key);\n    final KeyedWeakReference reference =\n            new KeyedWeakReference(watchedReference, key, referenceName, queue);\n\n    ensureGoneAsync(watchStartNanoTime, reference);\n}\n```\n\n其中 retainedKeys 是一个 Set<String> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。 \nKeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。\n\n```Java\nprivate void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {\n    watchExecutor.execute(new Retryable() {\n        @Override public Retryable.Result run() {\n            return ensureGone(reference, watchStartNanoTime);\n        }\n    });\n}\n```\n\nwatchExecutor 为 AndroidWatchExecutor 对象\n```\npublic AndroidWatchExecutor(long initialDelayMillis) {\n    mainHandler = new Handler(Looper.getMainLooper());\n    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);\n    handlerThread.start();\n    backgroundHandler = new Handler(handlerThread.getLooper());\n    this.initialDelayMillis = initialDelayMillis;\n    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;\n}\n\n@Override public void execute(@NonNull Retryable retryable) {\n    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\n        waitForIdle(retryable, 0);\n    } else {\n        postWaitForIdle(retryable, 0);\n    }\n}\n```\n在`execute`中，不管是`waitForIdle`还是`postWaitForIdle`都会切换到主线程执行，最终会调用以下代码：\n```Java\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        postToBackgroundWithDelay(retryable, failedAttempts);\n        return false;\n      }\n    });\n```\n那么 IdleHandler 到底是什么呢？\n\n我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。\n\n`ensureGoneAsync`方法最终会调用`ensureGone`\n\n```Java\nRetryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {\n    ......\n    removeWeaklyReachableReferences();\n    ......\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n        ......\n        File heapDumpFile = heapDumper.dumpHeap();\n        ......\n        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)\n            .referenceName(reference.name)\n            .watchDurationMs(watchDurationMs)\n            .gcDurationMs(gcDurationMs)\n            .heapDumpDurationMs(heapDumpDurationMs)\n            .build();\n\n        heapdumpListener.analyze(heapDump);\n    }\n    return DONE;\n}\n```\n\n- `removeWeaklyReachableReferences`遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。\n- 调用`gcTrigger.runGc`去进行内存回收，这里没有使用`System.gc`，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。\n- 主动进行 GC 之后会再次调用`removeWeaklyReachableReferences`清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。\n- 生成性能统计文件.hprof，进行内存泄漏的分析。\n\n那么 hprof 文件是被解析成信息的呢\n\n```Java\nAnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);\n```\n\n```Java\npublic AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {\n    ......\n    MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile);\n    HprofParser parser = new HprofParser(e);\n    Snapshot snapshot = parser.parse();\n    this.deduplicateGcRoots(snapshot);\n    Instance leakingRef = this.findLeakingReference(referenceKey, snapshot);\n    return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ：\n        this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);\n}\n```\n\n`checkForLeak`方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的`parse`方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。\n\n得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。\n\n### 总结\nLeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。\n","source":"_posts/LeakCanary源码解析.md","raw":"---\ntitle: LeakCanary源码解析\ndate: 2019-02-13 13:28:31\ntags:\n- 内存泄漏\n- Android\n- 源码\ncategories:\n- Android\n---\n\n内存泄漏是 Android 开发中无法避免的问题，[LeakCanary](https://github.com/square/leakcanary) 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<!--more-->\n\n## ActivityLifecycleCallbacks\nLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。\n\n### 接口方法\n可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。\n\n```Java\n    public interface ActivityLifecycleCallbacks {\n        void onActivityCreated(Activity activity, Bundle savedInstanceState);\n        void onActivityStarted(Activity activity);\n        void onActivityResumed(Activity activity);\n        void onActivityPaused(Activity activity);\n        void onActivityStopped(Activity activity);\n        void onActivitySaveInstanceState(Activity activity, Bundle outState);\n        void onActivityDestroyed(Activity activity);\n    }\n```\n\n### 简单用法\n开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。\n```Java\npublic class MyApplication extends Application {\n\n    public static List<Activity> activityList;\n    public static final int ACTIVITY_MAX_NUM = 10;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        activityList = new LinkedList<>();\n        registerActivityLifecycleCallbacks(new MyActivityCallbacks());\n    }\n\n    class MyActivityCallbacks implements ActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            if (activityList.size() >= ACTIVITY_MAX_NUM) {\n                activityList.remove(activityList.size()-1).finish();\n            }\n            activityList.add(activity);\n        }\n\n        @Override\n        public void onActivityStarted(Activity activity) { }\n\n        @Override\n        public void onActivityResumed(Activity activity) { }\n\n        @Override\n        public void onActivityPaused(Activity activity) { }\n\n        @Override\n        public void onActivityStopped(Activity activity) { }\n\n        @Override\n        public void onActivitySaveInstanceState(Activity activity, Bundle outState) { }\n\n        @Override\n        public void onActivityDestroyed(Activity activity) {\n            activityList.remove(activity);\n        }\n    }\n    \n    public static Activity getCurrentActivity() {\n        return activityList.get(0);\n    }\n}\n```\n\n## 引用类型\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。\n\n### 强引用\n强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的`A a = new A()`中的引用a。\n\n### 软引用\n软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。\n```Java\nSoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));\nSystem.out.println(sr.get());\n```\n\n### 弱引用\n弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n```Java\nWeakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n         \nSystem.out.println(sr.get());\nSystem.gc();                //通知JVM的gc进行垃圾回收\nSystem.out.println(sr.get());\n```\n打印的结果为\n> hello\n<br>null\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n```Java\nReferenceQueue queue = new ReferenceQueue();\nWeakReference pr = new WeakReference(object, queue);\n```\n\n### 虚引用\nPhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其`get()`永远返回`null`\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n```Java\npublic class PhantomReference<T> extends Reference<T> {\n\n    public T get() {\n        return null;\n    }\n\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n## LeakCanary源码\n实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。\n\n### 执行流程\n跟踪调用的入口方法`install`\n```Java\npublic static @NonNull RefWatcher install(@NonNull Application application) {\n    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n}\n```\n\n`listenerServiceClass`方法位于 AndroidRefWatcherBuilder\n\n```Java\npublic @NonNull AndroidRefWatcherBuilder listenerServiceClass(\n      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {\n      \n    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);\n    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));\n}\n```\n该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和`excludedRefs`方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：\n\n```Java\npublic @NonNull RefWatcher buildAndInstall() {\n    if (LeakCanaryInternals.installedRefWatcher != null) {\n        throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\");\n    }\n    RefWatcher refWatcher = build();\n    if (refWatcher != DISABLED) {\n        if (enableDisplayLeakActivity) {\n            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);\n        }\n        if (watchActivities) {\n            ActivityRefWatcher.install(context, refWatcher);\n        }\n        if (watchFragments) {\n            FragmentRefWatcher.Helper.install(context, refWatcher);\n        }\n    }\n    LeakCanaryInternals.installedRefWatcher = refWatcher;\n    return refWatcher;\n}\n```\n该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪`install`方法\n\n```Java\npublic static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {\n    Application application = (Application) context.getApplicationContext();\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n\n    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);\n}\n\n//成员变量 lifecycleCallbacks\nprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n    new ActivityLifecycleCallbacksAdapter  {\n        @Override public void onActivityDestroyed(Activity activity) {\n            refWatcher.watch(activity);\n        }\n    };\n```\n\n由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。\n\n`watch`方法由 RefWatcher 默认实现：\n\n```Java\npublic void watch(Object watchedReference, String referenceName) {\n    ......  \n    retainedKeys.add(key);\n    final KeyedWeakReference reference =\n            new KeyedWeakReference(watchedReference, key, referenceName, queue);\n\n    ensureGoneAsync(watchStartNanoTime, reference);\n}\n```\n\n其中 retainedKeys 是一个 Set<String> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。 \nKeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。\n\n```Java\nprivate void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {\n    watchExecutor.execute(new Retryable() {\n        @Override public Retryable.Result run() {\n            return ensureGone(reference, watchStartNanoTime);\n        }\n    });\n}\n```\n\nwatchExecutor 为 AndroidWatchExecutor 对象\n```\npublic AndroidWatchExecutor(long initialDelayMillis) {\n    mainHandler = new Handler(Looper.getMainLooper());\n    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);\n    handlerThread.start();\n    backgroundHandler = new Handler(handlerThread.getLooper());\n    this.initialDelayMillis = initialDelayMillis;\n    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;\n}\n\n@Override public void execute(@NonNull Retryable retryable) {\n    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\n        waitForIdle(retryable, 0);\n    } else {\n        postWaitForIdle(retryable, 0);\n    }\n}\n```\n在`execute`中，不管是`waitForIdle`还是`postWaitForIdle`都会切换到主线程执行，最终会调用以下代码：\n```Java\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        postToBackgroundWithDelay(retryable, failedAttempts);\n        return false;\n      }\n    });\n```\n那么 IdleHandler 到底是什么呢？\n\n我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。\n\n`ensureGoneAsync`方法最终会调用`ensureGone`\n\n```Java\nRetryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {\n    ......\n    removeWeaklyReachableReferences();\n    ......\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n        ......\n        File heapDumpFile = heapDumper.dumpHeap();\n        ......\n        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)\n            .referenceName(reference.name)\n            .watchDurationMs(watchDurationMs)\n            .gcDurationMs(gcDurationMs)\n            .heapDumpDurationMs(heapDumpDurationMs)\n            .build();\n\n        heapdumpListener.analyze(heapDump);\n    }\n    return DONE;\n}\n```\n\n- `removeWeaklyReachableReferences`遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。\n- 调用`gcTrigger.runGc`去进行内存回收，这里没有使用`System.gc`，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。\n- 主动进行 GC 之后会再次调用`removeWeaklyReachableReferences`清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。\n- 生成性能统计文件.hprof，进行内存泄漏的分析。\n\n那么 hprof 文件是被解析成信息的呢\n\n```Java\nAnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);\n```\n\n```Java\npublic AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {\n    ......\n    MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile);\n    HprofParser parser = new HprofParser(e);\n    Snapshot snapshot = parser.parse();\n    this.deduplicateGcRoots(snapshot);\n    Instance leakingRef = this.findLeakingReference(referenceKey, snapshot);\n    return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ：\n        this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);\n}\n```\n\n`checkForLeak`方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的`parse`方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。\n\n得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。\n\n### 总结\nLeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。\n","slug":"LeakCanary源码解析","published":1,"updated":"2019-06-02T05:02:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxs003my4uppfhdga4n","content":"<p>内存泄漏是 Android 开发中无法避免的问题，<a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"noopener\">LeakCanary</a> 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<a id=\"more\"></a></p>\n<h2 id=\"ActivityLifecycleCallbacks\"><a href=\"#ActivityLifecycleCallbacks\" class=\"headerlink\" title=\"ActivityLifecycleCallbacks\"></a>ActivityLifecycleCallbacks</h2><p>LeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。</p>\n<h3 id=\"接口方法\"><a href=\"#接口方法\" class=\"headerlink\" title=\"接口方法\"></a>接口方法</h3><p>可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h3><p>开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List<Activity> activityList;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_MAX_NUM = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        activityList = <span class=\"keyword\">new</span> LinkedList<>();</span><br><span class=\"line\">        registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> MyActivityCallbacks());</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivityCallbacks</span> <span class=\"keyword\">implements</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activityList.size() >= ACTIVITY_MAX_NUM) {</span><br><span class=\"line\">                activityList.remove(activityList.size()-<span class=\"number\">1</span>).finish();</span><br><span class=\"line\">            }</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>{</span><br><span class=\"line\">            activityList.remove(activity);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity <span class=\"title\">getCurrentActivity</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activityList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的<code>A a = new A()</code>中的引用a。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">SoftReference<String> sr = <span class=\"keyword\">new</span> SoftReference<String>(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">WeakReference<String> sr = <span class=\"keyword\">new</span> WeakReference<String>(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">         </span><br><span class=\"line\">System.out.println(sr.get());</span><br><span class=\"line\">System.gc();                <span class=\"comment\">//通知JVM的gc进行垃圾回收</span></span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>打印的结果为</p>\n<blockquote>\n<p>hello<br><br>null</p>\n</blockquote>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">WeakReference pr = <span class=\"keyword\">new</span> WeakReference(object, queue);</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其<code>get()</code>永远返回<code>null</code></p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span><<span class=\"title\">T</span>> <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span><<span class=\"title\">T</span>> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue<? <span class=\"keyword\">super</span> T> q)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"LeakCanary源码\"><a href=\"#LeakCanary源码\" class=\"headerlink\" title=\"LeakCanary源码\"></a>LeakCanary源码</h2><p>实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>跟踪调用的入口方法<code>install</code><br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">install</span><span class=\"params\">(@NonNull Application application)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class=\"line\">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class=\"line\">        .buildAndInstall();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p><code>listenerServiceClass</code>方法位于 AndroidRefWatcherBuilder</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">AndroidRefWatcherBuilder <span class=\"title\">listenerServiceClass</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass)</span> </span>{</span><br><span class=\"line\">      </span><br><span class=\"line\">    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heapDumpListener(<span class=\"keyword\">new</span> ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和<code>excludedRefs</code>方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">buildAndInstall</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LeakCanaryInternals.installedRefWatcher != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"buildAndInstall() should only be called once.\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    RefWatcher refWatcher = build();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refWatcher != DISABLED) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enableDisplayLeakActivity) {</span><br><span class=\"line\">            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchActivities) {</span><br><span class=\"line\">            ActivityRefWatcher.install(context, refWatcher);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchFragments) {</span><br><span class=\"line\">            FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪<code>install</code>方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>{</span><br><span class=\"line\">    Application application = (Application) context.getApplicationContext();</span><br><span class=\"line\">    ActivityRefWatcher activityRefWatcher = <span class=\"keyword\">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//成员变量 lifecycleCallbacks</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ActivityLifecycleCallbacksAdapter  {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>{</span><br><span class=\"line\">            refWatcher.watch(activity);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    };</span><br></pre></td></tr></tbody></table></figure>\n<p>由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。</p>\n<p><code>watch</code>方法由 RefWatcher 默认实现：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">watch</span><span class=\"params\">(Object watchedReference, String referenceName)</span> </span>{</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">    retainedKeys.add(key);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> KeyedWeakReference reference =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>其中 retainedKeys 是一个 Set<string> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。<br>KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。</string></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureGoneAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime, <span class=\"keyword\">final</span> KeyedWeakReference reference)</span> </span>{</span><br><span class=\"line\">    watchExecutor.execute(<span class=\"keyword\">new</span> Retryable() {</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> Retryable.<span class=\"function\">Result <span class=\"title\">run</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>watchExecutor 为 AndroidWatchExecutor 对象<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">public AndroidWatchExecutor(long initialDelayMillis) {</span><br><span class=\"line\">    mainHandler = new Handler(Looper.getMainLooper());</span><br><span class=\"line\">    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    backgroundHandler = new Handler(handlerThread.getLooper());</span><br><span class=\"line\">    this.initialDelayMillis = initialDelayMillis;</span><br><span class=\"line\">    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">@Override public void execute(@NonNull Retryable retryable) {</span><br><span class=\"line\">    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {</span><br><span class=\"line\">        waitForIdle(retryable, 0);</span><br><span class=\"line\">    } else {</span><br><span class=\"line\">        postWaitForIdle(retryable, 0);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>在<code>execute</code>中，不管是<code>waitForIdle</code>还是<code>postWaitForIdle</code>都会切换到主线程执行，最终会调用以下代码：<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> MessageQueue.IdleHandler() {</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>那么 IdleHandler 到底是什么呢？</p>\n<p>我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。</p>\n<p><code>ensureGoneAsync</code>方法最终会调用<code>ensureGone</code></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Retryable.<span class=\"function\">Result <span class=\"title\">ensureGone</span><span class=\"params\">(<span class=\"keyword\">final</span> KeyedWeakReference reference, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime)</span> </span>{</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    gcTrigger.runGc();</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gone(reference)) {</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        File heapDumpFile = heapDumper.dumpHeap();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class=\"line\">            .referenceName(reference.name)</span><br><span class=\"line\">            .watchDurationMs(watchDurationMs)</span><br><span class=\"line\">            .gcDurationMs(gcDurationMs)</span><br><span class=\"line\">            .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        heapdumpListener.analyze(heapDump);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DONE;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li><code>removeWeaklyReachableReferences</code>遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。</li>\n<li>调用<code>gcTrigger.runGc</code>去进行内存回收，这里没有使用<code>System.gc</code>，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。</li>\n<li>主动进行 GC 之后会再次调用<code>removeWeaklyReachableReferences</code>清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。</li>\n<li>生成性能统计文件.hprof，进行内存泄漏的分析。</li>\n</ul>\n<p>那么 hprof 文件是被解析成信息的呢</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AnalysisResult <span class=\"title\">checkForLeak</span><span class=\"params\">(File heapDumpFile, String referenceKey)</span> </span>{</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    MemoryMappedFileBuffer e = <span class=\"keyword\">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class=\"line\">    HprofParser parser = <span class=\"keyword\">new</span> HprofParser(e);</span><br><span class=\"line\">    Snapshot snapshot = parser.parse();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deduplicateGcRoots(snapshot);</span><br><span class=\"line\">    Instance leakingRef = <span class=\"keyword\">this</span>.findLeakingReference(referenceKey, snapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leakingRef == <span class=\"keyword\">null</span> ? AnalysisResult.noLeak(<span class=\"keyword\">this</span>.since(analysisStartNanoTime)) ：</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p><code>checkForLeak</code>方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的<code>parse</code>方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。</p>\n<p>得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":10658,"excerpt":"<p>内存泄漏是 Android 开发中无法避免的问题，<a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"noopener\">LeakCanary</a> 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。</p>","more":"<p></p>\n<h2 id=\"ActivityLifecycleCallbacks\"><a href=\"#ActivityLifecycleCallbacks\" class=\"headerlink\" title=\"ActivityLifecycleCallbacks\"></a>ActivityLifecycleCallbacks</h2><p>LeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。</p>\n<h3 id=\"接口方法\"><a href=\"#接口方法\" class=\"headerlink\" title=\"接口方法\"></a>接口方法</h3><p>可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h3><p>开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Activity&gt; activityList;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_MAX_NUM = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        activityList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> MyActivityCallbacks());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivityCallbacks</span> <span class=\"keyword\">implements</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activityList.size() &gt;= ACTIVITY_MAX_NUM) &#123;</span><br><span class=\"line\">                activityList.remove(activityList.size()-<span class=\"number\">1</span>).finish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            activityList.remove(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity <span class=\"title\">getCurrentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activityList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的<code>A a = new A()</code>中的引用a。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;String&gt; sr = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">         </span><br><span class=\"line\">System.out.println(sr.get());</span><br><span class=\"line\">System.gc();                <span class=\"comment\">//通知JVM的gc进行垃圾回收</span></span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<p>打印的结果为</p>\n<blockquote>\n<p>hello<br><br>null</p>\n</blockquote>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">WeakReference pr = <span class=\"keyword\">new</span> WeakReference(object, queue);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其<code>get()</code>永远返回<code>null</code></p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LeakCanary源码\"><a href=\"#LeakCanary源码\" class=\"headerlink\" title=\"LeakCanary源码\"></a>LeakCanary源码</h2><p>实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>跟踪调用的入口方法<code>install</code><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">install</span><span class=\"params\">(@NonNull Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class=\"line\">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class=\"line\">        .buildAndInstall();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>listenerServiceClass</code>方法位于 AndroidRefWatcherBuilder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">AndroidRefWatcherBuilder <span class=\"title\">listenerServiceClass</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heapDumpListener(<span class=\"keyword\">new</span> ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和<code>excludedRefs</code>方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">buildAndInstall</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LeakCanaryInternals.installedRefWatcher != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"buildAndInstall() should only be called once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RefWatcher refWatcher = build();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refWatcher != DISABLED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class=\"line\">            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchActivities) &#123;</span><br><span class=\"line\">            ActivityRefWatcher.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchFragments) &#123;</span><br><span class=\"line\">            FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪<code>install</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class=\"line\">    Application application = (Application) context.getApplicationContext();</span><br><span class=\"line\">    ActivityRefWatcher activityRefWatcher = <span class=\"keyword\">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//成员变量 lifecycleCallbacks</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ActivityLifecycleCallbacksAdapter  &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            refWatcher.watch(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。</p>\n<p><code>watch</code>方法由 RefWatcher 默认实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">watch</span><span class=\"params\">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">    retainedKeys.add(key);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> KeyedWeakReference reference =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 retainedKeys 是一个 Set<string> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。<br>KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。</string></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureGoneAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime, <span class=\"keyword\">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class=\"line\">    watchExecutor.execute(<span class=\"keyword\">new</span> Retryable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> Retryable.<span class=\"function\">Result <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>watchExecutor 为 AndroidWatchExecutor 对象<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public AndroidWatchExecutor(long initialDelayMillis) &#123;</span><br><span class=\"line\">    mainHandler = new Handler(Looper.getMainLooper());</span><br><span class=\"line\">    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    backgroundHandler = new Handler(handlerThread.getLooper());</span><br><span class=\"line\">    this.initialDelayMillis = initialDelayMillis;</span><br><span class=\"line\">    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override public void execute(@NonNull Retryable retryable) &#123;</span><br><span class=\"line\">    if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class=\"line\">        waitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        postWaitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>execute</code>中，不管是<code>waitForIdle</code>还是<code>postWaitForIdle</code>都会切换到主线程执行，最终会调用以下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>那么 IdleHandler 到底是什么呢？</p>\n<p>我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。</p>\n<p><code>ensureGoneAsync</code>方法最终会调用<code>ensureGone</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Retryable.<span class=\"function\">Result <span class=\"title\">ensureGone</span><span class=\"params\">(<span class=\"keyword\">final</span> KeyedWeakReference reference, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    gcTrigger.runGc();</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gone(reference)) &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        File heapDumpFile = heapDumper.dumpHeap();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class=\"line\">            .referenceName(reference.name)</span><br><span class=\"line\">            .watchDurationMs(watchDurationMs)</span><br><span class=\"line\">            .gcDurationMs(gcDurationMs)</span><br><span class=\"line\">            .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        heapdumpListener.analyze(heapDump);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DONE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>removeWeaklyReachableReferences</code>遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。</li>\n<li>调用<code>gcTrigger.runGc</code>去进行内存回收，这里没有使用<code>System.gc</code>，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。</li>\n<li>主动进行 GC 之后会再次调用<code>removeWeaklyReachableReferences</code>清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。</li>\n<li>生成性能统计文件.hprof，进行内存泄漏的分析。</li>\n</ul>\n<p>那么 hprof 文件是被解析成信息的呢</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AnalysisResult <span class=\"title\">checkForLeak</span><span class=\"params\">(File heapDumpFile, String referenceKey)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    MemoryMappedFileBuffer e = <span class=\"keyword\">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class=\"line\">    HprofParser parser = <span class=\"keyword\">new</span> HprofParser(e);</span><br><span class=\"line\">    Snapshot snapshot = parser.parse();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deduplicateGcRoots(snapshot);</span><br><span class=\"line\">    Instance leakingRef = <span class=\"keyword\">this</span>.findLeakingReference(referenceKey, snapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leakingRef == <span class=\"keyword\">null</span> ? AnalysisResult.noLeak(<span class=\"keyword\">this</span>.since(analysisStartNanoTime)) ：</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>checkForLeak</code>方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的<code>parse</code>方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。</p>\n<p>得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。</p>"},{"title":"Markdown 语法详解","date":"2019-05-19T07:36:02.000Z","mathjax":true,"_content":"\n这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown  的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。\n\n![logo](Markdown-语法详解\\markdown.png)\n\n<!--more-->\n\n## 关于 \n\nMarkdown 是一门轻量级的标记语言，由美国工程师 John Gruber 于2004年创造。这门语言的目的是让人们`使用易于阅读、易于撰写的纯文字格式，并选择性地转换成有效的 XHTML（或是 HTML）`。\n\nMarkdown 所谓的**易读**并不是指排版之后呈现的结果易读，而是指原始格式下的文件依然拥有优秀的可读性，不会像阅读原始 HTML 代码一样，满眼都是尖括号（可以通过 右键浏览器页面 -> 查看源代码 体验）。Markdown 的**易写**则体现在其语法足够简单，学习曲线平缓，并且在写作中基本可以脱离鼠标操作。\n\nMarkdown 的轻量级是相对于 LaTeX 来说的，这种基于 Tex 的排版系统广泛运用在高质量书籍印刷和复杂公式论文中。不过使用 Markdown 仍然可以使用一些基本的数学公式，比如`$ E = mc^2 $`、`$ \\int_0^xf(x)dx $`，单个`$`用于行内公式，`$$`用于单行公式\n\n比如 $ E = mc^2 $、$ \\int_0^xf(x)dx $ \n\n这需要不同平台上的 Markdown 数学公式插件的支持，本博客使用`Hexo` + `Github Pages`搭建，可以通过安装 [MathJax](https://www.mathjax.org) 实现。\n\n### 分类\n\n跟早期的 HTML 类似，Markdown 在发展的过程中衍生出了不同的版本，它们的基本语法上相通，但是在诸如表格、锚点、时序图等实现上出现了不一致。在关于语法规范化的讨论中，作者 John Gruber 认为，`不同的网站（和人们）有不同的需求，没有一种语法可以让所有人满意`。\n\n现今 Markdown 的主要分类如下\n\n- CommonMark：由 Stack Exchange、Github、Reddit 等组织发起的标准化项目。一开始名称为`Standard Markdown`，由于遭到作者的反对，更名`CommonMark`\n- GFM：Github Flavored Markdown，由 Github 于2017年发布，基于 CommonMark。相信很多开发者都是通过一份`README.md`文件认识 Markdown，这也是本博客采用的版本。\n- Markdown Extra：基于 PHP、Python 和 Rudy 中实现的 Markdown。\n\n### 编辑器\n\n市面上优秀的 Markdown 编辑器层出不穷，这也有力推动了 Markdown 的发展。可以使用`Sublime Text`配合插件编辑写作，可以使用`Typora`等优秀的跨平台工具实现所见即所得，也可以通过 [Cmd Markdown ](https://www.zybuluo.com)在线书写并导出、发布。\n\n博主使用的是`Typora。`\n\n![编辑器](Markdown-语法详解\\编辑器.png)\n\n相关链接：[码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点](https://sspai.com/post/32483)、 [用 Markdown 写作用什么文本编辑器？ - 知乎](https://www.zhihu.com/question/19637157)\n\n## 初级语法\n\n### 标题\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n---\n\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n---\n\n另外在 GFM 中，任意 1-6 个 **#** 标注的标题都会被添加上同名的锚点链接，比如`# First Title `会被标注成`[First Title](#first-title)`（注意小写转换），因此我们可以在文章的其他地方，使用标注之后的格式跳转到任何标题，比如`[跳转至引言](#引言)`\n\n\n\n### 文字\n\n| 格式                                                 | 效果                   |\n| ---------------------------------------------------- | ---------------------- |\n| `*斜体1*`                                            | *斜体1*                |\n| `_斜体2_`                                            | _斜体2_                |\n| `**粗体1**`                                          | **粗体1**              |\n| `__粗体2__`                                          | __粗体2__              |\n| `~~删除线~~`                                         | ~~删除线~~             |\n| `***斜粗体1***`                                      | ***斜粗体1***          |\n| `___斜粗体2___`                                      | ___斜粗体2___          |\n| `***~~斜粗体删除线1~~***`、`~~***斜粗体删除线2***~~` | ***~~斜粗体删除线~~*** |\n\n\n\n### 表情\n\nGFM 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。比如`:stuck_out_tongue_winking_eye:`：:stuck_out_tongue_winking_eye:\n\n:ghost: :dog: :poop: :fire: :bow:\n\n:smile: :rowboat: :watermelon: :swimmer: :fallen_leaf:\n\n可以在此找到不同表情对应的符号码：[Emoji cheat sheet for GitHub, Basecamp, Slack & more](https://www.webfx.com/tools/emoji-cheat-sheet/)\n\n\n\nHexo 默认不支持 emoji 表情，可以通过安装 [hexo-filter-github-emojis](https://github.com/crimx/hexo-filter-github-emojis) 实现\n\n\n\n### 分割线\n\n使用三个（或多个连续）的`-`、`*`、`-`实现分割线效果\n\n```markdown\n---\n___\n******\n```\n\n------\n\n------\n\n------\n\n\n\n### 链接\n\n链接分为文字链接和图片链接\n\n#### 文字链接\n\n`[ReBe](https://febers.github.io \"鼠标悬停显示\")`：[ReBe](https://febers.github.io \"鼠标悬停显示\")\n\n支持使用标识符标志地址，将真正的URL地址放在文末，比如\n\n```markdown\n[Github][Github URL]\n[Github URL]:https://github.com/Febers\n```\n\n效果如下:\n\n[Github][Github URL]\n\n[Github URL]:https://github.com/Febers\n\n#### 图片链接\n\n基本格式为`![title](url)`，其中`title`可省略，`![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067)`\n\n![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067)\n\n\n\n### 列表\n\n#### 有序列表\n\n看起来并不明显\n\n```markdown\n1. PHP是最好的语言？\n2. PHP是最好的语言！\n```\n\n1. PHP是最好的语言？\n\n2. PHP是最好的语言！\n\n   \n\n#### 无序列表\n\n可以使用`-`、`*`、`+`开头接空格，但在多级列表中最好使用`-`\n\n```markdown\n- PHP是最好的语言？\n* PHP是最好的语言。\n+ PHP是最好的语言！\n\t- 毫无疑问\n\t\t- 众所周知\n```\n\n- PHP是最好的语言？\n* PHP是最好的语言。\n+ PHP是最好的语言！\n  - 毫无疑问\n    - 众所周知\n\n#### 复选框列表\n\n```markdown\n- [x] 大一\n- [x] 大二\n- [ ] 大三\n- [ ] 大四\n```\n\n- [x] 大一\n- [x] 大二\n- [ ] 大三\n- [ ] 大四\n\nHexo 默认的渲染引擎 Marked 不支持 TODO list，可以更换为 markdown-it，之后实现的效果如 Typora 预览\n\n![todo-list](Markdown-语法详解\\todo-list.png)\n\n\n\n### 引用与高亮\n\n#### 引用\n\n使用`>`实现引用，多个`>`实现引用层级\n\n```markdown\n> PHP\n>> 是\n>>> 最好的\n>>>> 语言\n```\n\n> PHP\n> > 是\n> > > 最好的\n> > >\n> > > > 语言\n\n一般用在引用原文内容中\n\n> 一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！”黛玉纳罕道：“这些人个个皆敛声屏气，恭肃严整如此，这来者系谁，这样放诞无礼？”心下想时，只见一群媳妇丫鬟围拥着一个人从后房门进来。这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子：头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗；项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩；身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂；下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未起笑先闻。黛玉连忙起身接见。\n\n\n\n#### 居中\n\nMarkdown 中标准引用是 `>` 符号后面加上引用内容，可以嵌套，或者搭配其他 Markdown 语法结合一起使用。但样式未免单一，不够美观，可以直接使用 HTML 语言插入，如下，使用 `class=\"blockquote-center\"`\n\n```HTML\n<blockquote class=\"blockquote-center\">勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。\n    \n    鲁迅</blockquote>\n```\n\n<blockquote class=\"blockquote-center\">勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。\n\n    鲁迅</blockquote>\n\n也可以使用标签的方式`centerquote`（或者其别名`cq`）\n\n```js\n{% centerquote %}盛年不重来，一日难再晨。及时当勉励，岁月不待人。\n\n陶渊明 {% endcenterquote %}\n```\n\n*该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用*\n\n#### Note\n\n使用前端框架 Bootstrap Callout 的语法，Hexo 提供了对其的支持，Content 可以搭配 Markdown 语法\n\n```javascript\n{% note class_name %} Content (md partial supported) {% endnote %}\n\n{% note default %} This is a default note {% endnote %}\n\n{% note primary %} This is a  primary note {% endnote %}\n\n{% note success %} This is a success note {% endnote %}\n\n{% note info %} This is a info note {% endnote %}\n\n{% note warning %} This is a warning note {% endnote %}\n\n{% note danger %} This is a danger note {% endnote %}\n```\n\n实现类似笔记的引用效果，其中`class_name`可以为\n\n- `default`\n- `primary`\n- `success`\n- `info`\n- `warning`\n- `danger`\n\n*该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用*\n\n#### 高亮\n\n使用单个反引号实现单行文本高亮，三个反引号实现代码块高亮。可以在第一个三反引号后添加语言名称实现不同的语法高亮\n\n```markdown\nPHP是`最好的`语言\n```\n\nPHP是`最好的`语言\n\n![](Markdown-语法详解\\kotlin.png)\n\n```Kotlin\nfun main(args: Array<String>) {\n    print(\"hello\")\n}\n```\n\n## 高级进阶\n\n在不同的 Markdown 版本中实现可能不同\n\n### 表格\n\n```markdown\n| 序号 | 列名1 | 列名2 |\n| - | - | - |\n| 0 | 一一  | 一二  |\n| 1 | 二一  | 二二  |\n```\n\n| 序号 | 列名1 | 列名2 |\n| - | - | - |\n| 0 | 一一  | 一二  |\n| 1 | 二一  | 二二  |\n\n在分隔行（第二行）中的`-`右边添加`:`，表格内容实现右对齐效果，两边都加则为居中对齐，默认为左对齐\n\n```markdown\n| 序号 | 列名1 | 列名2 |\n| :-: | :-: | :-: |\n| 0 | 一一  | 一二  |\n```\n\n| 序号 | 列名1 | 列名2 |\n| :--: | :---: | :---: |\n|  0   | 一一  | 一二  |\n\n\n\n### 流程图\n\n分为两部分，第一部分定义元素，第二部分定义元素走向。定义元素语法为`tag=>type: content:>url`，其中`tag`为元素名称，`type`为元素类型，有以下6种\n\n| type        | 含义       |\n| ----------- | ---------- |\n| start       | 开始       |\n| end         | 结束       |\n| operation   | 操作       |\n| subroutine  | 子程序     |\n| condition   | 条件       |\n| inputoutput | 输入或输出 |\n\n`content`为在流程图方框中显示的内容\n\n```markdown\nst=>start: 开始:>https://www.markdown-syntax.com\nio=>inputoutput: 输入或输出\nop=>operation: 操作\ncond=>condition: Yes or No?\nsub=>subroutine: 子程序\ne=>end: 结束\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n\n\n```flow\nst=>start: 开始:>https://www.markdown-syntax.com\nio=>inputoutput: 输入或输出\nop=>operation: 操作\ncond=>condition: Yes or No?\nsub=>subroutine: 子程序\ne=>end: 结束\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n\n\nHexo 原生并不支持流程图，需要安装[hexo-filter-flowchart](\nhttps://github.com/bubkoo/hexo-filter-flowchart)\n\n### 时序图\n\n`title`为时序图标题，`participant`定义时序图对象，`note`定义时序图中的说明，有三种方位控制\n\n- left of, 表示说明位于当前对象的左侧\n- right of, 表示说明位于当前对象的右侧\n- over, 表示说明覆盖在当前对象（们）上\n\n不同对象之间使用箭头控制指向\n\n- ->：实线实箭头\n- -->：虚线实箭头\n- ->>：实线虚箭头\n- -->>：虚线虚箭头\n\n```markdown\ntitle: 时序图标题\nparticipant 大一\nparticipant 大二\nparticipant 大三\n\nnote left of 大一: 大一好好学习\nnote over 大二: 大二课程很多\nnote right of 大三: 大三面临毕业\n\n大一->大一:大一留级\n大一->大二:大一迟早要到大二\n大二-->大三:大二不一定能升大三\n大二->>大三:大二不一定能升大三\n大三-->>大一:大三也可能回炉重造\n```\n\n\n\n```sequence\ntitle: 大学生活\nparticipant 大一\nparticipant 大二\nparticipant 大三\n\nnote left of 大一: 大一好好学习\nnote over 大二: 大二课程很多\nnote right of 大三: 大三面临毕业\n\n大一->大一:大一惨遭留级\n大一->大二:大一迟早要到大二\n大二-->大三:大二不一定能升大三\n大二->>大三:大二不一定能升大三\n大三-->>大一:大三也可能回炉重造\n```\n\n\n\nHexo 默认同样不支持时序图，使用 [hexo-filter-sequence](https://github.com/bubkoo/hexo-filter-sequence)。具体的做法参考 [为 Hexo 增加时序图解析功能](http://wewelove.github.io/fcoder/2017/09/06/markdown-sequence/)\n\n### 字符转义\n\n由于 Markdown 最终会渲染成 HTML 页面，所以一些特殊字符需要遵循 HTML 的转义规则，转义成实体字符才能显示，传送门：[HTML 转义字符](http://www.w3chtml.com/html/character.html)。以下图表中为了显示空格的实体多添加了一个空格\n\n| 显示结果  | 描述    | 实体名称               | 实体编号                   |\n| -- | -- | -- | -- |\n| &nbsp;   | 空格   | &n bsp;            | &# 160;                 |\n| <        | 小于号 | &l t;                 | &# 60;                  |\n| >        | 大于号 | &g t;                 | &# 62;                  |\n| &        | 和号   | &a mp;                 | &# 38;                  |\n| \"        | 引号   | &q uot;                | &# 34;                  |\n| '        | 撇号   | &a pos; (IE不支持)      | &# 39;                  |","source":"_posts/Markdown-语法详解.md","raw":"---\ntitle: Markdown 语法详解\ndate: 2019-05-19 15:36:02\nmathjax: true\ntags: \n- Markdown\ncategories: \n- Markdown\n---\n\n这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown  的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。\n\n![logo](Markdown-语法详解\\markdown.png)\n\n<!--more-->\n\n## 关于 \n\nMarkdown 是一门轻量级的标记语言，由美国工程师 John Gruber 于2004年创造。这门语言的目的是让人们`使用易于阅读、易于撰写的纯文字格式，并选择性地转换成有效的 XHTML（或是 HTML）`。\n\nMarkdown 所谓的**易读**并不是指排版之后呈现的结果易读，而是指原始格式下的文件依然拥有优秀的可读性，不会像阅读原始 HTML 代码一样，满眼都是尖括号（可以通过 右键浏览器页面 -> 查看源代码 体验）。Markdown 的**易写**则体现在其语法足够简单，学习曲线平缓，并且在写作中基本可以脱离鼠标操作。\n\nMarkdown 的轻量级是相对于 LaTeX 来说的，这种基于 Tex 的排版系统广泛运用在高质量书籍印刷和复杂公式论文中。不过使用 Markdown 仍然可以使用一些基本的数学公式，比如`$ E = mc^2 $`、`$ \\int_0^xf(x)dx $`，单个`$`用于行内公式，`$$`用于单行公式\n\n比如 $ E = mc^2 $、$ \\int_0^xf(x)dx $ \n\n这需要不同平台上的 Markdown 数学公式插件的支持，本博客使用`Hexo` + `Github Pages`搭建，可以通过安装 [MathJax](https://www.mathjax.org) 实现。\n\n### 分类\n\n跟早期的 HTML 类似，Markdown 在发展的过程中衍生出了不同的版本，它们的基本语法上相通，但是在诸如表格、锚点、时序图等实现上出现了不一致。在关于语法规范化的讨论中，作者 John Gruber 认为，`不同的网站（和人们）有不同的需求，没有一种语法可以让所有人满意`。\n\n现今 Markdown 的主要分类如下\n\n- CommonMark：由 Stack Exchange、Github、Reddit 等组织发起的标准化项目。一开始名称为`Standard Markdown`，由于遭到作者的反对，更名`CommonMark`\n- GFM：Github Flavored Markdown，由 Github 于2017年发布，基于 CommonMark。相信很多开发者都是通过一份`README.md`文件认识 Markdown，这也是本博客采用的版本。\n- Markdown Extra：基于 PHP、Python 和 Rudy 中实现的 Markdown。\n\n### 编辑器\n\n市面上优秀的 Markdown 编辑器层出不穷，这也有力推动了 Markdown 的发展。可以使用`Sublime Text`配合插件编辑写作，可以使用`Typora`等优秀的跨平台工具实现所见即所得，也可以通过 [Cmd Markdown ](https://www.zybuluo.com)在线书写并导出、发布。\n\n博主使用的是`Typora。`\n\n![编辑器](Markdown-语法详解\\编辑器.png)\n\n相关链接：[码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点](https://sspai.com/post/32483)、 [用 Markdown 写作用什么文本编辑器？ - 知乎](https://www.zhihu.com/question/19637157)\n\n## 初级语法\n\n### 标题\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n---\n\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n---\n\n另外在 GFM 中，任意 1-6 个 **#** 标注的标题都会被添加上同名的锚点链接，比如`# First Title `会被标注成`[First Title](#first-title)`（注意小写转换），因此我们可以在文章的其他地方，使用标注之后的格式跳转到任何标题，比如`[跳转至引言](#引言)`\n\n\n\n### 文字\n\n| 格式                                                 | 效果                   |\n| ---------------------------------------------------- | ---------------------- |\n| `*斜体1*`                                            | *斜体1*                |\n| `_斜体2_`                                            | _斜体2_                |\n| `**粗体1**`                                          | **粗体1**              |\n| `__粗体2__`                                          | __粗体2__              |\n| `~~删除线~~`                                         | ~~删除线~~             |\n| `***斜粗体1***`                                      | ***斜粗体1***          |\n| `___斜粗体2___`                                      | ___斜粗体2___          |\n| `***~~斜粗体删除线1~~***`、`~~***斜粗体删除线2***~~` | ***~~斜粗体删除线~~*** |\n\n\n\n### 表情\n\nGFM 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。比如`:stuck_out_tongue_winking_eye:`：:stuck_out_tongue_winking_eye:\n\n:ghost: :dog: :poop: :fire: :bow:\n\n:smile: :rowboat: :watermelon: :swimmer: :fallen_leaf:\n\n可以在此找到不同表情对应的符号码：[Emoji cheat sheet for GitHub, Basecamp, Slack & more](https://www.webfx.com/tools/emoji-cheat-sheet/)\n\n\n\nHexo 默认不支持 emoji 表情，可以通过安装 [hexo-filter-github-emojis](https://github.com/crimx/hexo-filter-github-emojis) 实现\n\n\n\n### 分割线\n\n使用三个（或多个连续）的`-`、`*`、`-`实现分割线效果\n\n```markdown\n---\n___\n******\n```\n\n------\n\n------\n\n------\n\n\n\n### 链接\n\n链接分为文字链接和图片链接\n\n#### 文字链接\n\n`[ReBe](https://febers.github.io \"鼠标悬停显示\")`：[ReBe](https://febers.github.io \"鼠标悬停显示\")\n\n支持使用标识符标志地址，将真正的URL地址放在文末，比如\n\n```markdown\n[Github][Github URL]\n[Github URL]:https://github.com/Febers\n```\n\n效果如下:\n\n[Github][Github URL]\n\n[Github URL]:https://github.com/Febers\n\n#### 图片链接\n\n基本格式为`![title](url)`，其中`title`可省略，`![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067)`\n\n![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067)\n\n\n\n### 列表\n\n#### 有序列表\n\n看起来并不明显\n\n```markdown\n1. PHP是最好的语言？\n2. PHP是最好的语言！\n```\n\n1. PHP是最好的语言？\n\n2. PHP是最好的语言！\n\n   \n\n#### 无序列表\n\n可以使用`-`、`*`、`+`开头接空格，但在多级列表中最好使用`-`\n\n```markdown\n- PHP是最好的语言？\n* PHP是最好的语言。\n+ PHP是最好的语言！\n\t- 毫无疑问\n\t\t- 众所周知\n```\n\n- PHP是最好的语言？\n* PHP是最好的语言。\n+ PHP是最好的语言！\n  - 毫无疑问\n    - 众所周知\n\n#### 复选框列表\n\n```markdown\n- [x] 大一\n- [x] 大二\n- [ ] 大三\n- [ ] 大四\n```\n\n- [x] 大一\n- [x] 大二\n- [ ] 大三\n- [ ] 大四\n\nHexo 默认的渲染引擎 Marked 不支持 TODO list，可以更换为 markdown-it，之后实现的效果如 Typora 预览\n\n![todo-list](Markdown-语法详解\\todo-list.png)\n\n\n\n### 引用与高亮\n\n#### 引用\n\n使用`>`实现引用，多个`>`实现引用层级\n\n```markdown\n> PHP\n>> 是\n>>> 最好的\n>>>> 语言\n```\n\n> PHP\n> > 是\n> > > 最好的\n> > >\n> > > > 语言\n\n一般用在引用原文内容中\n\n> 一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！”黛玉纳罕道：“这些人个个皆敛声屏气，恭肃严整如此，这来者系谁，这样放诞无礼？”心下想时，只见一群媳妇丫鬟围拥着一个人从后房门进来。这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子：头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗；项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩；身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂；下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未起笑先闻。黛玉连忙起身接见。\n\n\n\n#### 居中\n\nMarkdown 中标准引用是 `>` 符号后面加上引用内容，可以嵌套，或者搭配其他 Markdown 语法结合一起使用。但样式未免单一，不够美观，可以直接使用 HTML 语言插入，如下，使用 `class=\"blockquote-center\"`\n\n```HTML\n<blockquote class=\"blockquote-center\">勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。\n    \n    鲁迅</blockquote>\n```\n\n<blockquote class=\"blockquote-center\">勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。\n\n    鲁迅</blockquote>\n\n也可以使用标签的方式`centerquote`（或者其别名`cq`）\n\n```js\n{% centerquote %}盛年不重来，一日难再晨。及时当勉励，岁月不待人。\n\n陶渊明 {% endcenterquote %}\n```\n\n*该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用*\n\n#### Note\n\n使用前端框架 Bootstrap Callout 的语法，Hexo 提供了对其的支持，Content 可以搭配 Markdown 语法\n\n```javascript\n{% note class_name %} Content (md partial supported) {% endnote %}\n\n{% note default %} This is a default note {% endnote %}\n\n{% note primary %} This is a  primary note {% endnote %}\n\n{% note success %} This is a success note {% endnote %}\n\n{% note info %} This is a info note {% endnote %}\n\n{% note warning %} This is a warning note {% endnote %}\n\n{% note danger %} This is a danger note {% endnote %}\n```\n\n实现类似笔记的引用效果，其中`class_name`可以为\n\n- `default`\n- `primary`\n- `success`\n- `info`\n- `warning`\n- `danger`\n\n*该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用*\n\n#### 高亮\n\n使用单个反引号实现单行文本高亮，三个反引号实现代码块高亮。可以在第一个三反引号后添加语言名称实现不同的语法高亮\n\n```markdown\nPHP是`最好的`语言\n```\n\nPHP是`最好的`语言\n\n![](Markdown-语法详解\\kotlin.png)\n\n```Kotlin\nfun main(args: Array<String>) {\n    print(\"hello\")\n}\n```\n\n## 高级进阶\n\n在不同的 Markdown 版本中实现可能不同\n\n### 表格\n\n```markdown\n| 序号 | 列名1 | 列名2 |\n| - | - | - |\n| 0 | 一一  | 一二  |\n| 1 | 二一  | 二二  |\n```\n\n| 序号 | 列名1 | 列名2 |\n| - | - | - |\n| 0 | 一一  | 一二  |\n| 1 | 二一  | 二二  |\n\n在分隔行（第二行）中的`-`右边添加`:`，表格内容实现右对齐效果，两边都加则为居中对齐，默认为左对齐\n\n```markdown\n| 序号 | 列名1 | 列名2 |\n| :-: | :-: | :-: |\n| 0 | 一一  | 一二  |\n```\n\n| 序号 | 列名1 | 列名2 |\n| :--: | :---: | :---: |\n|  0   | 一一  | 一二  |\n\n\n\n### 流程图\n\n分为两部分，第一部分定义元素，第二部分定义元素走向。定义元素语法为`tag=>type: content:>url`，其中`tag`为元素名称，`type`为元素类型，有以下6种\n\n| type        | 含义       |\n| ----------- | ---------- |\n| start       | 开始       |\n| end         | 结束       |\n| operation   | 操作       |\n| subroutine  | 子程序     |\n| condition   | 条件       |\n| inputoutput | 输入或输出 |\n\n`content`为在流程图方框中显示的内容\n\n```markdown\nst=>start: 开始:>https://www.markdown-syntax.com\nio=>inputoutput: 输入或输出\nop=>operation: 操作\ncond=>condition: Yes or No?\nsub=>subroutine: 子程序\ne=>end: 结束\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n\n\n```flow\nst=>start: 开始:>https://www.markdown-syntax.com\nio=>inputoutput: 输入或输出\nop=>operation: 操作\ncond=>condition: Yes or No?\nsub=>subroutine: 子程序\ne=>end: 结束\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n\n\nHexo 原生并不支持流程图，需要安装[hexo-filter-flowchart](\nhttps://github.com/bubkoo/hexo-filter-flowchart)\n\n### 时序图\n\n`title`为时序图标题，`participant`定义时序图对象，`note`定义时序图中的说明，有三种方位控制\n\n- left of, 表示说明位于当前对象的左侧\n- right of, 表示说明位于当前对象的右侧\n- over, 表示说明覆盖在当前对象（们）上\n\n不同对象之间使用箭头控制指向\n\n- ->：实线实箭头\n- -->：虚线实箭头\n- ->>：实线虚箭头\n- -->>：虚线虚箭头\n\n```markdown\ntitle: 时序图标题\nparticipant 大一\nparticipant 大二\nparticipant 大三\n\nnote left of 大一: 大一好好学习\nnote over 大二: 大二课程很多\nnote right of 大三: 大三面临毕业\n\n大一->大一:大一留级\n大一->大二:大一迟早要到大二\n大二-->大三:大二不一定能升大三\n大二->>大三:大二不一定能升大三\n大三-->>大一:大三也可能回炉重造\n```\n\n\n\n```sequence\ntitle: 大学生活\nparticipant 大一\nparticipant 大二\nparticipant 大三\n\nnote left of 大一: 大一好好学习\nnote over 大二: 大二课程很多\nnote right of 大三: 大三面临毕业\n\n大一->大一:大一惨遭留级\n大一->大二:大一迟早要到大二\n大二-->大三:大二不一定能升大三\n大二->>大三:大二不一定能升大三\n大三-->>大一:大三也可能回炉重造\n```\n\n\n\nHexo 默认同样不支持时序图，使用 [hexo-filter-sequence](https://github.com/bubkoo/hexo-filter-sequence)。具体的做法参考 [为 Hexo 增加时序图解析功能](http://wewelove.github.io/fcoder/2017/09/06/markdown-sequence/)\n\n### 字符转义\n\n由于 Markdown 最终会渲染成 HTML 页面，所以一些特殊字符需要遵循 HTML 的转义规则，转义成实体字符才能显示，传送门：[HTML 转义字符](http://www.w3chtml.com/html/character.html)。以下图表中为了显示空格的实体多添加了一个空格\n\n| 显示结果  | 描述    | 实体名称               | 实体编号                   |\n| -- | -- | -- | -- |\n| &nbsp;   | 空格   | &n bsp;            | &# 160;                 |\n| <        | 小于号 | &l t;                 | &# 60;                  |\n| >        | 大于号 | &g t;                 | &# 62;                  |\n| &        | 和号   | &a mp;                 | &# 38;                  |\n| \"        | 引号   | &q uot;                | &# 34;                  |\n| '        | 撇号   | &a pos; (IE不支持)      | &# 39;                  |","slug":"Markdown-语法详解","published":1,"updated":"2019-06-02T07:10:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxv003ry4upw1dmpgzv","content":"<p>这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown  的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。</p>\n<p><img src=\"/Markdown-语法详解/markdown.png\" alt=\"logo\"></p>\n<a id=\"more\"></a>\n<h2 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h2><p>Markdown 是一门轻量级的标记语言，由美国工程师 John Gruber 于2004年创造。这门语言的目的是让人们<code>使用易于阅读、易于撰写的纯文字格式，并选择性地转换成有效的 XHTML（或是 HTML）</code>。</p>\n<p>Markdown 所谓的<strong>易读</strong>并不是指排版之后呈现的结果易读，而是指原始格式下的文件依然拥有优秀的可读性，不会像阅读原始 HTML 代码一样，满眼都是尖括号（可以通过 右键浏览器页面 -> 查看源代码 体验）。Markdown 的<strong>易写</strong>则体现在其语法足够简单，学习曲线平缓，并且在写作中基本可以脱离鼠标操作。</p>\n<p>Markdown 的轻量级是相对于 LaTeX 来说的，这种基于 Tex 的排版系统广泛运用在高质量书籍印刷和复杂公式论文中。不过使用 Markdown 仍然可以使用一些基本的数学公式，比如<code>$ E = mc^2 $</code>、<code>$ \\int_0^xf(x)dx $</code>，单个<code>$</code>用于行内公式，<code>$$</code>用于单行公式</p>\n<p>比如 $ E = mc^2 $、$ \\int_0^xf(x)dx $ </p>\n<p>这需要不同平台上的 Markdown 数学公式插件的支持，本博客使用<code>Hexo</code> + <code>Github Pages</code>搭建，可以通过安装 <a href=\"https://www.mathjax.org\" target=\"_blank\" rel=\"noopener\">MathJax</a> 实现。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>跟早期的 HTML 类似，Markdown 在发展的过程中衍生出了不同的版本，它们的基本语法上相通，但是在诸如表格、锚点、时序图等实现上出现了不一致。在关于语法规范化的讨论中，作者 John Gruber 认为，<code>不同的网站（和人们）有不同的需求，没有一种语法可以让所有人满意</code>。</p>\n<p>现今 Markdown 的主要分类如下</p>\n<ul>\n<li>CommonMark：由 Stack Exchange、Github、Reddit 等组织发起的标准化项目。一开始名称为<code>Standard Markdown</code>，由于遭到作者的反对，更名<code>CommonMark</code></li>\n<li>GFM：Github Flavored Markdown，由 Github 于2017年发布，基于 CommonMark。相信很多开发者都是通过一份<code>README.md</code>文件认识 Markdown，这也是本博客采用的版本。</li>\n<li>Markdown Extra：基于 PHP、Python 和 Rudy 中实现的 Markdown。</li>\n</ul>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><p>市面上优秀的 Markdown 编辑器层出不穷，这也有力推动了 Markdown 的发展。可以使用<code>Sublime Text</code>配合插件编辑写作，可以使用<code>Typora</code>等优秀的跨平台工具实现所见即所得，也可以通过 <a href=\"https://www.zybuluo.com\" target=\"_blank\" rel=\"noopener\">Cmd Markdown </a>在线书写并导出、发布。</p>\n<p>博主使用的是<code>Typora。</code></p>\n<p><img src=\"/Markdown-语法详解/编辑器.png\" alt=\"编辑器\"></p>\n<p>相关链接：<a href=\"https://sspai.com/post/32483\" target=\"_blank\" rel=\"noopener\">码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点</a>、 <a href=\"https://www.zhihu.com/question/19637157\" target=\"_blank\" rel=\"noopener\">用 Markdown 写作用什么文本编辑器？ - 知乎</a></p>\n<h2 id=\"初级语法\"><a href=\"#初级语法\" class=\"headerlink\" title=\"初级语法\"></a>初级语法</h2><h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 一级标题</span></span><br><span class=\"line\"><span class=\"section\">## 二级标题</span></span><br><span class=\"line\"><span class=\"section\">### 三级标题</span></span><br><span class=\"line\"><span class=\"section\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"section\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"section\">###### 六级标题</span></span><br></pre></td></tr></tbody></table></figure>\n<hr>\n<h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><hr>\n<p>另外在 GFM 中，任意 1-6 个 <strong>#</strong> 标注的标题都会被添加上同名的锚点链接，比如<code># First Title</code>会被标注成<code>[First Title](#first-title)</code>（注意小写转换），因此我们可以在文章的其他地方，使用标注之后的格式跳转到任何标题，比如<code>[跳转至引言](#引言)</code></p>\n<h3 id=\"文字\"><a href=\"#文字\" class=\"headerlink\" title=\"文字\"></a>文字</h3><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*斜体1*</code></td>\n<td><em>斜体1</em></td>\n</tr>\n<tr>\n<td><code>_斜体2_</code></td>\n<td><em>斜体2</em></td>\n</tr>\n<tr>\n<td><code>**粗体1**</code></td>\n<td><strong>粗体1</strong></td>\n</tr>\n<tr>\n<td><code>__粗体2__</code></td>\n<td><strong>粗体2</strong></td>\n</tr>\n<tr>\n<td><code>~~删除线~~</code></td>\n<td><del>删除线</del></td>\n</tr>\n<tr>\n<td><code>***斜粗体1***</code></td>\n<td><strong><em>斜粗体1</em></strong></td>\n</tr>\n<tr>\n<td><code>___斜粗体2___</code></td>\n<td><strong><em>斜粗体2</em></strong></td>\n</tr>\n<tr>\n<td><code>***~~斜粗体删除线1~~***</code>、<code>~~***斜粗体删除线2***~~</code></td>\n<td><strong><em><del>斜粗体删除线</del></em></strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"表情\"><a href=\"#表情\" class=\"headerlink\" title=\"表情\"></a>表情</h3><p>GFM 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。比如<code>:stuck_out_tongue_winking_eye:</code>：<span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f61c.png?v8\">😜</span></p>\n<p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f47b.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f47b.png?v8\">👻</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f436.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f436.png?v8\">🐶</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v8\">💩</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v8\">🔥</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f647.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f647.png?v8\">🙇</span></p>\n<p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8\">😄</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a3.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a3.png?v8\">🚣</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f349.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f349.png?v8\">🍉</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f3ca.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f3ca.png?v8\">🏊</span> <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f342.png?v8) center/contain\" data-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f342.png?v8\">🍂</span></p>\n<p>可以在此找到不同表情对应的符号码：<a href=\"https://www.webfx.com/tools/emoji-cheat-sheet/\" target=\"_blank\" rel=\"noopener\">Emoji cheat sheet for GitHub, Basecamp, Slack & more</a></p>\n<p>Hexo 默认不支持 emoji 表情，可以通过安装 <a href=\"https://github.com/crimx/hexo-filter-github-emojis\" target=\"_blank\" rel=\"noopener\">hexo-filter-github-emojis</a> 实现</p>\n<h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><p>使用三个（或多个连续）的<code>-</code>、<code>*</code>、<code>-</code>实现分割线效果</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\"><span class=\"emphasis\">___</span></span><br><span class=\"line\"><span class=\"strong\">*****</span>*</span><br></pre></td></tr></tbody></table></figure>\n<hr>\n<hr>\n<hr>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>链接分为文字链接和图片链接</p>\n<h4 id=\"文字链接\"><a href=\"#文字链接\" class=\"headerlink\" title=\"文字链接\"></a>文字链接</h4><p><code>[ReBe](https://febers.github.io \"鼠标悬停显示\")</code>：<a href=\"https://febers.github.io\" title=\"鼠标悬停显示\" target=\"_blank\" rel=\"noopener\">ReBe</a></p>\n<p>支持使用标识符标志地址，将真正的URL地址放在文末，比如</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">Github</span>][<span class=\"symbol\">Github URL</span>]</span><br><span class=\"line\">[<span class=\"symbol\">Github URL</span>]:<span class=\"link\">https://github.com/Febers</span></span><br></pre></td></tr></tbody></table></figure>\n<p>效果如下:</p>\n<p><a href=\"https://github.com/Febers\" target=\"_blank\" rel=\"noopener\">Github</a></p>\n<h4 id=\"图片链接\"><a href=\"#图片链接\" class=\"headerlink\" title=\"图片链接\"></a>图片链接</h4><p>基本格式为<code>![title](url)</code>，其中<code>title</code>可省略，<code>![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067)</code></p>\n<p><img src=\"https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067\" alt></p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><p>看起来并不明显</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1. </span>PHP是最好的语言？</span><br><span class=\"line\"><span class=\"bullet\">2. </span>PHP是最好的语言！</span><br></pre></td></tr></tbody></table></figure>\n<ol>\n<li><p>PHP是最好的语言？</p>\n</li>\n<li><p>PHP是最好的语言！</p>\n</li>\n</ol>\n<h4 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h4><p>可以使用<code>-</code>、<code>*</code>、<code>+</code>开头接空格，但在多级列表中最好使用<code>-</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>PHP是最好的语言？</span><br><span class=\"line\"><span class=\"bullet\">* </span>PHP是最好的语言。</span><br><span class=\"line\"><span class=\"bullet\">+ </span>PHP是最好的语言！</span><br><span class=\"line\"><span class=\"code\">\t- 毫无疑问</span></span><br><span class=\"line\"><span class=\"code\">\t\t- 众所周知</span></span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>PHP是最好的语言？</li>\n</ul>\n<ul>\n<li>PHP是最好的语言。</li>\n</ul>\n<ul>\n<li>PHP是最好的语言！<ul>\n<li>毫无疑问<ul>\n<li>众所周知</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"复选框列表\"><a href=\"#复选框列表\" class=\"headerlink\" title=\"复选框列表\"></a>复选框列表</h4><figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>[x] 大一</span><br><span class=\"line\"><span class=\"bullet\">- </span>[x] 大二</span><br><span class=\"line\"><span class=\"bullet\">- </span>[ ] 大三</span><br><span class=\"line\"><span class=\"bullet\">- </span>[ ] 大四</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>[x] 大一</li>\n<li>[x] 大二</li>\n<li>[ ] 大三</li>\n<li>[ ] 大四</li>\n</ul>\n<p>Hexo 默认的渲染引擎 Marked 不支持 TODO list，可以更换为 markdown-it，之后实现的效果如 Typora 预览</p>\n<p><img src=\"/Markdown-语法详解/todo-list.png\" alt=\"todo-list\"></p>\n<h3 id=\"引用与高亮\"><a href=\"#引用与高亮\" class=\"headerlink\" title=\"引用与高亮\"></a>引用与高亮</h3><h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>使用<code>></code>实现引用，多个<code>></code>实现引用层级</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"quote\">> PHP</span></span><br><span class=\"line\">>> 是</span><br><span class=\"line\">>>> 最好的</span><br><span class=\"line\">>>>> 语言</span><br></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>PHP</p>\n<blockquote>\n<p>是</p>\n<blockquote>\n<p>最好的</p>\n<blockquote>\n<p>语言</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>一般用在引用原文内容中</p>\n<blockquote>\n<p>一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！”黛玉纳罕道：“这些人个个皆敛声屏气，恭肃严整如此，这来者系谁，这样放诞无礼？”心下想时，只见一群媳妇丫鬟围拥着一个人从后房门进来。这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子：头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗；项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩；身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂；下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未起笑先闻。黛玉连忙起身接见。</p>\n</blockquote>\n<h4 id=\"居中\"><a href=\"#居中\" class=\"headerlink\" title=\"居中\"></a>居中</h4><p>Markdown 中标准引用是 <code>></code> 符号后面加上引用内容，可以嵌套，或者搭配其他 Markdown 语法结合一起使用。但样式未免单一，不够美观，可以直接使用 HTML 语言插入，如下，使用 <code>class=\"blockquote-center\"</code></p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\"><<span class=\"name\">blockquote</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blockquote-center\"</span>></span>勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。</span><br><span class=\"line\">    </span><br><span class=\"line\">    鲁迅<span class=\"tag\"></<span class=\"name\">blockquote</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<blockquote class=\"blockquote-center\">勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。<br><br>    鲁迅</blockquote>\n\n<p>也可以使用标签的方式<code>centerquote</code>（或者其别名<code>cq</code>）</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">{% centerquote %}盛年不重来，一日难再晨。及时当勉励，岁月不待人。</span><br><span class=\"line\"></span><br><span class=\"line\">陶渊明 {% endcenterquote %}</span><br></pre></td></tr></tbody></table></figure>\n<p><em>该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用</em></p>\n<h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h4><p>使用前端框架 Bootstrap Callout 的语法，Hexo 提供了对其的支持，Content 可以搭配 Markdown 语法</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">{% note class_name %} Content (md partial supported) {% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note <span class=\"keyword\">default</span> %} This is a <span class=\"keyword\">default</span> note {% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note primary %} This is a  primary note {% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note success %} This is a success note {% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note info %} This is a info note {% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note warning %} This is a warning note {% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note danger %} This is a danger note {% endnote %}</span><br></pre></td></tr></tbody></table></figure>\n<p>实现类似笔记的引用效果，其中<code>class_name</code>可以为</p>\n<ul>\n<li><code>default</code></li>\n<li><code>primary</code></li>\n<li><code>success</code></li>\n<li><code>info</code></li>\n<li><code>warning</code></li>\n<li><code>danger</code></li>\n</ul>\n<p><em>该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用</em></p>\n<h4 id=\"高亮\"><a href=\"#高亮\" class=\"headerlink\" title=\"高亮\"></a>高亮</h4><p>使用单个反引号实现单行文本高亮，三个反引号实现代码块高亮。可以在第一个三反引号后添加语言名称实现不同的语法高亮</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">PHP是<span class=\"code\">`最好的`</span>语言</span><br></pre></td></tr></tbody></table></figure>\n<p>PHP是<code>最好的</code>语言</p>\n<p><img src=\"/Markdown-语法详解/kotlin.png\" alt></p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span><<span class=\"type\">String</span>>)</span></span> {</span><br><span class=\"line\">    print(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"高级进阶\"><a href=\"#高级进阶\" class=\"headerlink\" title=\"高级进阶\"></a>高级进阶</h2><p>在不同的 Markdown 版本中实现可能不同</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">| 序号 | 列名1 | 列名2 |</span><br><span class=\"line\">| - | - | - |</span><br><span class=\"line\">| 0 | 一一  | 一二  |</span><br><span class=\"line\">| 1 | 二一  | 二二  |</span><br></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>列名1</th>\n<th>列名2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>一一</td>\n<td>一二</td>\n</tr>\n<tr>\n<td>1</td>\n<td>二一</td>\n<td>二二</td>\n</tr>\n</tbody>\n</table>\n<p>在分隔行（第二行）中的<code>-</code>右边添加<code>:</code>，表格内容实现右对齐效果，两边都加则为居中对齐，默认为左对齐</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">| 序号 | 列名1 | 列名2 |</span><br><span class=\"line\">| :-: | :-: | :-: |</span><br><span class=\"line\">| 0 | 一一  | 一二  |</span><br></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">列名1</th>\n<th style=\"text-align:center\">列名2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">一一</td>\n<td style=\"text-align:center\">一二</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h3><p>分为两部分，第一部分定义元素，第二部分定义元素走向。定义元素语法为<code>tag=>type: content:>url</code>，其中<code>tag</code>为元素名称，<code>type</code>为元素类型，有以下6种</p>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>start</td>\n<td>开始</td>\n</tr>\n<tr>\n<td>end</td>\n<td>结束</td>\n</tr>\n<tr>\n<td>operation</td>\n<td>操作</td>\n</tr>\n<tr>\n<td>subroutine</td>\n<td>子程序</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>条件</td>\n</tr>\n<tr>\n<td>inputoutput</td>\n<td>输入或输出</td>\n</tr>\n</tbody>\n</table>\n<p><code>content</code>为在流程图方框中显示的内容</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">st=>start: 开始:>https://www.markdown-syntax.com</span><br><span class=\"line\">io=>inputoutput: 输入或输出</span><br><span class=\"line\">op=>operation: 操作</span><br><span class=\"line\">cond=>condition: Yes or No?</span><br><span class=\"line\">sub=>subroutine: 子程序</span><br><span class=\"line\">e=>end: 结束</span><br><span class=\"line\"></span><br><span class=\"line\">st->io->op->cond</span><br><span class=\"line\">cond(yes)->e</span><br><span class=\"line\">cond(no)->sub->io</span><br></pre></td></tr></tbody></table></figure>\n<div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n\n\n<p>Hexo 原生并不支持流程图，需要安装<a href=\"https://github.com/bubkoo/hexo-filter-flowchart\" target=\"_blank\" rel=\"noopener\">hexo-filter-flowchart</a></p>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><p><code>title</code>为时序图标题，<code>participant</code>定义时序图对象，<code>note</code>定义时序图中的说明，有三种方位控制</p>\n<ul>\n<li>left of, 表示说明位于当前对象的左侧</li>\n<li>right of, 表示说明位于当前对象的右侧</li>\n<li>over, 表示说明覆盖在当前对象（们）上</li>\n</ul>\n<p>不同对象之间使用箭头控制指向</p>\n<ul>\n<li>->：实线实箭头</li>\n<li>–>：虚线实箭头</li>\n<li>->>：实线虚箭头</li>\n<li>–>>：虚线虚箭头</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">title: 时序图标题</span><br><span class=\"line\">participant 大一</span><br><span class=\"line\">participant 大二</span><br><span class=\"line\">participant 大三</span><br><span class=\"line\"></span><br><span class=\"line\">note left of 大一: 大一好好学习</span><br><span class=\"line\">note over 大二: 大二课程很多</span><br><span class=\"line\">note right of 大三: 大三面临毕业</span><br><span class=\"line\"></span><br><span class=\"line\">大一->大一:大一留级</span><br><span class=\"line\">大一->大二:大一迟早要到大二</span><br><span class=\"line\">大二-->大三:大二不一定能升大三</span><br><span class=\"line\">大二->>大三:大二不一定能升大三</span><br><span class=\"line\">大三-->>大一:大三也可能回炉重造</span><br></pre></td></tr></tbody></table></figure>\n<div id=\"sequence-0\"></div>\n\n\n\n<p>Hexo 默认同样不支持时序图，使用 <a href=\"https://github.com/bubkoo/hexo-filter-sequence\" target=\"_blank\" rel=\"noopener\">hexo-filter-sequence</a>。具体的做法参考 <a href=\"http://wewelove.github.io/fcoder/2017/09/06/markdown-sequence/\" target=\"_blank\" rel=\"noopener\">为 Hexo 增加时序图解析功能</a></p>\n<h3 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h3><p>由于 Markdown 最终会渲染成 HTML 页面，所以一些特殊字符需要遵循 HTML 的转义规则，转义成实体字符才能显示，传送门：<a href=\"http://www.w3chtml.com/html/character.html\" target=\"_blank\" rel=\"noopener\">HTML 转义字符</a>。以下图表中为了显示空格的实体多添加了一个空格</p>\n<table>\n<thead>\n<tr>\n<th>显示结果</th>\n<th>描述</th>\n<th>实体名称</th>\n<th>实体编号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> </td>\n<td>空格</td>\n<td>&n bsp;</td>\n<td>&# 160;</td>\n</tr>\n<tr>\n<td><</td>\n<td>小于号</td>\n<td>&l t;</td>\n<td>&# 60;</td>\n</tr>\n<tr>\n<td>></td>\n<td>大于号</td>\n<td>&g t;</td>\n<td>&# 62;</td>\n</tr>\n<tr>\n<td>&</td>\n<td>和号</td>\n<td>&a mp;</td>\n<td>&# 38;</td>\n</tr>\n<tr>\n<td>“</td>\n<td>引号</td>\n<td>&q uot;</td>\n<td>&# 34;</td>\n</tr>\n<tr>\n<td>‘</td>\n<td>撇号</td>\n<td>&a pos; (IE不支持)</td>\n<td>&# 39;</td>\n<td><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 开始:>https://www.markdown-syntax.com\nio=>inputoutput: 输入或输出\nop=>operation: 操作\ncond=>condition: Yes or No?\nsub=>subroutine: 子程序\ne=>end: 结束\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script><script src=\"https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js\"></script><script src=\"https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js\"></script><script src=\"https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js\"></script><script src=\"https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js\"></script><script src=\"https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js\"></script><textarea id=\"sequence-0-code\" style=\"display: none\">title: 大学生活\nparticipant 大一\nparticipant 大二\nparticipant 大三\n\nnote left of 大一: 大一好好学习\nnote over 大二: 大二课程很多\nnote right of 大三: 大三面临毕业\n\n大一->大一:大一惨遭留级\n大一->大二:大一迟早要到大二\n大二-->大三:大二不一定能升大三\n大二->>大三:大二不一定能升大三\n大三-->>大一:大三也可能回炉重造</textarea><textarea id=\"sequence-0-options\" style=\"display: none\">{\"theme\":\"simple\"}</textarea><script>  var code = document.getElementById(\"sequence-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value));  var diagram = Diagram.parse(code);  diagram.drawSVG(\"sequence-0\", options);</script></td>\n</tr>\n</tbody>\n</table>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":7111,"excerpt":"<p>这篇文章本应该在搭建博客之后就发布，一开始觉得 Markdown  的语法足够简单，熟能生巧，无需花费篇幅去记录；近来无事，反省了一下自己的错误认识，除去一些高级用法，了解这门用途广泛的标记语言的由来与发展，回顾它的基础语法如何将排版变成一件充满乐趣的事，完全值得专门写一篇文章。</p>\n<p><img src=\"/Markdown-语法详解/markdown.png\" alt=\"logo\"></p>","more":"<h2 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h2><p>Markdown 是一门轻量级的标记语言，由美国工程师 John Gruber 于2004年创造。这门语言的目的是让人们<code>使用易于阅读、易于撰写的纯文字格式，并选择性地转换成有效的 XHTML（或是 HTML）</code>。</p>\n<p>Markdown 所谓的<strong>易读</strong>并不是指排版之后呈现的结果易读，而是指原始格式下的文件依然拥有优秀的可读性，不会像阅读原始 HTML 代码一样，满眼都是尖括号（可以通过 右键浏览器页面 -&gt; 查看源代码 体验）。Markdown 的<strong>易写</strong>则体现在其语法足够简单，学习曲线平缓，并且在写作中基本可以脱离鼠标操作。</p>\n<p>Markdown 的轻量级是相对于 LaTeX 来说的，这种基于 Tex 的排版系统广泛运用在高质量书籍印刷和复杂公式论文中。不过使用 Markdown 仍然可以使用一些基本的数学公式，比如<code>$ E = mc^2 $</code>、<code>$ \\int_0^xf(x)dx $</code>，单个<code>$</code>用于行内公式，<code>$$</code>用于单行公式</p>\n<p>比如 $ E = mc^2 $、$ \\int_0^xf(x)dx $ </p>\n<p>这需要不同平台上的 Markdown 数学公式插件的支持，本博客使用<code>Hexo</code> + <code>Github Pages</code>搭建，可以通过安装 <a href=\"https://www.mathjax.org\" target=\"_blank\" rel=\"noopener\">MathJax</a> 实现。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>跟早期的 HTML 类似，Markdown 在发展的过程中衍生出了不同的版本，它们的基本语法上相通，但是在诸如表格、锚点、时序图等实现上出现了不一致。在关于语法规范化的讨论中，作者 John Gruber 认为，<code>不同的网站（和人们）有不同的需求，没有一种语法可以让所有人满意</code>。</p>\n<p>现今 Markdown 的主要分类如下</p>\n<ul>\n<li>CommonMark：由 Stack Exchange、Github、Reddit 等组织发起的标准化项目。一开始名称为<code>Standard Markdown</code>，由于遭到作者的反对，更名<code>CommonMark</code></li>\n<li>GFM：Github Flavored Markdown，由 Github 于2017年发布，基于 CommonMark。相信很多开发者都是通过一份<code>README.md</code>文件认识 Markdown，这也是本博客采用的版本。</li>\n<li>Markdown Extra：基于 PHP、Python 和 Rudy 中实现的 Markdown。</li>\n</ul>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><p>市面上优秀的 Markdown 编辑器层出不穷，这也有力推动了 Markdown 的发展。可以使用<code>Sublime Text</code>配合插件编辑写作，可以使用<code>Typora</code>等优秀的跨平台工具实现所见即所得，也可以通过 <a href=\"https://www.zybuluo.com\" target=\"_blank\" rel=\"noopener\">Cmd Markdown </a>在线书写并导出、发布。</p>\n<p>博主使用的是<code>Typora。</code></p>\n<p><img src=\"/Markdown-语法详解/编辑器.png\" alt=\"编辑器\"></p>\n<p>相关链接：<a href=\"https://sspai.com/post/32483\" target=\"_blank\" rel=\"noopener\">码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点</a>、 <a href=\"https://www.zhihu.com/question/19637157\" target=\"_blank\" rel=\"noopener\">用 Markdown 写作用什么文本编辑器？ - 知乎</a></p>\n<h2 id=\"初级语法\"><a href=\"#初级语法\" class=\"headerlink\" title=\"初级语法\"></a>初级语法</h2><h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 一级标题</span></span><br><span class=\"line\"><span class=\"section\">## 二级标题</span></span><br><span class=\"line\"><span class=\"section\">### 三级标题</span></span><br><span class=\"line\"><span class=\"section\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"section\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"section\">###### 六级标题</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><hr>\n<p>另外在 GFM 中，任意 1-6 个 <strong>#</strong> 标注的标题都会被添加上同名的锚点链接，比如<code># First Title</code>会被标注成<code>[First Title](#first-title)</code>（注意小写转换），因此我们可以在文章的其他地方，使用标注之后的格式跳转到任何标题，比如<code>[跳转至引言](#引言)</code></p>\n<h3 id=\"文字\"><a href=\"#文字\" class=\"headerlink\" title=\"文字\"></a>文字</h3><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*斜体1*</code></td>\n<td><em>斜体1</em></td>\n</tr>\n<tr>\n<td><code>_斜体2_</code></td>\n<td><em>斜体2</em></td>\n</tr>\n<tr>\n<td><code>**粗体1**</code></td>\n<td><strong>粗体1</strong></td>\n</tr>\n<tr>\n<td><code>__粗体2__</code></td>\n<td><strong>粗体2</strong></td>\n</tr>\n<tr>\n<td><code>~~删除线~~</code></td>\n<td><del>删除线</del></td>\n</tr>\n<tr>\n<td><code>***斜粗体1***</code></td>\n<td><strong><em>斜粗体1</em></strong></td>\n</tr>\n<tr>\n<td><code>___斜粗体2___</code></td>\n<td><strong><em>斜粗体2</em></strong></td>\n</tr>\n<tr>\n<td><code>***~~斜粗体删除线1~~***</code>、<code>~~***斜粗体删除线2***~~</code></td>\n<td><strong><em><del>斜粗体删除线</del></em></strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"表情\"><a href=\"#表情\" class=\"headerlink\" title=\"表情\"></a>表情</h3><p>GFM 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。比如<code>:stuck_out_tongue_winking_eye:</code>：:stuck_out_tongue_winking_eye:</p>\n<p>:ghost: :dog: :poop: :fire: :bow:</p>\n<p>:smile: :rowboat: :watermelon: :swimmer: :fallen_leaf:</p>\n<p>可以在此找到不同表情对应的符号码：<a href=\"https://www.webfx.com/tools/emoji-cheat-sheet/\" target=\"_blank\" rel=\"noopener\">Emoji cheat sheet for GitHub, Basecamp, Slack &amp; more</a></p>\n<p>Hexo 默认不支持 emoji 表情，可以通过安装 <a href=\"https://github.com/crimx/hexo-filter-github-emojis\" target=\"_blank\" rel=\"noopener\">hexo-filter-github-emojis</a> 实现</p>\n<h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><p>使用三个（或多个连续）的<code>-</code>、<code>*</code>、<code>-</code>实现分割线效果</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\"><span class=\"emphasis\">___</span></span><br><span class=\"line\"><span class=\"strong\">*****</span>*</span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<hr>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>链接分为文字链接和图片链接</p>\n<h4 id=\"文字链接\"><a href=\"#文字链接\" class=\"headerlink\" title=\"文字链接\"></a>文字链接</h4><p><code>[ReBe](https://febers.github.io &quot;鼠标悬停显示&quot;)</code>：<a href=\"https://febers.github.io\" title=\"鼠标悬停显示\" target=\"_blank\" rel=\"noopener\">ReBe</a></p>\n<p>支持使用标识符标志地址，将真正的URL地址放在文末，比如</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">Github</span>][<span class=\"symbol\">Github URL</span>]</span><br><span class=\"line\">[<span class=\"symbol\">Github URL</span>]:<span class=\"link\">https://github.com/Febers</span></span><br></pre></td></tr></table></figure>\n<p>效果如下:</p>\n<p><a href=\"https://github.com/Febers\" target=\"_blank\" rel=\"noopener\">Github</a></p>\n<h4 id=\"图片链接\"><a href=\"#图片链接\" class=\"headerlink\" title=\"图片链接\"></a>图片链接</h4><p>基本格式为<code>![title](url)</code>，其中<code>title</code>可省略，<code>![](https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067)</code></p>\n<p><img src=\"https://camo.githubusercontent.com/abf9d87ce112444bca1ddfffaa2063f02a2c26d0/68747470733a2f2f7261772e6769746875622e636f6d2f6164616d2d702f6d61726b646f776e2d686572652f6d61737465722f73746f72652d6173736574732f646f732d65717569732d4d44482e6a7067\" alt=\"\"></p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><p>看起来并不明显</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1. </span>PHP是最好的语言？</span><br><span class=\"line\"><span class=\"bullet\">2. </span>PHP是最好的语言！</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>PHP是最好的语言？</p>\n</li>\n<li><p>PHP是最好的语言！</p>\n</li>\n</ol>\n<h4 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h4><p>可以使用<code>-</code>、<code>*</code>、<code>+</code>开头接空格，但在多级列表中最好使用<code>-</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>PHP是最好的语言？</span><br><span class=\"line\"><span class=\"bullet\">* </span>PHP是最好的语言。</span><br><span class=\"line\"><span class=\"bullet\">+ </span>PHP是最好的语言！</span><br><span class=\"line\"><span class=\"code\">\t- 毫无疑问</span></span><br><span class=\"line\"><span class=\"code\">\t\t- 众所周知</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>PHP是最好的语言？</li>\n</ul>\n<ul>\n<li>PHP是最好的语言。</li>\n</ul>\n<ul>\n<li>PHP是最好的语言！<ul>\n<li>毫无疑问<ul>\n<li>众所周知</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"复选框列表\"><a href=\"#复选框列表\" class=\"headerlink\" title=\"复选框列表\"></a>复选框列表</h4><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>[x] 大一</span><br><span class=\"line\"><span class=\"bullet\">- </span>[x] 大二</span><br><span class=\"line\"><span class=\"bullet\">- </span>[ ] 大三</span><br><span class=\"line\"><span class=\"bullet\">- </span>[ ] 大四</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[x] 大一</li>\n<li>[x] 大二</li>\n<li>[ ] 大三</li>\n<li>[ ] 大四</li>\n</ul>\n<p>Hexo 默认的渲染引擎 Marked 不支持 TODO list，可以更换为 markdown-it，之后实现的效果如 Typora 预览</p>\n<p><img src=\"/Markdown-语法详解/todo-list.png\" alt=\"todo-list\"></p>\n<h3 id=\"引用与高亮\"><a href=\"#引用与高亮\" class=\"headerlink\" title=\"引用与高亮\"></a>引用与高亮</h3><h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>使用<code>&gt;</code>实现引用，多个<code>&gt;</code>实现引用层级</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"quote\">&gt; PHP</span></span><br><span class=\"line\">&gt;&gt; 是</span><br><span class=\"line\">&gt;&gt;&gt; 最好的</span><br><span class=\"line\">&gt;&gt;&gt;&gt; 语言</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PHP</p>\n<blockquote>\n<p>是</p>\n<blockquote>\n<p>最好的</p>\n<blockquote>\n<p>语言</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>一般用在引用原文内容中</p>\n<blockquote>\n<p>一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！”黛玉纳罕道：“这些人个个皆敛声屏气，恭肃严整如此，这来者系谁，这样放诞无礼？”心下想时，只见一群媳妇丫鬟围拥着一个人从后房门进来。这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子：头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗；项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩；身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂；下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未起笑先闻。黛玉连忙起身接见。</p>\n</blockquote>\n<h4 id=\"居中\"><a href=\"#居中\" class=\"headerlink\" title=\"居中\"></a>居中</h4><p>Markdown 中标准引用是 <code>&gt;</code> 符号后面加上引用内容，可以嵌套，或者搭配其他 Markdown 语法结合一起使用。但样式未免单一，不够美观，可以直接使用 HTML 语言插入，如下，使用 <code>class=&quot;blockquote-center&quot;</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blockquote</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blockquote-center\"</span>&gt;</span>勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。</span><br><span class=\"line\">    </span><br><span class=\"line\">    鲁迅<span class=\"tag\">&lt;/<span class=\"name\">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote class=\"blockquote-center\">勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。<br><br>    鲁迅</blockquote>\n\n<p>也可以使用标签的方式<code>centerquote</code>（或者其别名<code>cq</code>）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% centerquote %&#125;盛年不重来，一日难再晨。及时当勉励，岁月不待人。</span><br><span class=\"line\"></span><br><span class=\"line\">陶渊明 &#123;% endcenterquote %&#125;</span><br></pre></td></tr></table></figure>\n<p><em>该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用</em></p>\n<h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h4><p>使用前端框架 Bootstrap Callout 的语法，Hexo 提供了对其的支持，Content 可以搭配 Markdown 语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% note <span class=\"keyword\">default</span> %&#125; This is a <span class=\"keyword\">default</span> note &#123;% endnote %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% note primary %&#125; This is a  primary note &#123;% endnote %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% note success %&#125; This is a success note &#123;% endnote %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% note info %&#125; This is a info note &#123;% endnote %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% note warning %&#125; This is a warning note &#123;% endnote %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% note danger %&#125; This is a danger note &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>\n<p>实现类似笔记的引用效果，其中<code>class_name</code>可以为</p>\n<ul>\n<li><code>default</code></li>\n<li><code>primary</code></li>\n<li><code>success</code></li>\n<li><code>info</code></li>\n<li><code>warning</code></li>\n<li><code>danger</code></li>\n</ul>\n<p><em>该标签不会被当前主题识别，且造成部署 Hexo 时报错，在 NexT 主题上正常使用</em></p>\n<h4 id=\"高亮\"><a href=\"#高亮\" class=\"headerlink\" title=\"高亮\"></a>高亮</h4><p>使用单个反引号实现单行文本高亮，三个反引号实现代码块高亮。可以在第一个三反引号后添加语言名称实现不同的语法高亮</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">PHP是<span class=\"code\">`最好的`</span>语言</span><br></pre></td></tr></table></figure>\n<p>PHP是<code>最好的</code>语言</p>\n<p><img src=\"/Markdown-语法详解/kotlin.png\" alt=\"\"></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    print(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级进阶\"><a href=\"#高级进阶\" class=\"headerlink\" title=\"高级进阶\"></a>高级进阶</h2><p>在不同的 Markdown 版本中实现可能不同</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">| 序号 | 列名1 | 列名2 |</span><br><span class=\"line\">| - | - | - |</span><br><span class=\"line\">| 0 | 一一  | 一二  |</span><br><span class=\"line\">| 1 | 二一  | 二二  |</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>列名1</th>\n<th>列名2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>一一</td>\n<td>一二</td>\n</tr>\n<tr>\n<td>1</td>\n<td>二一</td>\n<td>二二</td>\n</tr>\n</tbody>\n</table>\n<p>在分隔行（第二行）中的<code>-</code>右边添加<code>:</code>，表格内容实现右对齐效果，两边都加则为居中对齐，默认为左对齐</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">| 序号 | 列名1 | 列名2 |</span><br><span class=\"line\">| :-: | :-: | :-: |</span><br><span class=\"line\">| 0 | 一一  | 一二  |</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">列名1</th>\n<th style=\"text-align:center\">列名2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">一一</td>\n<td style=\"text-align:center\">一二</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h3><p>分为两部分，第一部分定义元素，第二部分定义元素走向。定义元素语法为<code>tag=&gt;type: content:&gt;url</code>，其中<code>tag</code>为元素名称，<code>type</code>为元素类型，有以下6种</p>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>start</td>\n<td>开始</td>\n</tr>\n<tr>\n<td>end</td>\n<td>结束</td>\n</tr>\n<tr>\n<td>operation</td>\n<td>操作</td>\n</tr>\n<tr>\n<td>subroutine</td>\n<td>子程序</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>条件</td>\n</tr>\n<tr>\n<td>inputoutput</td>\n<td>输入或输出</td>\n</tr>\n</tbody>\n</table>\n<p><code>content</code>为在流程图方框中显示的内容</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">st=&gt;start: 开始:&gt;https://www.markdown-syntax.com</span><br><span class=\"line\">io=&gt;inputoutput: 输入或输出</span><br><span class=\"line\">op=&gt;operation: 操作</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">sub=&gt;subroutine: 子程序</span><br><span class=\"line\">e=&gt;end: 结束</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;io-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure>\n<div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n\n\n<p>Hexo 原生并不支持流程图，需要安装<a href=\"https://github.com/bubkoo/hexo-filter-flowchart\" target=\"_blank\" rel=\"noopener\">hexo-filter-flowchart</a></p>\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><p><code>title</code>为时序图标题，<code>participant</code>定义时序图对象，<code>note</code>定义时序图中的说明，有三种方位控制</p>\n<ul>\n<li>left of, 表示说明位于当前对象的左侧</li>\n<li>right of, 表示说明位于当前对象的右侧</li>\n<li>over, 表示说明覆盖在当前对象（们）上</li>\n</ul>\n<p>不同对象之间使用箭头控制指向</p>\n<ul>\n<li>-&gt;：实线实箭头</li>\n<li>–&gt;：虚线实箭头</li>\n<li>-&gt;&gt;：实线虚箭头</li>\n<li>–&gt;&gt;：虚线虚箭头</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 时序图标题</span><br><span class=\"line\">participant 大一</span><br><span class=\"line\">participant 大二</span><br><span class=\"line\">participant 大三</span><br><span class=\"line\"></span><br><span class=\"line\">note left of 大一: 大一好好学习</span><br><span class=\"line\">note over 大二: 大二课程很多</span><br><span class=\"line\">note right of 大三: 大三面临毕业</span><br><span class=\"line\"></span><br><span class=\"line\">大一-&gt;大一:大一留级</span><br><span class=\"line\">大一-&gt;大二:大一迟早要到大二</span><br><span class=\"line\">大二--&gt;大三:大二不一定能升大三</span><br><span class=\"line\">大二-&gt;&gt;大三:大二不一定能升大三</span><br><span class=\"line\">大三--&gt;&gt;大一:大三也可能回炉重造</span><br></pre></td></tr></table></figure>\n<div id=\"sequence-0\"></div>\n\n\n\n<p>Hexo 默认同样不支持时序图，使用 <a href=\"https://github.com/bubkoo/hexo-filter-sequence\" target=\"_blank\" rel=\"noopener\">hexo-filter-sequence</a>。具体的做法参考 <a href=\"http://wewelove.github.io/fcoder/2017/09/06/markdown-sequence/\" target=\"_blank\" rel=\"noopener\">为 Hexo 增加时序图解析功能</a></p>\n<h3 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h3><p>由于 Markdown 最终会渲染成 HTML 页面，所以一些特殊字符需要遵循 HTML 的转义规则，转义成实体字符才能显示，传送门：<a href=\"http://www.w3chtml.com/html/character.html\" target=\"_blank\" rel=\"noopener\">HTML 转义字符</a>。以下图表中为了显示空格的实体多添加了一个空格</p>\n<table>\n<thead>\n<tr>\n<th>显示结果</th>\n<th>描述</th>\n<th>实体名称</th>\n<th>实体编号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td>空格</td>\n<td>&amp;n bsp;</td>\n<td>&amp;# 160;</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于号</td>\n<td>&amp;l t;</td>\n<td>&amp;# 60;</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于号</td>\n<td>&amp;g t;</td>\n<td>&amp;# 62;</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>和号</td>\n<td>&amp;a mp;</td>\n<td>&amp;# 38;</td>\n</tr>\n<tr>\n<td>“</td>\n<td>引号</td>\n<td>&amp;q uot;</td>\n<td>&amp;# 34;</td>\n</tr>\n<tr>\n<td>‘</td>\n<td>撇号</td>\n<td>&amp;a pos; (IE不支持)</td>\n<td>&amp;# 39;</td>\n<td><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 开始:>https://www.markdown-syntax.com\nio=>inputoutput: 输入或输出\nop=>operation: 操作\ncond=>condition: Yes or No?\nsub=>subroutine: 子程序\ne=>end: 结束\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script><script src=\"https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js\"></script><script src=\"https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js\"></script><script src=\"https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js\"></script><script src=\"https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js\"></script><script src=\"https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js\"></script><textarea id=\"sequence-0-code\" style=\"display: none\">title: 大学生活\nparticipant 大一\nparticipant 大二\nparticipant 大三\n\nnote left of 大一: 大一好好学习\nnote over 大二: 大二课程很多\nnote right of 大三: 大三面临毕业\n\n大一->大一:大一惨遭留级\n大一->大二:大一迟早要到大二\n大二-->大三:大二不一定能升大三\n大二->>大三:大二不一定能升大三\n大三-->>大一:大三也可能回炉重造</textarea><textarea id=\"sequence-0-options\" style=\"display: none\">{\"theme\":\"simple\"}</textarea><script>  var code = document.getElementById(\"sequence-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value));  var diagram = Diagram.parse(code);  diagram.drawSVG(\"sequence-0\", options);</script></td>\n</tr>\n</tbody>\n</table>"},{"title":"Spring 学习笔记（三）：面向切面","date":"2019-06-02T04:52:24.000Z","_content":"\n[第一篇笔记](https://febers.github.io/Spring-学习笔记（一）：基本理念和-Bean-装配/) 曾简单提及了 AOP 的知识，本文将重点展开 Spring 对切面的支持，包括如何使用和 AspectJ 的具体应用<!--more-->\n\n## 面向切面编程\n\nAspect-Oriented Programming，AOP。每个应用除了其核心业务之外，还会需要一些模块化的通用功能——比如日志、安全、通知等。重用通用功能的方式一般有继承（inheritance）、 委托（delegation），缺点在于前者会导致对象体系复杂、难以维护，后者则可能需要对委托对象进行复杂的调用。切面提供了不一样的思路，并且在很多场景下更加清晰简洁。\n\n### AOP 术语\n\n![](Spring-学习笔记（三）：面向切面\\AOP_1.jpg)\n\n#### Advice\n\n通知，如果翻译为“增强”就能更直观地理解它所扮演的角色。Spring 切面可以应用 5 种类型的通知\n\n- 前置通知（ Before ）：在目标方法被调用之前调用通知功能\n- 后置通知（ After ）：在目标方法完成之后调用通知，不关心方法的返回值\n- 返回通知（ After-returning ）：在目标方法成功执行之后调用通知\n- 异常通知（ After-throwing ）：在目标方法抛出异常之后调用通知\n- 环绕通知（ Around ）：通知包裹了被通知的方法，在被通知的方法调用之前喝调用之后执行自定义的行为\n\n#### Joint point\n\n连接点，应用可能有数以千计的时机应用通知，这些时机被称为连接点。根据上面的图理解，连接点是在应用执行过程中能够插入切面的一个点，改点可以是调用方法时、抛出异常时、甚至修改一个字段时。\n\n#### Pointcut\n\n切点，通知定义了切面的“什么”和“何时”，连接点定义了“时间点”，切点则定义了“何处”。切点会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称、或者使用正则表达式定义所匹配的类和方法来指定切点，有些 AOP 框架也会允许动态创建切点。\n\n#### Aspect\n\n切面，通知+切点，这两者共同定义了切面的全部内容\n\n#### Introduction\n\n引入，允许开发者向现有的类添加方法或属性\n\n#### Weaving\n\n织入，把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入：\n\n- 编译期：切面在目标类编译时被织入。需要特殊的编译器，如 AspectJ 的织入编译器\n- 类加载期：切面在目标类加载到 JVM 时被织入。这种方式需要特殊的类加载器，从而在目标类被引用之前增强其字节码。比如 AspectJ 5 的加载时织入（load-time weaving，LTW）\n- 运行期：切面在应用运行的某个时刻被织入。一般情况下，织入时 AOP 容器会为目标对象动态地创建一个代理对象。比如 Spring AOP\n\n### Spring AOP\n\nSpring 提供了 4 中类型的 AOP 支持：\n\n- 基于代理的经典 Spring AOP\n- 纯 POJO 切面\n- `@AspectJ`注解驱动的切面\n- 注入式 AspectJ 切面\n\n相比起其他方式，第一种显得笨重而古典，不再介绍。纯 POJO 切面需要借助 Spring 的 `aop`命名空间，虽然足够简便，但也不再赘述。Spring 借鉴了 AspectJ 的切面以提供注解驱动的 AOP，其本质仍然是代理，但是编程模型几乎与成熟的 AspectJ 注解完全一致。如果开发者对 AOP 的需求超过了简单的方法调用（如构造器或属性拦截），那么可以考虑第四种方式——使用 AspectJ。\n\n通过再代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。代理类封装了目标类并拦截被通知方法的调用，再把调用转发给真正的目标 bean\n\n![](Spring-学习笔记（三）：面向切面\\AOP_2.jpg)\n\n由于 Spring  AOP 基于动态代理，所以只支持方法连接点，不支持字段连接点——无法创建细粒度的通知、不支持构造器连接点——无法在 bean 创建时应用通知。\n\n## 通过切点选择连接点\n\n使用 AspectJ 的切点表达式语言来定义切点。Spring 仅支持 AspectJ 切点指示器的一个子集，因为 Spring 基于代理，而某些切点表达式与代理无关。下表是 Spring AOP 所支持的指示器\n\n| AspectJ 指示器 | 描述                                                     |\n| -------------- | -------------------------------------------------------- |\n| arg()          | 限制连接点匹配参数为指定类型的执行方法                   |\n| @args()        | 限制连接点匹配参数由指定注解标注的执行方法               |\n| execution()    | 用于匹配是连接点的执行方法                               |\n| this()         | 限制连接点匹配 AOP 代理的 bean 引用为指定类型的类        |\n| target()       | 限制连接点匹配目标对象为指定类型的类                     |\n| @target()      | 限制连接点匹配特定的具有指定类型注解的执行对象           |\n| within()       | 限制连接点匹配指定的类型                                 |\n| @within()      | 限制连接点匹配指定注解所标注的类型（方法定义在该类型中） |\n| @annotation    | 限定匹配带有指定注解的连接点                             |\n\n尝试使用其他指示器时，将抛出`IllegalArgumentException`异常\n\n以上的指示器只有`execution()`指示器是实际执行匹配的，其他指示器都是用来限制匹配的。\n\n### 编写切点\n\n准备一个主题 Performance，可代表任何类型的现场表演，假设要编写其中`perform`方法触发的通知\n\n```kotlin\npackage concert\n\ninterface Performance {\n    fun perform()\n}\n```\n\n使用 AspectJ 表达式编写切点\n\n```java\nexecution(* concert.Performance.perform(..)) && within(concert.*)\n```\n\n使用`execution()`指示器选择`perform`方法，方法表达式以`*`开始表示不关心返回值类型，然后使用全限定类名和方法名；使用两个点号`..`表示不关心方法参数列表，切点会选择为所有的`perform`方法。`&&`操作符把`execution()`和`within`指示器连接在一起形成`与（and）`关系，限制需要配置的切点仅匹配`concert`包，类似也可以使用`||`和`!`来标识`或（or）`和`非（not）`操作\n\n当然也可以通过 Spring 引入的指示器`bean()`指示特定的 bean，参数为 bean 的 id\n\n```java\nexecution(* concert.Performance.perform(..)) && bean('woodstock')\nexecution(* concert.Performance.perform(..)) && !bean('woodstock')  \n```\n\n## 使用注解创建切面\n\n### 简单通知\n\n对于一场演出，我们将“观众”定义为切面\n\n```kotlin\n@Aspect\nclass Audience {\n\n    @Before(\"execution(** concert.Performance.perform(..)\")\n    fun silenceCellPhones() {\n        println(\"Silencing cell phones\")\n    }\n\n    @Before(\"execution(** concert.Performance.perform(..)\")\n    fun takeSeats() {\n        println(\"Taking seats\")\n    }\n\n    @AfterReturning(\"execution(** concert.Performance.perform(..)\")\n    fun applause() {\n        println(\"CLAP CLAP CLAP!!\")\n    }\n\n    @AfterThrowing(\"execution(** concert.Performance.perform(..)\")\n    fun demandRefund() {\n        println(\"Demanding a refund\")\n    }\n}\n```\n\n> AspectJ 库需要通过依赖引入\n\nAudience 定义了四个方法，通过 AOP 注解，形成以下期望的行为——演出之前观众就坐、将手机静音，演出很精彩则鼓掌欢呼，演出没有达到预期则要求退款。以上的方式有一点不足，每个方法的切点表达式都是一样的，重复了四次。为此可以使用`@Pointcut`注解定义可重用的切点\n\n```kotlin\n@Aspect\nclass Audience {\n\n    @Pointcut(\"execution(** concert.Performance.perform(..))\")\n    fun performance(){ }\n    \n    @Before(\"performance()\")\n    fun silenceCellPhones() {\n        println(\"Silencing cell phones\")\n    }\n\n    @Before(\"performance()\")\n    fun takeSeats() {\n        println(\"Taking seats\")\n    }\n\n    @AfterReturning(\"performance()\")\n    fun applause() {\n        println(\"CLAP CLAP CLAP!!\")\n    }\n\n    @AfterThrowing(\"performance()\")\n    fun demandRefund() {\n        println(\"Demanding a refund\")\n    }\n}\n```\n\n除了注解和作为标识的空`performance`方法，Audience 仍然是一个 POJO，可以添加`@Component`注解将其注入容器中。但此时 Audience 不会视为切面，需要在配置类的的类级别通过使用`@EnableAspectJAutoProxy`注解启动自动代理功能\n\n```kotlin\n@Configuration\n@EnableAspectJAutoProxy\n@ComponentScan\nopen class ConcertConfig\n```\n\n同时为 Performance 提供一个实现类\n\n```kotlin\n@Component\nopen class MyPerformance: Performance {\n    \n    override fun perform() {\n        println(\"Start perform\")\n    }\n\n}\n```\n\n测试类如下\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [ConcertConfig::class])\nclass PerformTest {\n    \n    @Autowired\n    lateinit var performance: Performance\n\n    @Test\n    fun perform() {\n        performance.perform()\n    }\n}\n```\n\n输出结果为\n\n```bash\nSilencing cell phones\nTaking seats\nStart perform\nCLAP CLAP CLAP!!\n```\n\n### 环绕通知\n\n环绕通知时最强大的通知类型，能够使编写的逻辑将被通知的目标方法完全包装，就像 在一个通知方法中同时编写前置通知和后置通知，重写上面的 Audience 切面\n\n```kotlin\n@Aspect\n@Component\nclass Audience {\n\n    @Pointcut(\"execution(** concert.Performance.perform(..))\")\n    fun performance(){ }\n\n    @Around(\"performance()\")\n    fun watchPerformance(jointPoint: ProceedingJoinPoint) {\n        try {\n            println(\"Silencing cell phones\")\n            println(\"Taking seats\")\n            jointPoint.proceed()\n            println(\"CLAP CLAP CLAP!!\")\n        } catch (e: Exception) {\n            println(\"Demanding a refund\")\n        }\n    }\n}\n```\n\n上面的代码将实现同样的功能。环绕通知注解的方法`watchPerformance`中类型为`ProceedingJoinPoint`的参数是必须的，由此拿到切点的引用\n\n### 带参数的通知\n\n通过一个例子来展现带参数的通知如何实现，首先修改 MyPerformance 类\n\n```kotlin\n@Component\nopen class MyPerformance: Performance {\n\n    private var performList: List<String> = arrayListOf(\"Song\", \"Dance\", \"Magic\")\n\n    override fun perform() {\n        perform(Math.round(10f) % 2)\n    }\n\n    override fun perform(type: Int) {\n        println(\"Start perform: ${performList[type]}\")\n    }\n}\n```\n\n假设现在有一个计数类 PerformanceCounter，其将跟踪每一次表演节目，记录下该节目的类型以及次数并打印\n\n```kotlin\n@Aspect\n@Component\nclass PerformanceCounter {\n\n    private var playCounter: MutableMap<Int, Int> = HashMap()\n\n    @Pointcut(\"execution(** concert.Performance.perform(..)) && args(whichType)\")\n    fun performanceTypePlay(whichType: Int) { }\n\n    @After(\"performanceTypePlay(typeIntValue)\")\n    fun countPerformance(typeIntValue: Int) {\n        val currentCount = getPlayCount(typeIntValue)\n        playCounter[typeIntValue] = currentCount+1\n        println(\"=== type: ${getDesByInt(typeIntValue)}, played ${currentCount+1} times ===\")\n    }\n\n    private fun getPlayCount(type: Int): Int = playCounter[type] ?: 0\n\n    private fun getDesByInt(type: Int): String = when(type) {\n        0 -> \"Song\"\n        1 -> \"Dance\"\n        2 -> \"Magic\"\n        else -> \"null\"\n    }\n}\n```\n\n着重注意不同方法中的`type`参数，参数名称各有不同，但本质都代表“表演类型”。而相同的参数名称则表示一一对应的关系：定义切点时，AspectJ 表达式内使用的参数名称为`whichType`，与标识该切点的空函数的参数是一致的；通知方法上的参数名称`typeIntValue`则与通知时机中引用切点时 AspectJ 表达式内的参数名称一致\n\n测试类如下\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [ConcertConfig::class])\nclass PerformTest {\n\n    @Autowired\n    lateinit var performance: Performance\n\n    @Test\n    fun perform() {\n        for (i in 0..4) {\n            performance.perform(i % 3)\n        }\n    }\n}\n```\n\n控制台输出为\n\n```bash\nStart perform: Song\n=== type: Song, played 1 times ===\nStart perform: Dance\n=== type: Dance, played 1 times ===\nStart perform: Magic\n=== type: Magic, played 1 times ===\nStart perform: Song\n=== type: Song, played 2 times ===\nStart perform: Dance\n=== type: Dance, played 2 times ===\n```\n\n## 注入 AspectJ 切面\n\nAspectJ 和 Spring 实际上是独立的，只不过 Spring AOP 借助了前者的指示器。通过一个例子展示如何注入原始的 AspectJ 切面。\n\n首先准备一个评论员，在表演之后发表一段言论，其类型为`aspect`，在 IDEA 中可通过右键 New -> Aspect 新建一个该类型的文件\n\n```java\npublic aspect CriticAspect {\n\n    public CriticAspect() { }\n\n    pointcut performance(): execution(* concert.MyPerformance.perform(..));\n\n    after(): performance() {\n        System.out.println(\"something\");\n    }\n\n}\n```\n\n在 Spring 框架中，CriticAspect 将不会由容器创建，因为它属于 AspectJ 切面，由 AspectJ 在运行时创建。所以需要通过 AspectJ 切面提供的静态`aspectOf`方法给 Spring 返回切面的单例，Spring XML 配置写成以下形式\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans ...>\n\n    <context:component-scan base-package=\"concert\" />\n\n    <aop:aspectj-autoproxy />\n\n    <bean class=\"concert.CriticismEngineImpl\" id=\"criticismEngine\" />\n\n    <bean class=\"concert.MyPerformance\" id=\"performance\" />\n\n    <bean class=\"concert.CriticAspect\" factory-method=\"aspectOf\" />\n</beans>\n```\n\n如果是 JavaConfig，则需要以下形式\n\n```kotlin\n@Configuration\n@EnableAspectJAutoProxy\n@ComponentScan\nopen class ConcertConfig {\n    @Bean\n    open fun criticAspect(): concert.CriticAspect = org.aspectj.lang.Aspects.aspectOf(CriticAspect::class.java)\n}\n```\n\n但是运行时 JRE 将不会识别类 CriticAspect，无法运行。目前未找到解决办法，故使用 XML 配置的方法\n\n之后最重要的一步是使用`ajc`编译器，以编译`.aj`文件。通过一个插件[ Mojo's AspectJ Maven Plugin](https://www.mojohaus.org/aspectj-maven-plugin/usage.html) 引入`ajc`，注意此时 IDEA Compiler 的选项截图为\n\n![](Spring-学习笔记（三）：面向切面\\Compiler.png)\n\n测试类如下\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:concert.xml\"})\npublic class PerformTest {\n\n    @Autowired\n    Performance performance;\n\n    @Test\n    public void test() {\n        performance.perform();\n    }\n}\n```\n\n按理说应该运行成功，然而此时还是报错\n\n```bash\nError:ajc: can't find critical required type java.io.Serializable\nError:ajc: can't determine whether missing type java.io.Serializable is an instance of concert.CriticAspect\n......\nError:ajc: can't find critical required type java.lang.Cloneable\nError:ajc: can't determine whether missing type java.lang.Cloneable is an instance of concert.CriticAspect\n......\n\n```\n\n目前并无解决办法， V2EX 上的求助帖为 [诚心求助 Spring 注入式 AspectJ 切面时 ClassNotFoundException 的问题](\nhttps://www.v2ex.com/t/570139#reply11)\n\nSpring AOP 的内容到此为止，日后大概率会对本篇文章进行增删查改，继续进行下一步的学习吧\n\n","source":"_posts/Spring-学习笔记（三）：面向切面.md","raw":"---\ntitle: Spring 学习笔记（三）：面向切面\ndate: 2019-06-02 12:52:24\ntags:\n- Spring \n- AOP\ncategories:\n- Spring\n---\n\n[第一篇笔记](https://febers.github.io/Spring-学习笔记（一）：基本理念和-Bean-装配/) 曾简单提及了 AOP 的知识，本文将重点展开 Spring 对切面的支持，包括如何使用和 AspectJ 的具体应用<!--more-->\n\n## 面向切面编程\n\nAspect-Oriented Programming，AOP。每个应用除了其核心业务之外，还会需要一些模块化的通用功能——比如日志、安全、通知等。重用通用功能的方式一般有继承（inheritance）、 委托（delegation），缺点在于前者会导致对象体系复杂、难以维护，后者则可能需要对委托对象进行复杂的调用。切面提供了不一样的思路，并且在很多场景下更加清晰简洁。\n\n### AOP 术语\n\n![](Spring-学习笔记（三）：面向切面\\AOP_1.jpg)\n\n#### Advice\n\n通知，如果翻译为“增强”就能更直观地理解它所扮演的角色。Spring 切面可以应用 5 种类型的通知\n\n- 前置通知（ Before ）：在目标方法被调用之前调用通知功能\n- 后置通知（ After ）：在目标方法完成之后调用通知，不关心方法的返回值\n- 返回通知（ After-returning ）：在目标方法成功执行之后调用通知\n- 异常通知（ After-throwing ）：在目标方法抛出异常之后调用通知\n- 环绕通知（ Around ）：通知包裹了被通知的方法，在被通知的方法调用之前喝调用之后执行自定义的行为\n\n#### Joint point\n\n连接点，应用可能有数以千计的时机应用通知，这些时机被称为连接点。根据上面的图理解，连接点是在应用执行过程中能够插入切面的一个点，改点可以是调用方法时、抛出异常时、甚至修改一个字段时。\n\n#### Pointcut\n\n切点，通知定义了切面的“什么”和“何时”，连接点定义了“时间点”，切点则定义了“何处”。切点会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称、或者使用正则表达式定义所匹配的类和方法来指定切点，有些 AOP 框架也会允许动态创建切点。\n\n#### Aspect\n\n切面，通知+切点，这两者共同定义了切面的全部内容\n\n#### Introduction\n\n引入，允许开发者向现有的类添加方法或属性\n\n#### Weaving\n\n织入，把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入：\n\n- 编译期：切面在目标类编译时被织入。需要特殊的编译器，如 AspectJ 的织入编译器\n- 类加载期：切面在目标类加载到 JVM 时被织入。这种方式需要特殊的类加载器，从而在目标类被引用之前增强其字节码。比如 AspectJ 5 的加载时织入（load-time weaving，LTW）\n- 运行期：切面在应用运行的某个时刻被织入。一般情况下，织入时 AOP 容器会为目标对象动态地创建一个代理对象。比如 Spring AOP\n\n### Spring AOP\n\nSpring 提供了 4 中类型的 AOP 支持：\n\n- 基于代理的经典 Spring AOP\n- 纯 POJO 切面\n- `@AspectJ`注解驱动的切面\n- 注入式 AspectJ 切面\n\n相比起其他方式，第一种显得笨重而古典，不再介绍。纯 POJO 切面需要借助 Spring 的 `aop`命名空间，虽然足够简便，但也不再赘述。Spring 借鉴了 AspectJ 的切面以提供注解驱动的 AOP，其本质仍然是代理，但是编程模型几乎与成熟的 AspectJ 注解完全一致。如果开发者对 AOP 的需求超过了简单的方法调用（如构造器或属性拦截），那么可以考虑第四种方式——使用 AspectJ。\n\n通过再代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。代理类封装了目标类并拦截被通知方法的调用，再把调用转发给真正的目标 bean\n\n![](Spring-学习笔记（三）：面向切面\\AOP_2.jpg)\n\n由于 Spring  AOP 基于动态代理，所以只支持方法连接点，不支持字段连接点——无法创建细粒度的通知、不支持构造器连接点——无法在 bean 创建时应用通知。\n\n## 通过切点选择连接点\n\n使用 AspectJ 的切点表达式语言来定义切点。Spring 仅支持 AspectJ 切点指示器的一个子集，因为 Spring 基于代理，而某些切点表达式与代理无关。下表是 Spring AOP 所支持的指示器\n\n| AspectJ 指示器 | 描述                                                     |\n| -------------- | -------------------------------------------------------- |\n| arg()          | 限制连接点匹配参数为指定类型的执行方法                   |\n| @args()        | 限制连接点匹配参数由指定注解标注的执行方法               |\n| execution()    | 用于匹配是连接点的执行方法                               |\n| this()         | 限制连接点匹配 AOP 代理的 bean 引用为指定类型的类        |\n| target()       | 限制连接点匹配目标对象为指定类型的类                     |\n| @target()      | 限制连接点匹配特定的具有指定类型注解的执行对象           |\n| within()       | 限制连接点匹配指定的类型                                 |\n| @within()      | 限制连接点匹配指定注解所标注的类型（方法定义在该类型中） |\n| @annotation    | 限定匹配带有指定注解的连接点                             |\n\n尝试使用其他指示器时，将抛出`IllegalArgumentException`异常\n\n以上的指示器只有`execution()`指示器是实际执行匹配的，其他指示器都是用来限制匹配的。\n\n### 编写切点\n\n准备一个主题 Performance，可代表任何类型的现场表演，假设要编写其中`perform`方法触发的通知\n\n```kotlin\npackage concert\n\ninterface Performance {\n    fun perform()\n}\n```\n\n使用 AspectJ 表达式编写切点\n\n```java\nexecution(* concert.Performance.perform(..)) && within(concert.*)\n```\n\n使用`execution()`指示器选择`perform`方法，方法表达式以`*`开始表示不关心返回值类型，然后使用全限定类名和方法名；使用两个点号`..`表示不关心方法参数列表，切点会选择为所有的`perform`方法。`&&`操作符把`execution()`和`within`指示器连接在一起形成`与（and）`关系，限制需要配置的切点仅匹配`concert`包，类似也可以使用`||`和`!`来标识`或（or）`和`非（not）`操作\n\n当然也可以通过 Spring 引入的指示器`bean()`指示特定的 bean，参数为 bean 的 id\n\n```java\nexecution(* concert.Performance.perform(..)) && bean('woodstock')\nexecution(* concert.Performance.perform(..)) && !bean('woodstock')  \n```\n\n## 使用注解创建切面\n\n### 简单通知\n\n对于一场演出，我们将“观众”定义为切面\n\n```kotlin\n@Aspect\nclass Audience {\n\n    @Before(\"execution(** concert.Performance.perform(..)\")\n    fun silenceCellPhones() {\n        println(\"Silencing cell phones\")\n    }\n\n    @Before(\"execution(** concert.Performance.perform(..)\")\n    fun takeSeats() {\n        println(\"Taking seats\")\n    }\n\n    @AfterReturning(\"execution(** concert.Performance.perform(..)\")\n    fun applause() {\n        println(\"CLAP CLAP CLAP!!\")\n    }\n\n    @AfterThrowing(\"execution(** concert.Performance.perform(..)\")\n    fun demandRefund() {\n        println(\"Demanding a refund\")\n    }\n}\n```\n\n> AspectJ 库需要通过依赖引入\n\nAudience 定义了四个方法，通过 AOP 注解，形成以下期望的行为——演出之前观众就坐、将手机静音，演出很精彩则鼓掌欢呼，演出没有达到预期则要求退款。以上的方式有一点不足，每个方法的切点表达式都是一样的，重复了四次。为此可以使用`@Pointcut`注解定义可重用的切点\n\n```kotlin\n@Aspect\nclass Audience {\n\n    @Pointcut(\"execution(** concert.Performance.perform(..))\")\n    fun performance(){ }\n    \n    @Before(\"performance()\")\n    fun silenceCellPhones() {\n        println(\"Silencing cell phones\")\n    }\n\n    @Before(\"performance()\")\n    fun takeSeats() {\n        println(\"Taking seats\")\n    }\n\n    @AfterReturning(\"performance()\")\n    fun applause() {\n        println(\"CLAP CLAP CLAP!!\")\n    }\n\n    @AfterThrowing(\"performance()\")\n    fun demandRefund() {\n        println(\"Demanding a refund\")\n    }\n}\n```\n\n除了注解和作为标识的空`performance`方法，Audience 仍然是一个 POJO，可以添加`@Component`注解将其注入容器中。但此时 Audience 不会视为切面，需要在配置类的的类级别通过使用`@EnableAspectJAutoProxy`注解启动自动代理功能\n\n```kotlin\n@Configuration\n@EnableAspectJAutoProxy\n@ComponentScan\nopen class ConcertConfig\n```\n\n同时为 Performance 提供一个实现类\n\n```kotlin\n@Component\nopen class MyPerformance: Performance {\n    \n    override fun perform() {\n        println(\"Start perform\")\n    }\n\n}\n```\n\n测试类如下\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [ConcertConfig::class])\nclass PerformTest {\n    \n    @Autowired\n    lateinit var performance: Performance\n\n    @Test\n    fun perform() {\n        performance.perform()\n    }\n}\n```\n\n输出结果为\n\n```bash\nSilencing cell phones\nTaking seats\nStart perform\nCLAP CLAP CLAP!!\n```\n\n### 环绕通知\n\n环绕通知时最强大的通知类型，能够使编写的逻辑将被通知的目标方法完全包装，就像 在一个通知方法中同时编写前置通知和后置通知，重写上面的 Audience 切面\n\n```kotlin\n@Aspect\n@Component\nclass Audience {\n\n    @Pointcut(\"execution(** concert.Performance.perform(..))\")\n    fun performance(){ }\n\n    @Around(\"performance()\")\n    fun watchPerformance(jointPoint: ProceedingJoinPoint) {\n        try {\n            println(\"Silencing cell phones\")\n            println(\"Taking seats\")\n            jointPoint.proceed()\n            println(\"CLAP CLAP CLAP!!\")\n        } catch (e: Exception) {\n            println(\"Demanding a refund\")\n        }\n    }\n}\n```\n\n上面的代码将实现同样的功能。环绕通知注解的方法`watchPerformance`中类型为`ProceedingJoinPoint`的参数是必须的，由此拿到切点的引用\n\n### 带参数的通知\n\n通过一个例子来展现带参数的通知如何实现，首先修改 MyPerformance 类\n\n```kotlin\n@Component\nopen class MyPerformance: Performance {\n\n    private var performList: List<String> = arrayListOf(\"Song\", \"Dance\", \"Magic\")\n\n    override fun perform() {\n        perform(Math.round(10f) % 2)\n    }\n\n    override fun perform(type: Int) {\n        println(\"Start perform: ${performList[type]}\")\n    }\n}\n```\n\n假设现在有一个计数类 PerformanceCounter，其将跟踪每一次表演节目，记录下该节目的类型以及次数并打印\n\n```kotlin\n@Aspect\n@Component\nclass PerformanceCounter {\n\n    private var playCounter: MutableMap<Int, Int> = HashMap()\n\n    @Pointcut(\"execution(** concert.Performance.perform(..)) && args(whichType)\")\n    fun performanceTypePlay(whichType: Int) { }\n\n    @After(\"performanceTypePlay(typeIntValue)\")\n    fun countPerformance(typeIntValue: Int) {\n        val currentCount = getPlayCount(typeIntValue)\n        playCounter[typeIntValue] = currentCount+1\n        println(\"=== type: ${getDesByInt(typeIntValue)}, played ${currentCount+1} times ===\")\n    }\n\n    private fun getPlayCount(type: Int): Int = playCounter[type] ?: 0\n\n    private fun getDesByInt(type: Int): String = when(type) {\n        0 -> \"Song\"\n        1 -> \"Dance\"\n        2 -> \"Magic\"\n        else -> \"null\"\n    }\n}\n```\n\n着重注意不同方法中的`type`参数，参数名称各有不同，但本质都代表“表演类型”。而相同的参数名称则表示一一对应的关系：定义切点时，AspectJ 表达式内使用的参数名称为`whichType`，与标识该切点的空函数的参数是一致的；通知方法上的参数名称`typeIntValue`则与通知时机中引用切点时 AspectJ 表达式内的参数名称一致\n\n测试类如下\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [ConcertConfig::class])\nclass PerformTest {\n\n    @Autowired\n    lateinit var performance: Performance\n\n    @Test\n    fun perform() {\n        for (i in 0..4) {\n            performance.perform(i % 3)\n        }\n    }\n}\n```\n\n控制台输出为\n\n```bash\nStart perform: Song\n=== type: Song, played 1 times ===\nStart perform: Dance\n=== type: Dance, played 1 times ===\nStart perform: Magic\n=== type: Magic, played 1 times ===\nStart perform: Song\n=== type: Song, played 2 times ===\nStart perform: Dance\n=== type: Dance, played 2 times ===\n```\n\n## 注入 AspectJ 切面\n\nAspectJ 和 Spring 实际上是独立的，只不过 Spring AOP 借助了前者的指示器。通过一个例子展示如何注入原始的 AspectJ 切面。\n\n首先准备一个评论员，在表演之后发表一段言论，其类型为`aspect`，在 IDEA 中可通过右键 New -> Aspect 新建一个该类型的文件\n\n```java\npublic aspect CriticAspect {\n\n    public CriticAspect() { }\n\n    pointcut performance(): execution(* concert.MyPerformance.perform(..));\n\n    after(): performance() {\n        System.out.println(\"something\");\n    }\n\n}\n```\n\n在 Spring 框架中，CriticAspect 将不会由容器创建，因为它属于 AspectJ 切面，由 AspectJ 在运行时创建。所以需要通过 AspectJ 切面提供的静态`aspectOf`方法给 Spring 返回切面的单例，Spring XML 配置写成以下形式\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans ...>\n\n    <context:component-scan base-package=\"concert\" />\n\n    <aop:aspectj-autoproxy />\n\n    <bean class=\"concert.CriticismEngineImpl\" id=\"criticismEngine\" />\n\n    <bean class=\"concert.MyPerformance\" id=\"performance\" />\n\n    <bean class=\"concert.CriticAspect\" factory-method=\"aspectOf\" />\n</beans>\n```\n\n如果是 JavaConfig，则需要以下形式\n\n```kotlin\n@Configuration\n@EnableAspectJAutoProxy\n@ComponentScan\nopen class ConcertConfig {\n    @Bean\n    open fun criticAspect(): concert.CriticAspect = org.aspectj.lang.Aspects.aspectOf(CriticAspect::class.java)\n}\n```\n\n但是运行时 JRE 将不会识别类 CriticAspect，无法运行。目前未找到解决办法，故使用 XML 配置的方法\n\n之后最重要的一步是使用`ajc`编译器，以编译`.aj`文件。通过一个插件[ Mojo's AspectJ Maven Plugin](https://www.mojohaus.org/aspectj-maven-plugin/usage.html) 引入`ajc`，注意此时 IDEA Compiler 的选项截图为\n\n![](Spring-学习笔记（三）：面向切面\\Compiler.png)\n\n测试类如下\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:concert.xml\"})\npublic class PerformTest {\n\n    @Autowired\n    Performance performance;\n\n    @Test\n    public void test() {\n        performance.perform();\n    }\n}\n```\n\n按理说应该运行成功，然而此时还是报错\n\n```bash\nError:ajc: can't find critical required type java.io.Serializable\nError:ajc: can't determine whether missing type java.io.Serializable is an instance of concert.CriticAspect\n......\nError:ajc: can't find critical required type java.lang.Cloneable\nError:ajc: can't determine whether missing type java.lang.Cloneable is an instance of concert.CriticAspect\n......\n\n```\n\n目前并无解决办法， V2EX 上的求助帖为 [诚心求助 Spring 注入式 AspectJ 切面时 ClassNotFoundException 的问题](\nhttps://www.v2ex.com/t/570139#reply11)\n\nSpring AOP 的内容到此为止，日后大概率会对本篇文章进行增删查改，继续进行下一步的学习吧\n\n","slug":"Spring-学习笔记（三）：面向切面","published":1,"updated":"2019-06-03T04:18:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxw003uy4upi7qyv0pc","content":"<p><a href=\"https://febers.github.io/Spring-学习笔记（一）：基本理念和-Bean-装配/\" target=\"_blank\" rel=\"noopener\">第一篇笔记</a> 曾简单提及了 AOP 的知识，本文将重点展开 Spring 对切面的支持，包括如何使用和 AspectJ 的具体应用<a id=\"more\"></a></p>\n<h2 id=\"面向切面编程\"><a href=\"#面向切面编程\" class=\"headerlink\" title=\"面向切面编程\"></a>面向切面编程</h2><p>Aspect-Oriented Programming，AOP。每个应用除了其核心业务之外，还会需要一些模块化的通用功能——比如日志、安全、通知等。重用通用功能的方式一般有继承（inheritance）、 委托（delegation），缺点在于前者会导致对象体系复杂、难以维护，后者则可能需要对委托对象进行复杂的调用。切面提供了不一样的思路，并且在很多场景下更加清晰简洁。</p>\n<h3 id=\"AOP-术语\"><a href=\"#AOP-术语\" class=\"headerlink\" title=\"AOP 术语\"></a>AOP 术语</h3><p><img src=\"/Spring-学习笔记（三）：面向切面/AOP_1.jpg\" alt></p>\n<h4 id=\"Advice\"><a href=\"#Advice\" class=\"headerlink\" title=\"Advice\"></a>Advice</h4><p>通知，如果翻译为“增强”就能更直观地理解它所扮演的角色。Spring 切面可以应用 5 种类型的通知</p>\n<ul>\n<li>前置通知（ Before ）：在目标方法被调用之前调用通知功能</li>\n<li>后置通知（ After ）：在目标方法完成之后调用通知，不关心方法的返回值</li>\n<li>返回通知（ After-returning ）：在目标方法成功执行之后调用通知</li>\n<li>异常通知（ After-throwing ）：在目标方法抛出异常之后调用通知</li>\n<li>环绕通知（ Around ）：通知包裹了被通知的方法，在被通知的方法调用之前喝调用之后执行自定义的行为</li>\n</ul>\n<h4 id=\"Joint-point\"><a href=\"#Joint-point\" class=\"headerlink\" title=\"Joint point\"></a>Joint point</h4><p>连接点，应用可能有数以千计的时机应用通知，这些时机被称为连接点。根据上面的图理解，连接点是在应用执行过程中能够插入切面的一个点，改点可以是调用方法时、抛出异常时、甚至修改一个字段时。</p>\n<h4 id=\"Pointcut\"><a href=\"#Pointcut\" class=\"headerlink\" title=\"Pointcut\"></a>Pointcut</h4><p>切点，通知定义了切面的“什么”和“何时”，连接点定义了“时间点”，切点则定义了“何处”。切点会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称、或者使用正则表达式定义所匹配的类和方法来指定切点，有些 AOP 框架也会允许动态创建切点。</p>\n<h4 id=\"Aspect\"><a href=\"#Aspect\" class=\"headerlink\" title=\"Aspect\"></a>Aspect</h4><p>切面，通知+切点，这两者共同定义了切面的全部内容</p>\n<h4 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h4><p>引入，允许开发者向现有的类添加方法或属性</p>\n<h4 id=\"Weaving\"><a href=\"#Weaving\" class=\"headerlink\" title=\"Weaving\"></a>Weaving</h4><p>织入，把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入：</p>\n<ul>\n<li>编译期：切面在目标类编译时被织入。需要特殊的编译器，如 AspectJ 的织入编译器</li>\n<li>类加载期：切面在目标类加载到 JVM 时被织入。这种方式需要特殊的类加载器，从而在目标类被引用之前增强其字节码。比如 AspectJ 5 的加载时织入（load-time weaving，LTW）</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，织入时 AOP 容器会为目标对象动态地创建一个代理对象。比如 Spring AOP</li>\n</ul>\n<h3 id=\"Spring-AOP\"><a href=\"#Spring-AOP\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h3><p>Spring 提供了 4 中类型的 AOP 支持：</p>\n<ul>\n<li>基于代理的经典 Spring AOP</li>\n<li>纯 POJO 切面</li>\n<li><code>@AspectJ</code>注解驱动的切面</li>\n<li>注入式 AspectJ 切面</li>\n</ul>\n<p>相比起其他方式，第一种显得笨重而古典，不再介绍。纯 POJO 切面需要借助 Spring 的 <code>aop</code>命名空间，虽然足够简便，但也不再赘述。Spring 借鉴了 AspectJ 的切面以提供注解驱动的 AOP，其本质仍然是代理，但是编程模型几乎与成熟的 AspectJ 注解完全一致。如果开发者对 AOP 的需求超过了简单的方法调用（如构造器或属性拦截），那么可以考虑第四种方式——使用 AspectJ。</p>\n<p>通过再代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。代理类封装了目标类并拦截被通知方法的调用，再把调用转发给真正的目标 bean</p>\n<p><img src=\"/Spring-学习笔记（三）：面向切面/AOP_2.jpg\" alt></p>\n<p>由于 Spring  AOP 基于动态代理，所以只支持方法连接点，不支持字段连接点——无法创建细粒度的通知、不支持构造器连接点——无法在 bean 创建时应用通知。</p>\n<h2 id=\"通过切点选择连接点\"><a href=\"#通过切点选择连接点\" class=\"headerlink\" title=\"通过切点选择连接点\"></a>通过切点选择连接点</h2><p>使用 AspectJ 的切点表达式语言来定义切点。Spring 仅支持 AspectJ 切点指示器的一个子集，因为 Spring 基于代理，而某些切点表达式与代理无关。下表是 Spring AOP 所支持的指示器</p>\n<table>\n<thead>\n<tr>\n<th>AspectJ 指示器</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arg()</td>\n<td>限制连接点匹配参数为指定类型的执行方法</td>\n</tr>\n<tr>\n<td>@args()</td>\n<td>限制连接点匹配参数由指定注解标注的执行方法</td>\n</tr>\n<tr>\n<td>execution()</td>\n<td>用于匹配是连接点的执行方法</td>\n</tr>\n<tr>\n<td>this()</td>\n<td>限制连接点匹配 AOP 代理的 bean 引用为指定类型的类</td>\n</tr>\n<tr>\n<td>target()</td>\n<td>限制连接点匹配目标对象为指定类型的类</td>\n</tr>\n<tr>\n<td>@target()</td>\n<td>限制连接点匹配特定的具有指定类型注解的执行对象</td>\n</tr>\n<tr>\n<td>within()</td>\n<td>限制连接点匹配指定的类型</td>\n</tr>\n<tr>\n<td>@within()</td>\n<td>限制连接点匹配指定注解所标注的类型（方法定义在该类型中）</td>\n</tr>\n<tr>\n<td>@annotation</td>\n<td>限定匹配带有指定注解的连接点</td>\n</tr>\n</tbody>\n</table>\n<p>尝试使用其他指示器时，将抛出<code>IllegalArgumentException</code>异常</p>\n<p>以上的指示器只有<code>execution()</code>指示器是实际执行匹配的，其他指示器都是用来限制匹配的。</p>\n<h3 id=\"编写切点\"><a href=\"#编写切点\" class=\"headerlink\" title=\"编写切点\"></a>编写切点</h3><p>准备一个主题 Performance，可代表任何类型的现场表演，假设要编写其中<code>perform</code>方法触发的通知</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> concert</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Performance</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>使用 AspectJ 表达式编写切点</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">execution(* concert.Performance.perform(..)) && within(concert.*)</span><br></pre></td></tr></tbody></table></figure>\n<p>使用<code>execution()</code>指示器选择<code>perform</code>方法，方法表达式以<code>*</code>开始表示不关心返回值类型，然后使用全限定类名和方法名；使用两个点号<code>..</code>表示不关心方法参数列表，切点会选择为所有的<code>perform</code>方法。<code>&&</code>操作符把<code>execution()</code>和<code>within</code>指示器连接在一起形成<code>与（and）</code>关系，限制需要配置的切点仅匹配<code>concert</code>包，类似也可以使用<code>||</code>和<code>!</code>来标识<code>或（or）</code>和<code>非（not）</code>操作</p>\n<p>当然也可以通过 Spring 引入的指示器<code>bean()</code>指示特定的 bean，参数为 bean 的 id</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">execution(* concert.Performance.perform(..)) && bean(<span class=\"string\">'woodstock'</span>)</span><br><span class=\"line\">execution(* concert.Performance.perform(..)) && !bean(<span class=\"string\">'woodstock'</span>)</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"使用注解创建切面\"><a href=\"#使用注解创建切面\" class=\"headerlink\" title=\"使用注解创建切面\"></a>使用注解创建切面</h2><h3 id=\"简单通知\"><a href=\"#简单通知\" class=\"headerlink\" title=\"简单通知\"></a>简单通知</h3><p>对于一场演出，我们将“观众”定义为切面</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">silenceCellPhones</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Silencing cell phones\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">takeSeats</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Taking seats\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">applause</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">demandRefund</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Demanding a refund\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>AspectJ 库需要通过依赖引入</p>\n</blockquote>\n<p>Audience 定义了四个方法，通过 AOP 注解，形成以下期望的行为——演出之前观众就坐、将手机静音，演出很精彩则鼓掌欢呼，演出没有达到预期则要求退款。以上的方式有一点不足，每个方法的切点表达式都是一样的，重复了四次。为此可以使用<code>@Pointcut</code>注解定义可重用的切点</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..))\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">performance</span><span class=\"params\">()</span></span>{ }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">silenceCellPhones</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Silencing cell phones\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">takeSeats</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Taking seats\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">applause</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">demandRefund</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Demanding a refund\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>除了注解和作为标识的空<code>performance</code>方法，Audience 仍然是一个 POJO，可以添加<code>@Component</code>注解将其注入容器中。但此时 Audience 不会视为切面，需要在配置类的的类级别通过使用<code>@EnableAspectJAutoProxy</code>注解启动自动代理功能</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcertConfig</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>同时为 Performance 提供一个实现类</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPerformance</span>: <span class=\"type\">Performance {</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Start perform\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>测试类如下</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [ConcertConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformTest</span> </span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> performance: Performance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        performance.perform()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Silencing cell phones</span><br><span class=\"line\">Taking seats</span><br><span class=\"line\">Start perform</span><br><span class=\"line\">CLAP CLAP CLAP!!</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"环绕通知\"><a href=\"#环绕通知\" class=\"headerlink\" title=\"环绕通知\"></a>环绕通知</h3><p>环绕通知时最强大的通知类型，能够使编写的逻辑将被通知的目标方法完全包装，就像 在一个通知方法中同时编写前置通知和后置通知，重写上面的 Audience 切面</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..))\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">performance</span><span class=\"params\">()</span></span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">watchPerformance</span><span class=\"params\">(jointPoint: <span class=\"type\">ProceedingJoinPoint</span>)</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            println(<span class=\"string\">\"Silencing cell phones\"</span>)</span><br><span class=\"line\">            println(<span class=\"string\">\"Taking seats\"</span>)</span><br><span class=\"line\">            jointPoint.proceed()</span><br><span class=\"line\">            println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>)</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (e: Exception) {</span><br><span class=\"line\">            println(<span class=\"string\">\"Demanding a refund\"</span>)</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>上面的代码将实现同样的功能。环绕通知注解的方法<code>watchPerformance</code>中类型为<code>ProceedingJoinPoint</code>的参数是必须的，由此拿到切点的引用</p>\n<h3 id=\"带参数的通知\"><a href=\"#带参数的通知\" class=\"headerlink\" title=\"带参数的通知\"></a>带参数的通知</h3><p>通过一个例子来展现带参数的通知如何实现，首先修改 MyPerformance 类</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPerformance</span>: <span class=\"type\">Performance {</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> performList: List<String> = arrayListOf(<span class=\"string\">\"Song\"</span>, <span class=\"string\">\"Dance\"</span>, <span class=\"string\">\"Magic\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        perform(Math.round(<span class=\"number\">10f</span>) % <span class=\"number\">2</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Start perform: <span class=\"subst\">${performList[type]}</span>\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>假设现在有一个计数类 PerformanceCounter，其将跟踪每一次表演节目，记录下该节目的类型以及次数并打印</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformanceCounter</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> playCounter: MutableMap<<span class=\"built_in\">Int</span>, <span class=\"built_in\">Int</span>> = HashMap()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)) && args(whichType)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">performanceTypePlay</span><span class=\"params\">(whichType: <span class=\"type\">Int</span>)</span></span> { }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After(<span class=\"meta-string\">\"performanceTypePlay(typeIntValue)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">countPerformance</span><span class=\"params\">(typeIntValue: <span class=\"type\">Int</span>)</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">val</span> currentCount = getPlayCount(typeIntValue)</span><br><span class=\"line\">        playCounter[typeIntValue] = currentCount+<span class=\"number\">1</span></span><br><span class=\"line\">        println(<span class=\"string\">\"=== type: <span class=\"subst\">${getDesByInt(typeIntValue)}</span>, played <span class=\"subst\">${currentCount+<span class=\"number\">1</span>}</span> times ===\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getPlayCount</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> = playCounter[type] ?: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getDesByInt</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span>: String = <span class=\"keyword\">when</span>(type) {</span><br><span class=\"line\">        <span class=\"number\">0</span> -> <span class=\"string\">\"Song\"</span></span><br><span class=\"line\">        <span class=\"number\">1</span> -> <span class=\"string\">\"Dance\"</span></span><br><span class=\"line\">        <span class=\"number\">2</span> -> <span class=\"string\">\"Magic\"</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> -> <span class=\"string\">\"null\"</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>着重注意不同方法中的<code>type</code>参数，参数名称各有不同，但本质都代表“表演类型”。而相同的参数名称则表示一一对应的关系：定义切点时，AspectJ 表达式内使用的参数名称为<code>whichType</code>，与标识该切点的空函数的参数是一致的；通知方法上的参数名称<code>typeIntValue</code>则与通知时机中引用切点时 AspectJ 表达式内的参数名称一致</p>\n<p>测试类如下</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [ConcertConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformTest</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> performance: Performance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">4</span>) {</span><br><span class=\"line\">            performance.perform(i % <span class=\"number\">3</span>)</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Start perform: Song</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Song, played 1 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Dance</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Dance, played 1 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Magic</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Magic, played 1 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Song</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Song, played 2 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Dance</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Dance, played 2 <span class=\"built_in\">times</span> ===</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"注入-AspectJ-切面\"><a href=\"#注入-AspectJ-切面\" class=\"headerlink\" title=\"注入 AspectJ 切面\"></a>注入 AspectJ 切面</h2><p>AspectJ 和 Spring 实际上是独立的，只不过 Spring AOP 借助了前者的指示器。通过一个例子展示如何注入原始的 AspectJ 切面。</p>\n<p>首先准备一个评论员，在表演之后发表一段言论，其类型为<code>aspect</code>，在 IDEA 中可通过右键 New -> Aspect 新建一个该类型的文件</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect CriticAspect {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CriticAspect</span><span class=\"params\">()</span> </span>{ }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">performance</span><span class=\"params\">()</span>: <span class=\"title\">execution</span><span class=\"params\">(* concert.MyPerformance.perform(..)</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    after(): performance() {</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"something\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>在 Spring 框架中，CriticAspect 将不会由容器创建，因为它属于 AspectJ 切面，由 AspectJ 在运行时创建。所以需要通过 AspectJ 切面提供的静态<code>aspectOf</code>方法给 Spring 返回切面的单例，Spring XML 配置写成以下形式</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">...</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"concert\"</span> /></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">aop:aspectj-autoproxy</span> /></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"concert.CriticismEngineImpl\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"criticismEngine\"</span> /></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"concert.MyPerformance\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"performance\"</span> /></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"concert.CriticAspect\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"aspectOf\"</span> /></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<p>如果是 JavaConfig，则需要以下形式</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcertConfig</span> </span>{</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">criticAspect</span><span class=\"params\">()</span></span>: concert.CriticAspect = org.aspectj.lang.Aspects.aspectOf(CriticAspect::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>但是运行时 JRE 将不会识别类 CriticAspect，无法运行。目前未找到解决办法，故使用 XML 配置的方法</p>\n<p>之后最重要的一步是使用<code>ajc</code>编译器，以编译<code>.aj</code>文件。通过一个插件<a href=\"https://www.mojohaus.org/aspectj-maven-plugin/usage.html\" target=\"_blank\" rel=\"noopener\"> Mojo’s AspectJ Maven Plugin</a> 引入<code>ajc</code>，注意此时 IDEA Compiler 的选项截图为</p>\n<p><img src=\"/Spring-学习笔记（三）：面向切面/Compiler.png\" alt></p>\n<p>测试类如下</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = {<span class=\"meta-string\">\"classpath:concert.xml\"</span>})</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformTest</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    Performance performance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> void test() {</span><br><span class=\"line\">        performance.perform();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>按理说应该运行成功，然而此时还是报错</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Error:ajc: can<span class=\"string\">'t find critical required type java.io.Serializable</span></span><br><span class=\"line\"><span class=\"string\">Error:ajc: can'</span>t determine whether missing <span class=\"built_in\">type</span> java.io.Serializable is an instance of concert.CriticAspect</span><br><span class=\"line\">......</span><br><span class=\"line\">Error:ajc: can<span class=\"string\">'t find critical required type java.lang.Cloneable</span></span><br><span class=\"line\"><span class=\"string\">Error:ajc: can'</span>t determine whether missing <span class=\"built_in\">type</span> java.lang.Cloneable is an instance of concert.CriticAspect</span><br><span class=\"line\">......</span><br></pre></td></tr></tbody></table></figure>\n<p>目前并无解决办法， V2EX 上的求助帖为 <a href=\"https://www.v2ex.com/t/570139#reply11\" target=\"_blank\" rel=\"noopener\">诚心求助 Spring 注入式 AspectJ 切面时 ClassNotFoundException 的问题</a></p>\n<p>Spring AOP 的内容到此为止，日后大概率会对本篇文章进行增删查改，继续进行下一步的学习吧</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":9549,"excerpt":"<p><a href=\"https://febers.github.io/Spring-学习笔记（一）：基本理念和-Bean-装配/\" target=\"_blank\" rel=\"noopener\">第一篇笔记</a> 曾简单提及了 AOP 的知识，本文将重点展开 Spring 对切面的支持，包括如何使用和 AspectJ 的具体应用</p>","more":"<p></p>\n<h2 id=\"面向切面编程\"><a href=\"#面向切面编程\" class=\"headerlink\" title=\"面向切面编程\"></a>面向切面编程</h2><p>Aspect-Oriented Programming，AOP。每个应用除了其核心业务之外，还会需要一些模块化的通用功能——比如日志、安全、通知等。重用通用功能的方式一般有继承（inheritance）、 委托（delegation），缺点在于前者会导致对象体系复杂、难以维护，后者则可能需要对委托对象进行复杂的调用。切面提供了不一样的思路，并且在很多场景下更加清晰简洁。</p>\n<h3 id=\"AOP-术语\"><a href=\"#AOP-术语\" class=\"headerlink\" title=\"AOP 术语\"></a>AOP 术语</h3><p><img src=\"/Spring-学习笔记（三）：面向切面/AOP_1.jpg\" alt=\"\"></p>\n<h4 id=\"Advice\"><a href=\"#Advice\" class=\"headerlink\" title=\"Advice\"></a>Advice</h4><p>通知，如果翻译为“增强”就能更直观地理解它所扮演的角色。Spring 切面可以应用 5 种类型的通知</p>\n<ul>\n<li>前置通知（ Before ）：在目标方法被调用之前调用通知功能</li>\n<li>后置通知（ After ）：在目标方法完成之后调用通知，不关心方法的返回值</li>\n<li>返回通知（ After-returning ）：在目标方法成功执行之后调用通知</li>\n<li>异常通知（ After-throwing ）：在目标方法抛出异常之后调用通知</li>\n<li>环绕通知（ Around ）：通知包裹了被通知的方法，在被通知的方法调用之前喝调用之后执行自定义的行为</li>\n</ul>\n<h4 id=\"Joint-point\"><a href=\"#Joint-point\" class=\"headerlink\" title=\"Joint point\"></a>Joint point</h4><p>连接点，应用可能有数以千计的时机应用通知，这些时机被称为连接点。根据上面的图理解，连接点是在应用执行过程中能够插入切面的一个点，改点可以是调用方法时、抛出异常时、甚至修改一个字段时。</p>\n<h4 id=\"Pointcut\"><a href=\"#Pointcut\" class=\"headerlink\" title=\"Pointcut\"></a>Pointcut</h4><p>切点，通知定义了切面的“什么”和“何时”，连接点定义了“时间点”，切点则定义了“何处”。切点会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称、或者使用正则表达式定义所匹配的类和方法来指定切点，有些 AOP 框架也会允许动态创建切点。</p>\n<h4 id=\"Aspect\"><a href=\"#Aspect\" class=\"headerlink\" title=\"Aspect\"></a>Aspect</h4><p>切面，通知+切点，这两者共同定义了切面的全部内容</p>\n<h4 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h4><p>引入，允许开发者向现有的类添加方法或属性</p>\n<h4 id=\"Weaving\"><a href=\"#Weaving\" class=\"headerlink\" title=\"Weaving\"></a>Weaving</h4><p>织入，把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入：</p>\n<ul>\n<li>编译期：切面在目标类编译时被织入。需要特殊的编译器，如 AspectJ 的织入编译器</li>\n<li>类加载期：切面在目标类加载到 JVM 时被织入。这种方式需要特殊的类加载器，从而在目标类被引用之前增强其字节码。比如 AspectJ 5 的加载时织入（load-time weaving，LTW）</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，织入时 AOP 容器会为目标对象动态地创建一个代理对象。比如 Spring AOP</li>\n</ul>\n<h3 id=\"Spring-AOP\"><a href=\"#Spring-AOP\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h3><p>Spring 提供了 4 中类型的 AOP 支持：</p>\n<ul>\n<li>基于代理的经典 Spring AOP</li>\n<li>纯 POJO 切面</li>\n<li><code>@AspectJ</code>注解驱动的切面</li>\n<li>注入式 AspectJ 切面</li>\n</ul>\n<p>相比起其他方式，第一种显得笨重而古典，不再介绍。纯 POJO 切面需要借助 Spring 的 <code>aop</code>命名空间，虽然足够简便，但也不再赘述。Spring 借鉴了 AspectJ 的切面以提供注解驱动的 AOP，其本质仍然是代理，但是编程模型几乎与成熟的 AspectJ 注解完全一致。如果开发者对 AOP 的需求超过了简单的方法调用（如构造器或属性拦截），那么可以考虑第四种方式——使用 AspectJ。</p>\n<p>通过再代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。代理类封装了目标类并拦截被通知方法的调用，再把调用转发给真正的目标 bean</p>\n<p><img src=\"/Spring-学习笔记（三）：面向切面/AOP_2.jpg\" alt=\"\"></p>\n<p>由于 Spring  AOP 基于动态代理，所以只支持方法连接点，不支持字段连接点——无法创建细粒度的通知、不支持构造器连接点——无法在 bean 创建时应用通知。</p>\n<h2 id=\"通过切点选择连接点\"><a href=\"#通过切点选择连接点\" class=\"headerlink\" title=\"通过切点选择连接点\"></a>通过切点选择连接点</h2><p>使用 AspectJ 的切点表达式语言来定义切点。Spring 仅支持 AspectJ 切点指示器的一个子集，因为 Spring 基于代理，而某些切点表达式与代理无关。下表是 Spring AOP 所支持的指示器</p>\n<table>\n<thead>\n<tr>\n<th>AspectJ 指示器</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arg()</td>\n<td>限制连接点匹配参数为指定类型的执行方法</td>\n</tr>\n<tr>\n<td>@args()</td>\n<td>限制连接点匹配参数由指定注解标注的执行方法</td>\n</tr>\n<tr>\n<td>execution()</td>\n<td>用于匹配是连接点的执行方法</td>\n</tr>\n<tr>\n<td>this()</td>\n<td>限制连接点匹配 AOP 代理的 bean 引用为指定类型的类</td>\n</tr>\n<tr>\n<td>target()</td>\n<td>限制连接点匹配目标对象为指定类型的类</td>\n</tr>\n<tr>\n<td>@target()</td>\n<td>限制连接点匹配特定的具有指定类型注解的执行对象</td>\n</tr>\n<tr>\n<td>within()</td>\n<td>限制连接点匹配指定的类型</td>\n</tr>\n<tr>\n<td>@within()</td>\n<td>限制连接点匹配指定注解所标注的类型（方法定义在该类型中）</td>\n</tr>\n<tr>\n<td>@annotation</td>\n<td>限定匹配带有指定注解的连接点</td>\n</tr>\n</tbody>\n</table>\n<p>尝试使用其他指示器时，将抛出<code>IllegalArgumentException</code>异常</p>\n<p>以上的指示器只有<code>execution()</code>指示器是实际执行匹配的，其他指示器都是用来限制匹配的。</p>\n<h3 id=\"编写切点\"><a href=\"#编写切点\" class=\"headerlink\" title=\"编写切点\"></a>编写切点</h3><p>准备一个主题 Performance，可代表任何类型的现场表演，假设要编写其中<code>perform</code>方法触发的通知</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> concert</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Performance</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 AspectJ 表达式编写切点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*)</span><br></pre></td></tr></table></figure>\n<p>使用<code>execution()</code>指示器选择<code>perform</code>方法，方法表达式以<code>*</code>开始表示不关心返回值类型，然后使用全限定类名和方法名；使用两个点号<code>..</code>表示不关心方法参数列表，切点会选择为所有的<code>perform</code>方法。<code>&amp;&amp;</code>操作符把<code>execution()</code>和<code>within</code>指示器连接在一起形成<code>与（and）</code>关系，限制需要配置的切点仅匹配<code>concert</code>包，类似也可以使用<code>||</code>和<code>!</code>来标识<code>或（or）</code>和<code>非（not）</code>操作</p>\n<p>当然也可以通过 Spring 引入的指示器<code>bean()</code>指示特定的 bean，参数为 bean 的 id</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">execution(* concert.Performance.perform(..)) &amp;&amp; bean(<span class=\"string\">'woodstock'</span>)</span><br><span class=\"line\">execution(* concert.Performance.perform(..)) &amp;&amp; !bean(<span class=\"string\">'woodstock'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用注解创建切面\"><a href=\"#使用注解创建切面\" class=\"headerlink\" title=\"使用注解创建切面\"></a>使用注解创建切面</h2><h3 id=\"简单通知\"><a href=\"#简单通知\" class=\"headerlink\" title=\"简单通知\"></a>简单通知</h3><p>对于一场演出，我们将“观众”定义为切面</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">silenceCellPhones</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Silencing cell phones\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">takeSeats</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Taking seats\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">applause</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">demandRefund</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Demanding a refund\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>AspectJ 库需要通过依赖引入</p>\n</blockquote>\n<p>Audience 定义了四个方法，通过 AOP 注解，形成以下期望的行为——演出之前观众就坐、将手机静音，演出很精彩则鼓掌欢呼，演出没有达到预期则要求退款。以上的方式有一点不足，每个方法的切点表达式都是一样的，重复了四次。为此可以使用<code>@Pointcut</code>注解定义可重用的切点</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..))\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">performance</span><span class=\"params\">()</span></span>&#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">silenceCellPhones</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Silencing cell phones\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">takeSeats</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Taking seats\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">applause</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">demandRefund</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Demanding a refund\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了注解和作为标识的空<code>performance</code>方法，Audience 仍然是一个 POJO，可以添加<code>@Component</code>注解将其注入容器中。但此时 Audience 不会视为切面，需要在配置类的的类级别通过使用<code>@EnableAspectJAutoProxy</code>注解启动自动代理功能</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcertConfig</span></span></span><br></pre></td></tr></table></figure>\n<p>同时为 Performance 提供一个实现类</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPerformance</span>: <span class=\"type\">Performance &#123;</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Start perform\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [ConcertConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformTest</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> performance: Performance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        performance.perform()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Silencing cell phones</span><br><span class=\"line\">Taking seats</span><br><span class=\"line\">Start perform</span><br><span class=\"line\">CLAP CLAP CLAP!!</span><br></pre></td></tr></table></figure>\n<h3 id=\"环绕通知\"><a href=\"#环绕通知\" class=\"headerlink\" title=\"环绕通知\"></a>环绕通知</h3><p>环绕通知时最强大的通知类型，能够使编写的逻辑将被通知的目标方法完全包装，就像 在一个通知方法中同时编写前置通知和后置通知，重写上面的 Audience 切面</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..))\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">performance</span><span class=\"params\">()</span></span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(<span class=\"meta-string\">\"performance()\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">watchPerformance</span><span class=\"params\">(jointPoint: <span class=\"type\">ProceedingJoinPoint</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"Silencing cell phones\"</span>)</span><br><span class=\"line\">            println(<span class=\"string\">\"Taking seats\"</span>)</span><br><span class=\"line\">            jointPoint.proceed()</span><br><span class=\"line\">            println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"Demanding a refund\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码将实现同样的功能。环绕通知注解的方法<code>watchPerformance</code>中类型为<code>ProceedingJoinPoint</code>的参数是必须的，由此拿到切点的引用</p>\n<h3 id=\"带参数的通知\"><a href=\"#带参数的通知\" class=\"headerlink\" title=\"带参数的通知\"></a>带参数的通知</h3><p>通过一个例子来展现带参数的通知如何实现，首先修改 MyPerformance 类</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPerformance</span>: <span class=\"type\">Performance &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> performList: List&lt;String&gt; = arrayListOf(<span class=\"string\">\"Song\"</span>, <span class=\"string\">\"Dance\"</span>, <span class=\"string\">\"Magic\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        perform(Math.round(<span class=\"number\">10f</span>) % <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Start perform: <span class=\"subst\">$&#123;performList[type]&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设现在有一个计数类 PerformanceCounter，其将跟踪每一次表演节目，记录下该节目的类型以及次数并打印</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformanceCounter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> playCounter: MutableMap&lt;<span class=\"built_in\">Int</span>, <span class=\"built_in\">Int</span>&gt; = HashMap()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(<span class=\"meta-string\">\"execution(** concert.Performance.perform(..)) &amp;&amp; args(whichType)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">performanceTypePlay</span><span class=\"params\">(whichType: <span class=\"type\">Int</span>)</span></span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After(<span class=\"meta-string\">\"performanceTypePlay(typeIntValue)\"</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">countPerformance</span><span class=\"params\">(typeIntValue: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> currentCount = getPlayCount(typeIntValue)</span><br><span class=\"line\">        playCounter[typeIntValue] = currentCount+<span class=\"number\">1</span></span><br><span class=\"line\">        println(<span class=\"string\">\"=== type: <span class=\"subst\">$&#123;getDesByInt(typeIntValue)&#125;</span>, played <span class=\"subst\">$&#123;currentCount+<span class=\"number\">1</span>&#125;</span> times ===\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getPlayCount</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> = playCounter[type] ?: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getDesByInt</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span>: String = <span class=\"keyword\">when</span>(type) &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> -&gt; <span class=\"string\">\"Song\"</span></span><br><span class=\"line\">        <span class=\"number\">1</span> -&gt; <span class=\"string\">\"Dance\"</span></span><br><span class=\"line\">        <span class=\"number\">2</span> -&gt; <span class=\"string\">\"Magic\"</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; <span class=\"string\">\"null\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>着重注意不同方法中的<code>type</code>参数，参数名称各有不同，但本质都代表“表演类型”。而相同的参数名称则表示一一对应的关系：定义切点时，AspectJ 表达式内使用的参数名称为<code>whichType</code>，与标识该切点的空函数的参数是一致的；通知方法上的参数名称<code>typeIntValue</code>则与通知时机中引用切点时 AspectJ 表达式内的参数名称一致</p>\n<p>测试类如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [ConcertConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> performance: Performance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            performance.perform(i % <span class=\"number\">3</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Start perform: Song</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Song, played 1 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Dance</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Dance, played 1 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Magic</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Magic, played 1 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Song</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Song, played 2 <span class=\"built_in\">times</span> ===</span><br><span class=\"line\">Start perform: Dance</span><br><span class=\"line\">=== <span class=\"built_in\">type</span>: Dance, played 2 <span class=\"built_in\">times</span> ===</span><br></pre></td></tr></table></figure>\n<h2 id=\"注入-AspectJ-切面\"><a href=\"#注入-AspectJ-切面\" class=\"headerlink\" title=\"注入 AspectJ 切面\"></a>注入 AspectJ 切面</h2><p>AspectJ 和 Spring 实际上是独立的，只不过 Spring AOP 借助了前者的指示器。通过一个例子展示如何注入原始的 AspectJ 切面。</p>\n<p>首先准备一个评论员，在表演之后发表一段言论，其类型为<code>aspect</code>，在 IDEA 中可通过右键 New -&gt; Aspect 新建一个该类型的文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> aspect CriticAspect &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CriticAspect</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">pointcut <span class=\"title\">performance</span><span class=\"params\">()</span>: <span class=\"title\">execution</span><span class=\"params\">(* concert.MyPerformance.perform(..)</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    after(): performance() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"something\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Spring 框架中，CriticAspect 将不会由容器创建，因为它属于 AspectJ 切面，由 AspectJ 在运行时创建。所以需要通过 AspectJ 切面提供的静态<code>aspectOf</code>方法给 Spring 返回切面的单例，Spring XML 配置写成以下形式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"concert\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"concert.CriticismEngineImpl\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"criticismEngine\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"concert.MyPerformance\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"performance\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"concert.CriticAspect\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"aspectOf\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果是 JavaConfig，则需要以下形式</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcertConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">criticAspect</span><span class=\"params\">()</span></span>: concert.CriticAspect = org.aspectj.lang.Aspects.aspectOf(CriticAspect::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是运行时 JRE 将不会识别类 CriticAspect，无法运行。目前未找到解决办法，故使用 XML 配置的方法</p>\n<p>之后最重要的一步是使用<code>ajc</code>编译器，以编译<code>.aj</code>文件。通过一个插件<a href=\"https://www.mojohaus.org/aspectj-maven-plugin/usage.html\" target=\"_blank\" rel=\"noopener\"> Mojo’s AspectJ Maven Plugin</a> 引入<code>ajc</code>，注意此时 IDEA Compiler 的选项截图为</p>\n<p><img src=\"/Spring-学习笔记（三）：面向切面/Compiler.png\" alt=\"\"></p>\n<p>测试类如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &#123;<span class=\"meta-string\">\"classpath:concert.xml\"</span>&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PerformTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    Performance performance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> void test() &#123;</span><br><span class=\"line\">        performance.perform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按理说应该运行成功，然而此时还是报错</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Error:ajc: can<span class=\"string\">'t find critical required type java.io.Serializable</span></span><br><span class=\"line\"><span class=\"string\">Error:ajc: can'</span>t determine whether missing <span class=\"built_in\">type</span> java.io.Serializable is an instance of concert.CriticAspect</span><br><span class=\"line\">......</span><br><span class=\"line\">Error:ajc: can<span class=\"string\">'t find critical required type java.lang.Cloneable</span></span><br><span class=\"line\"><span class=\"string\">Error:ajc: can'</span>t determine whether missing <span class=\"built_in\">type</span> java.lang.Cloneable is an instance of concert.CriticAspect</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>目前并无解决办法， V2EX 上的求助帖为 <a href=\"https://www.v2ex.com/t/570139#reply11\" target=\"_blank\" rel=\"noopener\">诚心求助 Spring 注入式 AspectJ 切面时 ClassNotFoundException 的问题</a></p>\n<p>Spring AOP 的内容到此为止，日后大概率会对本篇文章进行增删查改，继续进行下一步的学习吧</p>"},{"title":"Spring 学习笔记（二）：高级装配","date":"2019-06-01T08:17:51.000Z","_content":"\n开发软件的过程中要涉及到不同的环境，需要配置不同的数据库配置、加密算法和外部环境的集成等组件，为此必须要考虑不同的环境下对应不同的配置。本文将从 Spring profile 出发，进而介绍条件化的 Bean 声明、自动装配的歧义性和 Bean 的作用域，以及 Spring 表达式语言。<!--more-->\n\n## Spring profile\n\n### 配置 profile\n\n使用注解`@Profile`指定某个 Bean 属于哪一个 profile，以不同环境下的数据库 Bean 为例\n\n```kotlin\n@Configuration\nopen class DataSourceConfig {\n    \n    @Bean\n    @Profile(\"dev\")\n    open fun embeddedDataSource(): DataSource = EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .addScript(\"classpath:schema.sql\")\n            .build()\n\n    @Bean\n    @Profile(\"prod\")\n    open fun jndiDataSource(): DataSource {\n        val jndiObjectFactoryBean = JndiObjectFactoryBean()\n        jndiObjectFactoryBean.jndiName = \"jndi/myDS\"\n        jndiObjectFactoryBean.isResourceRef = true\n        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource::class.java)\n        return jndiObjectFactoryBean.`object` as DataSource\n    }\n}\n```\n\n同样支持使用 XML 文件配置 profile\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"\n       profile=\"dev\">\n    <jdbc:embedded-database id=\"dataSource2\">\n        <jdbc:script location=\"classpath:schema.sql\" />\n    < /jdbc:embedded-database>\n</beans>\n```\n\n可以将  profile 设置为`prod`，创建适用于生产环境的 JNDI 获取的 DataSource Bean，所有的配置文件都会被放进部署单元之中（如 WAR 文件），但是只有 profile 属性与当前激活 profile 相匹配的配置文件才会被使用。\n\n不过更方便的方法是把所有的 Bean 放进同一个配置文件中\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n       xmlns:jee=\"http://www.springframework.org/schema/jee\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd\">\n\n    <beans profile=\"dev\">\n        <jdbc:embedded-database id=\"dataSource\">\n            <jdbc:script location=\"classpath:schema.sql\" />\n        </jdbc:embedded-database>\n    </beans>\n\n    <beans profile=\"prod\">\n        <jee:jndi-lookup id=\"dataSource\"\n                         jndi-name=\"jdbc/myDS\"\n                         resource-ref=\"true\"\n                         proxy-interface=\"javax.sql.DataSource\" />\n    </beans>\n</beans>\n```\n\n### 激活 profile\n\nSpring 借助两个独立的属性`spring.profiles.active`、`spring.profiles.default`来确定哪个 profile 处于激活状态，优先级从高到低。如果两个值都没有设置，那就没有激活的 profile，此时只会创建那些没有定义在 profile 中的 Bean。以下是设置这两个属性的方式\n\n- 作为 DispatcherServlet 的初始化参数\n- 作为 Web 应用的上下文参数\n- 作为 JNDI 条目\n- 作为环境变量\n- 作为 JVM 的系统属性\n- 在集成测试类上，使用`@ActiveProfiles`注解设置\n\n例如在 Web 应用中，设置`spring.profiles.default`的 web.xml 文件如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <context-param>\n        <param-name>spring.profiles.default</param-name>\n        <param-value>dev</param-value>\n    </context-param>\n    \n    <servlet>\n        <servlet-name>appServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet\n        </servlet-class>\n        <init-param>\n            <param-name>spring.profiles.default</param-name>\n            <param-value>dev</param-value>\n        </init-param>\n    </servlet>\n</web-app>\n```\n\n该文件分别为上下文和 Servlet 设置了默认的 profile。当应用程序部署到 QA、生产或者其他环境中时，负责部署的人根据情况使用系统属性、环境变量或 JNDI 设置`spring.profiles.active`即可——其优先级比`spring.profiles.default`高\n\n## 条件化的 Bean \n\n使用 Spring 提供的注解`@Conditional`，可以实现 Bean 在符合条件的情况下才会配置的效果，不符合条件则该 Bean 会被忽略。下面的例子假设只有设置了`magic`环境属性时 Spring 才会实例化 MagicBean（事先准备），否则它将被忽略。\n\n```kotlin\n@Configuration\nopen class MagicConfig {\n\n    @Bean\n    @Conditional(MagicExistsCondition::class)\n    open fun magicBean(): MagicBean = MagicBean()\n\n}\n```\n\n`@Conditional`需要一个`class`参数，并且该类要实现`Condition`接口，重写方法`match`，如果该方法返回 true 则创建带有`@Conditional`的 Bean。\n\n```kotlin\nclass MagicExistsCondition: Condition {\n    \n    override fun matches(p0: ConditionContext?, p1: AnnotatedTypeMetadata?): Boolean {\n        val env = p0?.environment\n        return env?.containsProperty(\"magic\") ?: false\n    }\n    \n}\n```\n\n该方法传入两个参数，第一个为`ConditionContext`\n\n```java\npublic interface ConditionContext {\n    BeanDefinitionRegistry getRegistry();\n\n    ConfigurableListableBeanFactory getBeanFactory();\n\n    Environment getEnvironment();\n\n    ResourceLoader getResourceLoader();\n\n    ClassLoader getClassLoader();\n}\n```\n\n可以看到该参数为我们提供了很多接口。第二个参数为`AnnotatedTypeMetadata`\n\n```java\npublic interface AnnotatedTypeMetadata {\n    boolean isAnnotated(String var1);\n\n    Map<String, Object> getAnnotationAttributes(String var1);\n\n    Map<String, Object> getAnnotationAttributes(String var1, boolean var2);\n\n    MultiValueMap<String, Object> getAllAnnotationAttributes(String var1);\n\n    MultiValueMap<String, Object> getAllAnnotationAttributes(String var1, boolean var2);\n}\n```\n\n该参数为我们提供了一系列检查`@Bean`方法上的其他注解的接口\n\n观察第一节提到的`Profile`注解\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional({ProfileCondition.class})\npublic @interface Profile {\n    String[] value();\n}\n```\n\n可以看到其本身也使用了`@Conditional`，引用`ProfileCondition.class`作为 Condition 实现\n\n```java\nclass ProfileCondition implements Condition {\n    ProfileCondition() {\n    }\n\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n        if (context.getEnvironment() != null) {\n            MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n            if (attrs != null) {\n                Iterator var4 = ((List)attrs.get(\"value\")).iterator();\n\n                Object value;\n                do {\n                    if (!var4.hasNext()) {\n                        return false;\n                    }\n\n                    value = var4.next();\n                } while(!context.getEnvironment().acceptsProfiles((String[])((String[])value)));\n\n                return true;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n该类通过 AnnotatedTypeMetadata 获得用于`@Profile`注解的所有属性，然后检查`value`属性，得到`profile`名称。然后通过 ConditionContext 检查该`profile`是否激活\n\n## 自动装配的歧义性\n\n在自动装配中，只有当仅有一个 Bean 匹配所需的结果时，自动装配才是有效的，出现歧义则将阻碍 Spring 自动装配属性、构造器参数或方法参数。\n\n比如下面的例子，提供两个 CompactDisc 的实现类\n\n```kotlin\ninterface CompactDisc {\n    fun play()\n}\n\n@Component\nclass SgtPeppers: CompactDisc {\n\t......\n}\n\n@Component\nclass BlankDisc: CompactDisc {\n\t......\n}\n```\n\n测试代码为\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [CDPlayerConfig::class])\nclass CDPlayerTest {\n\n    private lateinit var cd: CompactDisc\n\n    @Test\n    fun play() {\n    \tcd.play()\n    }\n\n    @Autowired\n    fun setCompactDisc(cd: CompactDisc) {\n        this.cd = cd\n    }\n}\n```\n\n测试将会报错\n\n```bash\norg.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'soundsystem.CompactDisc' available: expected single matching bean but found 2: blankDisc,sgtPeppers\n```\n\n针对这种情况，可以使用`@Primary`和`@Qualifier`解决\n\n### @Primary\n\n在其中一个实现上添加注解\n\n```kotlin\n@Component\n@Primary\nclass SgtPeppers: CompactDisc {\n\t......\n}\n```\n\n该注解也可以应用在 JavaConfig 代码中，在 XML 文件的配置方式为\n\n```xml\n<bean id=\"sgtPeppers\" class=\"sound_system.SgtPeppers\"\n    primary=\"true\">\n</bean>\n\n```\n\n### @Qualifier\n\n该注解比`@Primary`更加灵活，使用简单\n\n```kotlin\n@Autowired\n@Qualifier(\"sgtPeppers\")\nfun setCompactDisc(cd: CompactDisc) {\n\tthis.cd = cd\n}\n```\n\n为`@Qualifier`注解设置的参数就是想要注入的 Bean 的 id，一般为 Bean 的类名首字母变为小写之后的字符。当然开发者也可以自定义 Bean 的限定符防止重命名之后原来的注解失效\n\n```kotlin\n@Component\n@Qualifier(\"byBeatles\")\nclass SgtPeppers: CompactDisc {\n\n    private val title = \"Sgt. Pepper's Lonely Hearts Club Band\"\n    private val artist = \"The Beatles\"\n\n    override fun play() {\n        println(\"Playing $title by $artist\")\n    }\n}\n```\n\n相应的代码也更改为\n\n```kotlin\n@Autowired\n@Qualifier(\"byBeatles\")\nfun setCompactDisc(cd: CompactDisc) {\n\tthis.cd = cd\n}\n```\n\n更进一步，开发者可以自定义一个使用`@Qualifier`注解的注解类，防止以后再出现一个`byBeatles`的 Bean\n\n```kotlin\nimport org.springframework.beans.factory.annotation.Qualifier\n\n@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FIELD, AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\nannotation class FavoriteCD \n```\n\n使用方法和`@Qualifier(\"id\")`类似，在需要注解的类上添加`@FavoriteCD`，然后在自动装配的地方同样使用该注解即可。\n\n## Bean 的作用域\n\n 在上一篇文章中我们提到 Spring 中的 Bean 默认是单例的，但是显然这样的实例将会保持一定的“状态”，因此重用将是不安全的。Spring 定义了多种 Bean 作用域\n\n- 单例（Singleton）：整个应用中只创建 Bean 的一个实例\n- 原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候都会创建一个新的实例\n- 会话（Session）：在 Web 应用中，为每个会话创建一个实例\n- 请求（Request）：在 Web 应用中，为每个请求创建一个实例\n\n要使用作用域，可以通过`@Scope`注解实现\n\n```kotlin\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\nclass SgtPeppers\n```\n\n当然在自动装配的地方使用该注解也可以，XML 文件的配置方式同理，不再赘述\n\n### 会话和请求作用域\n\n在典型的电子商务应用中，可能有一个 Bean 代表用户的购物车，当其为单例时意味着所有的用户共用一个购物车。这种情况下使用会话作用域显然更加合适\n\n```kotlin\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION,\n        proxyMode = ScopedProxyMode..TARGET_CLASS)\nopen class ShoppingCart\n```\n\n注解的第一个参数`value`将告诉 Spring 为 Web 应用的每个会话创建一个 ShoppingCart，在会话相关的操作中其相当于一个单例。第二个参数`proxyMode`被设为`ScopedProxyMode.INTERFACES`，解决将会话或者请求作用域的 Bean 注入到单例 Bean 中所遇到的问题\n\n假设 ShoppingCart 注入到一个单例 StoreService 中，由于单例 Bean 会在 Spring 应用上下文加载的时候创建，然而此时属于会话作用域的 ShoppingCart 并不存在；此外，系统中将会有多个 ShoppingCart 实例，我们并不想让某一个固定的 ShoppingCart 实例到 StoreService 中，而是希望当 StoreService 处理购物车功能时，其所使用的 ShoppingCart 实例刚好是当前会话所对应的那个\n\n`proxyMode`的作用就在于，Spring 不会将实际的 ShoppingCart 注入到 StoreService 中，而是将它的代理注入。这一代理会暴露与 ShoppingCart 相同的方法，所以 StoreService 会认为它就是一个购物车。当 StoreService 调用方法时，代理会进行懒解析并将调用委托到会话作用域内真正的 ShoppingCart 实例\n\nXML 方式配置不再赘述\n\n## Spring 表达式语言\n\nSpring Expression Language，简称 SpEL，能够以一种强大和简洁的方式将值装配到 Bean 属性和构造器参数中。其有很多特性\n\n- 使用 ID 来引用 Bean\n- 调用方法和访问对象的属性\n- 对值进行算数、关系和逻辑运算\n- 正则表达式匹配\n- 集合操作\n\nSpEL 要放到`#{ ... }`中，与属性占位符放到`${ ... }`中类似。对于下面的表达式\n\n```kotlin\n#{T(System).currentTimeMillis()}\n```\n\n将得到表达式计算的那一刻时间的毫秒数。`T()`表达式将其中参数视为 Java 中的类型，从而可以调用该类型的静态方法。\n\n`#{ ... }`中既可以放字面值如整数、浮点数、字符串、布尔值，也可以引用对象属性和方法\n\n```kotlin\n#{sgtPeppers.artist}\n\n#{systemProperties['sgtPeppers.title']}\n\n#{sgtPeppers.toString()?.toUpperCase}\n```\n\n上面的第二个表达式将调用`properties`文件中`sgtPeppers`的`title`属性值。第三个参数表示我们可以对方法返回值使用安全调用\n\nSpEL 支持各种常用的运算，包括算术运算、比较运算、逻辑运算、条件运算（`? :`和`?:`）、正则表达式（`matches`），下面是一个正则表达式的例子，用以验证邮箱\n\n```kotlin\n#{admin.email matches '[a-zA-Z0-9._&+-]+@[a-zA-Z0-9._&+-]'+\\\\.com}\n```\n\n下面是一个操作集合的例子\n\n```kotlin\n#{cd.tracks[1].title}\n\n#{'the string'[1]} //得到 h\n\n#{cd.tracks.?[title eq 'Title'} //得到 title 为 Title 的新集合\n\n#{cd.tracks.^[title eq 'Title'} //得到第一个 title 值为 Title 的元素\n              \n#{cd.tracks.$[title eq 'Title'} //得到最后一个 title 值为 Title 的元素             \n\n#{cd.tracks.![title]} //得到 title 的集合\n         \n```\n\n\n\n","source":"_posts/Spring-学习笔记（二）：高级装配.md","raw":"---\ntitle: Spring 学习笔记（二）：高级装配\ndate: 2019-06-01 16:17:51\ntags:\n- Spring\ncategories:\n- Spring\n---\n\n开发软件的过程中要涉及到不同的环境，需要配置不同的数据库配置、加密算法和外部环境的集成等组件，为此必须要考虑不同的环境下对应不同的配置。本文将从 Spring profile 出发，进而介绍条件化的 Bean 声明、自动装配的歧义性和 Bean 的作用域，以及 Spring 表达式语言。<!--more-->\n\n## Spring profile\n\n### 配置 profile\n\n使用注解`@Profile`指定某个 Bean 属于哪一个 profile，以不同环境下的数据库 Bean 为例\n\n```kotlin\n@Configuration\nopen class DataSourceConfig {\n    \n    @Bean\n    @Profile(\"dev\")\n    open fun embeddedDataSource(): DataSource = EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .addScript(\"classpath:schema.sql\")\n            .build()\n\n    @Bean\n    @Profile(\"prod\")\n    open fun jndiDataSource(): DataSource {\n        val jndiObjectFactoryBean = JndiObjectFactoryBean()\n        jndiObjectFactoryBean.jndiName = \"jndi/myDS\"\n        jndiObjectFactoryBean.isResourceRef = true\n        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource::class.java)\n        return jndiObjectFactoryBean.`object` as DataSource\n    }\n}\n```\n\n同样支持使用 XML 文件配置 profile\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"\n       profile=\"dev\">\n    <jdbc:embedded-database id=\"dataSource2\">\n        <jdbc:script location=\"classpath:schema.sql\" />\n    < /jdbc:embedded-database>\n</beans>\n```\n\n可以将  profile 设置为`prod`，创建适用于生产环境的 JNDI 获取的 DataSource Bean，所有的配置文件都会被放进部署单元之中（如 WAR 文件），但是只有 profile 属性与当前激活 profile 相匹配的配置文件才会被使用。\n\n不过更方便的方法是把所有的 Bean 放进同一个配置文件中\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n       xmlns:jee=\"http://www.springframework.org/schema/jee\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd\">\n\n    <beans profile=\"dev\">\n        <jdbc:embedded-database id=\"dataSource\">\n            <jdbc:script location=\"classpath:schema.sql\" />\n        </jdbc:embedded-database>\n    </beans>\n\n    <beans profile=\"prod\">\n        <jee:jndi-lookup id=\"dataSource\"\n                         jndi-name=\"jdbc/myDS\"\n                         resource-ref=\"true\"\n                         proxy-interface=\"javax.sql.DataSource\" />\n    </beans>\n</beans>\n```\n\n### 激活 profile\n\nSpring 借助两个独立的属性`spring.profiles.active`、`spring.profiles.default`来确定哪个 profile 处于激活状态，优先级从高到低。如果两个值都没有设置，那就没有激活的 profile，此时只会创建那些没有定义在 profile 中的 Bean。以下是设置这两个属性的方式\n\n- 作为 DispatcherServlet 的初始化参数\n- 作为 Web 应用的上下文参数\n- 作为 JNDI 条目\n- 作为环境变量\n- 作为 JVM 的系统属性\n- 在集成测试类上，使用`@ActiveProfiles`注解设置\n\n例如在 Web 应用中，设置`spring.profiles.default`的 web.xml 文件如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <context-param>\n        <param-name>spring.profiles.default</param-name>\n        <param-value>dev</param-value>\n    </context-param>\n    \n    <servlet>\n        <servlet-name>appServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet\n        </servlet-class>\n        <init-param>\n            <param-name>spring.profiles.default</param-name>\n            <param-value>dev</param-value>\n        </init-param>\n    </servlet>\n</web-app>\n```\n\n该文件分别为上下文和 Servlet 设置了默认的 profile。当应用程序部署到 QA、生产或者其他环境中时，负责部署的人根据情况使用系统属性、环境变量或 JNDI 设置`spring.profiles.active`即可——其优先级比`spring.profiles.default`高\n\n## 条件化的 Bean \n\n使用 Spring 提供的注解`@Conditional`，可以实现 Bean 在符合条件的情况下才会配置的效果，不符合条件则该 Bean 会被忽略。下面的例子假设只有设置了`magic`环境属性时 Spring 才会实例化 MagicBean（事先准备），否则它将被忽略。\n\n```kotlin\n@Configuration\nopen class MagicConfig {\n\n    @Bean\n    @Conditional(MagicExistsCondition::class)\n    open fun magicBean(): MagicBean = MagicBean()\n\n}\n```\n\n`@Conditional`需要一个`class`参数，并且该类要实现`Condition`接口，重写方法`match`，如果该方法返回 true 则创建带有`@Conditional`的 Bean。\n\n```kotlin\nclass MagicExistsCondition: Condition {\n    \n    override fun matches(p0: ConditionContext?, p1: AnnotatedTypeMetadata?): Boolean {\n        val env = p0?.environment\n        return env?.containsProperty(\"magic\") ?: false\n    }\n    \n}\n```\n\n该方法传入两个参数，第一个为`ConditionContext`\n\n```java\npublic interface ConditionContext {\n    BeanDefinitionRegistry getRegistry();\n\n    ConfigurableListableBeanFactory getBeanFactory();\n\n    Environment getEnvironment();\n\n    ResourceLoader getResourceLoader();\n\n    ClassLoader getClassLoader();\n}\n```\n\n可以看到该参数为我们提供了很多接口。第二个参数为`AnnotatedTypeMetadata`\n\n```java\npublic interface AnnotatedTypeMetadata {\n    boolean isAnnotated(String var1);\n\n    Map<String, Object> getAnnotationAttributes(String var1);\n\n    Map<String, Object> getAnnotationAttributes(String var1, boolean var2);\n\n    MultiValueMap<String, Object> getAllAnnotationAttributes(String var1);\n\n    MultiValueMap<String, Object> getAllAnnotationAttributes(String var1, boolean var2);\n}\n```\n\n该参数为我们提供了一系列检查`@Bean`方法上的其他注解的接口\n\n观察第一节提到的`Profile`注解\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional({ProfileCondition.class})\npublic @interface Profile {\n    String[] value();\n}\n```\n\n可以看到其本身也使用了`@Conditional`，引用`ProfileCondition.class`作为 Condition 实现\n\n```java\nclass ProfileCondition implements Condition {\n    ProfileCondition() {\n    }\n\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n        if (context.getEnvironment() != null) {\n            MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n            if (attrs != null) {\n                Iterator var4 = ((List)attrs.get(\"value\")).iterator();\n\n                Object value;\n                do {\n                    if (!var4.hasNext()) {\n                        return false;\n                    }\n\n                    value = var4.next();\n                } while(!context.getEnvironment().acceptsProfiles((String[])((String[])value)));\n\n                return true;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n该类通过 AnnotatedTypeMetadata 获得用于`@Profile`注解的所有属性，然后检查`value`属性，得到`profile`名称。然后通过 ConditionContext 检查该`profile`是否激活\n\n## 自动装配的歧义性\n\n在自动装配中，只有当仅有一个 Bean 匹配所需的结果时，自动装配才是有效的，出现歧义则将阻碍 Spring 自动装配属性、构造器参数或方法参数。\n\n比如下面的例子，提供两个 CompactDisc 的实现类\n\n```kotlin\ninterface CompactDisc {\n    fun play()\n}\n\n@Component\nclass SgtPeppers: CompactDisc {\n\t......\n}\n\n@Component\nclass BlankDisc: CompactDisc {\n\t......\n}\n```\n\n测试代码为\n\n```kotlin\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [CDPlayerConfig::class])\nclass CDPlayerTest {\n\n    private lateinit var cd: CompactDisc\n\n    @Test\n    fun play() {\n    \tcd.play()\n    }\n\n    @Autowired\n    fun setCompactDisc(cd: CompactDisc) {\n        this.cd = cd\n    }\n}\n```\n\n测试将会报错\n\n```bash\norg.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'soundsystem.CompactDisc' available: expected single matching bean but found 2: blankDisc,sgtPeppers\n```\n\n针对这种情况，可以使用`@Primary`和`@Qualifier`解决\n\n### @Primary\n\n在其中一个实现上添加注解\n\n```kotlin\n@Component\n@Primary\nclass SgtPeppers: CompactDisc {\n\t......\n}\n```\n\n该注解也可以应用在 JavaConfig 代码中，在 XML 文件的配置方式为\n\n```xml\n<bean id=\"sgtPeppers\" class=\"sound_system.SgtPeppers\"\n    primary=\"true\">\n</bean>\n\n```\n\n### @Qualifier\n\n该注解比`@Primary`更加灵活，使用简单\n\n```kotlin\n@Autowired\n@Qualifier(\"sgtPeppers\")\nfun setCompactDisc(cd: CompactDisc) {\n\tthis.cd = cd\n}\n```\n\n为`@Qualifier`注解设置的参数就是想要注入的 Bean 的 id，一般为 Bean 的类名首字母变为小写之后的字符。当然开发者也可以自定义 Bean 的限定符防止重命名之后原来的注解失效\n\n```kotlin\n@Component\n@Qualifier(\"byBeatles\")\nclass SgtPeppers: CompactDisc {\n\n    private val title = \"Sgt. Pepper's Lonely Hearts Club Band\"\n    private val artist = \"The Beatles\"\n\n    override fun play() {\n        println(\"Playing $title by $artist\")\n    }\n}\n```\n\n相应的代码也更改为\n\n```kotlin\n@Autowired\n@Qualifier(\"byBeatles\")\nfun setCompactDisc(cd: CompactDisc) {\n\tthis.cd = cd\n}\n```\n\n更进一步，开发者可以自定义一个使用`@Qualifier`注解的注解类，防止以后再出现一个`byBeatles`的 Bean\n\n```kotlin\nimport org.springframework.beans.factory.annotation.Qualifier\n\n@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FIELD, AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\nannotation class FavoriteCD \n```\n\n使用方法和`@Qualifier(\"id\")`类似，在需要注解的类上添加`@FavoriteCD`，然后在自动装配的地方同样使用该注解即可。\n\n## Bean 的作用域\n\n 在上一篇文章中我们提到 Spring 中的 Bean 默认是单例的，但是显然这样的实例将会保持一定的“状态”，因此重用将是不安全的。Spring 定义了多种 Bean 作用域\n\n- 单例（Singleton）：整个应用中只创建 Bean 的一个实例\n- 原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候都会创建一个新的实例\n- 会话（Session）：在 Web 应用中，为每个会话创建一个实例\n- 请求（Request）：在 Web 应用中，为每个请求创建一个实例\n\n要使用作用域，可以通过`@Scope`注解实现\n\n```kotlin\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\nclass SgtPeppers\n```\n\n当然在自动装配的地方使用该注解也可以，XML 文件的配置方式同理，不再赘述\n\n### 会话和请求作用域\n\n在典型的电子商务应用中，可能有一个 Bean 代表用户的购物车，当其为单例时意味着所有的用户共用一个购物车。这种情况下使用会话作用域显然更加合适\n\n```kotlin\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION,\n        proxyMode = ScopedProxyMode..TARGET_CLASS)\nopen class ShoppingCart\n```\n\n注解的第一个参数`value`将告诉 Spring 为 Web 应用的每个会话创建一个 ShoppingCart，在会话相关的操作中其相当于一个单例。第二个参数`proxyMode`被设为`ScopedProxyMode.INTERFACES`，解决将会话或者请求作用域的 Bean 注入到单例 Bean 中所遇到的问题\n\n假设 ShoppingCart 注入到一个单例 StoreService 中，由于单例 Bean 会在 Spring 应用上下文加载的时候创建，然而此时属于会话作用域的 ShoppingCart 并不存在；此外，系统中将会有多个 ShoppingCart 实例，我们并不想让某一个固定的 ShoppingCart 实例到 StoreService 中，而是希望当 StoreService 处理购物车功能时，其所使用的 ShoppingCart 实例刚好是当前会话所对应的那个\n\n`proxyMode`的作用就在于，Spring 不会将实际的 ShoppingCart 注入到 StoreService 中，而是将它的代理注入。这一代理会暴露与 ShoppingCart 相同的方法，所以 StoreService 会认为它就是一个购物车。当 StoreService 调用方法时，代理会进行懒解析并将调用委托到会话作用域内真正的 ShoppingCart 实例\n\nXML 方式配置不再赘述\n\n## Spring 表达式语言\n\nSpring Expression Language，简称 SpEL，能够以一种强大和简洁的方式将值装配到 Bean 属性和构造器参数中。其有很多特性\n\n- 使用 ID 来引用 Bean\n- 调用方法和访问对象的属性\n- 对值进行算数、关系和逻辑运算\n- 正则表达式匹配\n- 集合操作\n\nSpEL 要放到`#{ ... }`中，与属性占位符放到`${ ... }`中类似。对于下面的表达式\n\n```kotlin\n#{T(System).currentTimeMillis()}\n```\n\n将得到表达式计算的那一刻时间的毫秒数。`T()`表达式将其中参数视为 Java 中的类型，从而可以调用该类型的静态方法。\n\n`#{ ... }`中既可以放字面值如整数、浮点数、字符串、布尔值，也可以引用对象属性和方法\n\n```kotlin\n#{sgtPeppers.artist}\n\n#{systemProperties['sgtPeppers.title']}\n\n#{sgtPeppers.toString()?.toUpperCase}\n```\n\n上面的第二个表达式将调用`properties`文件中`sgtPeppers`的`title`属性值。第三个参数表示我们可以对方法返回值使用安全调用\n\nSpEL 支持各种常用的运算，包括算术运算、比较运算、逻辑运算、条件运算（`? :`和`?:`）、正则表达式（`matches`），下面是一个正则表达式的例子，用以验证邮箱\n\n```kotlin\n#{admin.email matches '[a-zA-Z0-9._&+-]+@[a-zA-Z0-9._&+-]'+\\\\.com}\n```\n\n下面是一个操作集合的例子\n\n```kotlin\n#{cd.tracks[1].title}\n\n#{'the string'[1]} //得到 h\n\n#{cd.tracks.?[title eq 'Title'} //得到 title 为 Title 的新集合\n\n#{cd.tracks.^[title eq 'Title'} //得到第一个 title 值为 Title 的元素\n              \n#{cd.tracks.$[title eq 'Title'} //得到最后一个 title 值为 Title 的元素             \n\n#{cd.tracks.![title]} //得到 title 的集合\n         \n```\n\n\n\n","slug":"Spring-学习笔记（二）：高级装配","published":1,"updated":"2019-06-02T05:03:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxy003wy4upw0z9dyea","content":"<p>开发软件的过程中要涉及到不同的环境，需要配置不同的数据库配置、加密算法和外部环境的集成等组件，为此必须要考虑不同的环境下对应不同的配置。本文将从 Spring profile 出发，进而介绍条件化的 Bean 声明、自动装配的歧义性和 Bean 的作用域，以及 Spring 表达式语言。<a id=\"more\"></a></p>\n<h2 id=\"Spring-profile\"><a href=\"#Spring-profile\" class=\"headerlink\" title=\"Spring profile\"></a>Spring profile</h2><h3 id=\"配置-profile\"><a href=\"#配置-profile\" class=\"headerlink\" title=\"配置 profile\"></a>配置 profile</h3><p>使用注解<code>@Profile</code>指定某个 Bean 属于哪一个 profile，以不同环境下的数据库 Bean 为例</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceConfig</span> </span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile(<span class=\"meta-string\">\"dev\"</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embeddedDataSource</span><span class=\"params\">()</span></span>: DataSource = EmbeddedDatabaseBuilder()</span><br><span class=\"line\">            .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"classpath:schema.sql\"</span>)</span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile(<span class=\"meta-string\">\"prod\"</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jndiDataSource</span><span class=\"params\">()</span></span>: DataSource {</span><br><span class=\"line\">        <span class=\"keyword\">val</span> jndiObjectFactoryBean = JndiObjectFactoryBean()</span><br><span class=\"line\">        jndiObjectFactoryBean.jndiName = <span class=\"string\">\"jndi/myDS\"</span></span><br><span class=\"line\">        jndiObjectFactoryBean.isResourceRef = <span class=\"literal\">true</span></span><br><span class=\"line\">        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> jndiObjectFactoryBean.`<span class=\"keyword\">object</span>` <span class=\"keyword\">as</span> DataSource</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>同样支持使用 XML 文件配置 profile</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:jdbc</span>=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">profile</span>=<span class=\"string\">\"dev\"</span>></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">jdbc:embedded-database</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource2\"</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">jdbc:script</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:schema.sql\"</span> /></span></span><br><span class=\"line\">    <span class=\"tag\">< /<span class=\"attr\">jdbc:embedded-database</span>></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<p>可以将  profile 设置为<code>prod</code>，创建适用于生产环境的 JNDI 获取的 DataSource Bean，所有的配置文件都会被放进部署单元之中（如 WAR 文件），但是只有 profile 属性与当前激活 profile 相匹配的配置文件才会被使用。</p>\n<p>不过更方便的方法是把所有的 Bean 放进同一个配置文件中</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:jdbc</span>=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:jee</span>=<span class=\"string\">\"http://www.springframework.org/schema/jee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd\"</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">profile</span>=<span class=\"string\">\"dev\"</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">jdbc:embedded-database</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span>></span></span><br><span class=\"line\">            <span class=\"tag\"><<span class=\"name\">jdbc:script</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:schema.sql\"</span> /></span></span><br><span class=\"line\">        <span class=\"tag\"></<span class=\"name\">jdbc:embedded-database</span>></span></span><br><span class=\"line\">    <span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">profile</span>=<span class=\"string\">\"prod\"</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">jee:jndi-lookup</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">jndi-name</span>=<span class=\"string\">\"jdbc/myDS\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">resource-ref</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">proxy-interface</span>=<span class=\"string\">\"javax.sql.DataSource\"</span> /></span></span><br><span class=\"line\">    <span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"激活-profile\"><a href=\"#激活-profile\" class=\"headerlink\" title=\"激活 profile\"></a>激活 profile</h3><p>Spring 借助两个独立的属性<code>spring.profiles.active</code>、<code>spring.profiles.default</code>来确定哪个 profile 处于激活状态，优先级从高到低。如果两个值都没有设置，那就没有激活的 profile，此时只会创建那些没有定义在 profile 中的 Bean。以下是设置这两个属性的方式</p>\n<ul>\n<li>作为 DispatcherServlet 的初始化参数</li>\n<li>作为 Web 应用的上下文参数</li>\n<li>作为 JNDI 条目</li>\n<li>作为环境变量</li>\n<li>作为 JVM 的系统属性</li>\n<li>在集成测试类上，使用<code>@ActiveProfiles</code>注解设置</li>\n</ul>\n<p>例如在 Web 应用中，设置<code>spring.profiles.default</code>的 web.xml 文件如下</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">web-app</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://xmlns.jcp.org/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">version</span>=<span class=\"string\">\"4.0\"</span>></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">context-param</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">param-name</span>></span>spring.profiles.default<span class=\"tag\"></<span class=\"name\">param-name</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">param-value</span>></span>dev<span class=\"tag\"></<span class=\"name\">param-value</span>></span></span><br><span class=\"line\">    <span class=\"tag\"></<span class=\"name\">context-param</span>></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">servlet</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">servlet-name</span>></span>appServlet<span class=\"tag\"></<span class=\"name\">servlet-name</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet</span><br><span class=\"line\">        <span class=\"tag\"></<span class=\"name\">servlet-class</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">init-param</span>></span></span><br><span class=\"line\">            <span class=\"tag\"><<span class=\"name\">param-name</span>></span>spring.profiles.default<span class=\"tag\"></<span class=\"name\">param-name</span>></span></span><br><span class=\"line\">            <span class=\"tag\"><<span class=\"name\">param-value</span>></span>dev<span class=\"tag\"></<span class=\"name\">param-value</span>></span></span><br><span class=\"line\">        <span class=\"tag\"></<span class=\"name\">init-param</span>></span></span><br><span class=\"line\">    <span class=\"tag\"></<span class=\"name\">servlet</span>></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">web-app</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<p>该文件分别为上下文和 Servlet 设置了默认的 profile。当应用程序部署到 QA、生产或者其他环境中时，负责部署的人根据情况使用系统属性、环境变量或 JNDI 设置<code>spring.profiles.active</code>即可——其优先级比<code>spring.profiles.default</code>高</p>\n<h2 id=\"条件化的-Bean\"><a href=\"#条件化的-Bean\" class=\"headerlink\" title=\"条件化的 Bean\"></a>条件化的 Bean</h2><p>使用 Spring 提供的注解<code>@Conditional</code>，可以实现 Bean 在符合条件的情况下才会配置的效果，不符合条件则该 Bean 会被忽略。下面的例子假设只有设置了<code>magic</code>环境属性时 Spring 才会实例化 MagicBean（事先准备），否则它将被忽略。</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicConfig</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Conditional(MagicExistsCondition::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">magicBean</span><span class=\"params\">()</span></span>: MagicBean = MagicBean()</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p><code>@Conditional</code>需要一个<code>class</code>参数，并且该类要实现<code>Condition</code>接口，重写方法<code>match</code>，如果该方法返回 true 则创建带有<code>@Conditional</code>的 Bean。</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicExistsCondition</span>: <span class=\"type\">Condition {</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">matches</span><span class=\"params\">(p0: <span class=\"type\">ConditionContext</span>?, p1: <span class=\"type\">AnnotatedTypeMetadata</span>?)</span></span>: <span class=\"built_in\">Boolean</span> {</span><br><span class=\"line\">        <span class=\"keyword\">val</span> env = p0?.environment</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env?.containsProperty(<span class=\"string\">\"magic\"</span>) ?: <span class=\"literal\">false</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该方法传入两个参数，第一个为<code>ConditionContext</code></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConditionContext</span> </span>{</span><br><span class=\"line\">    <span class=\"function\">BeanDefinitionRegistry <span class=\"title\">getRegistry</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ConfigurableListableBeanFactory <span class=\"title\">getBeanFactory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Environment <span class=\"title\">getEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ResourceLoader <span class=\"title\">getResourceLoader</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ClassLoader <span class=\"title\">getClassLoader</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到该参数为我们提供了很多接口。第二个参数为<code>AnnotatedTypeMetadata</code></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AnnotatedTypeMetadata</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAnnotated</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Map<String, Object> <span class=\"title\">getAnnotationAttributes</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Map<String, Object> <span class=\"title\">getAnnotationAttributes</span><span class=\"params\">(String var1, <span class=\"keyword\">boolean</span> var2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MultiValueMap<String, Object> <span class=\"title\">getAllAnnotationAttributes</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MultiValueMap<String, Object> <span class=\"title\">getAllAnnotationAttributes</span><span class=\"params\">(String var1, <span class=\"keyword\">boolean</span> var2)</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该参数为我们提供了一系列检查<code>@Bean</code>方法上的其他注解的接口</p>\n<p>观察第一节提到的<code>Profile</code>注解</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>({ElementType.TYPE, ElementType.METHOD})</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>({ProfileCondition.class})</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Profile {</span><br><span class=\"line\">    String[] value();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到其本身也使用了<code>@Conditional</code>，引用<code>ProfileCondition.class</code>作为 Condition 实现</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProfileCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>{</span><br><span class=\"line\">    ProfileCondition() {</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context.getEnvironment() != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (attrs != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">                Iterator var4 = ((List)attrs.get(<span class=\"string\">\"value\"</span>)).iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">                Object value;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> {</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!var4.hasNext()) {</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    }</span><br><span class=\"line\"></span><br><span class=\"line\">                    value = var4.next();</span><br><span class=\"line\">                } <span class=\"keyword\">while</span>(!context.getEnvironment().acceptsProfiles((String[])((String[])value)));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该类通过 AnnotatedTypeMetadata 获得用于<code>@Profile</code>注解的所有属性，然后检查<code>value</code>属性，得到<code>profile</code>名称。然后通过 ConditionContext 检查该<code>profile</code>是否激活</p>\n<h2 id=\"自动装配的歧义性\"><a href=\"#自动装配的歧义性\" class=\"headerlink\" title=\"自动装配的歧义性\"></a>自动装配的歧义性</h2><p>在自动装配中，只有当仅有一个 Bean 匹配所需的结果时，自动装配才是有效的，出现歧义则将阻碍 Spring 自动装配属性、构造器参数或方法参数。</p>\n<p>比如下面的例子，提供两个 CompactDisc 的实现类</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CompactDisc</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc {</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlankDisc</span>: <span class=\"type\">CompactDisc {</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>测试代码为</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [CDPlayerConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> cd: CompactDisc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">    \tcd.play()</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(cd: <span class=\"type\">CompactDisc</span>)</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cd = cd</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>测试将会报错</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of <span class=\"built_in\">type</span> <span class=\"string\">'soundsystem.CompactDisc'</span> available: expected single matching bean but found 2: blankDisc,sgtPeppers</span><br></pre></td></tr></tbody></table></figure>\n<p>针对这种情况，可以使用<code>@Primary</code>和<code>@Qualifier</code>解决</p>\n<h3 id=\"Primary\"><a href=\"#Primary\" class=\"headerlink\" title=\"@Primary\"></a>@Primary</h3><p>在其中一个实现上添加注解</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc {</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该注解也可以应用在 JavaConfig 代码中，在 XML 文件的配置方式为</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sgtPeppers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.SgtPeppers\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">primary</span>=<span class=\"string\">\"true\"</span>></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">bean</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Qualifier\"><a href=\"#Qualifier\" class=\"headerlink\" title=\"@Qualifier\"></a>@Qualifier</h3><p>该注解比<code>@Primary</code>更加灵活，使用简单</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(<span class=\"meta-string\">\"sgtPeppers\"</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(cd: <span class=\"type\">CompactDisc</span>)</span></span> {</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cd = cd</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>为<code>@Qualifier</code>注解设置的参数就是想要注入的 Bean 的 id，一般为 Bean 的类名首字母变为小写之后的字符。当然开发者也可以自定义 Bean 的限定符防止重命名之后原来的注解失效</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(<span class=\"meta-string\">\"byBeatles\"</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc {</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> artist = <span class=\"string\">\"The Beatles\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Playing <span class=\"variable\">$title</span> by <span class=\"variable\">$artist</span>\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>相应的代码也更改为</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(<span class=\"meta-string\">\"byBeatles\"</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(cd: <span class=\"type\">CompactDisc</span>)</span></span> {</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cd = cd</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>更进一步，开发者可以自定义一个使用<code>@Qualifier</code>注解的注解类，防止以后再出现一个<code>byBeatles</code>的 Bean</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.<span class=\"keyword\">annotation</span>.Qualifier</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FIELD, AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FavoriteCD</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>使用方法和<code>@Qualifier(\"id\")</code>类似，在需要注解的类上添加<code>@FavoriteCD</code>，然后在自动装配的地方同样使用该注解即可。</p>\n<h2 id=\"Bean-的作用域\"><a href=\"#Bean-的作用域\" class=\"headerlink\" title=\"Bean 的作用域\"></a>Bean 的作用域</h2><p> 在上一篇文章中我们提到 Spring 中的 Bean 默认是单例的，但是显然这样的实例将会保持一定的“状态”，因此重用将是不安全的。Spring 定义了多种 Bean 作用域</p>\n<ul>\n<li>单例（Singleton）：整个应用中只创建 Bean 的一个实例</li>\n<li>原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候都会创建一个新的实例</li>\n<li>会话（Session）：在 Web 应用中，为每个会话创建一个实例</li>\n<li>请求（Request）：在 Web 应用中，为每个请求创建一个实例</li>\n</ul>\n<p>要使用作用域，可以通过<code>@Scope</code>注解实现</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>当然在自动装配的地方使用该注解也可以，XML 文件的配置方式同理，不再赘述</p>\n<h3 id=\"会话和请求作用域\"><a href=\"#会话和请求作用域\" class=\"headerlink\" title=\"会话和请求作用域\"></a>会话和请求作用域</h3><p>在典型的电子商务应用中，可能有一个 Bean 代表用户的购物车，当其为单例时意味着所有的用户共用一个购物车。这种情况下使用会话作用域显然更加合适</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(value = WebApplicationContext.SCOPE_SESSION,</span></span><br><span class=\"line\"><span class=\"meta\">        proxyMode = ScopedProxyMode..TARGET_CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoppingCart</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>注解的第一个参数<code>value</code>将告诉 Spring 为 Web 应用的每个会话创建一个 ShoppingCart，在会话相关的操作中其相当于一个单例。第二个参数<code>proxyMode</code>被设为<code>ScopedProxyMode.INTERFACES</code>，解决将会话或者请求作用域的 Bean 注入到单例 Bean 中所遇到的问题</p>\n<p>假设 ShoppingCart 注入到一个单例 StoreService 中，由于单例 Bean 会在 Spring 应用上下文加载的时候创建，然而此时属于会话作用域的 ShoppingCart 并不存在；此外，系统中将会有多个 ShoppingCart 实例，我们并不想让某一个固定的 ShoppingCart 实例到 StoreService 中，而是希望当 StoreService 处理购物车功能时，其所使用的 ShoppingCart 实例刚好是当前会话所对应的那个</p>\n<p><code>proxyMode</code>的作用就在于，Spring 不会将实际的 ShoppingCart 注入到 StoreService 中，而是将它的代理注入。这一代理会暴露与 ShoppingCart 相同的方法，所以 StoreService 会认为它就是一个购物车。当 StoreService 调用方法时，代理会进行懒解析并将调用委托到会话作用域内真正的 ShoppingCart 实例</p>\n<p>XML 方式配置不再赘述</p>\n<h2 id=\"Spring-表达式语言\"><a href=\"#Spring-表达式语言\" class=\"headerlink\" title=\"Spring 表达式语言\"></a>Spring 表达式语言</h2><p>Spring Expression Language，简称 SpEL，能够以一种强大和简洁的方式将值装配到 Bean 属性和构造器参数中。其有很多特性</p>\n<ul>\n<li>使用 ID 来引用 Bean</li>\n<li>调用方法和访问对象的属性</li>\n<li>对值进行算数、关系和逻辑运算</li>\n<li>正则表达式匹配</li>\n<li>集合操作</li>\n</ul>\n<p>SpEL 要放到<code>#{ ... }</code>中，与属性占位符放到<code>${ ... }</code>中类似。对于下面的表达式</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">#{T(System).currentTimeMillis()}</span><br></pre></td></tr></tbody></table></figure>\n<p>将得到表达式计算的那一刻时间的毫秒数。<code>T()</code>表达式将其中参数视为 Java 中的类型，从而可以调用该类型的静态方法。</p>\n<p><code>#{ ... }</code>中既可以放字面值如整数、浮点数、字符串、布尔值，也可以引用对象属性和方法</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">#{sgtPeppers.artist}</span><br><span class=\"line\"></span><br><span class=\"line\">#{systemProperties[<span class=\"string\">'sgtPeppers.title'</span>]}</span><br><span class=\"line\"></span><br><span class=\"line\">#{sgtPeppers.toString()?.toUpperCase}</span><br></pre></td></tr></tbody></table></figure>\n<p>上面的第二个表达式将调用<code>properties</code>文件中<code>sgtPeppers</code>的<code>title</code>属性值。第三个参数表示我们可以对方法返回值使用安全调用</p>\n<p>SpEL 支持各种常用的运算，包括算术运算、比较运算、逻辑运算、条件运算（<code>? :</code>和<code>?:</code>）、正则表达式（<code>matches</code>），下面是一个正则表达式的例子，用以验证邮箱</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">#{admin.email matches <span class=\"string\">'[a-zA-Z0-9._&+-]+@[a-zA-Z0-9._&+-]'</span>+\\\\.com}</span><br></pre></td></tr></tbody></table></figure>\n<p>下面是一个操作集合的例子</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">#{cd.tracks[<span class=\"number\">1</span>].title}</span><br><span class=\"line\"></span><br><span class=\"line\">#{<span class=\"string\">'the string'</span>[<span class=\"number\">1</span>]} <span class=\"comment\">//得到 h</span></span><br><span class=\"line\"></span><br><span class=\"line\">#{cd.tracks.?[title eq <span class=\"string\">'Title'</span>} <span class=\"comment\">//得到 title 为 Title 的新集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">#{cd.tracks.^[title eq <span class=\"string\">'Title'</span>} <span class=\"comment\">//得到第一个 title 值为 Title 的元素</span></span><br><span class=\"line\">              </span><br><span class=\"line\">#{cd.tracks.$[title eq <span class=\"string\">'Title'</span>} <span class=\"comment\">//得到最后一个 title 值为 Title 的元素             </span></span><br><span class=\"line\"></span><br><span class=\"line\">#{cd.tracks.![title]} <span class=\"comment\">//得到 title 的集合</span></span><br></pre></td></tr></tbody></table></figure>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":11094,"excerpt":"<p>开发软件的过程中要涉及到不同的环境，需要配置不同的数据库配置、加密算法和外部环境的集成等组件，为此必须要考虑不同的环境下对应不同的配置。本文将从 Spring profile 出发，进而介绍条件化的 Bean 声明、自动装配的歧义性和 Bean 的作用域，以及 Spring 表达式语言。</p>","more":"<p></p>\n<h2 id=\"Spring-profile\"><a href=\"#Spring-profile\" class=\"headerlink\" title=\"Spring profile\"></a>Spring profile</h2><h3 id=\"配置-profile\"><a href=\"#配置-profile\" class=\"headerlink\" title=\"配置 profile\"></a>配置 profile</h3><p>使用注解<code>@Profile</code>指定某个 Bean 属于哪一个 profile，以不同环境下的数据库 Bean 为例</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceConfig</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile(<span class=\"meta-string\">\"dev\"</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embeddedDataSource</span><span class=\"params\">()</span></span>: DataSource = EmbeddedDatabaseBuilder()</span><br><span class=\"line\">            .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"classpath:schema.sql\"</span>)</span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile(<span class=\"meta-string\">\"prod\"</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jndiDataSource</span><span class=\"params\">()</span></span>: DataSource &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> jndiObjectFactoryBean = JndiObjectFactoryBean()</span><br><span class=\"line\">        jndiObjectFactoryBean.jndiName = <span class=\"string\">\"jndi/myDS\"</span></span><br><span class=\"line\">        jndiObjectFactoryBean.isResourceRef = <span class=\"literal\">true</span></span><br><span class=\"line\">        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> jndiObjectFactoryBean.`<span class=\"keyword\">object</span>` <span class=\"keyword\">as</span> DataSource</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样支持使用 XML 文件配置 profile</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:jdbc</span>=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">profile</span>=<span class=\"string\">\"dev\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">jdbc:embedded-database</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource2\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbc:script</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:schema.sql\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt; /<span class=\"attr\">jdbc:embedded-database</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以将  profile 设置为<code>prod</code>，创建适用于生产环境的 JNDI 获取的 DataSource Bean，所有的配置文件都会被放进部署单元之中（如 WAR 文件），但是只有 profile 属性与当前激活 profile 相匹配的配置文件才会被使用。</p>\n<p>不过更方便的方法是把所有的 Bean 放进同一个配置文件中</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:jdbc</span>=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:jee</span>=<span class=\"string\">\"http://www.springframework.org/schema/jee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">profile</span>=<span class=\"string\">\"dev\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbc:embedded-database</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">jdbc:script</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:schema.sql\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">jdbc:embedded-database</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">profile</span>=<span class=\"string\">\"prod\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jee:jndi-lookup</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">jndi-name</span>=<span class=\"string\">\"jdbc/myDS\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">resource-ref</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">proxy-interface</span>=<span class=\"string\">\"javax.sql.DataSource\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"激活-profile\"><a href=\"#激活-profile\" class=\"headerlink\" title=\"激活 profile\"></a>激活 profile</h3><p>Spring 借助两个独立的属性<code>spring.profiles.active</code>、<code>spring.profiles.default</code>来确定哪个 profile 处于激活状态，优先级从高到低。如果两个值都没有设置，那就没有激活的 profile，此时只会创建那些没有定义在 profile 中的 Bean。以下是设置这两个属性的方式</p>\n<ul>\n<li>作为 DispatcherServlet 的初始化参数</li>\n<li>作为 Web 应用的上下文参数</li>\n<li>作为 JNDI 条目</li>\n<li>作为环境变量</li>\n<li>作为 JVM 的系统属性</li>\n<li>在集成测试类上，使用<code>@ActiveProfiles</code>注解设置</li>\n</ul>\n<p>例如在 Web 应用中，设置<code>spring.profiles.default</code>的 web.xml 文件如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://xmlns.jcp.org/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">version</span>=<span class=\"string\">\"4.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>spring.profiles.default<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>dev<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>spring.profiles.default<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>dev<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该文件分别为上下文和 Servlet 设置了默认的 profile。当应用程序部署到 QA、生产或者其他环境中时，负责部署的人根据情况使用系统属性、环境变量或 JNDI 设置<code>spring.profiles.active</code>即可——其优先级比<code>spring.profiles.default</code>高</p>\n<h2 id=\"条件化的-Bean\"><a href=\"#条件化的-Bean\" class=\"headerlink\" title=\"条件化的 Bean\"></a>条件化的 Bean</h2><p>使用 Spring 提供的注解<code>@Conditional</code>，可以实现 Bean 在符合条件的情况下才会配置的效果，不符合条件则该 Bean 会被忽略。下面的例子假设只有设置了<code>magic</code>环境属性时 Spring 才会实例化 MagicBean（事先准备），否则它将被忽略。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Conditional(MagicExistsCondition::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">magicBean</span><span class=\"params\">()</span></span>: MagicBean = MagicBean()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Conditional</code>需要一个<code>class</code>参数，并且该类要实现<code>Condition</code>接口，重写方法<code>match</code>，如果该方法返回 true 则创建带有<code>@Conditional</code>的 Bean。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicExistsCondition</span>: <span class=\"type\">Condition &#123;</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">matches</span><span class=\"params\">(p0: <span class=\"type\">ConditionContext</span>?, p1: <span class=\"type\">AnnotatedTypeMetadata</span>?)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> env = p0?.environment</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env?.containsProperty(<span class=\"string\">\"magic\"</span>) ?: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法传入两个参数，第一个为<code>ConditionContext</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConditionContext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">BeanDefinitionRegistry <span class=\"title\">getRegistry</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ConfigurableListableBeanFactory <span class=\"title\">getBeanFactory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Environment <span class=\"title\">getEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ResourceLoader <span class=\"title\">getResourceLoader</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ClassLoader <span class=\"title\">getClassLoader</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到该参数为我们提供了很多接口。第二个参数为<code>AnnotatedTypeMetadata</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAnnotated</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getAnnotationAttributes</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getAnnotationAttributes</span><span class=\"params\">(String var1, <span class=\"keyword\">boolean</span> var2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MultiValueMap&lt;String, Object&gt; <span class=\"title\">getAllAnnotationAttributes</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MultiValueMap&lt;String, Object&gt; <span class=\"title\">getAllAnnotationAttributes</span><span class=\"params\">(String var1, <span class=\"keyword\">boolean</span> var2)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该参数为我们提供了一系列检查<code>@Bean</code>方法上的其他注解的接口</p>\n<p>观察第一节提到的<code>Profile</code>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>(&#123;ProfileCondition.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Profile &#123;</span><br><span class=\"line\">    String[] value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到其本身也使用了<code>@Conditional</code>，引用<code>ProfileCondition.class</code>作为 Condition 实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProfileCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    ProfileCondition() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context.getEnvironment() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (attrs != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Iterator var4 = ((List)attrs.get(<span class=\"string\">\"value\"</span>)).iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">                Object value;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!var4.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    value = var4.next();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span>(!context.getEnvironment().acceptsProfiles((String[])((String[])value)));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类通过 AnnotatedTypeMetadata 获得用于<code>@Profile</code>注解的所有属性，然后检查<code>value</code>属性，得到<code>profile</code>名称。然后通过 ConditionContext 检查该<code>profile</code>是否激活</p>\n<h2 id=\"自动装配的歧义性\"><a href=\"#自动装配的歧义性\" class=\"headerlink\" title=\"自动装配的歧义性\"></a>自动装配的歧义性</h2><p>在自动装配中，只有当仅有一个 Bean 匹配所需的结果时，自动装配才是有效的，出现歧义则将阻碍 Spring 自动装配属性、构造器参数或方法参数。</p>\n<p>比如下面的例子，提供两个 CompactDisc 的实现类</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CompactDisc</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc &#123;</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlankDisc</span>: <span class=\"type\">CompactDisc &#123;</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码为</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [CDPlayerConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> cd: CompactDisc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    \tcd.play()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(cd: <span class=\"type\">CompactDisc</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cd = cd</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试将会报错</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of <span class=\"built_in\">type</span> <span class=\"string\">'soundsystem.CompactDisc'</span> available: expected single matching bean but found 2: blankDisc,sgtPeppers</span><br></pre></td></tr></table></figure>\n<p>针对这种情况，可以使用<code>@Primary</code>和<code>@Qualifier</code>解决</p>\n<h3 id=\"Primary\"><a href=\"#Primary\" class=\"headerlink\" title=\"@Primary\"></a>@Primary</h3><p>在其中一个实现上添加注解</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc &#123;</span></span></span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该注解也可以应用在 JavaConfig 代码中，在 XML 文件的配置方式为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sgtPeppers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.SgtPeppers\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">primary</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Qualifier\"><a href=\"#Qualifier\" class=\"headerlink\" title=\"@Qualifier\"></a>@Qualifier</h3><p>该注解比<code>@Primary</code>更加灵活，使用简单</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(<span class=\"meta-string\">\"sgtPeppers\"</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(cd: <span class=\"type\">CompactDisc</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cd = cd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为<code>@Qualifier</code>注解设置的参数就是想要注入的 Bean 的 id，一般为 Bean 的类名首字母变为小写之后的字符。当然开发者也可以自定义 Bean 的限定符防止重命名之后原来的注解失效</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(<span class=\"meta-string\">\"byBeatles\"</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> artist = <span class=\"string\">\"The Beatles\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Playing <span class=\"variable\">$title</span> by <span class=\"variable\">$artist</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相应的代码也更改为</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(<span class=\"meta-string\">\"byBeatles\"</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(cd: <span class=\"type\">CompactDisc</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cd = cd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更进一步，开发者可以自定义一个使用<code>@Qualifier</code>注解的注解类，防止以后再出现一个<code>byBeatles</code>的 Bean</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.<span class=\"keyword\">annotation</span>.Qualifier</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FIELD, AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FavoriteCD</span></span></span><br></pre></td></tr></table></figure>\n<p>使用方法和<code>@Qualifier(&quot;id&quot;)</code>类似，在需要注解的类上添加<code>@FavoriteCD</code>，然后在自动装配的地方同样使用该注解即可。</p>\n<h2 id=\"Bean-的作用域\"><a href=\"#Bean-的作用域\" class=\"headerlink\" title=\"Bean 的作用域\"></a>Bean 的作用域</h2><p> 在上一篇文章中我们提到 Spring 中的 Bean 默认是单例的，但是显然这样的实例将会保持一定的“状态”，因此重用将是不安全的。Spring 定义了多种 Bean 作用域</p>\n<ul>\n<li>单例（Singleton）：整个应用中只创建 Bean 的一个实例</li>\n<li>原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候都会创建一个新的实例</li>\n<li>会话（Session）：在 Web 应用中，为每个会话创建一个实例</li>\n<li>请求（Request）：在 Web 应用中，为每个请求创建一个实例</li>\n</ul>\n<p>要使用作用域，可以通过<code>@Scope</code>注解实现</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span></span></span><br></pre></td></tr></table></figure>\n<p>当然在自动装配的地方使用该注解也可以，XML 文件的配置方式同理，不再赘述</p>\n<h3 id=\"会话和请求作用域\"><a href=\"#会话和请求作用域\" class=\"headerlink\" title=\"会话和请求作用域\"></a>会话和请求作用域</h3><p>在典型的电子商务应用中，可能有一个 Bean 代表用户的购物车，当其为单例时意味着所有的用户共用一个购物车。这种情况下使用会话作用域显然更加合适</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(value = WebApplicationContext.SCOPE_SESSION,</span></span><br><span class=\"line\"><span class=\"meta\">        proxyMode = ScopedProxyMode..TARGET_CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoppingCart</span></span></span><br></pre></td></tr></table></figure>\n<p>注解的第一个参数<code>value</code>将告诉 Spring 为 Web 应用的每个会话创建一个 ShoppingCart，在会话相关的操作中其相当于一个单例。第二个参数<code>proxyMode</code>被设为<code>ScopedProxyMode.INTERFACES</code>，解决将会话或者请求作用域的 Bean 注入到单例 Bean 中所遇到的问题</p>\n<p>假设 ShoppingCart 注入到一个单例 StoreService 中，由于单例 Bean 会在 Spring 应用上下文加载的时候创建，然而此时属于会话作用域的 ShoppingCart 并不存在；此外，系统中将会有多个 ShoppingCart 实例，我们并不想让某一个固定的 ShoppingCart 实例到 StoreService 中，而是希望当 StoreService 处理购物车功能时，其所使用的 ShoppingCart 实例刚好是当前会话所对应的那个</p>\n<p><code>proxyMode</code>的作用就在于，Spring 不会将实际的 ShoppingCart 注入到 StoreService 中，而是将它的代理注入。这一代理会暴露与 ShoppingCart 相同的方法，所以 StoreService 会认为它就是一个购物车。当 StoreService 调用方法时，代理会进行懒解析并将调用委托到会话作用域内真正的 ShoppingCart 实例</p>\n<p>XML 方式配置不再赘述</p>\n<h2 id=\"Spring-表达式语言\"><a href=\"#Spring-表达式语言\" class=\"headerlink\" title=\"Spring 表达式语言\"></a>Spring 表达式语言</h2><p>Spring Expression Language，简称 SpEL，能够以一种强大和简洁的方式将值装配到 Bean 属性和构造器参数中。其有很多特性</p>\n<ul>\n<li>使用 ID 来引用 Bean</li>\n<li>调用方法和访问对象的属性</li>\n<li>对值进行算数、关系和逻辑运算</li>\n<li>正则表达式匹配</li>\n<li>集合操作</li>\n</ul>\n<p>SpEL 要放到<code>#{ ... }</code>中，与属性占位符放到<code>${ ... }</code>中类似。对于下面的表达式</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">#&#123;T(System).currentTimeMillis()&#125;</span><br></pre></td></tr></table></figure>\n<p>将得到表达式计算的那一刻时间的毫秒数。<code>T()</code>表达式将其中参数视为 Java 中的类型，从而可以调用该类型的静态方法。</p>\n<p><code>#{ ... }</code>中既可以放字面值如整数、浮点数、字符串、布尔值，也可以引用对象属性和方法</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">#&#123;sgtPeppers.artist&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#&#123;systemProperties[<span class=\"string\">'sgtPeppers.title'</span>]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#&#123;sgtPeppers.toString()?.toUpperCase&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的第二个表达式将调用<code>properties</code>文件中<code>sgtPeppers</code>的<code>title</code>属性值。第三个参数表示我们可以对方法返回值使用安全调用</p>\n<p>SpEL 支持各种常用的运算，包括算术运算、比较运算、逻辑运算、条件运算（<code>? :</code>和<code>?:</code>）、正则表达式（<code>matches</code>），下面是一个正则表达式的例子，用以验证邮箱</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">#&#123;admin.email matches <span class=\"string\">'[a-zA-Z0-9._&amp;+-]+@[a-zA-Z0-9._&amp;+-]'</span>+\\\\.com&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是一个操作集合的例子</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">#&#123;cd.tracks[<span class=\"number\">1</span>].title&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#&#123;<span class=\"string\">'the string'</span>[<span class=\"number\">1</span>]&#125; <span class=\"comment\">//得到 h</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&#123;cd.tracks.?[title eq <span class=\"string\">'Title'</span>&#125; <span class=\"comment\">//得到 title 为 Title 的新集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&#123;cd.tracks.^[title eq <span class=\"string\">'Title'</span>&#125; <span class=\"comment\">//得到第一个 title 值为 Title 的元素</span></span><br><span class=\"line\">              </span><br><span class=\"line\">#&#123;cd.tracks.$[title eq <span class=\"string\">'Title'</span>&#125; <span class=\"comment\">//得到最后一个 title 值为 Title 的元素             </span></span><br><span class=\"line\"></span><br><span class=\"line\">#&#123;cd.tracks.![title]&#125; <span class=\"comment\">//得到 title 的集合</span></span><br></pre></td></tr></table></figure>"},{"title":"《红楼梦》读书笔记","date":"2019-04-24T03:35:40.000Z","_content":"\n完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促，不过更新周期可能会异常的漫长。\n\n<!--more-->\n\n## 第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀\n\n### 缘起\n\n> 曾历过一番梦幻之后，故将真事隐去，而借通灵说此《石头记》一书也，故曰“甄士隐”云云。\n>\n> \"....我虽不学无文，又何妨用假语村言敷演出来？亦可使闺阁昭传。复可破一时之闷，醒同人之目，不亦宜乎？\"故曰“贾雨村”云云。\n\n女娲补天所用三万六千五百零一块石头剩一块通灵，被一道人镌刻文字于其上，名《石头记》\n\n> 上面述着堕落之乡、投胎之处，以及家庭琐事、闺阁闲情、诗词谜语，倒还全备\n\n后所记录被空空道人所抄写，改《情僧录》，东鲁孔梅溪题《风月宝鉴》，曹雪芹于悼红轩批阅增删、分目录章节，题曰《金陵十二衩》，此为《石头记》缘起。曹雪芹题诗\n\n> 满纸荒唐言，一把辛酸泪。\n>\n> 都云作者痴，水解其中味！\n\n### 开篇\n\n姑苏城仁青巷中有一乡宦甄士隐，梦中忽逢一僧一道了结灵石公案。原来那石头各地游玩，入警幻仙子麾下，任赤霞宫神瑛侍者。因以甘露灌溉西方灵河绛珠草，结下姻缘。绛珠草为感谢雨露之惠，欲“还泪”解缘。一僧一道携一众风流冤家下凡。三人行至“太虚幻境”，两边有一对联\n\n> 假作真时真亦假\n>\n> 无为有处有还无\n\n甄士隐与附近葫芦庙穷儒贾雨村交好。中秋佳节两人畅饮，甄士隐资助贾雨村进京赶考后，独女英莲走失，家院因火灾烧成瓦砾，投靠岳父封肃遭受白眼非议。一日碰一跛足道人，听道人语有感\n\n> 金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧？训有方，保不定日后做强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛。昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。故荒唐，到头来都是“为他人作嫁衣裳”。\n\n便于道人飘飘而去。\n\n## 第二回 贾夫人仙逝扬州城　冷子兴演说荣国府\n\n贾雨村受甄士隐赠银、进京赶考，中了进士，升任本县太爷，遣人至封府答谢甄士隐，同时将当年在甄士隐家中回首相顾的丫头娇杏娶作二房。然其恃才贪腐，不到一年便被革职，于是前往各地游览。\n\n游至维扬时，入当朝盐政官林如海府中给其幼女林黛玉作西席。林如海年过五十，黛玉为嫡妻贾氏所生，聪明俊秀但体弱多病，其母一病身亡，需守丧尽礼，旧病复发。贾雨村便闲居无聊。\n\n一日贾雨村郊外村肆中偶遇旧友冷子兴，二人聊起荣、宁两府。宁国公与荣国公是一母同胞兄弟。宁国公贾演生有两子，长子贾代化同有两子，稍长之子贾敷早死，次子贾敬袭官，然而一味好道终日炼丹。贾敬有一子贾珍，生下一子名贾蓉。荣国公贾源的长子贾代善在其去世后袭官，娶金陵世家史侯的小姐为妻，生有两子，长子贾赦袭官，次子贾政任员外郎。贾政夫人王氏生下二胎女儿十几年后，竟又生一嘴衔五彩晶玉的男孩，其名贾宝玉。\n\n贾宝玉抓阄时只取脂粉钗环，引得贾政不喜。如今十来岁，淘气异常，聪明乖觉，自言\n\n> 女儿是水做的骨肉，男子是泥做的骨肉。我见了女儿便清爽，建了男子便觉浊臭逼人。\n>\n> 必得两个女儿陪着我读书，我方能认得字，心上也明白，不然我心里自己糊涂\n>\n> 这女儿两个字极尊贵极清静的，比那瑞兽珍禽、奇花异草更觉稀罕尊贵\n\n贾雨村道天下运隆，清明灵秀之气比比皆是，与那残忍乖邪之气搏击掀发。邪气附于人，上则不能为仁人君子、下亦不能为大凶大恶，正所谓“成则公侯败则贼”。复感慨其必不能守祖父基业、从师友规劝。\n\n贾政长女因正月初一出生，故名元春、贤孝才德，入宫作女史官；二女名迎春，三女名探春，四女名惜春，俱在祖母身边读书。林如海其妻、林黛玉其母名贾敏，原来是贾赦、贾政胞妹。贾赦有一子稍长于宝玉，名贾琏，娶了贾政夫人王氏的侄女，模样极标志、言谈又爽利、心机又极深细，正是王熙凤。\n\n\n## 第三回 托内兄如海荐西宾　接外孙贾母惜孤女\n\n都中（一说南京）要起复旧员，林如海为贾雨村写荐书投身贾政，恰巧林黛玉祖母念其无人依傍，派遣船只接其入贾府，两人便一同进京。\n\n黛玉弃舟登岸后，有轿子伺候，行半日见一大门，有匾`敕造宁国府`，往西不远一大门，正是`荣国府`。贾母一见黛玉，搂入怀中，“心肝儿肉”叫着大哭，旁人无不下泪。不一时有三位姑娘前来接客，正是迎、探、惜春三姐妹\n\n> 第一个肌肤微丰，身材合中，腮凝新荔，鼻腻鹅脂，温柔沉默，观之可亲。第二个削肩细腰，长挑身材，鸭蛋脸儿，俊眼修眉，顾盼神飞，文彩精华，见之忘俗。第三个身量未足，形容尚小。其钗环裙袄，三人皆是一样的妆束。\n\n黛玉谈起自己的病患，言其三岁时有一癞头和尚要其出家，父母不从，和尚便说\n\n> 既舍不得他，但只怕他的病一生也不能好的！若要好时，除非从此以后总不许见哭声...方可平安了此一生\n\n此时后院中有笑语声，“我来迟了，没得迎接远客！”黛玉思忖旁人皆敛声屏气，唯独此人放诞无礼。来者正是王熙凤\n\n> 彩绣辉煌，恍若神妃仙子。头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗，项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩，身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂，下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未启笑先闻\n\n相互打过招呼，王熙凤笑道，“天下竟有这样标致人儿！我今日才算看见了！”又交代好贾府上下事务。 \n\n黛玉在丫鬟嬷嬷带领下拜见王夫人，用膳饮茶，正巧宝玉归来由寺庙还原归来\n\n> 头上戴着束发嵌宝紫金冠，齐眉勒着二龙抢珠金抹额，穿一件二色金百蝶穿花大红箭袖，束着五彩丝攒花结长穗宫绦，外罩石青起花八团倭锻排穗褂，登着青缎粉底小朝靴。面若中秋之月，色如春晓之花，鬓若刀裁，眉如墨画，面如桃瓣，目若秋波。虽怒时而若笑，即瞋视而有情。项上金螭璎珞，又有一根五色丝绦，系着一块美玉\n\n黛玉心惊，“好生奇怪，倒像在那里见过的，何等眼熟！”宝玉见过其母，又换一身行头\n\n> 身上穿着银红撒花半旧大袄，仍旧带着项圈、宝玉、寄名锁、护身\n> 符等物，下面半露松绿撒花绫裤，锦边弹墨袜，厚底大红鞋。越显得面如傅粉，唇\n> 若施脂，转盼多情，语言若笑。天然一段风韵，全在眉梢；平生万种情思，悉堆眼\n> 角\n\n有词曰\n\n> 无故寻愁觅恨，有时似傻如狂。纵然生得好皮囊，腹内原来草莽。\n>\n> 潦倒不通庶务，愚顽怕读文章。行为偏僻性乖张，那管世人诽谤！\n>\n> 富贵不知乐业，贫穷难耐凄凉。可怜辜负好时光，于国于家无望。\n>\n> 天下无能第一，古今不肖无双。寄言纨绔与膏粱：莫效此儿形状！\n\n宝玉见了黛玉，细看形容，与众各别\n\n> 两弯似蹙非蹙罥烟眉，一双似喜非喜含情目。态生两靥之愁，娇袭一身之病。泪光点点，娇喘微微。闲静时如姣花照水，行动处似弱柳扶风。心较比干多一窍，病如西子胜三分。\n\n看罢笑道：“这个妹妹我曾见过的。”又问黛玉是否有玉，黛玉答无，发起痴狂，便欲摔玉。\n\n黛玉安置于贾府碧纱橱，身旁有奶娘王嬷嬷、随身丫头雪雁、鹦哥，外又有宝玉乳母李嬷嬷、大丫鬟袭人服侍。袭人本名花珍珠，贾母溺爱宝玉，便令心地纯良、恪尽职守的袭人侍奉宝玉。宝玉曾见诗云“花气袭人”，便命其改名。\n\n次日贾府收到金陵书信，说是城中所居薛家姨母之子薛蟠，倚财仗势，闹出了人命。\n\n## 第四回 薄命女偏逢薄命郎　葫芦僧乱判葫芦案","source":"_posts/《红楼梦》读书笔记.md","raw":"---\ntitle: 《红楼梦》读书笔记\ndate: 2019-04-24 11:35:40\ntags:\n- 文学\n- 笔记\n- 红楼梦\ncategories:\n- 文学\n---\n\n完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促，不过更新周期可能会异常的漫长。\n\n<!--more-->\n\n## 第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀\n\n### 缘起\n\n> 曾历过一番梦幻之后，故将真事隐去，而借通灵说此《石头记》一书也，故曰“甄士隐”云云。\n>\n> \"....我虽不学无文，又何妨用假语村言敷演出来？亦可使闺阁昭传。复可破一时之闷，醒同人之目，不亦宜乎？\"故曰“贾雨村”云云。\n\n女娲补天所用三万六千五百零一块石头剩一块通灵，被一道人镌刻文字于其上，名《石头记》\n\n> 上面述着堕落之乡、投胎之处，以及家庭琐事、闺阁闲情、诗词谜语，倒还全备\n\n后所记录被空空道人所抄写，改《情僧录》，东鲁孔梅溪题《风月宝鉴》，曹雪芹于悼红轩批阅增删、分目录章节，题曰《金陵十二衩》，此为《石头记》缘起。曹雪芹题诗\n\n> 满纸荒唐言，一把辛酸泪。\n>\n> 都云作者痴，水解其中味！\n\n### 开篇\n\n姑苏城仁青巷中有一乡宦甄士隐，梦中忽逢一僧一道了结灵石公案。原来那石头各地游玩，入警幻仙子麾下，任赤霞宫神瑛侍者。因以甘露灌溉西方灵河绛珠草，结下姻缘。绛珠草为感谢雨露之惠，欲“还泪”解缘。一僧一道携一众风流冤家下凡。三人行至“太虚幻境”，两边有一对联\n\n> 假作真时真亦假\n>\n> 无为有处有还无\n\n甄士隐与附近葫芦庙穷儒贾雨村交好。中秋佳节两人畅饮，甄士隐资助贾雨村进京赶考后，独女英莲走失，家院因火灾烧成瓦砾，投靠岳父封肃遭受白眼非议。一日碰一跛足道人，听道人语有感\n\n> 金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧？训有方，保不定日后做强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛。昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。故荒唐，到头来都是“为他人作嫁衣裳”。\n\n便于道人飘飘而去。\n\n## 第二回 贾夫人仙逝扬州城　冷子兴演说荣国府\n\n贾雨村受甄士隐赠银、进京赶考，中了进士，升任本县太爷，遣人至封府答谢甄士隐，同时将当年在甄士隐家中回首相顾的丫头娇杏娶作二房。然其恃才贪腐，不到一年便被革职，于是前往各地游览。\n\n游至维扬时，入当朝盐政官林如海府中给其幼女林黛玉作西席。林如海年过五十，黛玉为嫡妻贾氏所生，聪明俊秀但体弱多病，其母一病身亡，需守丧尽礼，旧病复发。贾雨村便闲居无聊。\n\n一日贾雨村郊外村肆中偶遇旧友冷子兴，二人聊起荣、宁两府。宁国公与荣国公是一母同胞兄弟。宁国公贾演生有两子，长子贾代化同有两子，稍长之子贾敷早死，次子贾敬袭官，然而一味好道终日炼丹。贾敬有一子贾珍，生下一子名贾蓉。荣国公贾源的长子贾代善在其去世后袭官，娶金陵世家史侯的小姐为妻，生有两子，长子贾赦袭官，次子贾政任员外郎。贾政夫人王氏生下二胎女儿十几年后，竟又生一嘴衔五彩晶玉的男孩，其名贾宝玉。\n\n贾宝玉抓阄时只取脂粉钗环，引得贾政不喜。如今十来岁，淘气异常，聪明乖觉，自言\n\n> 女儿是水做的骨肉，男子是泥做的骨肉。我见了女儿便清爽，建了男子便觉浊臭逼人。\n>\n> 必得两个女儿陪着我读书，我方能认得字，心上也明白，不然我心里自己糊涂\n>\n> 这女儿两个字极尊贵极清静的，比那瑞兽珍禽、奇花异草更觉稀罕尊贵\n\n贾雨村道天下运隆，清明灵秀之气比比皆是，与那残忍乖邪之气搏击掀发。邪气附于人，上则不能为仁人君子、下亦不能为大凶大恶，正所谓“成则公侯败则贼”。复感慨其必不能守祖父基业、从师友规劝。\n\n贾政长女因正月初一出生，故名元春、贤孝才德，入宫作女史官；二女名迎春，三女名探春，四女名惜春，俱在祖母身边读书。林如海其妻、林黛玉其母名贾敏，原来是贾赦、贾政胞妹。贾赦有一子稍长于宝玉，名贾琏，娶了贾政夫人王氏的侄女，模样极标志、言谈又爽利、心机又极深细，正是王熙凤。\n\n\n## 第三回 托内兄如海荐西宾　接外孙贾母惜孤女\n\n都中（一说南京）要起复旧员，林如海为贾雨村写荐书投身贾政，恰巧林黛玉祖母念其无人依傍，派遣船只接其入贾府，两人便一同进京。\n\n黛玉弃舟登岸后，有轿子伺候，行半日见一大门，有匾`敕造宁国府`，往西不远一大门，正是`荣国府`。贾母一见黛玉，搂入怀中，“心肝儿肉”叫着大哭，旁人无不下泪。不一时有三位姑娘前来接客，正是迎、探、惜春三姐妹\n\n> 第一个肌肤微丰，身材合中，腮凝新荔，鼻腻鹅脂，温柔沉默，观之可亲。第二个削肩细腰，长挑身材，鸭蛋脸儿，俊眼修眉，顾盼神飞，文彩精华，见之忘俗。第三个身量未足，形容尚小。其钗环裙袄，三人皆是一样的妆束。\n\n黛玉谈起自己的病患，言其三岁时有一癞头和尚要其出家，父母不从，和尚便说\n\n> 既舍不得他，但只怕他的病一生也不能好的！若要好时，除非从此以后总不许见哭声...方可平安了此一生\n\n此时后院中有笑语声，“我来迟了，没得迎接远客！”黛玉思忖旁人皆敛声屏气，唯独此人放诞无礼。来者正是王熙凤\n\n> 彩绣辉煌，恍若神妃仙子。头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗，项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩，身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂，下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未启笑先闻\n\n相互打过招呼，王熙凤笑道，“天下竟有这样标致人儿！我今日才算看见了！”又交代好贾府上下事务。 \n\n黛玉在丫鬟嬷嬷带领下拜见王夫人，用膳饮茶，正巧宝玉归来由寺庙还原归来\n\n> 头上戴着束发嵌宝紫金冠，齐眉勒着二龙抢珠金抹额，穿一件二色金百蝶穿花大红箭袖，束着五彩丝攒花结长穗宫绦，外罩石青起花八团倭锻排穗褂，登着青缎粉底小朝靴。面若中秋之月，色如春晓之花，鬓若刀裁，眉如墨画，面如桃瓣，目若秋波。虽怒时而若笑，即瞋视而有情。项上金螭璎珞，又有一根五色丝绦，系着一块美玉\n\n黛玉心惊，“好生奇怪，倒像在那里见过的，何等眼熟！”宝玉见过其母，又换一身行头\n\n> 身上穿着银红撒花半旧大袄，仍旧带着项圈、宝玉、寄名锁、护身\n> 符等物，下面半露松绿撒花绫裤，锦边弹墨袜，厚底大红鞋。越显得面如傅粉，唇\n> 若施脂，转盼多情，语言若笑。天然一段风韵，全在眉梢；平生万种情思，悉堆眼\n> 角\n\n有词曰\n\n> 无故寻愁觅恨，有时似傻如狂。纵然生得好皮囊，腹内原来草莽。\n>\n> 潦倒不通庶务，愚顽怕读文章。行为偏僻性乖张，那管世人诽谤！\n>\n> 富贵不知乐业，贫穷难耐凄凉。可怜辜负好时光，于国于家无望。\n>\n> 天下无能第一，古今不肖无双。寄言纨绔与膏粱：莫效此儿形状！\n\n宝玉见了黛玉，细看形容，与众各别\n\n> 两弯似蹙非蹙罥烟眉，一双似喜非喜含情目。态生两靥之愁，娇袭一身之病。泪光点点，娇喘微微。闲静时如姣花照水，行动处似弱柳扶风。心较比干多一窍，病如西子胜三分。\n\n看罢笑道：“这个妹妹我曾见过的。”又问黛玉是否有玉，黛玉答无，发起痴狂，便欲摔玉。\n\n黛玉安置于贾府碧纱橱，身旁有奶娘王嬷嬷、随身丫头雪雁、鹦哥，外又有宝玉乳母李嬷嬷、大丫鬟袭人服侍。袭人本名花珍珠，贾母溺爱宝玉，便令心地纯良、恪尽职守的袭人侍奉宝玉。宝玉曾见诗云“花气袭人”，便命其改名。\n\n次日贾府收到金陵书信，说是城中所居薛家姨母之子薛蟠，倚财仗势，闹出了人命。\n\n## 第四回 薄命女偏逢薄命郎　葫芦僧乱判葫芦案","slug":"《红楼梦》读书笔记","published":1,"updated":"2019-06-02T13:45:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqxz0040y4upvn33631d","content":"<p>完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促，不过更新周期可能会异常的漫长。</p>\n<a id=\"more\"></a>\n<h2 id=\"第一回-甄士隐梦幻识通灵-贾雨村风尘怀闺秀\"><a href=\"#第一回-甄士隐梦幻识通灵-贾雨村风尘怀闺秀\" class=\"headerlink\" title=\"第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀\"></a>第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀</h2><h3 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h3><blockquote>\n<p>曾历过一番梦幻之后，故将真事隐去，而借通灵说此《石头记》一书也，故曰“甄士隐”云云。</p>\n<p>“….我虽不学无文，又何妨用假语村言敷演出来？亦可使闺阁昭传。复可破一时之闷，醒同人之目，不亦宜乎？”故曰“贾雨村”云云。</p>\n</blockquote>\n<p>女娲补天所用三万六千五百零一块石头剩一块通灵，被一道人镌刻文字于其上，名《石头记》</p>\n<blockquote>\n<p>上面述着堕落之乡、投胎之处，以及家庭琐事、闺阁闲情、诗词谜语，倒还全备</p>\n</blockquote>\n<p>后所记录被空空道人所抄写，改《情僧录》，东鲁孔梅溪题《风月宝鉴》，曹雪芹于悼红轩批阅增删、分目录章节，题曰《金陵十二衩》，此为《石头记》缘起。曹雪芹题诗</p>\n<blockquote>\n<p>满纸荒唐言，一把辛酸泪。</p>\n<p>都云作者痴，水解其中味！</p>\n</blockquote>\n<h3 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h3><p>姑苏城仁青巷中有一乡宦甄士隐，梦中忽逢一僧一道了结灵石公案。原来那石头各地游玩，入警幻仙子麾下，任赤霞宫神瑛侍者。因以甘露灌溉西方灵河绛珠草，结下姻缘。绛珠草为感谢雨露之惠，欲“还泪”解缘。一僧一道携一众风流冤家下凡。三人行至“太虚幻境”，两边有一对联</p>\n<blockquote>\n<p>假作真时真亦假</p>\n<p>无为有处有还无</p>\n</blockquote>\n<p>甄士隐与附近葫芦庙穷儒贾雨村交好。中秋佳节两人畅饮，甄士隐资助贾雨村进京赶考后，独女英莲走失，家院因火灾烧成瓦砾，投靠岳父封肃遭受白眼非议。一日碰一跛足道人，听道人语有感</p>\n<blockquote>\n<p>金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧？训有方，保不定日后做强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛。昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。故荒唐，到头来都是“为他人作嫁衣裳”。</p>\n</blockquote>\n<p>便于道人飘飘而去。</p>\n<h2 id=\"第二回-贾夫人仙逝扬州城-冷子兴演说荣国府\"><a href=\"#第二回-贾夫人仙逝扬州城-冷子兴演说荣国府\" class=\"headerlink\" title=\"第二回 贾夫人仙逝扬州城　冷子兴演说荣国府\"></a>第二回 贾夫人仙逝扬州城　冷子兴演说荣国府</h2><p>贾雨村受甄士隐赠银、进京赶考，中了进士，升任本县太爷，遣人至封府答谢甄士隐，同时将当年在甄士隐家中回首相顾的丫头娇杏娶作二房。然其恃才贪腐，不到一年便被革职，于是前往各地游览。</p>\n<p>游至维扬时，入当朝盐政官林如海府中给其幼女林黛玉作西席。林如海年过五十，黛玉为嫡妻贾氏所生，聪明俊秀但体弱多病，其母一病身亡，需守丧尽礼，旧病复发。贾雨村便闲居无聊。</p>\n<p>一日贾雨村郊外村肆中偶遇旧友冷子兴，二人聊起荣、宁两府。宁国公与荣国公是一母同胞兄弟。宁国公贾演生有两子，长子贾代化同有两子，稍长之子贾敷早死，次子贾敬袭官，然而一味好道终日炼丹。贾敬有一子贾珍，生下一子名贾蓉。荣国公贾源的长子贾代善在其去世后袭官，娶金陵世家史侯的小姐为妻，生有两子，长子贾赦袭官，次子贾政任员外郎。贾政夫人王氏生下二胎女儿十几年后，竟又生一嘴衔五彩晶玉的男孩，其名贾宝玉。</p>\n<p>贾宝玉抓阄时只取脂粉钗环，引得贾政不喜。如今十来岁，淘气异常，聪明乖觉，自言</p>\n<blockquote>\n<p>女儿是水做的骨肉，男子是泥做的骨肉。我见了女儿便清爽，建了男子便觉浊臭逼人。</p>\n<p>必得两个女儿陪着我读书，我方能认得字，心上也明白，不然我心里自己糊涂</p>\n<p>这女儿两个字极尊贵极清静的，比那瑞兽珍禽、奇花异草更觉稀罕尊贵</p>\n</blockquote>\n<p>贾雨村道天下运隆，清明灵秀之气比比皆是，与那残忍乖邪之气搏击掀发。邪气附于人，上则不能为仁人君子、下亦不能为大凶大恶，正所谓“成则公侯败则贼”。复感慨其必不能守祖父基业、从师友规劝。</p>\n<p>贾政长女因正月初一出生，故名元春、贤孝才德，入宫作女史官；二女名迎春，三女名探春，四女名惜春，俱在祖母身边读书。林如海其妻、林黛玉其母名贾敏，原来是贾赦、贾政胞妹。贾赦有一子稍长于宝玉，名贾琏，娶了贾政夫人王氏的侄女，模样极标志、言谈又爽利、心机又极深细，正是王熙凤。</p>\n<h2 id=\"第三回-托内兄如海荐西宾-接外孙贾母惜孤女\"><a href=\"#第三回-托内兄如海荐西宾-接外孙贾母惜孤女\" class=\"headerlink\" title=\"第三回 托内兄如海荐西宾　接外孙贾母惜孤女\"></a>第三回 托内兄如海荐西宾　接外孙贾母惜孤女</h2><p>都中（一说南京）要起复旧员，林如海为贾雨村写荐书投身贾政，恰巧林黛玉祖母念其无人依傍，派遣船只接其入贾府，两人便一同进京。</p>\n<p>黛玉弃舟登岸后，有轿子伺候，行半日见一大门，有匾<code>敕造宁国府</code>，往西不远一大门，正是<code>荣国府</code>。贾母一见黛玉，搂入怀中，“心肝儿肉”叫着大哭，旁人无不下泪。不一时有三位姑娘前来接客，正是迎、探、惜春三姐妹</p>\n<blockquote>\n<p>第一个肌肤微丰，身材合中，腮凝新荔，鼻腻鹅脂，温柔沉默，观之可亲。第二个削肩细腰，长挑身材，鸭蛋脸儿，俊眼修眉，顾盼神飞，文彩精华，见之忘俗。第三个身量未足，形容尚小。其钗环裙袄，三人皆是一样的妆束。</p>\n</blockquote>\n<p>黛玉谈起自己的病患，言其三岁时有一癞头和尚要其出家，父母不从，和尚便说</p>\n<blockquote>\n<p>既舍不得他，但只怕他的病一生也不能好的！若要好时，除非从此以后总不许见哭声…方可平安了此一生</p>\n</blockquote>\n<p>此时后院中有笑语声，“我来迟了，没得迎接远客！”黛玉思忖旁人皆敛声屏气，唯独此人放诞无礼。来者正是王熙凤</p>\n<blockquote>\n<p>彩绣辉煌，恍若神妃仙子。头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗，项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩，身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂，下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未启笑先闻</p>\n</blockquote>\n<p>相互打过招呼，王熙凤笑道，“天下竟有这样标致人儿！我今日才算看见了！”又交代好贾府上下事务。 </p>\n<p>黛玉在丫鬟嬷嬷带领下拜见王夫人，用膳饮茶，正巧宝玉归来由寺庙还原归来</p>\n<blockquote>\n<p>头上戴着束发嵌宝紫金冠，齐眉勒着二龙抢珠金抹额，穿一件二色金百蝶穿花大红箭袖，束着五彩丝攒花结长穗宫绦，外罩石青起花八团倭锻排穗褂，登着青缎粉底小朝靴。面若中秋之月，色如春晓之花，鬓若刀裁，眉如墨画，面如桃瓣，目若秋波。虽怒时而若笑，即瞋视而有情。项上金螭璎珞，又有一根五色丝绦，系着一块美玉</p>\n</blockquote>\n<p>黛玉心惊，“好生奇怪，倒像在那里见过的，何等眼熟！”宝玉见过其母，又换一身行头</p>\n<blockquote>\n<p>身上穿着银红撒花半旧大袄，仍旧带着项圈、宝玉、寄名锁、护身<br>符等物，下面半露松绿撒花绫裤，锦边弹墨袜，厚底大红鞋。越显得面如傅粉，唇<br>若施脂，转盼多情，语言若笑。天然一段风韵，全在眉梢；平生万种情思，悉堆眼<br>角</p>\n</blockquote>\n<p>有词曰</p>\n<blockquote>\n<p>无故寻愁觅恨，有时似傻如狂。纵然生得好皮囊，腹内原来草莽。</p>\n<p>潦倒不通庶务，愚顽怕读文章。行为偏僻性乖张，那管世人诽谤！</p>\n<p>富贵不知乐业，贫穷难耐凄凉。可怜辜负好时光，于国于家无望。</p>\n<p>天下无能第一，古今不肖无双。寄言纨绔与膏粱：莫效此儿形状！</p>\n</blockquote>\n<p>宝玉见了黛玉，细看形容，与众各别</p>\n<blockquote>\n<p>两弯似蹙非蹙罥烟眉，一双似喜非喜含情目。态生两靥之愁，娇袭一身之病。泪光点点，娇喘微微。闲静时如姣花照水，行动处似弱柳扶风。心较比干多一窍，病如西子胜三分。</p>\n</blockquote>\n<p>看罢笑道：“这个妹妹我曾见过的。”又问黛玉是否有玉，黛玉答无，发起痴狂，便欲摔玉。</p>\n<p>黛玉安置于贾府碧纱橱，身旁有奶娘王嬷嬷、随身丫头雪雁、鹦哥，外又有宝玉乳母李嬷嬷、大丫鬟袭人服侍。袭人本名花珍珠，贾母溺爱宝玉，便令心地纯良、恪尽职守的袭人侍奉宝玉。宝玉曾见诗云“花气袭人”，便命其改名。</p>\n<p>次日贾府收到金陵书信，说是城中所居薛家姨母之子薛蟠，倚财仗势，闹出了人命。</p>\n<h2 id=\"第四回-薄命女偏逢薄命郎-葫芦僧乱判葫芦案\"><a href=\"#第四回-薄命女偏逢薄命郎-葫芦僧乱判葫芦案\" class=\"headerlink\" title=\"第四回 薄命女偏逢薄命郎　葫芦僧乱判葫芦案\"></a>第四回 薄命女偏逢薄命郎　葫芦僧乱判葫芦案</h2><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":2964,"excerpt":"<p>完整认真地读完一遍《红楼梦》，应该是长久以来的念想。小学时 ，四叔寄给我一套中华书局出版的四大名著，从那时开始与之结缘。中学至今，书读得不少，但终究没有一次认真细致地拜读这一古典著作。这篇读书笔记，主要是记录章节概括和精彩之处，同时也是对自己的督促，不过更新周期可能会异常的漫长。</p>","more":"<h2 id=\"第一回-甄士隐梦幻识通灵-贾雨村风尘怀闺秀\"><a href=\"#第一回-甄士隐梦幻识通灵-贾雨村风尘怀闺秀\" class=\"headerlink\" title=\"第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀\"></a>第一回 甄士隐梦幻识通灵　贾雨村风尘怀闺秀</h2><h3 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h3><blockquote>\n<p>曾历过一番梦幻之后，故将真事隐去，而借通灵说此《石头记》一书也，故曰“甄士隐”云云。</p>\n<p>“….我虽不学无文，又何妨用假语村言敷演出来？亦可使闺阁昭传。复可破一时之闷，醒同人之目，不亦宜乎？”故曰“贾雨村”云云。</p>\n</blockquote>\n<p>女娲补天所用三万六千五百零一块石头剩一块通灵，被一道人镌刻文字于其上，名《石头记》</p>\n<blockquote>\n<p>上面述着堕落之乡、投胎之处，以及家庭琐事、闺阁闲情、诗词谜语，倒还全备</p>\n</blockquote>\n<p>后所记录被空空道人所抄写，改《情僧录》，东鲁孔梅溪题《风月宝鉴》，曹雪芹于悼红轩批阅增删、分目录章节，题曰《金陵十二衩》，此为《石头记》缘起。曹雪芹题诗</p>\n<blockquote>\n<p>满纸荒唐言，一把辛酸泪。</p>\n<p>都云作者痴，水解其中味！</p>\n</blockquote>\n<h3 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h3><p>姑苏城仁青巷中有一乡宦甄士隐，梦中忽逢一僧一道了结灵石公案。原来那石头各地游玩，入警幻仙子麾下，任赤霞宫神瑛侍者。因以甘露灌溉西方灵河绛珠草，结下姻缘。绛珠草为感谢雨露之惠，欲“还泪”解缘。一僧一道携一众风流冤家下凡。三人行至“太虚幻境”，两边有一对联</p>\n<blockquote>\n<p>假作真时真亦假</p>\n<p>无为有处有还无</p>\n</blockquote>\n<p>甄士隐与附近葫芦庙穷儒贾雨村交好。中秋佳节两人畅饮，甄士隐资助贾雨村进京赶考后，独女英莲走失，家院因火灾烧成瓦砾，投靠岳父封肃遭受白眼非议。一日碰一跛足道人，听道人语有感</p>\n<blockquote>\n<p>金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧？训有方，保不定日后做强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛。昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。故荒唐，到头来都是“为他人作嫁衣裳”。</p>\n</blockquote>\n<p>便于道人飘飘而去。</p>\n<h2 id=\"第二回-贾夫人仙逝扬州城-冷子兴演说荣国府\"><a href=\"#第二回-贾夫人仙逝扬州城-冷子兴演说荣国府\" class=\"headerlink\" title=\"第二回 贾夫人仙逝扬州城　冷子兴演说荣国府\"></a>第二回 贾夫人仙逝扬州城　冷子兴演说荣国府</h2><p>贾雨村受甄士隐赠银、进京赶考，中了进士，升任本县太爷，遣人至封府答谢甄士隐，同时将当年在甄士隐家中回首相顾的丫头娇杏娶作二房。然其恃才贪腐，不到一年便被革职，于是前往各地游览。</p>\n<p>游至维扬时，入当朝盐政官林如海府中给其幼女林黛玉作西席。林如海年过五十，黛玉为嫡妻贾氏所生，聪明俊秀但体弱多病，其母一病身亡，需守丧尽礼，旧病复发。贾雨村便闲居无聊。</p>\n<p>一日贾雨村郊外村肆中偶遇旧友冷子兴，二人聊起荣、宁两府。宁国公与荣国公是一母同胞兄弟。宁国公贾演生有两子，长子贾代化同有两子，稍长之子贾敷早死，次子贾敬袭官，然而一味好道终日炼丹。贾敬有一子贾珍，生下一子名贾蓉。荣国公贾源的长子贾代善在其去世后袭官，娶金陵世家史侯的小姐为妻，生有两子，长子贾赦袭官，次子贾政任员外郎。贾政夫人王氏生下二胎女儿十几年后，竟又生一嘴衔五彩晶玉的男孩，其名贾宝玉。</p>\n<p>贾宝玉抓阄时只取脂粉钗环，引得贾政不喜。如今十来岁，淘气异常，聪明乖觉，自言</p>\n<blockquote>\n<p>女儿是水做的骨肉，男子是泥做的骨肉。我见了女儿便清爽，建了男子便觉浊臭逼人。</p>\n<p>必得两个女儿陪着我读书，我方能认得字，心上也明白，不然我心里自己糊涂</p>\n<p>这女儿两个字极尊贵极清静的，比那瑞兽珍禽、奇花异草更觉稀罕尊贵</p>\n</blockquote>\n<p>贾雨村道天下运隆，清明灵秀之气比比皆是，与那残忍乖邪之气搏击掀发。邪气附于人，上则不能为仁人君子、下亦不能为大凶大恶，正所谓“成则公侯败则贼”。复感慨其必不能守祖父基业、从师友规劝。</p>\n<p>贾政长女因正月初一出生，故名元春、贤孝才德，入宫作女史官；二女名迎春，三女名探春，四女名惜春，俱在祖母身边读书。林如海其妻、林黛玉其母名贾敏，原来是贾赦、贾政胞妹。贾赦有一子稍长于宝玉，名贾琏，娶了贾政夫人王氏的侄女，模样极标志、言谈又爽利、心机又极深细，正是王熙凤。</p>\n<h2 id=\"第三回-托内兄如海荐西宾-接外孙贾母惜孤女\"><a href=\"#第三回-托内兄如海荐西宾-接外孙贾母惜孤女\" class=\"headerlink\" title=\"第三回 托内兄如海荐西宾　接外孙贾母惜孤女\"></a>第三回 托内兄如海荐西宾　接外孙贾母惜孤女</h2><p>都中（一说南京）要起复旧员，林如海为贾雨村写荐书投身贾政，恰巧林黛玉祖母念其无人依傍，派遣船只接其入贾府，两人便一同进京。</p>\n<p>黛玉弃舟登岸后，有轿子伺候，行半日见一大门，有匾<code>敕造宁国府</code>，往西不远一大门，正是<code>荣国府</code>。贾母一见黛玉，搂入怀中，“心肝儿肉”叫着大哭，旁人无不下泪。不一时有三位姑娘前来接客，正是迎、探、惜春三姐妹</p>\n<blockquote>\n<p>第一个肌肤微丰，身材合中，腮凝新荔，鼻腻鹅脂，温柔沉默，观之可亲。第二个削肩细腰，长挑身材，鸭蛋脸儿，俊眼修眉，顾盼神飞，文彩精华，见之忘俗。第三个身量未足，形容尚小。其钗环裙袄，三人皆是一样的妆束。</p>\n</blockquote>\n<p>黛玉谈起自己的病患，言其三岁时有一癞头和尚要其出家，父母不从，和尚便说</p>\n<blockquote>\n<p>既舍不得他，但只怕他的病一生也不能好的！若要好时，除非从此以后总不许见哭声…方可平安了此一生</p>\n</blockquote>\n<p>此时后院中有笑语声，“我来迟了，没得迎接远客！”黛玉思忖旁人皆敛声屏气，唯独此人放诞无礼。来者正是王熙凤</p>\n<blockquote>\n<p>彩绣辉煌，恍若神妃仙子。头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗，项上戴着赤金盘螭璎珞圈，裙边系着豆绿宫绦，双衡比目玫瑰佩，身上穿着缕金百蝶穿花大红洋缎窄褃袄，外罩五彩刻丝石青银鼠褂，下着翡翠撒花洋绉裙。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚，粉面含春威不露，丹唇未启笑先闻</p>\n</blockquote>\n<p>相互打过招呼，王熙凤笑道，“天下竟有这样标致人儿！我今日才算看见了！”又交代好贾府上下事务。 </p>\n<p>黛玉在丫鬟嬷嬷带领下拜见王夫人，用膳饮茶，正巧宝玉归来由寺庙还原归来</p>\n<blockquote>\n<p>头上戴着束发嵌宝紫金冠，齐眉勒着二龙抢珠金抹额，穿一件二色金百蝶穿花大红箭袖，束着五彩丝攒花结长穗宫绦，外罩石青起花八团倭锻排穗褂，登着青缎粉底小朝靴。面若中秋之月，色如春晓之花，鬓若刀裁，眉如墨画，面如桃瓣，目若秋波。虽怒时而若笑，即瞋视而有情。项上金螭璎珞，又有一根五色丝绦，系着一块美玉</p>\n</blockquote>\n<p>黛玉心惊，“好生奇怪，倒像在那里见过的，何等眼熟！”宝玉见过其母，又换一身行头</p>\n<blockquote>\n<p>身上穿着银红撒花半旧大袄，仍旧带着项圈、宝玉、寄名锁、护身<br>符等物，下面半露松绿撒花绫裤，锦边弹墨袜，厚底大红鞋。越显得面如傅粉，唇<br>若施脂，转盼多情，语言若笑。天然一段风韵，全在眉梢；平生万种情思，悉堆眼<br>角</p>\n</blockquote>\n<p>有词曰</p>\n<blockquote>\n<p>无故寻愁觅恨，有时似傻如狂。纵然生得好皮囊，腹内原来草莽。</p>\n<p>潦倒不通庶务，愚顽怕读文章。行为偏僻性乖张，那管世人诽谤！</p>\n<p>富贵不知乐业，贫穷难耐凄凉。可怜辜负好时光，于国于家无望。</p>\n<p>天下无能第一，古今不肖无双。寄言纨绔与膏粱：莫效此儿形状！</p>\n</blockquote>\n<p>宝玉见了黛玉，细看形容，与众各别</p>\n<blockquote>\n<p>两弯似蹙非蹙罥烟眉，一双似喜非喜含情目。态生两靥之愁，娇袭一身之病。泪光点点，娇喘微微。闲静时如姣花照水，行动处似弱柳扶风。心较比干多一窍，病如西子胜三分。</p>\n</blockquote>\n<p>看罢笑道：“这个妹妹我曾见过的。”又问黛玉是否有玉，黛玉答无，发起痴狂，便欲摔玉。</p>\n<p>黛玉安置于贾府碧纱橱，身旁有奶娘王嬷嬷、随身丫头雪雁、鹦哥，外又有宝玉乳母李嬷嬷、大丫鬟袭人服侍。袭人本名花珍珠，贾母溺爱宝玉，便令心地纯良、恪尽职守的袭人侍奉宝玉。宝玉曾见诗云“花气袭人”，便命其改名。</p>\n<p>次日贾府收到金陵书信，说是城中所居薛家姨母之子薛蟠，倚财仗势，闹出了人命。</p>\n<h2 id=\"第四回-薄命女偏逢薄命郎-葫芦僧乱判葫芦案\"><a href=\"#第四回-薄命女偏逢薄命郎-葫芦僧乱判葫芦案\" class=\"headerlink\" title=\"第四回 薄命女偏逢薄命郎　葫芦僧乱判葫芦案\"></a>第四回 薄命女偏逢薄命郎　葫芦僧乱判葫芦案</h2>"},{"title":"利用反射实现 DrawerLayout 全屏滑动","date":"2019-05-06T04:58:30.000Z","_content":"\n在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。<!--more-->\n\n## DrawerLayout 侧滑\n\n在 DrawerLayout 中定义了两个变量，分别对应 Gravity 为 Left 和 Right 的滑动情景，两者并无实质分别，本文只分析 Left 的情况。此外，DrawerLayout 包含三种状态，STATE_IDLE（已打开或已关闭），STATE_DRAGGING（正在拖动），STATE_SETTLING（执行打开或关闭的动画过程中）。\n\n```java\nprivate final ViewDragHelper mLeftDragger;\nprivate final ViewDragHelper mRightDragger;\n```\n\n 构造函数对一些变量做了初始化\n\n```java\nmLeftCallback = new ViewDragCallback(Gravity.LEFT);\n\nmLeftDragger = ViewDragHelper.create(this, TOUCH_SLOP_SENSITIVITY, mLeftCallback);\nmLeftDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);\nmLeftDragger.setMinVelocity(minVel);\nmLeftCallback.setDragger(mLeftDragger);\n```\n\nViewDraghelper 是官方提供的专门为自定义 ViewGroup 处理拖拽的手势类。此处用到的构造方法为\n\n```java\npublic static ViewDragHelper create(@NonNull ViewGroup forParent, float sensitivity,\n            @NonNull Callback cb)\n```\n\nDrawerLayout 中侧滑打开界面正是通过 ViewDragHelper 实现的，查看 DrawerLayout 的`onTouchEvent`方法\n\n```java\n@Override\npublic boolean onTouchEvent(MotionEvent ev) {\n\tmLeftDragger.processTouchEvent(ev);\n\tmRightDragger.processTouchEvent(ev);\n\n\tfinal int action = ev.getAction();\n\tboolean wantTouchEvents = true;\n\n\tswitch (action & MotionEvent.ACTION_MASK) {\n\t\t......\n\t}\n\n    return wantTouchEvents;\n}\n```\n\n其明显调用了 ViewDragHelper 的`processTouchEvent`方法处理 Touch 事件\n\n```java\npublic void processTouchEvent(MotionEvent ev) {\n\t......\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = ev.getPointerId(0);\n            //找到当前触摸点的最顶层的子View,作为需要操作的View\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n            //保存当前Touch点发生的初始状态\n            saveInitialMotion(x, y, pointerId);\n            //这里是点在一个正在滑动的侧滑栏上，使侧滑栏的状态由正在滑动状态变为正在拖动状态\n            tryCaptureViewForDrag(toCapture, pointerId);\n            //处理侧滑栏的触摸触发区域是否触摸，如果触摸则通知回调，在DrawerLayout中处理，执行一个侧滑微弹的操作，也就是稍微弹出一点，表示触发了侧滑操作\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched & mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n            }\n            break;\n        }\n    ......\n}\n\n```\n\n重点在`mInitialEdgesTouched[pointerId]`，其为一个保存边缘滑动值的 int 数组。在`saveInitialMotion`方法中发现其赋值过程\n\n```java\nprivate void saveInitialMotion(float x, float y, int pointerId) {\n\tensureMotionHistorySizeForId(pointerId);\n\tmInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;\n\tmInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;\n\tmInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y);\n\tmPointersDown |= 1 << pointerId;\n}\n```\n\n原来是调用了`getEdgesTouched`方法\n\n```java\nprivate int getEdgesTouched(int x, int y) {\n\tint result = 0;\n\n\tif (x < mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;\n\tif (y < mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;\n\tif (x > mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;\n\tif (y > mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;\n\n\treturn result;\n}\n```\n\n可以看到，该方法将判断`x < mParentView.get*() + mEdgeSize`，然后将对应的 result 返回。`mEdgeSize`即为边缘滑动的临界值，其初始化值为\n\n```java\nfinal float density = context.getResources().getDisplayMetrics().density;\nmEdgeSize = (int) (EDGE_SIZE * density + 0.5f);\n```\n\n因此，要让 DrawerLayout 支持全屏滑动打开侧滑菜单而不是边缘滑动，重点便是要修改该值，将其设为屏幕宽度。\n\n具体的反射代码（kotlin）\n\n```kotlin\n//获取 ViewDragHelper，更改 edgeSizeField\nval leftDraggerField = drawerLayout.javaClass.getDeclaredField(\"mLeftDragger\")\nleftDraggerField.isAccessible = true\nval leftDragger = leftDraggerField.get(drawerLayout) as ViewDragHelper\n\nval edgeSizeField = leftDragger.javaClass.getDeclaredField(\"mEdgeSize\")\nedgeSizeField.isAccessible = true\nval edgeSize = edgeSizeField.getInt(leftDragger)\n\nval displaySize = Point()\nactivity.windowManager.defaultDisplay.getSize(displaySize)\nedgeSizeField.setInt(leftDragger, displaySize.x)\n```\n\n\n\n## DrawerLayout 长按弹出\n\n[引言](#引言)\n\n在 DrawerLayout 中，用户在非侧滑界面的 mEdgeSize 范围内长按，侧滑界面将弹出。当我们修改 mEdgeSize 为屏幕宽度之后，用户所有的长按动作都将触发原来的弹出逻辑，而且触发范围为屏幕宽度，侧滑菜单将过度右移，造成左侧边缘有空白。\n\n原来是 DrawerLayout 的私有内部类 ViewDragCallback 重写了`onEdgeTouched`方法\n\n```java\nprivate class ViewDragCallback extends ViewDragHelper.Callback\n```\n\n```java\n@Override\npublic void onEdgeTouched(int edgeFlags, int pointerId) {\n\tpostDelayed(mPeekRunnable, PEEK_DELAY);\n}\n```\n\n该方法会执行一个 mPeekRunnable，其为内部类的私有 Runnable 类型的属性，其`run`方法执行了`peekDrawer`方法\n\n```java\nvoid peekDrawer() {\n\tfinal View toCapture;\n\tfinal int childLeft;\n\tfinal int peekDistance = mDragger.getEdgeSize();\n\tfinal boolean leftEdge = mAbsGravity == Gravity.LEFT;\n\tif (leftEdge) {\n\t\ttoCapture = findDrawerWithGravity(Gravity.LEFT);\n\t\tchildLeft = (toCapture != null ? -toCapture.getWidth() : 0) + peekDistance;\n\t} else {\n\t\ttoCapture = findDrawerWithGravity(Gravity.RIGHT);\n\t\tchildLeft = getWidth() - peekDistance;\n\t}\n\t// Only peek if it would mean making the drawer more visible and the drawer isn't locked\n\tif (toCapture != null && ((leftEdge && toCapture.getLeft() < childLeft)\n\t\t|| (!leftEdge && toCapture.getLeft() > childLeft))\n\t\t&& getDrawerLockMode(toCapture) == LOCK_MODE_UNLOCKED) {\n\t\tfinal LayoutParams lp = (LayoutParams) toCapture.getLayoutParams();\n\t\tmDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop());\n\t\tlp.isPeeking = true;\n\t\tinvalidate();\n\n\t\tcloseOtherDrawer();\n\t\tcancelChildViewTouch();\n\t}\n}\n```\n\n注意`mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop())`就是长按屏幕时，侧滑菜单会自动滑出来的原因。\n\n解决这个问题着实费了一番脑筋，因为 ViewDragCallback 为私有内部类，外部无法直接得到其引用。幸好观察之后发现其实现了 ViewDragHelper.Callback 接口，从而让我们可以利用多态的方式，获取其反射实例\n\n```kotlin\n//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”\n//更改其属性 mPeekRunnable\nval leftCallbackField = drawerLayout.javaClass.getDeclaredField(\"mLeftCallback\")\nleftCallbackField.isAccessible = true\n\n//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例\nval leftCallback = leftCallbackField.get(drawerLayout) as ViewDragHelper.Callback\n\nval peekRunnableField = leftCallback.javaClass.getDeclaredField(\"mPeekRunnable\")\npeekRunnableField.isAccessible = true\nval nullRunnable = Runnable {  }\npeekRunnableField.set(leftCallback, nullRunnable)\n```\n\n完美解决问题！\n\n最后便是构建一个工具类\n\n```kotlin\nobject DrawerLayoutHelper {\n\n    /**\n     * 通过反射的方式将 DrawerLayout 的侧滑范围设为全屏\n     * 该方法存在一个问题，在侧滑范围内长按，也会划出菜单\n     * 通过查看 DrawerLayout 的源码分析，其内部类 ViewDragCallback\n     * 重写了 onEdgeTouched 方法，然后调用一个 Runnable 属性的变量 “mPeekRunnable”\n     * 该变量调用了 peekDraw 方法，实现了长按划出侧滑菜单的功能\n     * 同样使用反射将该 Runnable 更改为空实现\n     *\n     * @param activity\n     * @param drawerLayout\n     * @param displayWidthPercentage\n     */\n    fun setDrawerLeftEdgeSize(activity: Activity?,\n                              drawerLayout: DrawerLayout?,\n                              displayWidthPercentage: Float) {\n        if (activity == null || drawerLayout == null) return\n        try {\n            //获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小\n            val leftDraggerField = drawerLayout.javaClass.getDeclaredField(\"mLeftDragger\")\n            leftDraggerField.isAccessible = true\n            val leftDragger = leftDraggerField.get(drawerLayout) as ViewDragHelper\n\n            val edgeSizeField = leftDragger.javaClass.getDeclaredField(\"mEdgeSize\")\n            edgeSizeField.isAccessible = true\n            val edgeSize = edgeSizeField.getInt(leftDragger)\n\n            val displaySize = Point()\n            activity.windowManager.defaultDisplay.getSize(displaySize)\n            edgeSizeField.setInt(leftDragger, Math.max(edgeSize, (displaySize.x * displayWidthPercentage).toInt()))\n\n            //获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”\n            //更改其属性 mPeekRunnable\n            val leftCallbackField = drawerLayout.javaClass.getDeclaredField(\"mLeftCallback\")\n            leftCallbackField.isAccessible = true\n\n            //因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例\n            val leftCallback = leftCallbackField.get(drawerLayout) as ViewDragHelper.Callback\n\n            val peekRunnableField = leftCallback.javaClass.getDeclaredField(\"mPeekRunnable\")\n            peekRunnableField.isAccessible = true\n            val nullRunnable = Runnable {  }\n            peekRunnableField.set(leftCallback, nullRunnable)\n\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    fun setDrawerLeftEdgeFullScreen(activity: Activity?, drawerLayout: DrawerLayout?) {\n        setDrawerLeftEdgeSize(activity, drawerLayout, 1.0f)\n    }\n}\n```\n\n","source":"_posts/利用反射实现-DrawerLayout-全屏滑动.md","raw":"---\ntitle: 利用反射实现 DrawerLayout 全屏滑动\ndate: 2019-05-06 12:58:30\ntags:\n- Android\n- 反射\ncategories:\n- Android\n---\n\n在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。<!--more-->\n\n## DrawerLayout 侧滑\n\n在 DrawerLayout 中定义了两个变量，分别对应 Gravity 为 Left 和 Right 的滑动情景，两者并无实质分别，本文只分析 Left 的情况。此外，DrawerLayout 包含三种状态，STATE_IDLE（已打开或已关闭），STATE_DRAGGING（正在拖动），STATE_SETTLING（执行打开或关闭的动画过程中）。\n\n```java\nprivate final ViewDragHelper mLeftDragger;\nprivate final ViewDragHelper mRightDragger;\n```\n\n 构造函数对一些变量做了初始化\n\n```java\nmLeftCallback = new ViewDragCallback(Gravity.LEFT);\n\nmLeftDragger = ViewDragHelper.create(this, TOUCH_SLOP_SENSITIVITY, mLeftCallback);\nmLeftDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);\nmLeftDragger.setMinVelocity(minVel);\nmLeftCallback.setDragger(mLeftDragger);\n```\n\nViewDraghelper 是官方提供的专门为自定义 ViewGroup 处理拖拽的手势类。此处用到的构造方法为\n\n```java\npublic static ViewDragHelper create(@NonNull ViewGroup forParent, float sensitivity,\n            @NonNull Callback cb)\n```\n\nDrawerLayout 中侧滑打开界面正是通过 ViewDragHelper 实现的，查看 DrawerLayout 的`onTouchEvent`方法\n\n```java\n@Override\npublic boolean onTouchEvent(MotionEvent ev) {\n\tmLeftDragger.processTouchEvent(ev);\n\tmRightDragger.processTouchEvent(ev);\n\n\tfinal int action = ev.getAction();\n\tboolean wantTouchEvents = true;\n\n\tswitch (action & MotionEvent.ACTION_MASK) {\n\t\t......\n\t}\n\n    return wantTouchEvents;\n}\n```\n\n其明显调用了 ViewDragHelper 的`processTouchEvent`方法处理 Touch 事件\n\n```java\npublic void processTouchEvent(MotionEvent ev) {\n\t......\n    switch (action) {\n        case MotionEvent.ACTION_DOWN: {\n            final float x = ev.getX();\n            final float y = ev.getY();\n            final int pointerId = ev.getPointerId(0);\n            //找到当前触摸点的最顶层的子View,作为需要操作的View\n            final View toCapture = findTopChildUnder((int) x, (int) y);\n            //保存当前Touch点发生的初始状态\n            saveInitialMotion(x, y, pointerId);\n            //这里是点在一个正在滑动的侧滑栏上，使侧滑栏的状态由正在滑动状态变为正在拖动状态\n            tryCaptureViewForDrag(toCapture, pointerId);\n            //处理侧滑栏的触摸触发区域是否触摸，如果触摸则通知回调，在DrawerLayout中处理，执行一个侧滑微弹的操作，也就是稍微弹出一点，表示触发了侧滑操作\n            final int edgesTouched = mInitialEdgesTouched[pointerId];\n            if ((edgesTouched & mTrackingEdges) != 0) {\n                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);\n            }\n            break;\n        }\n    ......\n}\n\n```\n\n重点在`mInitialEdgesTouched[pointerId]`，其为一个保存边缘滑动值的 int 数组。在`saveInitialMotion`方法中发现其赋值过程\n\n```java\nprivate void saveInitialMotion(float x, float y, int pointerId) {\n\tensureMotionHistorySizeForId(pointerId);\n\tmInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;\n\tmInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;\n\tmInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y);\n\tmPointersDown |= 1 << pointerId;\n}\n```\n\n原来是调用了`getEdgesTouched`方法\n\n```java\nprivate int getEdgesTouched(int x, int y) {\n\tint result = 0;\n\n\tif (x < mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;\n\tif (y < mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;\n\tif (x > mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;\n\tif (y > mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;\n\n\treturn result;\n}\n```\n\n可以看到，该方法将判断`x < mParentView.get*() + mEdgeSize`，然后将对应的 result 返回。`mEdgeSize`即为边缘滑动的临界值，其初始化值为\n\n```java\nfinal float density = context.getResources().getDisplayMetrics().density;\nmEdgeSize = (int) (EDGE_SIZE * density + 0.5f);\n```\n\n因此，要让 DrawerLayout 支持全屏滑动打开侧滑菜单而不是边缘滑动，重点便是要修改该值，将其设为屏幕宽度。\n\n具体的反射代码（kotlin）\n\n```kotlin\n//获取 ViewDragHelper，更改 edgeSizeField\nval leftDraggerField = drawerLayout.javaClass.getDeclaredField(\"mLeftDragger\")\nleftDraggerField.isAccessible = true\nval leftDragger = leftDraggerField.get(drawerLayout) as ViewDragHelper\n\nval edgeSizeField = leftDragger.javaClass.getDeclaredField(\"mEdgeSize\")\nedgeSizeField.isAccessible = true\nval edgeSize = edgeSizeField.getInt(leftDragger)\n\nval displaySize = Point()\nactivity.windowManager.defaultDisplay.getSize(displaySize)\nedgeSizeField.setInt(leftDragger, displaySize.x)\n```\n\n\n\n## DrawerLayout 长按弹出\n\n[引言](#引言)\n\n在 DrawerLayout 中，用户在非侧滑界面的 mEdgeSize 范围内长按，侧滑界面将弹出。当我们修改 mEdgeSize 为屏幕宽度之后，用户所有的长按动作都将触发原来的弹出逻辑，而且触发范围为屏幕宽度，侧滑菜单将过度右移，造成左侧边缘有空白。\n\n原来是 DrawerLayout 的私有内部类 ViewDragCallback 重写了`onEdgeTouched`方法\n\n```java\nprivate class ViewDragCallback extends ViewDragHelper.Callback\n```\n\n```java\n@Override\npublic void onEdgeTouched(int edgeFlags, int pointerId) {\n\tpostDelayed(mPeekRunnable, PEEK_DELAY);\n}\n```\n\n该方法会执行一个 mPeekRunnable，其为内部类的私有 Runnable 类型的属性，其`run`方法执行了`peekDrawer`方法\n\n```java\nvoid peekDrawer() {\n\tfinal View toCapture;\n\tfinal int childLeft;\n\tfinal int peekDistance = mDragger.getEdgeSize();\n\tfinal boolean leftEdge = mAbsGravity == Gravity.LEFT;\n\tif (leftEdge) {\n\t\ttoCapture = findDrawerWithGravity(Gravity.LEFT);\n\t\tchildLeft = (toCapture != null ? -toCapture.getWidth() : 0) + peekDistance;\n\t} else {\n\t\ttoCapture = findDrawerWithGravity(Gravity.RIGHT);\n\t\tchildLeft = getWidth() - peekDistance;\n\t}\n\t// Only peek if it would mean making the drawer more visible and the drawer isn't locked\n\tif (toCapture != null && ((leftEdge && toCapture.getLeft() < childLeft)\n\t\t|| (!leftEdge && toCapture.getLeft() > childLeft))\n\t\t&& getDrawerLockMode(toCapture) == LOCK_MODE_UNLOCKED) {\n\t\tfinal LayoutParams lp = (LayoutParams) toCapture.getLayoutParams();\n\t\tmDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop());\n\t\tlp.isPeeking = true;\n\t\tinvalidate();\n\n\t\tcloseOtherDrawer();\n\t\tcancelChildViewTouch();\n\t}\n}\n```\n\n注意`mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop())`就是长按屏幕时，侧滑菜单会自动滑出来的原因。\n\n解决这个问题着实费了一番脑筋，因为 ViewDragCallback 为私有内部类，外部无法直接得到其引用。幸好观察之后发现其实现了 ViewDragHelper.Callback 接口，从而让我们可以利用多态的方式，获取其反射实例\n\n```kotlin\n//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”\n//更改其属性 mPeekRunnable\nval leftCallbackField = drawerLayout.javaClass.getDeclaredField(\"mLeftCallback\")\nleftCallbackField.isAccessible = true\n\n//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例\nval leftCallback = leftCallbackField.get(drawerLayout) as ViewDragHelper.Callback\n\nval peekRunnableField = leftCallback.javaClass.getDeclaredField(\"mPeekRunnable\")\npeekRunnableField.isAccessible = true\nval nullRunnable = Runnable {  }\npeekRunnableField.set(leftCallback, nullRunnable)\n```\n\n完美解决问题！\n\n最后便是构建一个工具类\n\n```kotlin\nobject DrawerLayoutHelper {\n\n    /**\n     * 通过反射的方式将 DrawerLayout 的侧滑范围设为全屏\n     * 该方法存在一个问题，在侧滑范围内长按，也会划出菜单\n     * 通过查看 DrawerLayout 的源码分析，其内部类 ViewDragCallback\n     * 重写了 onEdgeTouched 方法，然后调用一个 Runnable 属性的变量 “mPeekRunnable”\n     * 该变量调用了 peekDraw 方法，实现了长按划出侧滑菜单的功能\n     * 同样使用反射将该 Runnable 更改为空实现\n     *\n     * @param activity\n     * @param drawerLayout\n     * @param displayWidthPercentage\n     */\n    fun setDrawerLeftEdgeSize(activity: Activity?,\n                              drawerLayout: DrawerLayout?,\n                              displayWidthPercentage: Float) {\n        if (activity == null || drawerLayout == null) return\n        try {\n            //获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小\n            val leftDraggerField = drawerLayout.javaClass.getDeclaredField(\"mLeftDragger\")\n            leftDraggerField.isAccessible = true\n            val leftDragger = leftDraggerField.get(drawerLayout) as ViewDragHelper\n\n            val edgeSizeField = leftDragger.javaClass.getDeclaredField(\"mEdgeSize\")\n            edgeSizeField.isAccessible = true\n            val edgeSize = edgeSizeField.getInt(leftDragger)\n\n            val displaySize = Point()\n            activity.windowManager.defaultDisplay.getSize(displaySize)\n            edgeSizeField.setInt(leftDragger, Math.max(edgeSize, (displaySize.x * displayWidthPercentage).toInt()))\n\n            //获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”\n            //更改其属性 mPeekRunnable\n            val leftCallbackField = drawerLayout.javaClass.getDeclaredField(\"mLeftCallback\")\n            leftCallbackField.isAccessible = true\n\n            //因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例\n            val leftCallback = leftCallbackField.get(drawerLayout) as ViewDragHelper.Callback\n\n            val peekRunnableField = leftCallback.javaClass.getDeclaredField(\"mPeekRunnable\")\n            peekRunnableField.isAccessible = true\n            val nullRunnable = Runnable {  }\n            peekRunnableField.set(leftCallback, nullRunnable)\n\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    fun setDrawerLeftEdgeFullScreen(activity: Activity?, drawerLayout: DrawerLayout?) {\n        setDrawerLeftEdgeSize(activity, drawerLayout, 1.0f)\n    }\n}\n```\n\n","slug":"利用反射实现-DrawerLayout-全屏滑动","published":1,"updated":"2019-06-02T05:04:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqy20043y4uptdn7bpia","content":"<p>在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。<a id=\"more\"></a></p>\n<h2 id=\"DrawerLayout-侧滑\"><a href=\"#DrawerLayout-侧滑\" class=\"headerlink\" title=\"DrawerLayout 侧滑\"></a>DrawerLayout 侧滑</h2><p>在 DrawerLayout 中定义了两个变量，分别对应 Gravity 为 Left 和 Right 的滑动情景，两者并无实质分别，本文只分析 Left 的情况。此外，DrawerLayout 包含三种状态，STATE_IDLE（已打开或已关闭），STATE_DRAGGING（正在拖动），STATE_SETTLING（执行打开或关闭的动画过程中）。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewDragHelper mLeftDragger;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewDragHelper mRightDragger;</span><br></pre></td></tr></tbody></table></figure>\n<p> 构造函数对一些变量做了初始化</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">mLeftCallback = <span class=\"keyword\">new</span> ViewDragCallback(Gravity.LEFT);</span><br><span class=\"line\"></span><br><span class=\"line\">mLeftDragger = ViewDragHelper.create(<span class=\"keyword\">this</span>, TOUCH_SLOP_SENSITIVITY, mLeftCallback);</span><br><span class=\"line\">mLeftDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);</span><br><span class=\"line\">mLeftDragger.setMinVelocity(minVel);</span><br><span class=\"line\">mLeftCallback.setDragger(mLeftDragger);</span><br></pre></td></tr></tbody></table></figure>\n<p>ViewDraghelper 是官方提供的专门为自定义 ViewGroup 处理拖拽的手势类。此处用到的构造方法为</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewDragHelper <span class=\"title\">create</span><span class=\"params\">(@NonNull ViewGroup forParent, <span class=\"keyword\">float</span> sensitivity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull Callback cb)</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>DrawerLayout 中侧滑打开界面正是通过 ViewDragHelper 实现的，查看 DrawerLayout 的<code>onTouchEvent</code>方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>{</span><br><span class=\"line\">\tmLeftDragger.processTouchEvent(ev);</span><br><span class=\"line\">\tmRightDragger.processTouchEvent(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = ev.getAction();</span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> wantTouchEvents = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (action & MotionEvent.ACTION_MASK) {</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wantTouchEvents;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>其明显调用了 ViewDragHelper 的<code>processTouchEvent</code>方法处理 Touch 事件</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>{</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action) {</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN: {</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> x = ev.getX();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> y = ev.getY();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">//找到当前触摸点的最顶层的子View,作为需要操作的View</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> View toCapture = findTopChildUnder((<span class=\"keyword\">int</span>) x, (<span class=\"keyword\">int</span>) y);</span><br><span class=\"line\">            <span class=\"comment\">//保存当前Touch点发生的初始状态</span></span><br><span class=\"line\">            saveInitialMotion(x, y, pointerId);</span><br><span class=\"line\">            <span class=\"comment\">//这里是点在一个正在滑动的侧滑栏上，使侧滑栏的状态由正在滑动状态变为正在拖动状态</span></span><br><span class=\"line\">            tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class=\"line\">            <span class=\"comment\">//处理侧滑栏的触摸触发区域是否触摸，如果触摸则通知回调，在DrawerLayout中处理，执行一个侧滑微弹的操作，也就是稍微弹出一点，表示触发了侧滑操作</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((edgesTouched & mTrackingEdges) != <span class=\"number\">0</span>) {</span><br><span class=\"line\">                mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    ......</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>重点在<code>mInitialEdgesTouched[pointerId]</code>，其为一个保存边缘滑动值的 int 数组。在<code>saveInitialMotion</code>方法中发现其赋值过程</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">saveInitialMotion</span><span class=\"params\">(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y, <span class=\"keyword\">int</span> pointerId)</span> </span>{</span><br><span class=\"line\">\tensureMotionHistorySizeForId(pointerId);</span><br><span class=\"line\">\tmInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;</span><br><span class=\"line\">\tmInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;</span><br><span class=\"line\">\tmInitialEdgesTouched[pointerId] = getEdgesTouched((<span class=\"keyword\">int</span>) x, (<span class=\"keyword\">int</span>) y);</span><br><span class=\"line\">\tmPointersDown |= <span class=\"number\">1</span> << pointerId;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>原来是调用了<code>getEdgesTouched</code>方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getEdgesTouched</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x < mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (y < mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x > mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (y > mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>可以看到，该方法将判断<code>x < mParentView.get*() + mEdgeSize</code>，然后将对应的 result 返回。<code>mEdgeSize</code>即为边缘滑动的临界值，其初始化值为</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class=\"line\">mEdgeSize = (<span class=\"keyword\">int</span>) (EDGE_SIZE * density + <span class=\"number\">0.5f</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>因此，要让 DrawerLayout 支持全屏滑动打开侧滑菜单而不是边缘滑动，重点便是要修改该值，将其设为屏幕宽度。</p>\n<p>具体的反射代码（kotlin）</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取 ViewDragHelper，更改 edgeSizeField</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftDraggerField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftDragger\"</span>)</span><br><span class=\"line\">leftDraggerField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftDragger = leftDraggerField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> edgeSizeField = leftDragger.javaClass.getDeclaredField(<span class=\"string\">\"mEdgeSize\"</span>)</span><br><span class=\"line\">edgeSizeField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> edgeSize = edgeSizeField.getInt(leftDragger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> displaySize = Point()</span><br><span class=\"line\">activity.windowManager.defaultDisplay.getSize(displaySize)</span><br><span class=\"line\">edgeSizeField.setInt(leftDragger, displaySize.x)</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"DrawerLayout-长按弹出\"><a href=\"#DrawerLayout-长按弹出\" class=\"headerlink\" title=\"DrawerLayout 长按弹出\"></a>DrawerLayout 长按弹出</h2><p><a href=\"#引言\">引言</a></p>\n<p>在 DrawerLayout 中，用户在非侧滑界面的 mEdgeSize 范围内长按，侧滑界面将弹出。当我们修改 mEdgeSize 为屏幕宽度之后，用户所有的长按动作都将触发原来的弹出逻辑，而且触发范围为屏幕宽度，侧滑菜单将过度右移，造成左侧边缘有空白。</p>\n<p>原来是 DrawerLayout 的私有内部类 ViewDragCallback 重写了<code>onEdgeTouched</code>方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewDragCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewDragHelper</span>.<span class=\"title\">Callback</span></span></span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEdgeTouched</span><span class=\"params\">(<span class=\"keyword\">int</span> edgeFlags, <span class=\"keyword\">int</span> pointerId)</span> </span>{</span><br><span class=\"line\">\tpostDelayed(mPeekRunnable, PEEK_DELAY);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>该方法会执行一个 mPeekRunnable，其为内部类的私有 Runnable 类型的属性，其<code>run</code>方法执行了<code>peekDrawer</code>方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">peekDrawer</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> View toCapture;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childLeft;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> peekDistance = mDragger.getEdgeSize();</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> leftEdge = mAbsGravity == Gravity.LEFT;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (leftEdge) {</span><br><span class=\"line\">\t\ttoCapture = findDrawerWithGravity(Gravity.LEFT);</span><br><span class=\"line\">\t\tchildLeft = (toCapture != <span class=\"keyword\">null</span> ? -toCapture.getWidth() : <span class=\"number\">0</span>) + peekDistance;</span><br><span class=\"line\">\t} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">\t\ttoCapture = findDrawerWithGravity(Gravity.RIGHT);</span><br><span class=\"line\">\t\tchildLeft = getWidth() - peekDistance;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t<span class=\"comment\">// Only peek if it would mean making the drawer more visible and the drawer isn't locked</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (toCapture != <span class=\"keyword\">null</span> && ((leftEdge && toCapture.getLeft() < childLeft)</span><br><span class=\"line\">\t\t|| (!leftEdge && toCapture.getLeft() > childLeft))</span><br><span class=\"line\">\t\t&& getDrawerLockMode(toCapture) == LOCK_MODE_UNLOCKED) {</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> LayoutParams lp = (LayoutParams) toCapture.getLayoutParams();</span><br><span class=\"line\">\t\tmDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop());</span><br><span class=\"line\">\t\tlp.isPeeking = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\tinvalidate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcloseOtherDrawer();</span><br><span class=\"line\">\t\tcancelChildViewTouch();</span><br><span class=\"line\">\t}</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>注意<code>mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop())</code>就是长按屏幕时，侧滑菜单会自动滑出来的原因。</p>\n<p>解决这个问题着实费了一番脑筋，因为 ViewDragCallback 为私有内部类，外部无法直接得到其引用。幸好观察之后发现其实现了 ViewDragHelper.Callback 接口，从而让我们可以利用多态的方式，获取其反射实例</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”</span></span><br><span class=\"line\"><span class=\"comment\">//更改其属性 mPeekRunnable</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftCallbackField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftCallback\"</span>)</span><br><span class=\"line\">leftCallbackField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftCallback = leftCallbackField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper.Callback</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> peekRunnableField = leftCallback.javaClass.getDeclaredField(<span class=\"string\">\"mPeekRunnable\"</span>)</span><br><span class=\"line\">peekRunnableField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> nullRunnable = Runnable {  }</span><br><span class=\"line\">peekRunnableField.<span class=\"keyword\">set</span>(leftCallback, nullRunnable)</span><br></pre></td></tr></tbody></table></figure>\n<p>完美解决问题！</p>\n<p>最后便是构建一个工具类</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> DrawerLayoutHelper {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过反射的方式将 DrawerLayout 的侧滑范围设为全屏</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法存在一个问题，在侧滑范围内长按，也会划出菜单</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过查看 DrawerLayout 的源码分析，其内部类 ViewDragCallback</span></span><br><span class=\"line\"><span class=\"comment\">     * 重写了 onEdgeTouched 方法，然后调用一个 Runnable 属性的变量 “mPeekRunnable”</span></span><br><span class=\"line\"><span class=\"comment\">     * 该变量调用了 peekDraw 方法，实现了长按划出侧滑菜单的功能</span></span><br><span class=\"line\"><span class=\"comment\">     * 同样使用反射将该 Runnable 更改为空实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> drawerLayout</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> displayWidthPercentage</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setDrawerLeftEdgeSize</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              drawerLayout: <span class=\"type\">DrawerLayout</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              displayWidthPercentage: <span class=\"type\">Float</span>)</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity == <span class=\"literal\">null</span> || drawerLayout == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            <span class=\"comment\">//获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftDraggerField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftDragger\"</span>)</span><br><span class=\"line\">            leftDraggerField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftDragger = leftDraggerField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> edgeSizeField = leftDragger.javaClass.getDeclaredField(<span class=\"string\">\"mEdgeSize\"</span>)</span><br><span class=\"line\">            edgeSizeField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> edgeSize = edgeSizeField.getInt(leftDragger)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> displaySize = Point()</span><br><span class=\"line\">            activity.windowManager.defaultDisplay.getSize(displaySize)</span><br><span class=\"line\">            edgeSizeField.setInt(leftDragger, Math.max(edgeSize, (displaySize.x * displayWidthPercentage).toInt()))</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”</span></span><br><span class=\"line\">            <span class=\"comment\">//更改其属性 mPeekRunnable</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftCallbackField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftCallback\"</span>)</span><br><span class=\"line\">            leftCallbackField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftCallback = leftCallbackField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper.Callback</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> peekRunnableField = leftCallback.javaClass.getDeclaredField(<span class=\"string\">\"mPeekRunnable\"</span>)</span><br><span class=\"line\">            peekRunnableField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> nullRunnable = Runnable {  }</span><br><span class=\"line\">            peekRunnableField.<span class=\"keyword\">set</span>(leftCallback, nullRunnable)</span><br><span class=\"line\"></span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (e: Exception) {</span><br><span class=\"line\">            e.printStackTrace()</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setDrawerLeftEdgeFullScreen</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>?, drawerLayout: <span class=\"type\">DrawerLayout</span>?)</span></span> {</span><br><span class=\"line\">        setDrawerLeftEdgeSize(activity, drawerLayout, <span class=\"number\">1.0f</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":8360,"excerpt":"<p>在一个项目中需要用到 DrawerLayout，但是其默认实现为边缘滑动打开侧滑界面，只能指定左边缘或者右边缘。想要实现全屏滑动，思路是通过反射的方式修改 DrawerLayout 的相应属性，涉及到枯燥的源码阅读。在完成全屏滑动之后，又发现其默认实现了长按弹出侧滑界面，在全屏滑动下，用户长按任何地方都会跳出侧滑菜单，而且还会出现留白问题。研究半天，还是利用反射的思路一并解决，特此记录。</p>","more":"<p></p>\n<h2 id=\"DrawerLayout-侧滑\"><a href=\"#DrawerLayout-侧滑\" class=\"headerlink\" title=\"DrawerLayout 侧滑\"></a>DrawerLayout 侧滑</h2><p>在 DrawerLayout 中定义了两个变量，分别对应 Gravity 为 Left 和 Right 的滑动情景，两者并无实质分别，本文只分析 Left 的情况。此外，DrawerLayout 包含三种状态，STATE_IDLE（已打开或已关闭），STATE_DRAGGING（正在拖动），STATE_SETTLING（执行打开或关闭的动画过程中）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewDragHelper mLeftDragger;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewDragHelper mRightDragger;</span><br></pre></td></tr></table></figure>\n<p> 构造函数对一些变量做了初始化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">mLeftCallback = <span class=\"keyword\">new</span> ViewDragCallback(Gravity.LEFT);</span><br><span class=\"line\"></span><br><span class=\"line\">mLeftDragger = ViewDragHelper.create(<span class=\"keyword\">this</span>, TOUCH_SLOP_SENSITIVITY, mLeftCallback);</span><br><span class=\"line\">mLeftDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);</span><br><span class=\"line\">mLeftDragger.setMinVelocity(minVel);</span><br><span class=\"line\">mLeftCallback.setDragger(mLeftDragger);</span><br></pre></td></tr></table></figure>\n<p>ViewDraghelper 是官方提供的专门为自定义 ViewGroup 处理拖拽的手势类。此处用到的构造方法为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewDragHelper <span class=\"title\">create</span><span class=\"params\">(@NonNull ViewGroup forParent, <span class=\"keyword\">float</span> sensitivity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull Callback cb)</span></span></span><br></pre></td></tr></table></figure>\n<p>DrawerLayout 中侧滑打开界面正是通过 ViewDragHelper 实现的，查看 DrawerLayout 的<code>onTouchEvent</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">\tmLeftDragger.processTouchEvent(ev);</span><br><span class=\"line\">\tmRightDragger.processTouchEvent(ev);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = ev.getAction();</span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> wantTouchEvents = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (action &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wantTouchEvents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其明显调用了 ViewDragHelper 的<code>processTouchEvent</code>方法处理 Touch 事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> x = ev.getX();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> y = ev.getY();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerId = ev.getPointerId(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">//找到当前触摸点的最顶层的子View,作为需要操作的View</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> View toCapture = findTopChildUnder((<span class=\"keyword\">int</span>) x, (<span class=\"keyword\">int</span>) y);</span><br><span class=\"line\">            <span class=\"comment\">//保存当前Touch点发生的初始状态</span></span><br><span class=\"line\">            saveInitialMotion(x, y, pointerId);</span><br><span class=\"line\">            <span class=\"comment\">//这里是点在一个正在滑动的侧滑栏上，使侧滑栏的状态由正在滑动状态变为正在拖动状态</span></span><br><span class=\"line\">            tryCaptureViewForDrag(toCapture, pointerId);</span><br><span class=\"line\">            <span class=\"comment\">//处理侧滑栏的触摸触发区域是否触摸，如果触摸则通知回调，在DrawerLayout中处理，执行一个侧滑微弹的操作，也就是稍微弹出一点，表示触发了侧滑操作</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点在<code>mInitialEdgesTouched[pointerId]</code>，其为一个保存边缘滑动值的 int 数组。在<code>saveInitialMotion</code>方法中发现其赋值过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">saveInitialMotion</span><span class=\"params\">(<span class=\"keyword\">float</span> x, <span class=\"keyword\">float</span> y, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">\tensureMotionHistorySizeForId(pointerId);</span><br><span class=\"line\">\tmInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;</span><br><span class=\"line\">\tmInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;</span><br><span class=\"line\">\tmInitialEdgesTouched[pointerId] = getEdgesTouched((<span class=\"keyword\">int</span>) x, (<span class=\"keyword\">int</span>) y);</span><br><span class=\"line\">\tmPointersDown |= <span class=\"number\">1</span> &lt;&lt; pointerId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来是调用了<code>getEdgesTouched</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getEdgesTouched</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x &lt; mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (y &lt; mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x &gt; mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (y &gt; mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，该方法将判断<code>x &lt; mParentView.get*() + mEdgeSize</code>，然后将对应的 result 返回。<code>mEdgeSize</code>即为边缘滑动的临界值，其初始化值为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class=\"line\">mEdgeSize = (<span class=\"keyword\">int</span>) (EDGE_SIZE * density + <span class=\"number\">0.5f</span>);</span><br></pre></td></tr></table></figure>\n<p>因此，要让 DrawerLayout 支持全屏滑动打开侧滑菜单而不是边缘滑动，重点便是要修改该值，将其设为屏幕宽度。</p>\n<p>具体的反射代码（kotlin）</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取 ViewDragHelper，更改 edgeSizeField</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftDraggerField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftDragger\"</span>)</span><br><span class=\"line\">leftDraggerField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftDragger = leftDraggerField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> edgeSizeField = leftDragger.javaClass.getDeclaredField(<span class=\"string\">\"mEdgeSize\"</span>)</span><br><span class=\"line\">edgeSizeField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> edgeSize = edgeSizeField.getInt(leftDragger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> displaySize = Point()</span><br><span class=\"line\">activity.windowManager.defaultDisplay.getSize(displaySize)</span><br><span class=\"line\">edgeSizeField.setInt(leftDragger, displaySize.x)</span><br></pre></td></tr></table></figure>\n<h2 id=\"DrawerLayout-长按弹出\"><a href=\"#DrawerLayout-长按弹出\" class=\"headerlink\" title=\"DrawerLayout 长按弹出\"></a>DrawerLayout 长按弹出</h2><p><a href=\"#引言\">引言</a></p>\n<p>在 DrawerLayout 中，用户在非侧滑界面的 mEdgeSize 范围内长按，侧滑界面将弹出。当我们修改 mEdgeSize 为屏幕宽度之后，用户所有的长按动作都将触发原来的弹出逻辑，而且触发范围为屏幕宽度，侧滑菜单将过度右移，造成左侧边缘有空白。</p>\n<p>原来是 DrawerLayout 的私有内部类 ViewDragCallback 重写了<code>onEdgeTouched</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewDragCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewDragHelper</span>.<span class=\"title\">Callback</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEdgeTouched</span><span class=\"params\">(<span class=\"keyword\">int</span> edgeFlags, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">\tpostDelayed(mPeekRunnable, PEEK_DELAY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法会执行一个 mPeekRunnable，其为内部类的私有 Runnable 类型的属性，其<code>run</code>方法执行了<code>peekDrawer</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">peekDrawer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> View toCapture;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childLeft;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> peekDistance = mDragger.getEdgeSize();</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> leftEdge = mAbsGravity == Gravity.LEFT;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (leftEdge) &#123;</span><br><span class=\"line\">\t\ttoCapture = findDrawerWithGravity(Gravity.LEFT);</span><br><span class=\"line\">\t\tchildLeft = (toCapture != <span class=\"keyword\">null</span> ? -toCapture.getWidth() : <span class=\"number\">0</span>) + peekDistance;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\ttoCapture = findDrawerWithGravity(Gravity.RIGHT);</span><br><span class=\"line\">\t\tchildLeft = getWidth() - peekDistance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Only peek if it would mean making the drawer more visible and the drawer isn't locked</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (toCapture != <span class=\"keyword\">null</span> &amp;&amp; ((leftEdge &amp;&amp; toCapture.getLeft() &lt; childLeft)</span><br><span class=\"line\">\t\t|| (!leftEdge &amp;&amp; toCapture.getLeft() &gt; childLeft))</span><br><span class=\"line\">\t\t&amp;&amp; getDrawerLockMode(toCapture) == LOCK_MODE_UNLOCKED) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> LayoutParams lp = (LayoutParams) toCapture.getLayoutParams();</span><br><span class=\"line\">\t\tmDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop());</span><br><span class=\"line\">\t\tlp.isPeeking = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\tinvalidate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcloseOtherDrawer();</span><br><span class=\"line\">\t\tcancelChildViewTouch();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意<code>mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop())</code>就是长按屏幕时，侧滑菜单会自动滑出来的原因。</p>\n<p>解决这个问题着实费了一番脑筋，因为 ViewDragCallback 为私有内部类，外部无法直接得到其引用。幸好观察之后发现其实现了 ViewDragHelper.Callback 接口，从而让我们可以利用多态的方式，获取其反射实例</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”</span></span><br><span class=\"line\"><span class=\"comment\">//更改其属性 mPeekRunnable</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftCallbackField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftCallback\"</span>)</span><br><span class=\"line\">leftCallbackField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> leftCallback = leftCallbackField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper.Callback</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> peekRunnableField = leftCallback.javaClass.getDeclaredField(<span class=\"string\">\"mPeekRunnable\"</span>)</span><br><span class=\"line\">peekRunnableField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> nullRunnable = Runnable &#123;  &#125;</span><br><span class=\"line\">peekRunnableField.<span class=\"keyword\">set</span>(leftCallback, nullRunnable)</span><br></pre></td></tr></table></figure>\n<p>完美解决问题！</p>\n<p>最后便是构建一个工具类</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> DrawerLayoutHelper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过反射的方式将 DrawerLayout 的侧滑范围设为全屏</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法存在一个问题，在侧滑范围内长按，也会划出菜单</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过查看 DrawerLayout 的源码分析，其内部类 ViewDragCallback</span></span><br><span class=\"line\"><span class=\"comment\">     * 重写了 onEdgeTouched 方法，然后调用一个 Runnable 属性的变量 “mPeekRunnable”</span></span><br><span class=\"line\"><span class=\"comment\">     * 该变量调用了 peekDraw 方法，实现了长按划出侧滑菜单的功能</span></span><br><span class=\"line\"><span class=\"comment\">     * 同样使用反射将该 Runnable 更改为空实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> drawerLayout</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> displayWidthPercentage</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setDrawerLeftEdgeSize</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              drawerLayout: <span class=\"type\">DrawerLayout</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              displayWidthPercentage: <span class=\"type\">Float</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity == <span class=\"literal\">null</span> || drawerLayout == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftDraggerField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftDragger\"</span>)</span><br><span class=\"line\">            leftDraggerField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftDragger = leftDraggerField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> edgeSizeField = leftDragger.javaClass.getDeclaredField(<span class=\"string\">\"mEdgeSize\"</span>)</span><br><span class=\"line\">            edgeSizeField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> edgeSize = edgeSizeField.getInt(leftDragger)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> displaySize = Point()</span><br><span class=\"line\">            activity.windowManager.defaultDisplay.getSize(displaySize)</span><br><span class=\"line\">            edgeSizeField.setInt(leftDragger, Math.max(edgeSize, (displaySize.x * displayWidthPercentage).toInt()))</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”</span></span><br><span class=\"line\">            <span class=\"comment\">//更改其属性 mPeekRunnable</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftCallbackField = drawerLayout.javaClass.getDeclaredField(<span class=\"string\">\"mLeftCallback\"</span>)</span><br><span class=\"line\">            leftCallbackField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> leftCallback = leftCallbackField.<span class=\"keyword\">get</span>(drawerLayout) <span class=\"keyword\">as</span> ViewDragHelper.Callback</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> peekRunnableField = leftCallback.javaClass.getDeclaredField(<span class=\"string\">\"mPeekRunnable\"</span>)</span><br><span class=\"line\">            peekRunnableField.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> nullRunnable = Runnable &#123;  &#125;</span><br><span class=\"line\">            peekRunnableField.<span class=\"keyword\">set</span>(leftCallback, nullRunnable)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">            e.printStackTrace()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setDrawerLeftEdgeFullScreen</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>?, drawerLayout: <span class=\"type\">DrawerLayout</span>?)</span></span> &#123;</span><br><span class=\"line\">        setDrawerLeftEdgeSize(activity, drawerLayout, <span class=\"number\">1.0f</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"基本数据结构的简单Java实现","date":"2019-03-16T14:08:55.000Z","_content":"\nJDK 中提供了很多数据结构，如下所示\n> Collection\n> ├ List\n> │   ├ LinkedList\n> │   ├ ArrayList\n> │   └ Vector\n> │　    └Stack\n> └ Set\n>\n> Map\n> ├ Hashtable\n> ├ HashMap\n> └ WeakHashMap\n\n本文将进行部分数据结构的简单实现。<!--more-->\n\n## Stack\n```Java\npublic class MyStack<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int nowSize = 0;\n\n    public MyStack() {\n        this(10);\n    }\n\n    public MyStack(int initialCapacity) {\n        maxSize = initialCapacity;\n        dataArray = new Object[maxSize];\n    }\n\n    public void push(T data) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        dataArray[nowSize++] = data;\n    }\n\n    public T pop() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[--nowSize];\n    }\n\n    public T peek() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[nowSize-1];\n    }\n\n    public int search(T target) {\n        int p = nowSize;\n        while (p >= 0) {\n            if (dataArray[p] == target) {\n                return p;\n            }\n            p--;\n        }\n        return -1;\n    }\n\n    private void resize() {\n        maxSize = maxSize << 1;\n        Object[] newArray = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            newArray[i] = dataArray[i];\n        }\n        this.dataArray = newArray;\n    }\n\n    public int size() {\n        return nowSize;\n    }\n\n    public boolean empty() {\n        return nowSize == 0 ? true : false;\n    }\n}\n```\n## Queue\n```Java\npublic class MyQueue<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int front;\n    private int rear;\n\n    public MyQueue() {\n        this(10);\n    }\n\n    public MyQueue(int initialSize) {\n        maxSize = initialSize;\n        dataArray = new Object[maxSize];\n        front = rear = 0;\n    }\n\n    public void enqueue(T newData) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        //非循环队列\n        dataArray[rear++] = newData;\n        \n        //循环队列\n        //dataArray[rear] = newData;\n        //rear = (rear+1) % maxSize;\n    }\n\n    public T dequeue() {\n        if (empty()) {\n            return null;\n        }\n        T value = (T)dataArray[front];\n        //非循环队列\n        dataArray[front++] = null;\n        \n        //循环队列\n        //dataArray[front] = null;\n        //front = (front+1) % maxSize;\n        \n        return value;\n    }\n\n    public void resize() {\n        maxSize = maxSize << 1;\n        Object[] temp = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            temp[i] = dataArray[i];\n        }\n        dataArray = temp;\n    }\n\n    public int size() {\n        return Math.abs(front - rear);\n    }\n\n    public boolean empty() {\n        return front == rear ? true : false;\n    }\n}\n```\n\n## BinaryTree\n\n![二叉搜索树](基本数据结构的简单Java实现/二叉搜索树.png)\n\n```Java\npublic class MyBinaryTree<T> {\n\n    private Node root;\n\n    class Node {\n        private int key;\n        private T value;\n        private Node leftChild;\n        private Node rightChild;\n\n        public Node(int key, T value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    public Node find(int key) {\n        Node currentNode = root;\n        while (currentNode != null && currentNode.key != key) {\n            if (key < currentNode.leftChild.key) {\n                currentNode = currentNode.leftChild;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        return currentNode;\n    }\n\n    public void insert(int key, T value) {\n        if (root == null) {\n            root = new Node(key, value);\n            return;\n        }\n        Node currentNode = root;\n        Node parentNode = root;\n        Boolean isLeftChild = true;\n\n        while (currentNode != null) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        Node newNode = new Node(key, value);\n        if (isLeftChild) {\n            parentNode.leftChild = newNode;\n        } else {\n            parentNode.rightChild = newNode;\n        }\n    }\n\n    public boolean delete(int key) {\n        Node currentNode = root;    //待删除节点\n        Node parentNode = root;     //待删除节点的父节点\n        Boolean isLeftChild = true;\n        while (currentNode != null && currentNode.key != key) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n                isLeftChild = false;\n            }\n        }\n        if (currentNode == null) {\n            return false;\n        }\n        //删除节点为叶子节点\n        if (currentNode.leftChild == null && currentNode.rightChild == null) {\n            if (currentNode == root) {\n                root = null;\n            } else if (isLeftChild) {\n                parentNode.leftChild = null;\n            } else {\n                parentNode.rightChild = null;\n            }\n        } else if (currentNode.rightChild == null) {    //待删除节点只有左子节点\n            if (currentNode == root) {\n                root = currentNode.leftChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.leftChild;\n            } else {\n                parentNode.rightChild = currentNode.leftChild;\n            }\n        } else if (currentNode.leftChild == null) {    //待删除节点只有右子节点\n            if (currentNode == root) {\n                root = currentNode.rightChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.rightChild;\n            } else {\n                parentNode.rightChild = currentNode.rightChild;\n            }\n        } else {    //待删除节点既有左子节点又有右子节点\n            Node directPostNode = getDirectPostNode(currentNode);\n            currentNode.key = directPostNode.key;\n            currentNode.value = directPostNode.value;\n        }\n        return true;\n    }\n\n    /**\n     * 获得待删除节点的直接后继节点\n     *\n     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点\n     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点\n     * 并删除 key 值为 10 的节点的中序后继节点，\n     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，\n     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子\n     *\n     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），\n     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值\n     *\n     * @param delNode 待删除节点\n     * @return 返回直接后继节点\n     */\n    private Node getDirectPostNode(Node delNode) {\n        Node parentNode = delNode;  //保存待删除节点的直接后继节点的父节点\n        Node direcrPostNode = delNode;  //保存待删除节点的直接后继节点\n        Node currentNode = delNode.rightChild;\n\n        while (currentNode != null) {\n            parentNode = direcrPostNode;\n            direcrPostNode = currentNode;\n            currentNode = currentNode.leftChild;\n        }\n        if (direcrPostNode != delNode.rightChild) { //从树中删除此直接后继节点\n            parentNode.leftChild = direcrPostNode.rightChild;\n            direcrPostNode.rightChild = null;\n        }\n        return direcrPostNode;\n\n    }\n\n    public void preOrder(Node rootNode) {\n        if (rootNode != null) {\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void inOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void postOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n        }\n    }\n}\n\n```\n## HashMap\n\n![HashMap](基本数据结构的简单Java实现/HashMap.png)","source":"_posts/基本数据结构的简单Java实现.md","raw":"---\ntitle: 基本数据结构的简单Java实现\ndate: 2019-03-16 22:08:55\ntags:\n- Java\n- 数据结构\ncategories:\n- Java\n---\n\nJDK 中提供了很多数据结构，如下所示\n> Collection\n> ├ List\n> │   ├ LinkedList\n> │   ├ ArrayList\n> │   └ Vector\n> │　    └Stack\n> └ Set\n>\n> Map\n> ├ Hashtable\n> ├ HashMap\n> └ WeakHashMap\n\n本文将进行部分数据结构的简单实现。<!--more-->\n\n## Stack\n```Java\npublic class MyStack<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int nowSize = 0;\n\n    public MyStack() {\n        this(10);\n    }\n\n    public MyStack(int initialCapacity) {\n        maxSize = initialCapacity;\n        dataArray = new Object[maxSize];\n    }\n\n    public void push(T data) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        dataArray[nowSize++] = data;\n    }\n\n    public T pop() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[--nowSize];\n    }\n\n    public T peek() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[nowSize-1];\n    }\n\n    public int search(T target) {\n        int p = nowSize;\n        while (p >= 0) {\n            if (dataArray[p] == target) {\n                return p;\n            }\n            p--;\n        }\n        return -1;\n    }\n\n    private void resize() {\n        maxSize = maxSize << 1;\n        Object[] newArray = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            newArray[i] = dataArray[i];\n        }\n        this.dataArray = newArray;\n    }\n\n    public int size() {\n        return nowSize;\n    }\n\n    public boolean empty() {\n        return nowSize == 0 ? true : false;\n    }\n}\n```\n## Queue\n```Java\npublic class MyQueue<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int front;\n    private int rear;\n\n    public MyQueue() {\n        this(10);\n    }\n\n    public MyQueue(int initialSize) {\n        maxSize = initialSize;\n        dataArray = new Object[maxSize];\n        front = rear = 0;\n    }\n\n    public void enqueue(T newData) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        //非循环队列\n        dataArray[rear++] = newData;\n        \n        //循环队列\n        //dataArray[rear] = newData;\n        //rear = (rear+1) % maxSize;\n    }\n\n    public T dequeue() {\n        if (empty()) {\n            return null;\n        }\n        T value = (T)dataArray[front];\n        //非循环队列\n        dataArray[front++] = null;\n        \n        //循环队列\n        //dataArray[front] = null;\n        //front = (front+1) % maxSize;\n        \n        return value;\n    }\n\n    public void resize() {\n        maxSize = maxSize << 1;\n        Object[] temp = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            temp[i] = dataArray[i];\n        }\n        dataArray = temp;\n    }\n\n    public int size() {\n        return Math.abs(front - rear);\n    }\n\n    public boolean empty() {\n        return front == rear ? true : false;\n    }\n}\n```\n\n## BinaryTree\n\n![二叉搜索树](基本数据结构的简单Java实现/二叉搜索树.png)\n\n```Java\npublic class MyBinaryTree<T> {\n\n    private Node root;\n\n    class Node {\n        private int key;\n        private T value;\n        private Node leftChild;\n        private Node rightChild;\n\n        public Node(int key, T value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    public Node find(int key) {\n        Node currentNode = root;\n        while (currentNode != null && currentNode.key != key) {\n            if (key < currentNode.leftChild.key) {\n                currentNode = currentNode.leftChild;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        return currentNode;\n    }\n\n    public void insert(int key, T value) {\n        if (root == null) {\n            root = new Node(key, value);\n            return;\n        }\n        Node currentNode = root;\n        Node parentNode = root;\n        Boolean isLeftChild = true;\n\n        while (currentNode != null) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        Node newNode = new Node(key, value);\n        if (isLeftChild) {\n            parentNode.leftChild = newNode;\n        } else {\n            parentNode.rightChild = newNode;\n        }\n    }\n\n    public boolean delete(int key) {\n        Node currentNode = root;    //待删除节点\n        Node parentNode = root;     //待删除节点的父节点\n        Boolean isLeftChild = true;\n        while (currentNode != null && currentNode.key != key) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n                isLeftChild = false;\n            }\n        }\n        if (currentNode == null) {\n            return false;\n        }\n        //删除节点为叶子节点\n        if (currentNode.leftChild == null && currentNode.rightChild == null) {\n            if (currentNode == root) {\n                root = null;\n            } else if (isLeftChild) {\n                parentNode.leftChild = null;\n            } else {\n                parentNode.rightChild = null;\n            }\n        } else if (currentNode.rightChild == null) {    //待删除节点只有左子节点\n            if (currentNode == root) {\n                root = currentNode.leftChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.leftChild;\n            } else {\n                parentNode.rightChild = currentNode.leftChild;\n            }\n        } else if (currentNode.leftChild == null) {    //待删除节点只有右子节点\n            if (currentNode == root) {\n                root = currentNode.rightChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.rightChild;\n            } else {\n                parentNode.rightChild = currentNode.rightChild;\n            }\n        } else {    //待删除节点既有左子节点又有右子节点\n            Node directPostNode = getDirectPostNode(currentNode);\n            currentNode.key = directPostNode.key;\n            currentNode.value = directPostNode.value;\n        }\n        return true;\n    }\n\n    /**\n     * 获得待删除节点的直接后继节点\n     *\n     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点\n     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点\n     * 并删除 key 值为 10 的节点的中序后继节点，\n     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，\n     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子\n     *\n     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），\n     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值\n     *\n     * @param delNode 待删除节点\n     * @return 返回直接后继节点\n     */\n    private Node getDirectPostNode(Node delNode) {\n        Node parentNode = delNode;  //保存待删除节点的直接后继节点的父节点\n        Node direcrPostNode = delNode;  //保存待删除节点的直接后继节点\n        Node currentNode = delNode.rightChild;\n\n        while (currentNode != null) {\n            parentNode = direcrPostNode;\n            direcrPostNode = currentNode;\n            currentNode = currentNode.leftChild;\n        }\n        if (direcrPostNode != delNode.rightChild) { //从树中删除此直接后继节点\n            parentNode.leftChild = direcrPostNode.rightChild;\n            direcrPostNode.rightChild = null;\n        }\n        return direcrPostNode;\n\n    }\n\n    public void preOrder(Node rootNode) {\n        if (rootNode != null) {\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void inOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void postOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n        }\n    }\n}\n\n```\n## HashMap\n\n![HashMap](基本数据结构的简单Java实现/HashMap.png)","slug":"基本数据结构的简单Java实现","published":1,"updated":"2019-06-02T05:04:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqy40047y4upy06toyoc","content":"<p>JDK 中提供了很多数据结构，如下所示</p>\n<blockquote>\n<p>Collection<br>├ List<br>│   ├ LinkedList<br>│   ├ ArrayList<br>│   └ Vector<br>│　    └Stack<br>└ Set</p>\n<p>Map<br>├ Hashtable<br>├ HashMap<br>└ WeakHashMap</p>\n</blockquote>\n<p>本文将进行部分数据结构的简单实现。<a id=\"more\"></a></p>\n<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span><<span class=\"title\">T</span>> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nowSize = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>{</span><br><span class=\"line\">        maxSize = initialCapacity;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(T data)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() >= maxSize) {</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        }</span><br><span class=\"line\">        dataArray[nowSize++] = data;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">pop</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[--nowSize];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">peek</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[nowSize-<span class=\"number\">1</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(T target)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = nowSize;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p >= <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dataArray[p] == target) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        maxSize = maxSize << <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] newArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < dataArray.length; i++) {</span><br><span class=\"line\">            newArray[i] = dataArray[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataArray = newArray;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize == <span class=\"number\">0</span> ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span><<span class=\"title\">T</span>> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> front;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rear;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialSize)</span> </span>{</span><br><span class=\"line\">        maxSize = initialSize;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        front = rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(T newData)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() >= maxSize) {</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[rear++] = newData;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[rear] = newData;</span></span><br><span class=\"line\">        <span class=\"comment\">//rear = (rear+1) % maxSize;</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        T value = (T)dataArray[front];</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[front++] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[front] = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//front = (front+1) % maxSize;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        maxSize = maxSize << <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] temp = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < dataArray.length; i++) {</span><br><span class=\"line\">            temp[i] = dataArray[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        dataArray = temp;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.abs(front - rear);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> front == rear ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"BinaryTree\"><a href=\"#BinaryTree\" class=\"headerlink\" title=\"BinaryTree\"></a>BinaryTree</h2><p><img src=\"/基本数据结构的简单Java实现/二叉搜索树.png\" alt=\"二叉搜索树\"></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBinaryTree</span><<span class=\"title\">T</span>> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> T value;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>{</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>{</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> && currentNode.key != key) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key < currentNode.leftChild.key) {</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        Node parentNode = root;</span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key < currentNode.key) {</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        Node newNode = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLeftChild) {</span><br><span class=\"line\">            parentNode.leftChild = newNode;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            parentNode.rightChild = newNode;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>{</span><br><span class=\"line\">        Node currentNode = root;    <span class=\"comment\">//待删除节点</span></span><br><span class=\"line\">        Node parentNode = root;     <span class=\"comment\">//待删除节点的父节点</span></span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> && currentNode.key != key) {</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key < currentNode.key) {</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">//删除节点为叶子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span> && currentNode.rightChild == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) {</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) {</span><br><span class=\"line\">                parentNode.leftChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                parentNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.rightChild == <span class=\"keyword\">null</span>) {    <span class=\"comment\">//待删除节点只有左子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) {</span><br><span class=\"line\">                root = currentNode.leftChild;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) {</span><br><span class=\"line\">                parentNode.leftChild = currentNode.leftChild;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                parentNode.rightChild = currentNode.leftChild;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span>) {    <span class=\"comment\">//待删除节点只有右子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) {</span><br><span class=\"line\">                root = currentNode.rightChild;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) {</span><br><span class=\"line\">                parentNode.leftChild = currentNode.rightChild;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                parentNode.rightChild = currentNode.rightChild;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {    <span class=\"comment\">//待删除节点既有左子节点又有右子节点</span></span><br><span class=\"line\">            Node directPostNode = getDirectPostNode(currentNode);</span><br><span class=\"line\">            currentNode.key = directPostNode.key;</span><br><span class=\"line\">            currentNode.value = directPostNode.value;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得待删除节点的直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除 key 值为 10 的节点的中序后继节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delNode 待删除节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">getDirectPostNode</span><span class=\"params\">(Node delNode)</span> </span>{</span><br><span class=\"line\">        Node parentNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点的父节点</span></span><br><span class=\"line\">        Node direcrPostNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点</span></span><br><span class=\"line\">        Node currentNode = delNode.rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            parentNode = direcrPostNode;</span><br><span class=\"line\">            direcrPostNode = currentNode;</span><br><span class=\"line\">            currentNode = currentNode.leftChild;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (direcrPostNode != delNode.rightChild) { <span class=\"comment\">//从树中删除此直接后继节点</span></span><br><span class=\"line\">            parentNode.leftChild = direcrPostNode.rightChild;</span><br><span class=\"line\">            direcrPostNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> direcrPostNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrder</span><span class=\"params\">(Node rootNode)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(Node rootNode)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrder</span><span class=\"params\">(Node rootNode)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><img src=\"/基本数据结构的简单Java实现/HashMap.png\" alt=\"HashMap\"></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":8351,"excerpt":"<p>JDK 中提供了很多数据结构，如下所示</p>\n<blockquote>\n<p>Collection<br>├ List<br>│   ├ LinkedList<br>│   ├ ArrayList<br>│   └ Vector<br>│　    └Stack<br>└ Set</p>\n<p>Map<br>├ Hashtable<br>├ HashMap<br>└ WeakHashMap</p>\n</blockquote>\n<p>本文将进行部分数据结构的简单实现。</p>","more":"<p></p>\n<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nowSize = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        maxSize = initialCapacity;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(T data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() &gt;= maxSize) &#123;</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dataArray[nowSize++] = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[--nowSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[nowSize-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(T target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = nowSize;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dataArray[p] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        maxSize = maxSize &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] newArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dataArray.length; i++) &#123;</span><br><span class=\"line\">            newArray[i] = dataArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataArray = newArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize == <span class=\"number\">0</span> ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> front;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rear;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialSize)</span> </span>&#123;</span><br><span class=\"line\">        maxSize = initialSize;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        front = rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(T newData)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() &gt;= maxSize) &#123;</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[rear++] = newData;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[rear] = newData;</span></span><br><span class=\"line\">        <span class=\"comment\">//rear = (rear+1) % maxSize;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        T value = (T)dataArray[front];</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[front++] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[front] = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//front = (front+1) % maxSize;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        maxSize = maxSize &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] temp = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dataArray.length; i++) &#123;</span><br><span class=\"line\">            temp[i] = dataArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dataArray = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.abs(front - rear);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> front == rear ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BinaryTree\"><a href=\"#BinaryTree\" class=\"headerlink\" title=\"BinaryTree\"></a>BinaryTree</h2><p><img src=\"/基本数据结构的简单Java实现/二叉搜索树.png\" alt=\"二叉搜索树\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBinaryTree</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> T value;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> &amp;&amp; currentNode.key != key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.leftChild.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        Node parentNode = root;</span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node newNode = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">            parentNode.leftChild = newNode;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            parentNode.rightChild = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        Node currentNode = root;    <span class=\"comment\">//待删除节点</span></span><br><span class=\"line\">        Node parentNode = root;     <span class=\"comment\">//待删除节点的父节点</span></span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> &amp;&amp; currentNode.key != key) &#123;</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//删除节点为叶子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span> &amp;&amp; currentNode.rightChild == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.rightChild == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">//待删除节点只有左子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = currentNode.leftChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">//待删除节点只有右子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = currentNode.rightChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = currentNode.rightChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">//待删除节点既有左子节点又有右子节点</span></span><br><span class=\"line\">            Node directPostNode = getDirectPostNode(currentNode);</span><br><span class=\"line\">            currentNode.key = directPostNode.key;</span><br><span class=\"line\">            currentNode.value = directPostNode.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得待删除节点的直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除 key 值为 10 的节点的中序后继节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delNode 待删除节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">getDirectPostNode</span><span class=\"params\">(Node delNode)</span> </span>&#123;</span><br><span class=\"line\">        Node parentNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点的父节点</span></span><br><span class=\"line\">        Node direcrPostNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点</span></span><br><span class=\"line\">        Node currentNode = delNode.rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentNode = direcrPostNode;</span><br><span class=\"line\">            direcrPostNode = currentNode;</span><br><span class=\"line\">            currentNode = currentNode.leftChild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (direcrPostNode != delNode.rightChild) &#123; <span class=\"comment\">//从树中删除此直接后继节点</span></span><br><span class=\"line\">            parentNode.leftChild = direcrPostNode.rightChild;</span><br><span class=\"line\">            direcrPostNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> direcrPostNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><img src=\"/基本数据结构的简单Java实现/HashMap.png\" alt=\"HashMap\"></p>"},{"title":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","date":"2019-01-13T15:09:12.000Z","_content":"\n第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<!--more-->\n\n “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。\n\n 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。\n\n 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：[巴赫《六首无伴奏大提琴组曲》斯塔克](https://music.163.com/#/playlist?id=596314970)\n\n\n ## 正文\n1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。\n\n如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。\n那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。\n\n回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。\n\n探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。\n\n如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。\n\n应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。\n\n12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。\n\n马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。\n\n在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。\n\n在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。\n\n最感人的还是大师们晚年的演奏，情感饱足，回归天真。\n\n罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。\n\n罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。\n\n俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。\n\n法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。\n\n只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜","source":"_posts/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》.md","raw":"---\ntitle: 巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》\ndate: 2019-01-13 23:09:12\ntags:\n- 音乐\n- 巴洛克\n- 巴赫\ncategories:\n- 艺术\n---\n\n第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<!--more-->\n\n “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。\n\n 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。\n\n 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：[巴赫《六首无伴奏大提琴组曲》斯塔克](https://music.163.com/#/playlist?id=596314970)\n\n\n ## 正文\n1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。\n\n如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。\n那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。\n\n回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。\n\n探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。\n\n如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。\n\n应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。\n\n12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。\n\n马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。\n\n在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。\n\n在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。\n\n最感人的还是大师们晚年的演奏，情感饱足，回归天真。\n\n罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。\n\n罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。\n\n俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。\n\n法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。\n\n只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜","slug":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","published":1,"updated":"2019-06-02T05:04:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqy7004by4upax1xywdg","content":"<p>第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<a id=\"more\"></a></p>\n<p> “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。</p>\n<p> 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。</p>\n<p> 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：<a href=\"https://music.163.com/#/playlist?id=596314970\" target=\"_blank\" rel=\"noopener\">巴赫《六首无伴奏大提琴组曲》斯塔克</a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。</p>\n<p>如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。<br>那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。</p>\n<p>回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。</p>\n<p>探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。</p>\n<p>如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。</p>\n<p>应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。</p>\n<p>12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。</p>\n<p>马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。</p>\n<p>在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。</p>\n<p>在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。</p>\n<p>最感人的还是大师们晚年的演奏，情感饱足，回归天真。</p>\n<p>罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。</p>\n<p>罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。</p>\n<p>俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。</p>\n<p>法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。</p>\n<p>只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":4059,"excerpt":"<p>第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。</p>","more":"<p></p>\n<p> “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。</p>\n<p> 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。</p>\n<p> 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：<a href=\"https://music.163.com/#/playlist?id=596314970\" target=\"_blank\" rel=\"noopener\">巴赫《六首无伴奏大提琴组曲》斯塔克</a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。</p>\n<p>如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。<br>那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。</p>\n<p>回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。</p>\n<p>探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。</p>\n<p>如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。</p>\n<p>应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。</p>\n<p>12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。</p>\n<p>马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。</p>\n<p>在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。</p>\n<p>在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。</p>\n<p>最感人的还是大师们晚年的演奏，情感饱足，回归天真。</p>\n<p>罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。</p>\n<p>罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。</p>\n<p>俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。</p>\n<p>法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。</p>\n<p>只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜</p>"},{"title":"翻越GFW记","date":"2019-01-12T15:31:31.000Z","_content":"\nGFW 是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录`GFW`所为何物，以及`翻`的原理。<!--more-->\n## GFW\n\n### 所为何物\nGFW：Great Firewall (of the People's Republic of China)，中国国家防火墙，由于谐音 the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 \n\n\n形象的描述，在没有 GFW 的时代，访问互联网的方式如下\n\n![原始连接方式](翻越GFW记/原始连接方式.png)\n\nGFW 出现之后，则变成\n\n![GFW存在后的连接方式](翻越GFW记/GFW存在后的连接方式.png)\n\n其内部构造如下\n\n![翻越GFW记/GFW内部结构](翻越GFW记/GFW内部结构.jpg)\n\n它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。\n\nGFW的具体原理可以查看此文章：[全面学习GFW](https://cokebar.info/archives/253)\n\n### 如何工作\n#### 关键字过滤阻断\n关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。\n\n#### IP地址封锁\n路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br> \nGFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。\n\n#### DNS污染、劫持\nDNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br>\n\nDNS劫持和污染的方式有两种： \n\n- 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 \n- 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。\n\n值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：[中国防火长城-污染攻击大事记](https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记)。 \n\n**除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。**\n\n## 翻越记\n\n### 翻\n\n#### 修改Hosts文件\n足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。\n\nHosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。\n\n所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。\n\n#### SSH Tunnel\nSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br>\n\n![SSH连接方式](翻越GFW记/SSH连接方式.png)\n1. 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)\n2. 用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)\n3. 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)\n\n由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。\n\n#### VPN\n对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。\n\nVPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。\n\nVPN 的特点如下：\n- VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。\n- 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。\n- VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。\n\n#### Shadowsocks\nVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。\n\n技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下\n\n![SS连接方式](翻越GFW记/SS连接方式.png)\n\n- 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题\n- 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密\n- 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。\n\n相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。\n\n##### Shadowsocks-R\n虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。\n\n作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。\n\n##### V2Ray\nV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。\n\n### 记\n\n- 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。\n- 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。\n- 2004年，维基百科遭遇网络封锁，至今未解封。\n- 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。\n- 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。\n- 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。\n- 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。\n- 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。\n\n## 结语\n从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。\n\n翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。\n\n本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。","source":"_posts/翻越GFW记.md","raw":"---\ntitle: 翻越GFW记\ndate: 2019-01-12 23:31:31\ntags:\n- 翻墙\n- 互联网\ncategories:\n- 互联网\n---\n\nGFW 是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录`GFW`所为何物，以及`翻`的原理。<!--more-->\n## GFW\n\n### 所为何物\nGFW：Great Firewall (of the People's Republic of China)，中国国家防火墙，由于谐音 the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 \n\n\n形象的描述，在没有 GFW 的时代，访问互联网的方式如下\n\n![原始连接方式](翻越GFW记/原始连接方式.png)\n\nGFW 出现之后，则变成\n\n![GFW存在后的连接方式](翻越GFW记/GFW存在后的连接方式.png)\n\n其内部构造如下\n\n![翻越GFW记/GFW内部结构](翻越GFW记/GFW内部结构.jpg)\n\n它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。\n\nGFW的具体原理可以查看此文章：[全面学习GFW](https://cokebar.info/archives/253)\n\n### 如何工作\n#### 关键字过滤阻断\n关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。\n\n#### IP地址封锁\n路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br> \nGFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。\n\n#### DNS污染、劫持\nDNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br>\n\nDNS劫持和污染的方式有两种： \n\n- 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 \n- 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。\n\n值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：[中国防火长城-污染攻击大事记](https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记)。 \n\n**除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。**\n\n## 翻越记\n\n### 翻\n\n#### 修改Hosts文件\n足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。\n\nHosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。\n\n所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。\n\n#### SSH Tunnel\nSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br>\n\n![SSH连接方式](翻越GFW记/SSH连接方式.png)\n1. 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)\n2. 用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)\n3. 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)\n\n由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。\n\n#### VPN\n对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。\n\nVPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。\n\nVPN 的特点如下：\n- VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。\n- 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。\n- VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。\n\n#### Shadowsocks\nVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。\n\n技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下\n\n![SS连接方式](翻越GFW记/SS连接方式.png)\n\n- 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题\n- 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密\n- 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。\n\n相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。\n\n##### Shadowsocks-R\n虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。\n\n作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。\n\n##### V2Ray\nV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。\n\n### 记\n\n- 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。\n- 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。\n- 2004年，维基百科遭遇网络封锁，至今未解封。\n- 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。\n- 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。\n- 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。\n- 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。\n- 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。\n\n## 结语\n从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。\n\n翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。\n\n本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。","slug":"翻越GFW记","published":1,"updated":"2019-06-02T05:04:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqy9004ey4upf25lq8d0","content":"<p>GFW 是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录<code>GFW</code>所为何物，以及<code>翻</code>的原理。<a id=\"more\"></a></p>\n<h2 id=\"GFW\"><a href=\"#GFW\" class=\"headerlink\" title=\"GFW\"></a>GFW</h2><h3 id=\"所为何物\"><a href=\"#所为何物\" class=\"headerlink\" title=\"所为何物\"></a>所为何物</h3><p>GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音 the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 </p>\n<p>形象的描述，在没有 GFW 的时代，访问互联网的方式如下</p>\n<p><img src=\"/翻越GFW记/原始连接方式.png\" alt=\"原始连接方式\"></p>\n<p>GFW 出现之后，则变成</p>\n<p><img src=\"/翻越GFW记/GFW存在后的连接方式.png\" alt=\"GFW存在后的连接方式\"></p>\n<p>其内部构造如下</p>\n<p><img src=\"/翻越GFW记/GFW内部结构.jpg\" alt=\"翻越GFW记/GFW内部结构\"></p>\n<p>它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。</p>\n<p>GFW的具体原理可以查看此文章：<a href=\"https://cokebar.info/archives/253\" target=\"_blank\" rel=\"noopener\">全面学习GFW</a></p>\n<h3 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h3><h4 id=\"关键字过滤阻断\"><a href=\"#关键字过滤阻断\" class=\"headerlink\" title=\"关键字过滤阻断\"></a>关键字过滤阻断</h4><p>关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: <a href=\"http://www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送\" target=\"_blank\" rel=\"noopener\">www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送</a> RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。</p>\n<h4 id=\"IP地址封锁\"><a href=\"#IP地址封锁\" class=\"headerlink\" title=\"IP地址封锁\"></a>IP地址封锁</h4><p>路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br><br>GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。</p>\n<h4 id=\"DNS污染、劫持\"><a href=\"#DNS污染、劫持\" class=\"headerlink\" title=\"DNS污染、劫持\"></a>DNS污染、劫持</h4><p>DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br></p>\n<p>DNS劫持和污染的方式有两种： </p>\n<ul>\n<li>一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 </li>\n<li>另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。</li>\n</ul>\n<p>值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记\" target=\"_blank\" rel=\"noopener\">中国防火长城-污染攻击大事记</a>。 </p>\n<p><strong>除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。</strong></p>\n<h2 id=\"翻越记\"><a href=\"#翻越记\" class=\"headerlink\" title=\"翻越记\"></a>翻越记</h2><h3 id=\"翻\"><a href=\"#翻\" class=\"headerlink\" title=\"翻\"></a>翻</h3><h4 id=\"修改Hosts文件\"><a href=\"#修改Hosts文件\" class=\"headerlink\" title=\"修改Hosts文件\"></a>修改Hosts文件</h4><p>足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。</p>\n<p>Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。</p>\n<p>所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。</p>\n<h4 id=\"SSH-Tunnel\"><a href=\"#SSH-Tunnel\" class=\"headerlink\" title=\"SSH Tunnel\"></a>SSH Tunnel</h4><p>SSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br></p>\n<p><img src=\"/翻越GFW记/SSH连接方式.png\" alt=\"SSH连接方式\"></p>\n<ol>\n<li>首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)</li>\n<li>用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)</li>\n<li>服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)</li>\n</ol>\n<p>由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。</p>\n<h4 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h4><p>对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。</p>\n<p>VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。</p>\n<p>VPN 的特点如下：</p>\n<ul>\n<li>VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。</li>\n<li>商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。</li>\n<li>VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。</li>\n</ul>\n<h4 id=\"Shadowsocks\"><a href=\"#Shadowsocks\" class=\"headerlink\" title=\"Shadowsocks\"></a>Shadowsocks</h4><p>VPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。</p>\n<p>技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下</p>\n<p><img src=\"/翻越GFW记/SS连接方式.png\" alt=\"SS连接方式\"></p>\n<ul>\n<li>1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题</li>\n<li>2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密</li>\n<li>3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。</li>\n</ul>\n<p>相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。</p>\n<h5 id=\"Shadowsocks-R\"><a href=\"#Shadowsocks-R\" class=\"headerlink\" title=\"Shadowsocks-R\"></a>Shadowsocks-R</h5><p>虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。</p>\n<p>作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。</p>\n<h5 id=\"V2Ray\"><a href=\"#V2Ray\" class=\"headerlink\" title=\"V2Ray\"></a>V2Ray</h5><p>V2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。</p>\n<h3 id=\"记\"><a href=\"#记\" class=\"headerlink\" title=\"记\"></a>记</h3><ul>\n<li>1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。</li>\n<li>2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。</li>\n<li>2004年，维基百科遭遇网络封锁，至今未解封。</li>\n<li>2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。</li>\n<li>2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。</li>\n<li>2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。</li>\n<li>2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。</li>\n<li>2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。</p>\n<p>翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。</p>\n<p>本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":4513,"excerpt":"<p>GFW 是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录<code>GFW</code>所为何物，以及<code>翻</code>的原理。</p>","more":"<p></p>\n<h2 id=\"GFW\"><a href=\"#GFW\" class=\"headerlink\" title=\"GFW\"></a>GFW</h2><h3 id=\"所为何物\"><a href=\"#所为何物\" class=\"headerlink\" title=\"所为何物\"></a>所为何物</h3><p>GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音 the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 </p>\n<p>形象的描述，在没有 GFW 的时代，访问互联网的方式如下</p>\n<p><img src=\"/翻越GFW记/原始连接方式.png\" alt=\"原始连接方式\"></p>\n<p>GFW 出现之后，则变成</p>\n<p><img src=\"/翻越GFW记/GFW存在后的连接方式.png\" alt=\"GFW存在后的连接方式\"></p>\n<p>其内部构造如下</p>\n<p><img src=\"/翻越GFW记/GFW内部结构.jpg\" alt=\"翻越GFW记/GFW内部结构\"></p>\n<p>它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。</p>\n<p>GFW的具体原理可以查看此文章：<a href=\"https://cokebar.info/archives/253\" target=\"_blank\" rel=\"noopener\">全面学习GFW</a></p>\n<h3 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h3><h4 id=\"关键字过滤阻断\"><a href=\"#关键字过滤阻断\" class=\"headerlink\" title=\"关键字过滤阻断\"></a>关键字过滤阻断</h4><p>关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: <a href=\"http://www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送\" target=\"_blank\" rel=\"noopener\">www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送</a> RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。</p>\n<h4 id=\"IP地址封锁\"><a href=\"#IP地址封锁\" class=\"headerlink\" title=\"IP地址封锁\"></a>IP地址封锁</h4><p>路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br><br>GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。</p>\n<h4 id=\"DNS污染、劫持\"><a href=\"#DNS污染、劫持\" class=\"headerlink\" title=\"DNS污染、劫持\"></a>DNS污染、劫持</h4><p>DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br></p>\n<p>DNS劫持和污染的方式有两种： </p>\n<ul>\n<li>一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 </li>\n<li>另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。</li>\n</ul>\n<p>值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记\" target=\"_blank\" rel=\"noopener\">中国防火长城-污染攻击大事记</a>。 </p>\n<p><strong>除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。</strong></p>\n<h2 id=\"翻越记\"><a href=\"#翻越记\" class=\"headerlink\" title=\"翻越记\"></a>翻越记</h2><h3 id=\"翻\"><a href=\"#翻\" class=\"headerlink\" title=\"翻\"></a>翻</h3><h4 id=\"修改Hosts文件\"><a href=\"#修改Hosts文件\" class=\"headerlink\" title=\"修改Hosts文件\"></a>修改Hosts文件</h4><p>足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。</p>\n<p>Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。</p>\n<p>所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。</p>\n<h4 id=\"SSH-Tunnel\"><a href=\"#SSH-Tunnel\" class=\"headerlink\" title=\"SSH Tunnel\"></a>SSH Tunnel</h4><p>SSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br></p>\n<p><img src=\"/翻越GFW记/SSH连接方式.png\" alt=\"SSH连接方式\"></p>\n<ol>\n<li>首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)</li>\n<li>用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)</li>\n<li>服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)</li>\n</ol>\n<p>由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。</p>\n<h4 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h4><p>对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。</p>\n<p>VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。</p>\n<p>VPN 的特点如下：</p>\n<ul>\n<li>VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。</li>\n<li>商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。</li>\n<li>VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。</li>\n</ul>\n<h4 id=\"Shadowsocks\"><a href=\"#Shadowsocks\" class=\"headerlink\" title=\"Shadowsocks\"></a>Shadowsocks</h4><p>VPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。</p>\n<p>技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下</p>\n<p><img src=\"/翻越GFW记/SS连接方式.png\" alt=\"SS连接方式\"></p>\n<ul>\n<li>1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题</li>\n<li>2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密</li>\n<li>3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。</li>\n</ul>\n<p>相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。</p>\n<h5 id=\"Shadowsocks-R\"><a href=\"#Shadowsocks-R\" class=\"headerlink\" title=\"Shadowsocks-R\"></a>Shadowsocks-R</h5><p>虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。</p>\n<p>作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。</p>\n<h5 id=\"V2Ray\"><a href=\"#V2Ray\" class=\"headerlink\" title=\"V2Ray\"></a>V2Ray</h5><p>V2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。</p>\n<h3 id=\"记\"><a href=\"#记\" class=\"headerlink\" title=\"记\"></a>记</h3><ul>\n<li>1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。</li>\n<li>2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。</li>\n<li>2004年，维基百科遭遇网络封锁，至今未解封。</li>\n<li>2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。</li>\n<li>2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。</li>\n<li>2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。</li>\n<li>2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。</li>\n<li>2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。</p>\n<p>翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。</p>\n<p>本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。</p>"},{"title":"Java 线程和线程池详解","date":"2019-03-20T09:29:06.000Z","_content":"\n线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：\n> java.lang.Thread 类的一个实例；\n>\n> 线程的执行。\n\n<!--more-->\n\n## Java 线程\n\n### 线程和进程\n\n#### 概念\n\n进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。\n\n#### 区别\n进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。\n\n线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。\n\n> 一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。\n>\n> Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。\n>\n> 由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。\n\n实际开发中使用多线程的优势在于\n\n- 进程之间不能共享内存，而线程之间可以共享内存。\n- 系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。\n- Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。\n\n### 线程的状态\n图一\n\n\n\n![](Java-线程和线程池详解/线程状态1.png)\n\n图二\n\n![](Java-线程和线程池详解/线程状态2.png)\n\n### 分类\nJava 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。\n\n只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。\n```Java\npublic class Main {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread();\n        thread.setDaemon(true);\n        System.out.println(\"is daemon thread? \" + thread.isDaemon());\n    }\n}\n```\n输出为\n```\nis daemon thread? true\n```\n使用守护线程要注意的点\n- `thread.setDaemon(true)` 必须在 `thread.start()` 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。\n- 在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 \n- 不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 \n\n### Runnable 和 Thread\nRunnable 是一个线程接口，查看其构造\n```Java\npublic interface Runnable {\n    public abstract void run();\n}\n```\n其中只定义了一个`run`方法\n\nThread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的`init`\n```\nprivate void init(ThreadGroup g, Runnable target, String name,\n                      long stackSize, AccessControlContext acc,\n                      boolean inheritThreadLocals)\n```\n观察 Thread 中重写的`run`方法\n```Java\n@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n其中 target 为 Runnable 对象，即调用 Thread 的`run`实际上是调用我们传进去的 Runnable 的对应方法\n\n观察其`start`方法\n```Java\npublic synchronized void start() {\n    //不能重复调用 start 方法\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n        \n    //将线程加入线程组\n    group.add(this);\n    //线程开始标志\n    boolean started = false;\n    try {\n        //调用native方法开始多线程\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n其中`start0`是 native 方法，在其中新建线程，然后回调 target 的 run 方法。\n\n也就是说，如果我们直接调用`run`方法，相当于调用普通方法，不会有多线程效果。只有调用`start`才会在后台开启另一个线程，等待 CPU 调度。\n\n### 多线程 API\n#### Object\n实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法\n\n| 方法            | 描述                                                         |\n| --------------- | ------------------------------------------------------------ |\n| wait()          | 锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池 |\n| wait(long)      | 锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。 |\n| wait(long, int) | 和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000 |\n| notify()        | 随机唤醒一个处于等待中的线程（同一个等待阻塞池中）           |\n| notifyAll()     | 唤醒所有等待中的线程（同一个等待阻塞池中）                   |\n\n以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行`object.wait()`方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下\n```Java\npublic class ThreadTest {\n    public static void main(String[] args) {\n        Thread t = Thread.currentThread();\n        try {\n            t.wait(2000);   //由于没有获得锁，将抛出 IllegalMonitorStateException 异常\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in Main: \" + t.toString());\n        A a = new A();\n        a.printThreadInfo();\n    }\n}\n\nclass A {\n    public synchronized void printThreadInfo() {\n        Thread t = Thread.currentThread();\n        try {\n            wait(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in A: \" + t.toString());\n    }\n}\n```\n删除`main`中 try/catch 语句之后，控制台输出如下\n```\ncurrent Thread info in Main: Thread[main,5,main]\n//等待两秒\ncurrent Thread info in A: Thread[main,5,main]\n```\n**为什么需要在 synchronized 中？**\n> wait和notify用于线程间通信。\n> 以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性\n>\n> 一般对队列的操作如下:\n> while(queue.size() == MAX_SIZE){ wait() }\n>\n> 假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2\n>\n> - t1判断队列满，需要 wait 阻塞线程。\n>\n> - 但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。\n>\n> - 这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。\n>\n> - 假如此时消费者不消费了，那么生产者则会一直阻塞下去。\n>\n> - 所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。\n\n**为什么定义在 Object 中？**\n> Object 中的`wait()`, `notify()`等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。\n>\n> `wait()`会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！\n> 当线程释放它持有的“同步锁”之后变成等待线程，可以被`notify()`或`notifyAll()`唤醒。那么，`notify()`依据什么唤醒等待线程的？或者说，`wait()`等待线程和`notify()`之间通过什么关联起来？答案是：依据“对象的同步锁”。\n>\n> 负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用`notify()`或`notifyAll()`方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n> 总之，`notify()`, `wait()`依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！\n>\n> 这就是`notify()`, `wait()`等函数定义在 Object 类，而不是 Thread 类中的原因。\n>\n> 来自 [JAVA 线程状态及转化](https://www.cnblogs.com/happy-coder/p/6587092.html)\n\n#### Thread \n| 方法                      | 描述                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| Thread.currentThread()    | 返回对当前线程对象的引用                                     |\n| Thread.interrupted()      | 检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false） |\n| Thread.sleep(long millis) | 使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会） |\n| Thread.yield()            | 使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会） |\n| t.getId()...              | 返回该线程的 id 等等信息                                     |\n| t.interrupt()             | 将该线程中断（实际并不会中断，只是将中断标志设置为true）     |\n| t.isInterrupted()         | 检测该线程是否已经中断                                       |\n| t.join()                  | 在a线程中调用b.join()，则a线程阻塞，直到b线程执行完          |\n| t.join(long millis)       | 同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。 |\n\n---\n关于 interrupt，[JAVA interrupt、interrupted和isInterrupted的区别](https://blog.csdn.net/qpc908694753/article/details/61414495)\n> interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为\"中断\"状态。\n>\n> 注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。\n\n#### 废弃方法\n- stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止\n- suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。\n- resume：用来回复被挂起的线程，跟 suspend 对应。\n\n## 线程池\n\nJava 中关于线程池的继承关系如下\n\n![](Java-线程和线程池详解/继承图.png)\n\nExecutor 是一个顶层接口，其中只声明了一个方法`execute(Runnable)`，用来执行传进去的任务\n\nExecutorService 接口继承了 Executor 接口，并声明了一些方法：`submit`、`invokeAll`、`invokeAny`以及`shutDown` 等\n\n抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法\n\nThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下\n```Java\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n- corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用`prestartAllCoreThreads`或者`prestartCoreThread`方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中\n- maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程\n- keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了`allowCoreThreadTimeOut(boolean)`方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0\n- unit：参数keepAliveTime的时间单位，有7种取值\n```\nTimeUnit.DAYS;               //天\nTimeUnit.HOURS;             //小时\nTimeUnit.MINUTES;           //分钟\nTimeUnit.SECONDS;           //秒\nTimeUnit.MILLISECONDS;      //毫秒\nTimeUnit.MICROSECONDS;      //微妙\nTimeUnit.NANOSECONDS;       //纳秒\n```\n\n- workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：\n```\nArrayBlockingQueue;\nLinkedBlockingQueue;\nSynchronousQueue;\n```\n- threadFactory：线程工厂，主要用来创建线程\n- handler：表示当拒绝处理任务时的策略，有以下四种选择：\n```\nThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 \nThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 \nThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\nThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 \n```\n\n#### 为何使用\n- 降低资源消耗<br>\n  可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 \n- 提高响应速度<br> \n  当任务到达时，任务可以不需要等到线程创建就能立即执行。 \n- 提高线程的可管理性 <br>\n  线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控\n\n#### 如何使用\n实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法\n```Java\n    //创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的\n    //线程池满了就不再添加线程；\n    //如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列\n    //因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务\n    //若池中线程空闲时间超过指定大小，则该线程会被销毁。\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //创建只有一个线程的线程池，且线程的存活时间是无限的\n    //当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>(),\n                                    threadFactory));\n    }\n    \n    //创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行\n    //如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中\n    //这是一种按照超时时间排序的队列结构\n    public static ScheduledExecutorService newScheduledThreadPool(\n            int corePoolSize, ThreadFactory threadFactory) {\n        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\n    }\n```\nThreadPoolExecutor 中比较重要的方法\n\n| 方法          | 描述                                                      |\n| ------------- | --------------------------------------------------------- |\n| execute()     | 向线程池提交一个任务，交由线程池去执行                    |\n| submit()      | 向线程池提交任务的，能够返回任务执行的结果（利用 Future） |\n| shutdown()    | 关闭线程池                                                |\n| shutdownNow() | 关闭线程池                                                |\n\n还有其他的方法比如：`getQueue()`、`getPoolSize()` 、`getActiveCount()`、`getCompletedTaskCount()`等用来获取线程池的相关属性。\n\n简单使用\n```Java\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        System.out.println(Thread.currentThread());\n        executor.execute(()-> {\n            System.out.println(Thread.currentThread());\n        });\n    }\n```\n控制台输出\n```\nThread[main,5,main]\nThread[pool-1-thread-1,5,main]\n```\n#### 工作原理\n观察 ThreadPoolExecutor 中的`execute`方法\n```Java\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n  \n        /**\n         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务\n         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。\n         * 三、如果加入 workQueue 失败，则创建线程执行任务，\n         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n\n跟踪`addWorker`方法\n```Java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (int c = ctl.get();;) {\n        // Check if queue empty only if necessary.\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP)\n                || firstTask != null\n                || workQueue.isEmpty()))\n            return false;\n        for (;;) {\n            /*\n             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，\n             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况\n             */\n            if (workerCountOf(c)\n                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateAtLeast(c, SHUTDOWN))\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n        \n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        /*\n         * 创建Worker时会调用threadFactory来创建一个线程。\n         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。\n         */\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                int c = ctl.get();\n                \n                if (isRunning(c) ||\n                    (runStateLessThan(c, STOP) && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n新建 Work ，同时也会利用工厂类实例化一个线程\n```Java\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n如果 workerAdded，调用`t.start()`\n```Java\npublic void run() {\n    runWorker(this);\n}\n```\n跟踪`runWorker`\n```Java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                try {\n                    task.run();\n                    afterExecute(task, null);\n                } catch (Throwable ex) {\n                    afterExecute(task, ex);\n                    throw ex;\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n可以看到`getTask`方法不断从 workerQueue 中读取任务然后执行。只要`getTask`方法不返回 null，循环就不会退出。\n```Java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n    for (;;) {\n        int c = ctl.get();\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        int wc = workerCountOf(c);\n\n        //是判断当前线程数是否大于 corePoolSize\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        \n        /*\n         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务\n         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出\n         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前\n         */\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n最后用一张图总结上述过程\n\n![](Java-线程和线程池详解/线程池流程.png)","source":"_posts/Java-线程和线程池详解.md","raw":"---\ntitle: Java 线程和线程池详解\ndate: 2019-03-20 17:29:06\ntags:\n- Java\n- 多线程\n- 线程池\ncategories:\n- Java\n---\n\n线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：\n> java.lang.Thread 类的一个实例；\n>\n> 线程的执行。\n\n<!--more-->\n\n## Java 线程\n\n### 线程和进程\n\n#### 概念\n\n进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。\n\n#### 区别\n进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。\n\n线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。\n\n> 一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。\n>\n> Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。\n>\n> 由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。\n\n实际开发中使用多线程的优势在于\n\n- 进程之间不能共享内存，而线程之间可以共享内存。\n- 系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。\n- Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。\n\n### 线程的状态\n图一\n\n\n\n![](Java-线程和线程池详解/线程状态1.png)\n\n图二\n\n![](Java-线程和线程池详解/线程状态2.png)\n\n### 分类\nJava 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。\n\n只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。\n```Java\npublic class Main {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread();\n        thread.setDaemon(true);\n        System.out.println(\"is daemon thread? \" + thread.isDaemon());\n    }\n}\n```\n输出为\n```\nis daemon thread? true\n```\n使用守护线程要注意的点\n- `thread.setDaemon(true)` 必须在 `thread.start()` 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。\n- 在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 \n- 不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 \n\n### Runnable 和 Thread\nRunnable 是一个线程接口，查看其构造\n```Java\npublic interface Runnable {\n    public abstract void run();\n}\n```\n其中只定义了一个`run`方法\n\nThread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的`init`\n```\nprivate void init(ThreadGroup g, Runnable target, String name,\n                      long stackSize, AccessControlContext acc,\n                      boolean inheritThreadLocals)\n```\n观察 Thread 中重写的`run`方法\n```Java\n@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n其中 target 为 Runnable 对象，即调用 Thread 的`run`实际上是调用我们传进去的 Runnable 的对应方法\n\n观察其`start`方法\n```Java\npublic synchronized void start() {\n    //不能重复调用 start 方法\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n        \n    //将线程加入线程组\n    group.add(this);\n    //线程开始标志\n    boolean started = false;\n    try {\n        //调用native方法开始多线程\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n其中`start0`是 native 方法，在其中新建线程，然后回调 target 的 run 方法。\n\n也就是说，如果我们直接调用`run`方法，相当于调用普通方法，不会有多线程效果。只有调用`start`才会在后台开启另一个线程，等待 CPU 调度。\n\n### 多线程 API\n#### Object\n实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法\n\n| 方法            | 描述                                                         |\n| --------------- | ------------------------------------------------------------ |\n| wait()          | 锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池 |\n| wait(long)      | 锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。 |\n| wait(long, int) | 和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000 |\n| notify()        | 随机唤醒一个处于等待中的线程（同一个等待阻塞池中）           |\n| notifyAll()     | 唤醒所有等待中的线程（同一个等待阻塞池中）                   |\n\n以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行`object.wait()`方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下\n```Java\npublic class ThreadTest {\n    public static void main(String[] args) {\n        Thread t = Thread.currentThread();\n        try {\n            t.wait(2000);   //由于没有获得锁，将抛出 IllegalMonitorStateException 异常\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in Main: \" + t.toString());\n        A a = new A();\n        a.printThreadInfo();\n    }\n}\n\nclass A {\n    public synchronized void printThreadInfo() {\n        Thread t = Thread.currentThread();\n        try {\n            wait(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in A: \" + t.toString());\n    }\n}\n```\n删除`main`中 try/catch 语句之后，控制台输出如下\n```\ncurrent Thread info in Main: Thread[main,5,main]\n//等待两秒\ncurrent Thread info in A: Thread[main,5,main]\n```\n**为什么需要在 synchronized 中？**\n> wait和notify用于线程间通信。\n> 以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性\n>\n> 一般对队列的操作如下:\n> while(queue.size() == MAX_SIZE){ wait() }\n>\n> 假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2\n>\n> - t1判断队列满，需要 wait 阻塞线程。\n>\n> - 但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。\n>\n> - 这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。\n>\n> - 假如此时消费者不消费了，那么生产者则会一直阻塞下去。\n>\n> - 所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。\n\n**为什么定义在 Object 中？**\n> Object 中的`wait()`, `notify()`等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。\n>\n> `wait()`会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！\n> 当线程释放它持有的“同步锁”之后变成等待线程，可以被`notify()`或`notifyAll()`唤醒。那么，`notify()`依据什么唤醒等待线程的？或者说，`wait()`等待线程和`notify()`之间通过什么关联起来？答案是：依据“对象的同步锁”。\n>\n> 负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用`notify()`或`notifyAll()`方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n> 总之，`notify()`, `wait()`依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！\n>\n> 这就是`notify()`, `wait()`等函数定义在 Object 类，而不是 Thread 类中的原因。\n>\n> 来自 [JAVA 线程状态及转化](https://www.cnblogs.com/happy-coder/p/6587092.html)\n\n#### Thread \n| 方法                      | 描述                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| Thread.currentThread()    | 返回对当前线程对象的引用                                     |\n| Thread.interrupted()      | 检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false） |\n| Thread.sleep(long millis) | 使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会） |\n| Thread.yield()            | 使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会） |\n| t.getId()...              | 返回该线程的 id 等等信息                                     |\n| t.interrupt()             | 将该线程中断（实际并不会中断，只是将中断标志设置为true）     |\n| t.isInterrupted()         | 检测该线程是否已经中断                                       |\n| t.join()                  | 在a线程中调用b.join()，则a线程阻塞，直到b线程执行完          |\n| t.join(long millis)       | 同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。 |\n\n---\n关于 interrupt，[JAVA interrupt、interrupted和isInterrupted的区别](https://blog.csdn.net/qpc908694753/article/details/61414495)\n> interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为\"中断\"状态。\n>\n> 注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。\n\n#### 废弃方法\n- stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止\n- suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。\n- resume：用来回复被挂起的线程，跟 suspend 对应。\n\n## 线程池\n\nJava 中关于线程池的继承关系如下\n\n![](Java-线程和线程池详解/继承图.png)\n\nExecutor 是一个顶层接口，其中只声明了一个方法`execute(Runnable)`，用来执行传进去的任务\n\nExecutorService 接口继承了 Executor 接口，并声明了一些方法：`submit`、`invokeAll`、`invokeAny`以及`shutDown` 等\n\n抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法\n\nThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下\n```Java\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n- corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用`prestartAllCoreThreads`或者`prestartCoreThread`方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中\n- maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程\n- keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了`allowCoreThreadTimeOut(boolean)`方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0\n- unit：参数keepAliveTime的时间单位，有7种取值\n```\nTimeUnit.DAYS;               //天\nTimeUnit.HOURS;             //小时\nTimeUnit.MINUTES;           //分钟\nTimeUnit.SECONDS;           //秒\nTimeUnit.MILLISECONDS;      //毫秒\nTimeUnit.MICROSECONDS;      //微妙\nTimeUnit.NANOSECONDS;       //纳秒\n```\n\n- workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：\n```\nArrayBlockingQueue;\nLinkedBlockingQueue;\nSynchronousQueue;\n```\n- threadFactory：线程工厂，主要用来创建线程\n- handler：表示当拒绝处理任务时的策略，有以下四种选择：\n```\nThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 \nThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 \nThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\nThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 \n```\n\n#### 为何使用\n- 降低资源消耗<br>\n  可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 \n- 提高响应速度<br> \n  当任务到达时，任务可以不需要等到线程创建就能立即执行。 \n- 提高线程的可管理性 <br>\n  线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控\n\n#### 如何使用\n实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法\n```Java\n    //创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的\n    //线程池满了就不再添加线程；\n    //如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列\n    //因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务\n    //若池中线程空闲时间超过指定大小，则该线程会被销毁。\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //创建只有一个线程的线程池，且线程的存活时间是无限的\n    //当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>(),\n                                    threadFactory));\n    }\n    \n    //创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行\n    //如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中\n    //这是一种按照超时时间排序的队列结构\n    public static ScheduledExecutorService newScheduledThreadPool(\n            int corePoolSize, ThreadFactory threadFactory) {\n        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\n    }\n```\nThreadPoolExecutor 中比较重要的方法\n\n| 方法          | 描述                                                      |\n| ------------- | --------------------------------------------------------- |\n| execute()     | 向线程池提交一个任务，交由线程池去执行                    |\n| submit()      | 向线程池提交任务的，能够返回任务执行的结果（利用 Future） |\n| shutdown()    | 关闭线程池                                                |\n| shutdownNow() | 关闭线程池                                                |\n\n还有其他的方法比如：`getQueue()`、`getPoolSize()` 、`getActiveCount()`、`getCompletedTaskCount()`等用来获取线程池的相关属性。\n\n简单使用\n```Java\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        System.out.println(Thread.currentThread());\n        executor.execute(()-> {\n            System.out.println(Thread.currentThread());\n        });\n    }\n```\n控制台输出\n```\nThread[main,5,main]\nThread[pool-1-thread-1,5,main]\n```\n#### 工作原理\n观察 ThreadPoolExecutor 中的`execute`方法\n```Java\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n  \n        /**\n         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务\n         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。\n         * 三、如果加入 workQueue 失败，则创建线程执行任务，\n         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n\n跟踪`addWorker`方法\n```Java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (int c = ctl.get();;) {\n        // Check if queue empty only if necessary.\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP)\n                || firstTask != null\n                || workQueue.isEmpty()))\n            return false;\n        for (;;) {\n            /*\n             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，\n             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况\n             */\n            if (workerCountOf(c)\n                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateAtLeast(c, SHUTDOWN))\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n        \n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        /*\n         * 创建Worker时会调用threadFactory来创建一个线程。\n         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。\n         */\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                int c = ctl.get();\n                \n                if (isRunning(c) ||\n                    (runStateLessThan(c, STOP) && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n新建 Work ，同时也会利用工厂类实例化一个线程\n```Java\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n如果 workerAdded，调用`t.start()`\n```Java\npublic void run() {\n    runWorker(this);\n}\n```\n跟踪`runWorker`\n```Java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                try {\n                    task.run();\n                    afterExecute(task, null);\n                } catch (Throwable ex) {\n                    afterExecute(task, ex);\n                    throw ex;\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n可以看到`getTask`方法不断从 workerQueue 中读取任务然后执行。只要`getTask`方法不返回 null，循环就不会退出。\n```Java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n    for (;;) {\n        int c = ctl.get();\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        int wc = workerCountOf(c);\n\n        //是判断当前线程数是否大于 corePoolSize\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        \n        /*\n         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务\n         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出\n         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前\n         */\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n最后用一张图总结上述过程\n\n![](Java-线程和线程池详解/线程池流程.png)","slug":"Java-线程和线程池详解","published":1,"updated":"2019-06-02T05:02:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqyv005gy4up42gdsjfa","content":"<p>线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：</p>\n<blockquote>\n<p>java.lang.Thread 类的一个实例；</p>\n<p>线程的执行。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Java-线程\"><a href=\"#Java-线程\" class=\"headerlink\" title=\"Java 线程\"></a>Java 线程</h2><h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>\n<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</p>\n<p>线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。</p>\n<blockquote>\n<p>一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。</p>\n<p>Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。</p>\n<p>由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。</p>\n</blockquote>\n<p>实际开发中使用多线程的优势在于</p>\n<ul>\n<li>进程之间不能共享内存，而线程之间可以共享内存。</li>\n<li>系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。</li>\n<li>Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。</li>\n</ul>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><p>图一</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态1.png\" alt></p>\n<p>图二</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态2.png\" alt></p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>Java 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。</p>\n<p>只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"is daemon thread? \"</span> + thread.isDaemon());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>输出为<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">is daemon thread? true</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>使用守护线程要注意的点</p>\n<ul>\n<li><code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。</li>\n<li>在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 </li>\n<li>不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 </li>\n</ul>\n<h3 id=\"Runnable-和-Thread\"><a href=\"#Runnable-和-Thread\" class=\"headerlink\" title=\"Runnable 和 Thread\"></a>Runnable 和 Thread</h3><p>Runnable 是一个线程接口，查看其构造<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>其中只定义了一个<code>run</code>方法</p>\n<p>Thread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的<code>init</code><br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class=\"line\">                      long stackSize, AccessControlContext acc,</span><br><span class=\"line\">                      boolean inheritThreadLocals)</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>观察 Thread 中重写的<code>run</code>方法<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>其中 target 为 Runnable 对象，即调用 Thread 的<code>run</code>实际上是调用我们传进去的 Runnable 的对应方法</p>\n<p>观察其<code>start</code>方法<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">//不能重复调用 start 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">//将线程加入线程组</span></span><br><span class=\"line\">    group.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程开始标志</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> started = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"comment\">//调用native方法开始多线程</span></span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">finally</span> {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!started) {</span><br><span class=\"line\">                group.threadStartFailed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (Throwable ignore) {</span><br><span class=\"line\">            <span class=\"comment\">/* do nothing. If start0 threw a Throwable then</span></span><br><span class=\"line\"><span class=\"comment\">              it will be passed up the call stack */</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>其中<code>start0</code>是 native 方法，在其中新建线程，然后回调 target 的 run 方法。</p>\n<p>也就是说，如果我们直接调用<code>run</code>方法，相当于调用普通方法，不会有多线程效果。只有调用<code>start</code>才会在后台开启另一个线程，等待 CPU 调度。</p>\n<h3 id=\"多线程-API\"><a href=\"#多线程-API\" class=\"headerlink\" title=\"多线程 API\"></a>多线程 API</h3><h4 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h4><p>实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wait()</td>\n<td>锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池</td>\n</tr>\n<tr>\n<td>wait(long)</td>\n<td>锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。</td>\n</tr>\n<tr>\n<td>wait(long, int)</td>\n<td>和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000</td>\n</tr>\n<tr>\n<td>notify()</td>\n<td>随机唤醒一个处于等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n<tr>\n<td>notifyAll()</td>\n<td>唤醒所有等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n</tbody>\n</table>\n<p>以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行<code>object.wait()</code>方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            t.wait(<span class=\"number\">2000</span>);   <span class=\"comment\">//由于没有获得锁，将抛出 IllegalMonitorStateException 异常</span></span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (InterruptedException e) {</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        }</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in Main: \"</span> + t.toString());</span><br><span class=\"line\">        A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">        a.printThreadInfo();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">printThreadInfo</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            wait(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (InterruptedException e) {</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        }</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in A: \"</span> + t.toString());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>删除<code>main</code>中 try/catch 语句之后，控制台输出如下<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">current Thread info in Main: Thread[main,5,main]</span><br><span class=\"line\">//等待两秒</span><br><span class=\"line\">current Thread info in A: Thread[main,5,main]</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p><strong>为什么需要在 synchronized 中？</strong></p>\n<blockquote>\n<p>wait和notify用于线程间通信。<br>以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性</p>\n<p>一般对队列的操作如下:<br>while(queue.size() == MAX_SIZE){ wait() }</p>\n<p>假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2</p>\n<ul>\n<li><p>t1判断队列满，需要 wait 阻塞线程。</p>\n</li>\n<li><p>但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。</p>\n</li>\n<li><p>这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。</p>\n</li>\n<li><p>假如此时消费者不消费了，那么生产者则会一直阻塞下去。</p>\n</li>\n<li><p>所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>为什么定义在 Object 中？</strong></p>\n<blockquote>\n<p>Object 中的<code>wait()</code>, <code>notify()</code>等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。</p>\n<p><code>wait()</code>会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！<br>当线程释放它持有的“同步锁”之后变成等待线程，可以被<code>notify()</code>或<code>notifyAll()</code>唤醒。那么，<code>notify()</code>依据什么唤醒等待线程的？或者说，<code>wait()</code>等待线程和<code>notify()</code>之间通过什么关联起来？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用<code>notify()</code>或<code>notifyAll()</code>方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，<code>notify()</code>, <code>wait()</code>依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！</p>\n<p>这就是<code>notify()</code>, <code>wait()</code>等函数定义在 Object 类，而不是 Thread 类中的原因。</p>\n<p>来自 <a href=\"https://www.cnblogs.com/happy-coder/p/6587092.html\" target=\"_blank\" rel=\"noopener\">JAVA 线程状态及转化</a></p>\n</blockquote>\n<h4 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Thread.currentThread()</td>\n<td>返回对当前线程对象的引用</td>\n</tr>\n<tr>\n<td>Thread.interrupted()</td>\n<td>检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false）</td>\n</tr>\n<tr>\n<td>Thread.sleep(long millis)</td>\n<td>使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会）</td>\n</tr>\n<tr>\n<td>Thread.yield()</td>\n<td>使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会）</td>\n</tr>\n<tr>\n<td>t.getId()…</td>\n<td>返回该线程的 id 等等信息</td>\n</tr>\n<tr>\n<td>t.interrupt()</td>\n<td>将该线程中断（实际并不会中断，只是将中断标志设置为true）</td>\n</tr>\n<tr>\n<td>t.isInterrupted()</td>\n<td>检测该线程是否已经中断</td>\n</tr>\n<tr>\n<td>t.join()</td>\n<td>在a线程中调用b.join()，则a线程阻塞，直到b线程执行完</td>\n</tr>\n<tr>\n<td>t.join(long millis)</td>\n<td>同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>关于 interrupt，<a href=\"https://blog.csdn.net/qpc908694753/article/details/61414495\" target=\"_blank\" rel=\"noopener\">JAVA interrupt、interrupted和isInterrupted的区别</a></p>\n<blockquote>\n<p>interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。</p>\n<p>注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>\n</blockquote>\n<h4 id=\"废弃方法\"><a href=\"#废弃方法\" class=\"headerlink\" title=\"废弃方法\"></a>废弃方法</h4><ul>\n<li>stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止</li>\n<li>suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。</li>\n<li>resume：用来回复被挂起的线程，跟 suspend 对应。</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>Java 中关于线程池的继承关系如下</p>\n<p><img src=\"/Java-线程和线程池详解/继承图.png\" alt></p>\n<p>Executor 是一个顶层接口，其中只声明了一个方法<code>execute(Runnable)</code>，用来执行传进去的任务</p>\n<p>ExecutorService 接口继承了 Executor 接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code> 等</p>\n<p>抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法</p>\n<p>ThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue<Runnable> workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize < <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize <= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize < corePoolSize ||</span><br><span class=\"line\">        keepAliveTime < <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<ul>\n<li>corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用<code>prestartAllCoreThreads</code>或者<code>prestartCoreThread</code>方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中</li>\n<li>maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程</li>\n<li>keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0</li>\n<li><p>unit：参数keepAliveTime的时间单位，有7种取值</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">TimeUnit.DAYS;               //天</span><br><span class=\"line\">TimeUnit.HOURS;             //小时</span><br><span class=\"line\">TimeUnit.MINUTES;           //分钟</span><br><span class=\"line\">TimeUnit.SECONDS;           //秒</span><br><span class=\"line\">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class=\"line\">TimeUnit.MICROSECONDS;      //微妙</span><br><span class=\"line\">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ArrayBlockingQueue;</span><br><span class=\"line\">LinkedBlockingQueue;</span><br><span class=\"line\">SynchronousQueue;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>threadFactory：线程工厂，主要用来创建线程</p>\n</li>\n<li>handler：表示当拒绝处理任务时的策略，有以下四种选择：<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<h4 id=\"为何使用\"><a href=\"#为何使用\" class=\"headerlink\" title=\"为何使用\"></a>为何使用</h4><ul>\n<li>降低资源消耗<br><br>可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>\n<li>提高响应速度<br><br>当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>\n<li>提高线程的可管理性 <br><br>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>\n</ul>\n<h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//线程池满了就不再添加线程；</span></span><br><span class=\"line\"><span class=\"comment\">//如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads, ThreadFactory threadFactory)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue<Runnable>(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列</span></span><br><span class=\"line\"><span class=\"comment\">//因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务</span></span><br><span class=\"line\"><span class=\"comment\">//若池中线程空闲时间超过指定大小，则该线程会被销毁。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> SynchronousQueue<Runnable>(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建只有一个线程的线程池，且线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">        (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> LinkedBlockingQueue<Runnable>(),</span><br><span class=\"line\">                                threadFactory));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行</span></span><br><span class=\"line\"><span class=\"comment\">//如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中</span></span><br><span class=\"line\"><span class=\"comment\">//这是一种按照超时时间排序的队列结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>ThreadPoolExecutor 中比较重要的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>execute()</td>\n<td>向线程池提交一个任务，交由线程池去执行</td>\n</tr>\n<tr>\n<td>submit()</td>\n<td>向线程池提交任务的，能够返回任务执行的结果（利用 Future）</td>\n</tr>\n<tr>\n<td>shutdown()</td>\n<td>关闭线程池</td>\n</tr>\n<tr>\n<td>shutdownNow()</td>\n<td>关闭线程池</td>\n</tr>\n</tbody>\n</table>\n<p>还有其他的方法比如：<code>getQueue()</code>、<code>getPoolSize()</code> 、<code>getActiveCount()</code>、<code>getCompletedTaskCount()</code>等用来获取线程池的相关属性。</p>\n<p>简单使用<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    System.out.println(Thread.currentThread());</span><br><span class=\"line\">    executor.execute(()-> {</span><br><span class=\"line\">        System.out.println(Thread.currentThread());</span><br><span class=\"line\">    });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>控制台输出<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Thread[main,5,main]</span><br><span class=\"line\">Thread[pool-1-thread-1,5,main]</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>观察 ThreadPoolExecutor 中的<code>execute</code>方法<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。</span></span><br><span class=\"line\"><span class=\"comment\">         * 三、如果加入 workQueue 失败，则创建线程执行任务，</span></span><br><span class=\"line\"><span class=\"comment\">         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) < corePoolSize) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            c = ctl.get();</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) && workQueue.offer(command)) {</span><br><span class=\"line\">            <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (! isRunning(recheck) && remove(command))</span><br><span class=\"line\">                reject(command);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>跟踪<code>addWorker</code>方法<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>{</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = ctl.get();;) {</span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            && (runStateAtLeast(c, STOP)</span><br><span class=\"line\">                || firstTask != <span class=\"keyword\">null</span></span><br><span class=\"line\">                || workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) {</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，</span></span><br><span class=\"line\"><span class=\"comment\">             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c)</span><br><span class=\"line\">                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 创建Worker时会调用threadFactory来创建一个线程。</span></span><br><span class=\"line\"><span class=\"comment\">         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isRunning(c) ||</span><br><span class=\"line\">                    (runStateLessThan(c, STOP) && firstTask == <span class=\"keyword\">null</span>)) {</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s > largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            } <span class=\"keyword\">finally</span> {</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) {</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    } <span class=\"keyword\">finally</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>新建 Work ，同时也会利用工厂类实例化一个线程<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Worker(Runnable firstTask) {</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>如果 workerAdded，调用<code>t.start()</code><br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>跟踪<code>runWorker</code><br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>{</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &&</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &&</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                    afterExecute(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                } <span class=\"keyword\">catch</span> (Throwable ex) {</span><br><span class=\"line\">                    afterExecute(task, ex);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            } <span class=\"keyword\">finally</span> {</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">finally</span> {</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>可以看到<code>getTask</code>方法不断从 workerQueue 中读取任务然后执行。只要<code>getTask</code>方法不返回 null，循环就不会退出。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//是判断当前线程数是否大于 corePoolSize</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc > corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc > maximumPoolSize || (timed && timedOut))</span><br><span class=\"line\">            && (wc > <span class=\"number\">1</span> || workQueue.isEmpty())) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (InterruptedException retry) {</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>最后用一张图总结上述过程</p>\n<p><img src=\"/Java-线程和线程池详解/线程池流程.png\" alt></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":16599,"excerpt":"<p>线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：</p>\n<blockquote>\n<p>java.lang.Thread 类的一个实例；</p>\n<p>线程的执行。</p>\n</blockquote>","more":"<h2 id=\"Java-线程\"><a href=\"#Java-线程\" class=\"headerlink\" title=\"Java 线程\"></a>Java 线程</h2><h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>\n<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</p>\n<p>线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。</p>\n<blockquote>\n<p>一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。</p>\n<p>Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。</p>\n<p>由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。</p>\n</blockquote>\n<p>实际开发中使用多线程的优势在于</p>\n<ul>\n<li>进程之间不能共享内存，而线程之间可以共享内存。</li>\n<li>系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。</li>\n<li>Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。</li>\n</ul>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><p>图一</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态1.png\" alt=\"\"></p>\n<p>图二</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态2.png\" alt=\"\"></p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>Java 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。</p>\n<p>只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"is daemon thread? \"</span> + thread.isDaemon());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出为<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">is daemon thread? true</span><br></pre></td></tr></table></figure></p>\n<p>使用守护线程要注意的点</p>\n<ul>\n<li><code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。</li>\n<li>在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 </li>\n<li>不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 </li>\n</ul>\n<h3 id=\"Runnable-和-Thread\"><a href=\"#Runnable-和-Thread\" class=\"headerlink\" title=\"Runnable 和 Thread\"></a>Runnable 和 Thread</h3><p>Runnable 是一个线程接口，查看其构造<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中只定义了一个<code>run</code>方法</p>\n<p>Thread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的<code>init</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class=\"line\">                      long stackSize, AccessControlContext acc,</span><br><span class=\"line\">                      boolean inheritThreadLocals)</span><br></pre></td></tr></table></figure></p>\n<p>观察 Thread 中重写的<code>run</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 target 为 Runnable 对象，即调用 Thread 的<code>run</code>实际上是调用我们传进去的 Runnable 的对应方法</p>\n<p>观察其<code>start</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不能重复调用 start 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">//将线程加入线程组</span></span><br><span class=\"line\">    group.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程开始标志</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> started = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用native方法开始多线程</span></span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!started) &#123;</span><br><span class=\"line\">                group.threadStartFailed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* do nothing. If start0 threw a Throwable then</span></span><br><span class=\"line\"><span class=\"comment\">              it will be passed up the call stack */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>start0</code>是 native 方法，在其中新建线程，然后回调 target 的 run 方法。</p>\n<p>也就是说，如果我们直接调用<code>run</code>方法，相当于调用普通方法，不会有多线程效果。只有调用<code>start</code>才会在后台开启另一个线程，等待 CPU 调度。</p>\n<h3 id=\"多线程-API\"><a href=\"#多线程-API\" class=\"headerlink\" title=\"多线程 API\"></a>多线程 API</h3><h4 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h4><p>实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wait()</td>\n<td>锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池</td>\n</tr>\n<tr>\n<td>wait(long)</td>\n<td>锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。</td>\n</tr>\n<tr>\n<td>wait(long, int)</td>\n<td>和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000</td>\n</tr>\n<tr>\n<td>notify()</td>\n<td>随机唤醒一个处于等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n<tr>\n<td>notifyAll()</td>\n<td>唤醒所有等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n</tbody>\n</table>\n<p>以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行<code>object.wait()</code>方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            t.wait(<span class=\"number\">2000</span>);   <span class=\"comment\">//由于没有获得锁，将抛出 IllegalMonitorStateException 异常</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in Main: \"</span> + t.toString());</span><br><span class=\"line\">        A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">        a.printThreadInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">printThreadInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            wait(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in A: \"</span> + t.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>删除<code>main</code>中 try/catch 语句之后，控制台输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">current Thread info in Main: Thread[main,5,main]</span><br><span class=\"line\">//等待两秒</span><br><span class=\"line\">current Thread info in A: Thread[main,5,main]</span><br></pre></td></tr></table></figure></p>\n<p><strong>为什么需要在 synchronized 中？</strong></p>\n<blockquote>\n<p>wait和notify用于线程间通信。<br>以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性</p>\n<p>一般对队列的操作如下:<br>while(queue.size() == MAX_SIZE){ wait() }</p>\n<p>假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2</p>\n<ul>\n<li><p>t1判断队列满，需要 wait 阻塞线程。</p>\n</li>\n<li><p>但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。</p>\n</li>\n<li><p>这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。</p>\n</li>\n<li><p>假如此时消费者不消费了，那么生产者则会一直阻塞下去。</p>\n</li>\n<li><p>所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>为什么定义在 Object 中？</strong></p>\n<blockquote>\n<p>Object 中的<code>wait()</code>, <code>notify()</code>等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。</p>\n<p><code>wait()</code>会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！<br>当线程释放它持有的“同步锁”之后变成等待线程，可以被<code>notify()</code>或<code>notifyAll()</code>唤醒。那么，<code>notify()</code>依据什么唤醒等待线程的？或者说，<code>wait()</code>等待线程和<code>notify()</code>之间通过什么关联起来？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用<code>notify()</code>或<code>notifyAll()</code>方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，<code>notify()</code>, <code>wait()</code>依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！</p>\n<p>这就是<code>notify()</code>, <code>wait()</code>等函数定义在 Object 类，而不是 Thread 类中的原因。</p>\n<p>来自 <a href=\"https://www.cnblogs.com/happy-coder/p/6587092.html\" target=\"_blank\" rel=\"noopener\">JAVA 线程状态及转化</a></p>\n</blockquote>\n<h4 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Thread.currentThread()</td>\n<td>返回对当前线程对象的引用</td>\n</tr>\n<tr>\n<td>Thread.interrupted()</td>\n<td>检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false）</td>\n</tr>\n<tr>\n<td>Thread.sleep(long millis)</td>\n<td>使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会）</td>\n</tr>\n<tr>\n<td>Thread.yield()</td>\n<td>使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会）</td>\n</tr>\n<tr>\n<td>t.getId()…</td>\n<td>返回该线程的 id 等等信息</td>\n</tr>\n<tr>\n<td>t.interrupt()</td>\n<td>将该线程中断（实际并不会中断，只是将中断标志设置为true）</td>\n</tr>\n<tr>\n<td>t.isInterrupted()</td>\n<td>检测该线程是否已经中断</td>\n</tr>\n<tr>\n<td>t.join()</td>\n<td>在a线程中调用b.join()，则a线程阻塞，直到b线程执行完</td>\n</tr>\n<tr>\n<td>t.join(long millis)</td>\n<td>同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>关于 interrupt，<a href=\"https://blog.csdn.net/qpc908694753/article/details/61414495\" target=\"_blank\" rel=\"noopener\">JAVA interrupt、interrupted和isInterrupted的区别</a></p>\n<blockquote>\n<p>interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。</p>\n<p>注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>\n</blockquote>\n<h4 id=\"废弃方法\"><a href=\"#废弃方法\" class=\"headerlink\" title=\"废弃方法\"></a>废弃方法</h4><ul>\n<li>stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止</li>\n<li>suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。</li>\n<li>resume：用来回复被挂起的线程，跟 suspend 对应。</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>Java 中关于线程池的继承关系如下</p>\n<p><img src=\"/Java-线程和线程池详解/继承图.png\" alt=\"\"></p>\n<p>Executor 是一个顶层接口，其中只声明了一个方法<code>execute(Runnable)</code>，用来执行传进去的任务</p>\n<p>ExecutorService 接口继承了 Executor 接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code> 等</p>\n<p>抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法</p>\n<p>ThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用<code>prestartAllCoreThreads</code>或者<code>prestartCoreThread</code>方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中</li>\n<li>maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程</li>\n<li>keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0</li>\n<li><p>unit：参数keepAliveTime的时间单位，有7种取值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">TimeUnit.DAYS;               //天</span><br><span class=\"line\">TimeUnit.HOURS;             //小时</span><br><span class=\"line\">TimeUnit.MINUTES;           //分钟</span><br><span class=\"line\">TimeUnit.SECONDS;           //秒</span><br><span class=\"line\">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class=\"line\">TimeUnit.MICROSECONDS;      //微妙</span><br><span class=\"line\">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayBlockingQueue;</span><br><span class=\"line\">LinkedBlockingQueue;</span><br><span class=\"line\">SynchronousQueue;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>threadFactory：线程工厂，主要用来创建线程</p>\n</li>\n<li>handler：表示当拒绝处理任务时的策略，有以下四种选择：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"为何使用\"><a href=\"#为何使用\" class=\"headerlink\" title=\"为何使用\"></a>为何使用</h4><ul>\n<li>降低资源消耗<br><br>可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>\n<li>提高响应速度<br><br>当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>\n<li>提高线程的可管理性 <br><br>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>\n</ul>\n<h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//线程池满了就不再添加线程；</span></span><br><span class=\"line\"><span class=\"comment\">//如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列</span></span><br><span class=\"line\"><span class=\"comment\">//因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务</span></span><br><span class=\"line\"><span class=\"comment\">//若池中线程空闲时间超过指定大小，则该线程会被销毁。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建只有一个线程的线程池，且线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">        (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                threadFactory));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行</span></span><br><span class=\"line\"><span class=\"comment\">//如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中</span></span><br><span class=\"line\"><span class=\"comment\">//这是一种按照超时时间排序的队列结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ThreadPoolExecutor 中比较重要的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>execute()</td>\n<td>向线程池提交一个任务，交由线程池去执行</td>\n</tr>\n<tr>\n<td>submit()</td>\n<td>向线程池提交任务的，能够返回任务执行的结果（利用 Future）</td>\n</tr>\n<tr>\n<td>shutdown()</td>\n<td>关闭线程池</td>\n</tr>\n<tr>\n<td>shutdownNow()</td>\n<td>关闭线程池</td>\n</tr>\n</tbody>\n</table>\n<p>还有其他的方法比如：<code>getQueue()</code>、<code>getPoolSize()</code> 、<code>getActiveCount()</code>、<code>getCompletedTaskCount()</code>等用来获取线程池的相关属性。</p>\n<p>简单使用<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    System.out.println(Thread.currentThread());</span><br><span class=\"line\">    executor.execute(()-&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Thread[main,5,main]</span><br><span class=\"line\">Thread[pool-1-thread-1,5,main]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>观察 ThreadPoolExecutor 中的<code>execute</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。</span></span><br><span class=\"line\"><span class=\"comment\">         * 三、如果加入 workQueue 失败，则创建线程执行任务，</span></span><br><span class=\"line\"><span class=\"comment\">         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            c = ctl.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">                reject(command);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟踪<code>addWorker</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = ctl.get();;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class=\"line\">                || firstTask != <span class=\"keyword\">null</span></span><br><span class=\"line\">                || workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，</span></span><br><span class=\"line\"><span class=\"comment\">             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c)</span><br><span class=\"line\">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 创建Worker时会调用threadFactory来创建一个线程。</span></span><br><span class=\"line\"><span class=\"comment\">         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isRunning(c) ||</span><br><span class=\"line\">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>新建 Work ，同时也会利用工厂类实例化一个线程<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果 workerAdded，调用<code>t.start()</code><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟踪<code>runWorker</code><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                    afterExecute(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    afterExecute(task, ex);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>getTask</code>方法不断从 workerQueue 中读取任务然后执行。只要<code>getTask</code>方法不返回 null，循环就不会退出。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//是判断当前线程数是否大于 corePoolSize</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后用一张图总结上述过程</p>\n<p><img src=\"/Java-线程和线程池详解/线程池流程.png\" alt=\"\"></p>"},{"title":"Gradle 构建工具详解","date":"2019-05-25T14:37:41.000Z","_content":"\nGradle 是一个基于 JVM 的自动化构建工具，使用 Groovy  DSL 声明配置。现代软件开发包含众多步骤，包括编译、测试、打包等，如果需要手动重复每一过程，将会耗费大量时间、增加出错概率，项目自动化应运而生。在此之前，常见的 Java 构建工具包括 Ant、Gant 和 Maven 等，Gradle 结合了以上工具的优点，基于约定大于配置，通用灵活，是 Android 的官方构建工具。本文将介绍 Gradle 的基本知识、Groovy 基本语法以及 Android 开发中的 Gradle 知识。\n\n![](https://plugins.gradle.org/shared-assets/shared/images/gradle-logo-horizontal.svg)\n\n<!--more-->\n\n## 入门\n\n### 搭建环境\n\n确保系统已安装 JDK 1.7及以上，此处将介绍 Gradle 在 Windows 平台下的手动安装。在 https://gradle.org/releases/ 下载最新的 release 包并解压至相应文件夹，然后在系统环境变量添加`GRADLE_HOME`，作者的变量值为`D:\\gradle-5.4.1`，最后再将`%GRADLE_HOME%\\bin`添加进`Path`变量中即可。在命令行中键入`gradle -v`验证环境搭建结果。\n\n```bash\nPS C:\\Users\\Febers> gradle -v\n\nWelcome to Gradle 5.4.1!\n\nHere are the highlights of this release:\n - Run builds with JDK12\n - New API for Incremental Tasks\n - Updates to native projects, including Swift 5 support\n\nFor more details see https://docs.gradle.org/5.4.1/release-notes.html\n```\n\n### Hello World\n\n新建一个工程项目，比如`gradle_demo`，然后新建一个`build.gradle`文件，在其中输入\n\n```groovy\ntask hello {\n  doLast {\n    println 'Hello World!'\n  }\n}\n```\n\n在当前文件夹命令行中键入`gradle -q hello`即可输出`Hello  World!`。这里使用的是基于 Groovy 的 DSL（Domain Specific Language，领域特定语言）。\n\ntask 和 action 是 Gradle 的重要元素，前者代表一个独立的原子操作，比如复制一个文件、编译一次 Java 代码，这里简单定义一个名为`hello`的 task；后者则是前者的组成部分，`doLast`代表 task 执行的最后一个 action，task 执行完毕之后会回调该 action。\n\n### 日志级别\n\n和 Android 类似，Gradle 也定义了日志级别\n\n| 级别      | 用于     |\n| --------- | -------- |\n| ERROR     | 错误信息 |\n| QUIET     | 重要信息 |\n| WARNING   | 警告信息 |\n| LIFECYCLE | 进度信息 |\n| INFO      | 信息消息 |\n| DEBUG     | 调试消息 |\n\n\n\n上文运行任务所使用到的命令`gradle -q hello`中的`-q`即为日志的级别开关选项\n\n| 开关选项      | 输出级别        |\n| ------------- | --------------- |\n| 无            | LIFECYCLE及以上 |\n| -q 或 --quiet | QUIET及以上     |\n| -i 或 --info  | INFO及以上      |\n| -d 或 --debug | DEBUG及以上     |\n\n### Project\n\n每个 Gradle 项目都由一个或多个 Project 构成，每个 Project 又都由 Task 构成。一个 `build.gradle`文件便是对一个 Project 对象的配置。在 Android 项目中，根目录会存在一个`build.gradle`文件，每个模块下也会有一个该文件。\n\n在构建脚本中调用的没有在构建脚本中定义的方法和属性都委派给 Project 对象，比如`project.copy()`等价于`copy()`、`project.buildDir`等价于`buildDir` \n\n### Task\n\n#### 创建任务\n\n```groovy\ntask hello {\n  doLast {\n    println 'Hello World!'\n  }\n}\n\n//直接用任务名称\ndef Task helloo = task(helloo)\nhelloo.doLast {\n  println 'Helloo World!'\n}\n\n//声明任务配置\ndef Task hellooo = task(hellooo, group: BasePlugin.BUILD_GROUP)\nhellooo.doLast {\n  println 'Hellooo World!'\n}\n\n//使用 TaskContainer 的 create 方法创建，以上三种方式最终都会调用该方法\ntasks.create(name: 'helloooo') {\n  doLast {\n    println 'helloooo World!'\n  }\n}\n```\n\n输入`gradle -q hello*`之后的结果为，说明成功创建任务\n\n```bash\nHello World!\nHelloo World!\nHellooo World!\nhelloooo World!\n```\n\n#### 任务顺序\n\n通过`dependsOn`指定任务的依赖，通过一个例子理解\n\n```groovy\ntask hello {\n  println 'hello'\n    \n  doFirst {\n    println 'hello first'\n  }\n  doLast {\n    println 'Hello last'\n  }\n}\n\ntask go(dependsOn: hello) {\n  println 'go'\n\n  doLast {\n    println 'go last 0'\n  } \n\n  doFirst {\n    println 'go first'\n  }\n\n  doLast {\n    println 'go last 1'\n  }\n}\n```\n\n输入`gradle -q go`之后的输出结果为\n\n```bash\nhello\ngo\nhello first\nHello last\ngo first\ngo last 0\ngo last 1\n```\n\n#### 排除任务\n\n在命令行后添加`-x go`来排除任务 go，输入`gradle hello -x go`之后\n\n```bash\n> Task :hello\nhello\nhello first\nhello last\n\nBUILD SUCCESSFUL in 1s\n1 actionable task: 1 executed\n```\n\n#### 动态任务\n\n可以通过拓展方法`times`动态创建任务\n\n```groovy\n3.times {\n  count -> task \"task$count\" {\n    doLast {\n      println \"task $count\"\n    }\n  }\n}\n```\n\n输入`gradle -q task0`之后将输出`task 0`，已创建的三个任务中的一个\n\n\n#### 任务属性\n\n标准属性有`group`、`description`等，除此之外的自定义属性需添加`ext`前缀\n\n```groovy\ntask hello {\n  group = 'group0'\n  description = 'description'\n  ext.myTitle = 'title'\n  ext.myId = 9527\n\n  doLast {\n    println \"任务分组属性: $group\"\n    println \"任务描述:属性 $description\"\n    println \"自定义Title属性: $myTitle\"\n    println \"自定义Id属性: $myId\"\n  }\n}\n```\n\n输出正常\n\n## Groovy \n\n![](Gradle-构建工具详解\\groovy.png)\n\nGadle 使用 Groovy 的 DSL 编写，Groovy 是 Apache 推出的 JVM 语言。Groovy 的学习可以参考其[官方文档](http://cndoc.github.io/groovy-doc-cn/)，写得相当友好。Groovy 可以与 Java 无缝连接，甚至可以在其中直接使用 Java 语法，Java 中调用 Groovy 也相当方便。此处只介绍一些与 Java 不同的地方。\n\nGroovy 会默认导入以下包，不需要显示导入\n\n```bash\njava.io.*\njava.lang.*\njava.math.BigDecimal\njava.math.BigInteger\njava.net.*\njava.util.*\ngroovy.lang.*\ngroovy.util.*\n```\n\n可以导入 SDK 之后在 IDE 中编写 Groovy 程序，也可以在 `build.gradle` 中编写代码，在 task\n\n中调用，使用 gradle 命令运行。以下的例子采用后一种方法。\n\n### 变量与方法\n\n使用 def 关键字来定义变量和方法，可以不指定变量的类型，默认访问修饰符为 public。Groovy 中使用双引号定义字符串的时候类型为`GString`而非`java.lang.String`，因此可以使用`$`输出表达式结果\n\n```groovy\ntask t {\n  //定义变量，可以使用 def，也可以使用具体类型，或者两者结合\n  def a = 0\n  def int b = 1\n\t\n  //定义字符串，同 dart \n  String s = \"s\"\t\n  String ss = 'ss'\n  String sss = \"\"\"first row\n  second row\"\"\"\n\n  println \"95-27=${minus(95,27)}\"\n  println \"95+27=${add 95,27}\"\n}\n\n//指定返回类型则 def 可省略，且参数类型可省略\n//不使用 return 则返回最后一行\nint minus(a, b) {\n  println \"before return\"\n  a - b\n}\n\n//定义方法\ndef add(int a, int b) {\n  return a + b\n}\n```\n\n控制台输出\n\n```bash\nbefore return\n95-27=68\n95+27=122\n```\n\n### 对象\n\nGroovy 中的类与 Java 类似，不过由于没有访问修饰符，默认为`public`，要想实现 Java 默认的包访问权限（`default`），可以使用注解` @PackageScope`。对于没有可见性修饰的变量，Groovy 会隐式提供`setter/getter`方法。以下的两个类是等价的\n\n```groovy\ntask t {\n  def object = new ClassInGroovy()\n  object.name = \"Jack\"\n  println \"${object.name}\"\n}\n\npublic class ClassInJava {\n  public String name;\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n}\n\nclass ClassInGroovy {\n  String name\n}\n```\n\n此外 Groovy 使用`asType`函数进行类型转换，支持`object.with{ }`进行级联操作，支持使用`?.`进行非空操作，都是些很眼熟的语法特性\n\n### 闭包\n\n闭包在 Groovy 中是`groovy.lang.Closure`的实例，类似于 Dart 中的函数是 Function 的实例，因此可以像变量一样传递，其语法定义为\n\n```groovy\n//闭包的参数为可选项\ndef closure = { [closureParameters -> ] statements }\n```\n\n闭包跟函数不同的地方在于其可以访问外部变量\n\n```groovy\ntask t {\n  def str = \"hello\"\n  def closure0 = {\n    println str  \n  }\n\n  def closure1 = { String name, int t -> \n    println \"before print\"\n    println \"$name call $t times\"\n  }\n\n  //调用，call 可省略\n  closure0.call()\t\n  closure1(\"Jack\", 10)\n}\n```\n\n与 Java 中的 Lambda 表达式类似，闭包可以当做参数传递，当闭包为最后一个参数时可写在调用的括号后\n\n### 文件读取\n\n相较于 Java，Groovy 的文件读写非常简洁友好。在当前文件夹新建一个文件`静夜思.txt`\n\n```groovy\ntask t {\n  def path = \"静夜思.txt\"\n  def file = new File(path).eachLine { line ->\n    println line\n  }\n  //更简洁\n  println file.text\n\t\n  //写入，该方法会打印并覆盖原来的内容\n  file.withPrintWriter {\n    it.println \"表达了诗人对家乡的思念\"\n  }\n}\n```\n\n### 其他\n\nGroovy 中的流程控制语句（比如`if/else`、`for/in`、`switch/case`）、数据结构（比如`List`、`Map`）与 Java/Dart 类似，在此便不过多费笔墨，参考官方文档即可。\n\n## Gradle Wrapper\n\nGradle 包装器。为了应对团队开发中 Gradle 环境和版本的差异会对编译结果带来的不确定性，使用 Gradle Wrapper，它是一个脚本，可以指定构建版本、快速运行项目，从而达到标准化、提到开发效率。Android Studio 新建项目时自带 Gradle Wrapper，因此 Android 开发者很少单独下载安装 Gradle\n\nGradle Wrapper 的工作流程如下图\n\n![](https://docs.gradle.org/current/userguide/img/wrapper-workflow.png)\n\n使用 Gradle Wrapper 启动 Gradle 之后，如果指定版本的 Gradle 没有被下载关联，会先从官方仓库下载到用户本地，进行解包并执行批处理文件。后续的构建运行都会重用这个解包的运行时安装程序\n\n### 构建 Gradle Wrapper\n\nGradle 内置 Wrapper Task，执行 Wrapper Task 就可以在项目目录中生成对应的目录文件。在项目根目录执行`gradle wrapper` 命令即可。之后根目录的文件结构如下\n\n```bash\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n└── gradlew.bat\n```\n\n文件含义为\n\n- gradle-wrapper.jar ：包含 Gradle 运行时的逻辑代码。\n- gradle-wrapper.properties ：负责配置包装器运行时行为的属性文件\n- gradlew：Linux 平台下，用于执行 Gralde 命令的包装器脚本。\n- gradlew.bat：Windows 平台下，用于执行 Gradle 命令的包装器脚本。\n\n查看`.properties`文件\n\n```properties\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.4.1-bin.zip\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\n```\n\n属性含义为\n\n- distributionBase：Gradle 解包后存储的主目录。\n- distributionPath：distributionBase 指定目录的子目录。distributionBase+distributionPath 为 Gradle 解包后的存放位置。\n- distributionUrl：Gradle 发行版压缩包的下载地址。\n- zipStoreBase：Gradle 压缩包存储主目录。\n- zipStorePath：zipStoreBase 指定目录的子目录。zipStoreBase+zipStorePath 为 Gradle 压缩包的存放位置。\n\n如果官方包发行版下载缓慢，可以手动更改`distributionUrl`为可用地址\n\n\n### 使用 Gradle Wrapper\n\n使用`gradlew.bar`代替`gradle`运行 Gradle Project，首次使用会下载 Gradle 到配置文件指定的位置，作者的路径为`C:\\Users\\23033\\.gradle\\wrapper\\dists\\gradle-5.4.1-bin\\e75iq110yv9r9wt1a6619x2xm\\gradle-5.4.1`\n\n```bash\nPS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat t\nDownloading https://services.gradle.org/distributions/gradle-5.4.1-bin.zip\n...................................................................................\n\nHello World!\n```\n\n再次使用该命令便不会重复下载。升级 Gradle 版本可以通过`gradlew wrapper –gradle-version 5.*.*`命令实现\n\n## Gradle 插件\n\nGradle 中的插件可分为两类\n\n- 脚本插件：额外的构建脚本，类似于一个 build.gradle\n- 对象插件：又叫二进制插件，是实现了 Plugin 接口的类\n\n应用插件又分为两个步骤，一是解析插件，二是通过`apply()`把插件应用到项目中。\n\n\n### 脚本插件\n\n在根目录新建一个`other.gradle`文件，内容如下\n\n```groovy\next {\n  otherVersion = '1.0'\n  otherUrl = 'https://febers.github.io'\n}\n```\n\n将`build.gradle`内容修改为\n\n```groovy\napply from: 'other.gradle'\ntask t {\n  println \"版本为: ${otherVersion},地址为: ${otherUrl}\"\n}\n```\n\n输出结果\n\n```bash\nPS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat t\n\n> Configure project :\n版本为: 1.0,地址为: https://febers.github.io\n```\n\n\n### 对象插件\n\n对象插件是实现了`org.gradle.api.plugin<Project>`接口的插件，又可分为内部插件和第三方插件\n\n\n#### 内部插件\n\n使用以下方法应用 Java 插件（因为默认导入`org.gradle.api.plugin`包，所以可以去掉包名）\n\n```groovy\napply plugin: org.gradle.api.plugins.JavaPlugin\napply plugin: JavaPlugin\t//去掉包名\napply plugin: 'java'\t//使用 pluginid（实现 plugin 接口的插件的属性）\napply plugin: 'cpp'    //Gradle 中含有大量插件\n```\n\n#### 第三方插件\n\n一般为 jar 文件，通过`buildscript`配置，此处引入 Android Gradle 插件\n\n```groovy\nbuildscript {\n  repositories {\n    google()\n  }\n  dependencies {\n    classpath 'com.android.tools.build:gradle:3.4.1'\n  }\n}\napply plugin: 'com.android.application'\n```\n\n如果第三方插件被托管到 [Gradle - Plugins](Gradle - Plugins\nhttps://plugins.gradle.org/)，也可以不使用`buildscript`\n\n```groovy\nplugins {\n  id \"com.quittle.setup-android-sdk\" version \"1.2.0\"\n}\n```\n\n#### 自定义对象插件\n\nPlugin 接口中定义了一个`apply`方法，重写该方法，在其中通过传进来的参数`Object o`（实际为 Project 类型）调用 task 新建一个任务\n\n```groovy\nclass MyPlugin implements Plugin {\n  @Override\n  void apply(Object o) {\n    o.task(\"myTask\") {\n      println \"This is a custom task in custom plugin\"\n    }\n  }\n}\napply plugin: MyPlugin\n```\n\n输入命令`gradle myTask`即可验证\n\n## Android 中的 Gradle\n\n为了支持 Android 项目的构建，Google 为 Gradle 编写了 Android 插件，组成 Android 构建系统。Android Studio+Gradle 是目前最流行的 Android 开发构建环境。关于 Android 构建配置可查阅官方文档 [配置构建](https://developer.android.com/studio/build?hl=zh-cn)\n\n\n\n### 模块类型\n\nAndroid Studio 中的每个项目包含一个或多个含有源代码文件和资源文件的模块，这些模块可以独立构建测试，模块类型包含以下几种\n\n-  Android 应用程序模块：可能依赖于库模块，构建系统会将其生成一个 apk 文件\n- Android 库模块：包含可重用的特定于 Android 的代码和资源，构建系统将其生成一个 aar 文件\n- App 引擎模块：包含应用程序引擎继承的代码和资源\n- Java 库模块：包含可重用的代码，构建系统将其生成一个 jar 文件\n\n\n\n### 项目结构\n\n在 Android Studio 中，Android 项目视图如下，以开发者个人项目 [UESTC_BBS](https://github.com/Febers/UESTC_BBS) 为例\n\n![](Gradle-构建工具详解\\项目结构.png)\n\n所有构建稳健位于 Gradle Scripts 层级下，文件作用如下\n\n- 项目 build.gradle：配置项目整体属性，比如指定的代码仓库、依赖的 Gradle 版本等\n- 模块 build.gradle：配置当前模块的编译参数\n- gradle-wrapper-properties：配置 Gradle Wrapper\n- gradle-properties：配置 Gradle\n- setting.gradle：配置 Gradle 的多项目管理\n- local.properties：存放 Android 项目的私有属性配置，如 SDK 路径\n- multiDexKeep.pro、proguard-rules.pro：可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类\n\n\n\n### 项目 build.gradle\n\n典型的项目`build.gradle`文件如下\n\n```groovy\nbuildscript {\n    ext.kotlin_version = '1.3.10'\n    repositories {\n        mavenCentral()\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.4.0'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n        classpath \"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\"\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        mavenCentral()\n        maven { url 'https://jitpack.io' }\n        maven { url \"https://maven.google.com\" }\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n```\n\n其中`google()`是配置 Google 的 Maven 仓库，`maven { url \"https://maven.google.com\" }`同理\n\n\n### 模块 build.gradle\n\n典型的模块`build.gradle`文件如下\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\next.anko_version = '0.10.5'\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n    implementation 'com.android.support:multidex:1.0.3'\n    implementation 'androidx.appcompat:appcompat:1.0.2'\n    testImplementation 'junit:junit:4.12'\n}\n\nandroid {\n    compileSdkVersion 28\n    defaultConfig {\n        applicationId \"com.febers.uestc_bbs\"\n        minSdkVersion 17\n        targetSdkVersion 28\n        versionCode 12\n        versionName \"1.1.4\"\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        multiDexEnabled true\n        multiDexKeepProguard file('multiDexKeep.pro') // keep specific classes using proguard syntax\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n```\n\n第一行 apply 的是一个`application`，说明当前模块为一个应用程序模块，Gradle 的 Android 插件分为以下几种\n\n- 应用程序插件：插件 id 为`com.android.application`，构建生成 apk\n- 库插件：插件 id 为`com.android.library`，构建生成 aar\n- 测试插件：插件 id 为`com.android.test`，用于测试其他模块\n- feature 插件：插件 id 为`com.android.feature`，用于创建 Android Instant App\n- instant App 插件：插件 id 为`com.android.instantapp`，是 Android Instant App 的入口\n\n很多属性都可以望文生义，此处不再赘述。\n\n\n\n---\n\n参考\n\n[Gradle的Android插件入门](http://liuwangshu.cn/application/android-gradle/1-gradle-plug-in.html)\n\n[Gradle核心思想](http://liuwangshu.cn/tags/Gradle%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/)\n\n","source":"_posts/Gradle-构建工具详解.md","raw":"---\ntitle: Gradle 构建工具详解\ndate: 2019-05-25 22:37:41\ntags:\n- Gradle\n- 构建工具\n- Groovy\n- Android  \n- Java\ncategories:\n- Gradle\n---\n\nGradle 是一个基于 JVM 的自动化构建工具，使用 Groovy  DSL 声明配置。现代软件开发包含众多步骤，包括编译、测试、打包等，如果需要手动重复每一过程，将会耗费大量时间、增加出错概率，项目自动化应运而生。在此之前，常见的 Java 构建工具包括 Ant、Gant 和 Maven 等，Gradle 结合了以上工具的优点，基于约定大于配置，通用灵活，是 Android 的官方构建工具。本文将介绍 Gradle 的基本知识、Groovy 基本语法以及 Android 开发中的 Gradle 知识。\n\n![](https://plugins.gradle.org/shared-assets/shared/images/gradle-logo-horizontal.svg)\n\n<!--more-->\n\n## 入门\n\n### 搭建环境\n\n确保系统已安装 JDK 1.7及以上，此处将介绍 Gradle 在 Windows 平台下的手动安装。在 https://gradle.org/releases/ 下载最新的 release 包并解压至相应文件夹，然后在系统环境变量添加`GRADLE_HOME`，作者的变量值为`D:\\gradle-5.4.1`，最后再将`%GRADLE_HOME%\\bin`添加进`Path`变量中即可。在命令行中键入`gradle -v`验证环境搭建结果。\n\n```bash\nPS C:\\Users\\Febers> gradle -v\n\nWelcome to Gradle 5.4.1!\n\nHere are the highlights of this release:\n - Run builds with JDK12\n - New API for Incremental Tasks\n - Updates to native projects, including Swift 5 support\n\nFor more details see https://docs.gradle.org/5.4.1/release-notes.html\n```\n\n### Hello World\n\n新建一个工程项目，比如`gradle_demo`，然后新建一个`build.gradle`文件，在其中输入\n\n```groovy\ntask hello {\n  doLast {\n    println 'Hello World!'\n  }\n}\n```\n\n在当前文件夹命令行中键入`gradle -q hello`即可输出`Hello  World!`。这里使用的是基于 Groovy 的 DSL（Domain Specific Language，领域特定语言）。\n\ntask 和 action 是 Gradle 的重要元素，前者代表一个独立的原子操作，比如复制一个文件、编译一次 Java 代码，这里简单定义一个名为`hello`的 task；后者则是前者的组成部分，`doLast`代表 task 执行的最后一个 action，task 执行完毕之后会回调该 action。\n\n### 日志级别\n\n和 Android 类似，Gradle 也定义了日志级别\n\n| 级别      | 用于     |\n| --------- | -------- |\n| ERROR     | 错误信息 |\n| QUIET     | 重要信息 |\n| WARNING   | 警告信息 |\n| LIFECYCLE | 进度信息 |\n| INFO      | 信息消息 |\n| DEBUG     | 调试消息 |\n\n\n\n上文运行任务所使用到的命令`gradle -q hello`中的`-q`即为日志的级别开关选项\n\n| 开关选项      | 输出级别        |\n| ------------- | --------------- |\n| 无            | LIFECYCLE及以上 |\n| -q 或 --quiet | QUIET及以上     |\n| -i 或 --info  | INFO及以上      |\n| -d 或 --debug | DEBUG及以上     |\n\n### Project\n\n每个 Gradle 项目都由一个或多个 Project 构成，每个 Project 又都由 Task 构成。一个 `build.gradle`文件便是对一个 Project 对象的配置。在 Android 项目中，根目录会存在一个`build.gradle`文件，每个模块下也会有一个该文件。\n\n在构建脚本中调用的没有在构建脚本中定义的方法和属性都委派给 Project 对象，比如`project.copy()`等价于`copy()`、`project.buildDir`等价于`buildDir` \n\n### Task\n\n#### 创建任务\n\n```groovy\ntask hello {\n  doLast {\n    println 'Hello World!'\n  }\n}\n\n//直接用任务名称\ndef Task helloo = task(helloo)\nhelloo.doLast {\n  println 'Helloo World!'\n}\n\n//声明任务配置\ndef Task hellooo = task(hellooo, group: BasePlugin.BUILD_GROUP)\nhellooo.doLast {\n  println 'Hellooo World!'\n}\n\n//使用 TaskContainer 的 create 方法创建，以上三种方式最终都会调用该方法\ntasks.create(name: 'helloooo') {\n  doLast {\n    println 'helloooo World!'\n  }\n}\n```\n\n输入`gradle -q hello*`之后的结果为，说明成功创建任务\n\n```bash\nHello World!\nHelloo World!\nHellooo World!\nhelloooo World!\n```\n\n#### 任务顺序\n\n通过`dependsOn`指定任务的依赖，通过一个例子理解\n\n```groovy\ntask hello {\n  println 'hello'\n    \n  doFirst {\n    println 'hello first'\n  }\n  doLast {\n    println 'Hello last'\n  }\n}\n\ntask go(dependsOn: hello) {\n  println 'go'\n\n  doLast {\n    println 'go last 0'\n  } \n\n  doFirst {\n    println 'go first'\n  }\n\n  doLast {\n    println 'go last 1'\n  }\n}\n```\n\n输入`gradle -q go`之后的输出结果为\n\n```bash\nhello\ngo\nhello first\nHello last\ngo first\ngo last 0\ngo last 1\n```\n\n#### 排除任务\n\n在命令行后添加`-x go`来排除任务 go，输入`gradle hello -x go`之后\n\n```bash\n> Task :hello\nhello\nhello first\nhello last\n\nBUILD SUCCESSFUL in 1s\n1 actionable task: 1 executed\n```\n\n#### 动态任务\n\n可以通过拓展方法`times`动态创建任务\n\n```groovy\n3.times {\n  count -> task \"task$count\" {\n    doLast {\n      println \"task $count\"\n    }\n  }\n}\n```\n\n输入`gradle -q task0`之后将输出`task 0`，已创建的三个任务中的一个\n\n\n#### 任务属性\n\n标准属性有`group`、`description`等，除此之外的自定义属性需添加`ext`前缀\n\n```groovy\ntask hello {\n  group = 'group0'\n  description = 'description'\n  ext.myTitle = 'title'\n  ext.myId = 9527\n\n  doLast {\n    println \"任务分组属性: $group\"\n    println \"任务描述:属性 $description\"\n    println \"自定义Title属性: $myTitle\"\n    println \"自定义Id属性: $myId\"\n  }\n}\n```\n\n输出正常\n\n## Groovy \n\n![](Gradle-构建工具详解\\groovy.png)\n\nGadle 使用 Groovy 的 DSL 编写，Groovy 是 Apache 推出的 JVM 语言。Groovy 的学习可以参考其[官方文档](http://cndoc.github.io/groovy-doc-cn/)，写得相当友好。Groovy 可以与 Java 无缝连接，甚至可以在其中直接使用 Java 语法，Java 中调用 Groovy 也相当方便。此处只介绍一些与 Java 不同的地方。\n\nGroovy 会默认导入以下包，不需要显示导入\n\n```bash\njava.io.*\njava.lang.*\njava.math.BigDecimal\njava.math.BigInteger\njava.net.*\njava.util.*\ngroovy.lang.*\ngroovy.util.*\n```\n\n可以导入 SDK 之后在 IDE 中编写 Groovy 程序，也可以在 `build.gradle` 中编写代码，在 task\n\n中调用，使用 gradle 命令运行。以下的例子采用后一种方法。\n\n### 变量与方法\n\n使用 def 关键字来定义变量和方法，可以不指定变量的类型，默认访问修饰符为 public。Groovy 中使用双引号定义字符串的时候类型为`GString`而非`java.lang.String`，因此可以使用`$`输出表达式结果\n\n```groovy\ntask t {\n  //定义变量，可以使用 def，也可以使用具体类型，或者两者结合\n  def a = 0\n  def int b = 1\n\t\n  //定义字符串，同 dart \n  String s = \"s\"\t\n  String ss = 'ss'\n  String sss = \"\"\"first row\n  second row\"\"\"\n\n  println \"95-27=${minus(95,27)}\"\n  println \"95+27=${add 95,27}\"\n}\n\n//指定返回类型则 def 可省略，且参数类型可省略\n//不使用 return 则返回最后一行\nint minus(a, b) {\n  println \"before return\"\n  a - b\n}\n\n//定义方法\ndef add(int a, int b) {\n  return a + b\n}\n```\n\n控制台输出\n\n```bash\nbefore return\n95-27=68\n95+27=122\n```\n\n### 对象\n\nGroovy 中的类与 Java 类似，不过由于没有访问修饰符，默认为`public`，要想实现 Java 默认的包访问权限（`default`），可以使用注解` @PackageScope`。对于没有可见性修饰的变量，Groovy 会隐式提供`setter/getter`方法。以下的两个类是等价的\n\n```groovy\ntask t {\n  def object = new ClassInGroovy()\n  object.name = \"Jack\"\n  println \"${object.name}\"\n}\n\npublic class ClassInJava {\n  public String name;\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n}\n\nclass ClassInGroovy {\n  String name\n}\n```\n\n此外 Groovy 使用`asType`函数进行类型转换，支持`object.with{ }`进行级联操作，支持使用`?.`进行非空操作，都是些很眼熟的语法特性\n\n### 闭包\n\n闭包在 Groovy 中是`groovy.lang.Closure`的实例，类似于 Dart 中的函数是 Function 的实例，因此可以像变量一样传递，其语法定义为\n\n```groovy\n//闭包的参数为可选项\ndef closure = { [closureParameters -> ] statements }\n```\n\n闭包跟函数不同的地方在于其可以访问外部变量\n\n```groovy\ntask t {\n  def str = \"hello\"\n  def closure0 = {\n    println str  \n  }\n\n  def closure1 = { String name, int t -> \n    println \"before print\"\n    println \"$name call $t times\"\n  }\n\n  //调用，call 可省略\n  closure0.call()\t\n  closure1(\"Jack\", 10)\n}\n```\n\n与 Java 中的 Lambda 表达式类似，闭包可以当做参数传递，当闭包为最后一个参数时可写在调用的括号后\n\n### 文件读取\n\n相较于 Java，Groovy 的文件读写非常简洁友好。在当前文件夹新建一个文件`静夜思.txt`\n\n```groovy\ntask t {\n  def path = \"静夜思.txt\"\n  def file = new File(path).eachLine { line ->\n    println line\n  }\n  //更简洁\n  println file.text\n\t\n  //写入，该方法会打印并覆盖原来的内容\n  file.withPrintWriter {\n    it.println \"表达了诗人对家乡的思念\"\n  }\n}\n```\n\n### 其他\n\nGroovy 中的流程控制语句（比如`if/else`、`for/in`、`switch/case`）、数据结构（比如`List`、`Map`）与 Java/Dart 类似，在此便不过多费笔墨，参考官方文档即可。\n\n## Gradle Wrapper\n\nGradle 包装器。为了应对团队开发中 Gradle 环境和版本的差异会对编译结果带来的不确定性，使用 Gradle Wrapper，它是一个脚本，可以指定构建版本、快速运行项目，从而达到标准化、提到开发效率。Android Studio 新建项目时自带 Gradle Wrapper，因此 Android 开发者很少单独下载安装 Gradle\n\nGradle Wrapper 的工作流程如下图\n\n![](https://docs.gradle.org/current/userguide/img/wrapper-workflow.png)\n\n使用 Gradle Wrapper 启动 Gradle 之后，如果指定版本的 Gradle 没有被下载关联，会先从官方仓库下载到用户本地，进行解包并执行批处理文件。后续的构建运行都会重用这个解包的运行时安装程序\n\n### 构建 Gradle Wrapper\n\nGradle 内置 Wrapper Task，执行 Wrapper Task 就可以在项目目录中生成对应的目录文件。在项目根目录执行`gradle wrapper` 命令即可。之后根目录的文件结构如下\n\n```bash\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n└── gradlew.bat\n```\n\n文件含义为\n\n- gradle-wrapper.jar ：包含 Gradle 运行时的逻辑代码。\n- gradle-wrapper.properties ：负责配置包装器运行时行为的属性文件\n- gradlew：Linux 平台下，用于执行 Gralde 命令的包装器脚本。\n- gradlew.bat：Windows 平台下，用于执行 Gradle 命令的包装器脚本。\n\n查看`.properties`文件\n\n```properties\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.4.1-bin.zip\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\n```\n\n属性含义为\n\n- distributionBase：Gradle 解包后存储的主目录。\n- distributionPath：distributionBase 指定目录的子目录。distributionBase+distributionPath 为 Gradle 解包后的存放位置。\n- distributionUrl：Gradle 发行版压缩包的下载地址。\n- zipStoreBase：Gradle 压缩包存储主目录。\n- zipStorePath：zipStoreBase 指定目录的子目录。zipStoreBase+zipStorePath 为 Gradle 压缩包的存放位置。\n\n如果官方包发行版下载缓慢，可以手动更改`distributionUrl`为可用地址\n\n\n### 使用 Gradle Wrapper\n\n使用`gradlew.bar`代替`gradle`运行 Gradle Project，首次使用会下载 Gradle 到配置文件指定的位置，作者的路径为`C:\\Users\\23033\\.gradle\\wrapper\\dists\\gradle-5.4.1-bin\\e75iq110yv9r9wt1a6619x2xm\\gradle-5.4.1`\n\n```bash\nPS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat t\nDownloading https://services.gradle.org/distributions/gradle-5.4.1-bin.zip\n...................................................................................\n\nHello World!\n```\n\n再次使用该命令便不会重复下载。升级 Gradle 版本可以通过`gradlew wrapper –gradle-version 5.*.*`命令实现\n\n## Gradle 插件\n\nGradle 中的插件可分为两类\n\n- 脚本插件：额外的构建脚本，类似于一个 build.gradle\n- 对象插件：又叫二进制插件，是实现了 Plugin 接口的类\n\n应用插件又分为两个步骤，一是解析插件，二是通过`apply()`把插件应用到项目中。\n\n\n### 脚本插件\n\n在根目录新建一个`other.gradle`文件，内容如下\n\n```groovy\next {\n  otherVersion = '1.0'\n  otherUrl = 'https://febers.github.io'\n}\n```\n\n将`build.gradle`内容修改为\n\n```groovy\napply from: 'other.gradle'\ntask t {\n  println \"版本为: ${otherVersion},地址为: ${otherUrl}\"\n}\n```\n\n输出结果\n\n```bash\nPS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat t\n\n> Configure project :\n版本为: 1.0,地址为: https://febers.github.io\n```\n\n\n### 对象插件\n\n对象插件是实现了`org.gradle.api.plugin<Project>`接口的插件，又可分为内部插件和第三方插件\n\n\n#### 内部插件\n\n使用以下方法应用 Java 插件（因为默认导入`org.gradle.api.plugin`包，所以可以去掉包名）\n\n```groovy\napply plugin: org.gradle.api.plugins.JavaPlugin\napply plugin: JavaPlugin\t//去掉包名\napply plugin: 'java'\t//使用 pluginid（实现 plugin 接口的插件的属性）\napply plugin: 'cpp'    //Gradle 中含有大量插件\n```\n\n#### 第三方插件\n\n一般为 jar 文件，通过`buildscript`配置，此处引入 Android Gradle 插件\n\n```groovy\nbuildscript {\n  repositories {\n    google()\n  }\n  dependencies {\n    classpath 'com.android.tools.build:gradle:3.4.1'\n  }\n}\napply plugin: 'com.android.application'\n```\n\n如果第三方插件被托管到 [Gradle - Plugins](Gradle - Plugins\nhttps://plugins.gradle.org/)，也可以不使用`buildscript`\n\n```groovy\nplugins {\n  id \"com.quittle.setup-android-sdk\" version \"1.2.0\"\n}\n```\n\n#### 自定义对象插件\n\nPlugin 接口中定义了一个`apply`方法，重写该方法，在其中通过传进来的参数`Object o`（实际为 Project 类型）调用 task 新建一个任务\n\n```groovy\nclass MyPlugin implements Plugin {\n  @Override\n  void apply(Object o) {\n    o.task(\"myTask\") {\n      println \"This is a custom task in custom plugin\"\n    }\n  }\n}\napply plugin: MyPlugin\n```\n\n输入命令`gradle myTask`即可验证\n\n## Android 中的 Gradle\n\n为了支持 Android 项目的构建，Google 为 Gradle 编写了 Android 插件，组成 Android 构建系统。Android Studio+Gradle 是目前最流行的 Android 开发构建环境。关于 Android 构建配置可查阅官方文档 [配置构建](https://developer.android.com/studio/build?hl=zh-cn)\n\n\n\n### 模块类型\n\nAndroid Studio 中的每个项目包含一个或多个含有源代码文件和资源文件的模块，这些模块可以独立构建测试，模块类型包含以下几种\n\n-  Android 应用程序模块：可能依赖于库模块，构建系统会将其生成一个 apk 文件\n- Android 库模块：包含可重用的特定于 Android 的代码和资源，构建系统将其生成一个 aar 文件\n- App 引擎模块：包含应用程序引擎继承的代码和资源\n- Java 库模块：包含可重用的代码，构建系统将其生成一个 jar 文件\n\n\n\n### 项目结构\n\n在 Android Studio 中，Android 项目视图如下，以开发者个人项目 [UESTC_BBS](https://github.com/Febers/UESTC_BBS) 为例\n\n![](Gradle-构建工具详解\\项目结构.png)\n\n所有构建稳健位于 Gradle Scripts 层级下，文件作用如下\n\n- 项目 build.gradle：配置项目整体属性，比如指定的代码仓库、依赖的 Gradle 版本等\n- 模块 build.gradle：配置当前模块的编译参数\n- gradle-wrapper-properties：配置 Gradle Wrapper\n- gradle-properties：配置 Gradle\n- setting.gradle：配置 Gradle 的多项目管理\n- local.properties：存放 Android 项目的私有属性配置，如 SDK 路径\n- multiDexKeep.pro、proguard-rules.pro：可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类\n\n\n\n### 项目 build.gradle\n\n典型的项目`build.gradle`文件如下\n\n```groovy\nbuildscript {\n    ext.kotlin_version = '1.3.10'\n    repositories {\n        mavenCentral()\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.4.0'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n        classpath \"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\"\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        mavenCentral()\n        maven { url 'https://jitpack.io' }\n        maven { url \"https://maven.google.com\" }\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n```\n\n其中`google()`是配置 Google 的 Maven 仓库，`maven { url \"https://maven.google.com\" }`同理\n\n\n### 模块 build.gradle\n\n典型的模块`build.gradle`文件如下\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\next.anko_version = '0.10.5'\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n    implementation 'com.android.support:multidex:1.0.3'\n    implementation 'androidx.appcompat:appcompat:1.0.2'\n    testImplementation 'junit:junit:4.12'\n}\n\nandroid {\n    compileSdkVersion 28\n    defaultConfig {\n        applicationId \"com.febers.uestc_bbs\"\n        minSdkVersion 17\n        targetSdkVersion 28\n        versionCode 12\n        versionName \"1.1.4\"\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        multiDexEnabled true\n        multiDexKeepProguard file('multiDexKeep.pro') // keep specific classes using proguard syntax\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n```\n\n第一行 apply 的是一个`application`，说明当前模块为一个应用程序模块，Gradle 的 Android 插件分为以下几种\n\n- 应用程序插件：插件 id 为`com.android.application`，构建生成 apk\n- 库插件：插件 id 为`com.android.library`，构建生成 aar\n- 测试插件：插件 id 为`com.android.test`，用于测试其他模块\n- feature 插件：插件 id 为`com.android.feature`，用于创建 Android Instant App\n- instant App 插件：插件 id 为`com.android.instantapp`，是 Android Instant App 的入口\n\n很多属性都可以望文生义，此处不再赘述。\n\n\n\n---\n\n参考\n\n[Gradle的Android插件入门](http://liuwangshu.cn/application/android-gradle/1-gradle-plug-in.html)\n\n[Gradle核心思想](http://liuwangshu.cn/tags/Gradle%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/)\n\n","slug":"Gradle-构建工具详解","published":1,"updated":"2019-06-02T05:00:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqyw005hy4upqkthukpj","content":"<p>Gradle 是一个基于 JVM 的自动化构建工具，使用 Groovy  DSL 声明配置。现代软件开发包含众多步骤，包括编译、测试、打包等，如果需要手动重复每一过程，将会耗费大量时间、增加出错概率，项目自动化应运而生。在此之前，常见的 Java 构建工具包括 Ant、Gant 和 Maven 等，Gradle 结合了以上工具的优点，基于约定大于配置，通用灵活，是 Android 的官方构建工具。本文将介绍 Gradle 的基本知识、Groovy 基本语法以及 Android 开发中的 Gradle 知识。</p>\n<p><img src=\"https://plugins.gradle.org/shared-assets/shared/images/gradle-logo-horizontal.svg\" alt></p>\n<a id=\"more\"></a>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><h3 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h3><p>确保系统已安装 JDK 1.7及以上，此处将介绍 Gradle 在 Windows 平台下的手动安装。在 <a href=\"https://gradle.org/releases/\" target=\"_blank\" rel=\"noopener\">https://gradle.org/releases/</a> 下载最新的 release 包并解压至相应文件夹，然后在系统环境变量添加<code>GRADLE_HOME</code>，作者的变量值为<code>D:\\gradle-5.4.1</code>，最后再将<code>%GRADLE_HOME%\\bin</code>添加进<code>Path</code>变量中即可。在命令行中键入<code>gradle -v</code>验证环境搭建结果。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\Febers> gradle -v</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to Gradle 5.4.1!</span><br><span class=\"line\"></span><br><span class=\"line\">Here are the highlights of this release:</span><br><span class=\"line\"> - Run builds with JDK12</span><br><span class=\"line\"> - New API <span class=\"keyword\">for</span> Incremental Tasks</span><br><span class=\"line\"> - Updates to native projects, including Swift 5 support</span><br><span class=\"line\"></span><br><span class=\"line\">For more details see https://docs.gradle.org/5.4.1/release-notes.html</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>新建一个工程项目，比如<code>gradle_demo</code>，然后新建一个<code>build.gradle</code>文件，在其中输入</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task hello {</span><br><span class=\"line\">  doLast {</span><br><span class=\"line\">    println <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>在当前文件夹命令行中键入<code>gradle -q hello</code>即可输出<code>Hello  World!</code>。这里使用的是基于 Groovy 的 DSL（Domain Specific Language，领域特定语言）。</p>\n<p>task 和 action 是 Gradle 的重要元素，前者代表一个独立的原子操作，比如复制一个文件、编译一次 Java 代码，这里简单定义一个名为<code>hello</code>的 task；后者则是前者的组成部分，<code>doLast</code>代表 task 执行的最后一个 action，task 执行完毕之后会回调该 action。</p>\n<h3 id=\"日志级别\"><a href=\"#日志级别\" class=\"headerlink\" title=\"日志级别\"></a>日志级别</h3><p>和 Android 类似，Gradle 也定义了日志级别</p>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>用于</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ERROR</td>\n<td>错误信息</td>\n</tr>\n<tr>\n<td>QUIET</td>\n<td>重要信息</td>\n</tr>\n<tr>\n<td>WARNING</td>\n<td>警告信息</td>\n</tr>\n<tr>\n<td>LIFECYCLE</td>\n<td>进度信息</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>信息消息</td>\n</tr>\n<tr>\n<td>DEBUG</td>\n<td>调试消息</td>\n</tr>\n</tbody>\n</table>\n<p>上文运行任务所使用到的命令<code>gradle -q hello</code>中的<code>-q</code>即为日志的级别开关选项</p>\n<table>\n<thead>\n<tr>\n<th>开关选项</th>\n<th>输出级别</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无</td>\n<td>LIFECYCLE及以上</td>\n</tr>\n<tr>\n<td>-q 或 –quiet</td>\n<td>QUIET及以上</td>\n</tr>\n<tr>\n<td>-i 或 –info</td>\n<td>INFO及以上</td>\n</tr>\n<tr>\n<td>-d 或 –debug</td>\n<td>DEBUG及以上</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h3><p>每个 Gradle 项目都由一个或多个 Project 构成，每个 Project 又都由 Task 构成。一个 <code>build.gradle</code>文件便是对一个 Project 对象的配置。在 Android 项目中，根目录会存在一个<code>build.gradle</code>文件，每个模块下也会有一个该文件。</p>\n<p>在构建脚本中调用的没有在构建脚本中定义的方法和属性都委派给 Project 对象，比如<code>project.copy()</code>等价于<code>copy()</code>、<code>project.buildDir</code>等价于<code>buildDir</code> </p>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><h4 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h4><figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task hello {</span><br><span class=\"line\">  doLast {</span><br><span class=\"line\">    println <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接用任务名称</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> Task helloo = task(helloo)</span><br><span class=\"line\">helloo.doLast {</span><br><span class=\"line\">  println <span class=\"string\">'Helloo World!'</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明任务配置</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> Task hellooo = task(hellooo, <span class=\"string\">group:</span> BasePlugin.BUILD_GROUP)</span><br><span class=\"line\">hellooo.doLast {</span><br><span class=\"line\">  println <span class=\"string\">'Hellooo World!'</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用 TaskContainer 的 create 方法创建，以上三种方式最终都会调用该方法</span></span><br><span class=\"line\">tasks.create(<span class=\"string\">name:</span> <span class=\"string\">'helloooo'</span>) {</span><br><span class=\"line\">  doLast {</span><br><span class=\"line\">    println <span class=\"string\">'helloooo World!'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输入<code>gradle -q hello*</code>之后的结果为，说明成功创建任务</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Hello World!</span><br><span class=\"line\">Helloo World!</span><br><span class=\"line\">Hellooo World!</span><br><span class=\"line\">helloooo World!</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"任务顺序\"><a href=\"#任务顺序\" class=\"headerlink\" title=\"任务顺序\"></a>任务顺序</h4><p>通过<code>dependsOn</code>指定任务的依赖，通过一个例子理解</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task hello {</span><br><span class=\"line\">  println <span class=\"string\">'hello'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  doFirst {</span><br><span class=\"line\">    println <span class=\"string\">'hello first'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">  doLast {</span><br><span class=\"line\">    println <span class=\"string\">'Hello last'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">task go(<span class=\"string\">dependsOn:</span> hello) {</span><br><span class=\"line\">  println <span class=\"string\">'go'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  doLast {</span><br><span class=\"line\">    println <span class=\"string\">'go last 0'</span></span><br><span class=\"line\">  } </span><br><span class=\"line\"></span><br><span class=\"line\">  doFirst {</span><br><span class=\"line\">    println <span class=\"string\">'go first'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  doLast {</span><br><span class=\"line\">    println <span class=\"string\">'go last 1'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输入<code>gradle -q go</code>之后的输出结果为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hello</span><br><span class=\"line\">go</span><br><span class=\"line\">hello first</span><br><span class=\"line\">Hello last</span><br><span class=\"line\">go first</span><br><span class=\"line\">go last 0</span><br><span class=\"line\">go last 1</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"排除任务\"><a href=\"#排除任务\" class=\"headerlink\" title=\"排除任务\"></a>排除任务</h4><p>在命令行后添加<code>-x go</code>来排除任务 go，输入<code>gradle hello -x go</code>之后</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">> Task :hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello first</span><br><span class=\"line\">hello last</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL <span class=\"keyword\">in</span> 1s</span><br><span class=\"line\">1 actionable task: 1 executed</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"动态任务\"><a href=\"#动态任务\" class=\"headerlink\" title=\"动态任务\"></a>动态任务</h4><p>可以通过拓展方法<code>times</code>动态创建任务</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3.</span>times {</span><br><span class=\"line\">  count -> task <span class=\"string\">\"task$count\"</span> {</span><br><span class=\"line\">    doLast {</span><br><span class=\"line\">      println <span class=\"string\">\"task $count\"</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输入<code>gradle -q task0</code>之后将输出<code>task 0</code>，已创建的三个任务中的一个</p>\n<h4 id=\"任务属性\"><a href=\"#任务属性\" class=\"headerlink\" title=\"任务属性\"></a>任务属性</h4><p>标准属性有<code>group</code>、<code>description</code>等，除此之外的自定义属性需添加<code>ext</code>前缀</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task hello {</span><br><span class=\"line\">  group = <span class=\"string\">'group0'</span></span><br><span class=\"line\">  description = <span class=\"string\">'description'</span></span><br><span class=\"line\">  ext.myTitle = <span class=\"string\">'title'</span></span><br><span class=\"line\">  ext.myId = <span class=\"number\">9527</span></span><br><span class=\"line\"></span><br><span class=\"line\">  doLast {</span><br><span class=\"line\">    println <span class=\"string\">\"任务分组属性: $group\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"任务描述:属性 $description\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"自定义Title属性: $myTitle\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"自定义Id属性: $myId\"</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输出正常</p>\n<h2 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h2><p><img src=\"/Gradle-构建工具详解/groovy.png\" alt></p>\n<p>Gadle 使用 Groovy 的 DSL 编写，Groovy 是 Apache 推出的 JVM 语言。Groovy 的学习可以参考其<a href=\"http://cndoc.github.io/groovy-doc-cn/\" target=\"_blank\" rel=\"noopener\">官方文档</a>，写得相当友好。Groovy 可以与 Java 无缝连接，甚至可以在其中直接使用 Java 语法，Java 中调用 Groovy 也相当方便。此处只介绍一些与 Java 不同的地方。</p>\n<p>Groovy 会默认导入以下包，不需要显示导入</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">java.io.*</span><br><span class=\"line\">java.lang.*</span><br><span class=\"line\">java.math.BigDecimal</span><br><span class=\"line\">java.math.BigInteger</span><br><span class=\"line\">java.net.*</span><br><span class=\"line\">java.util.*</span><br><span class=\"line\">groovy.lang.*</span><br><span class=\"line\">groovy.util.*</span><br></pre></td></tr></tbody></table></figure>\n<p>可以导入 SDK 之后在 IDE 中编写 Groovy 程序，也可以在 <code>build.gradle</code> 中编写代码，在 task</p>\n<p>中调用，使用 gradle 命令运行。以下的例子采用后一种方法。</p>\n<h3 id=\"变量与方法\"><a href=\"#变量与方法\" class=\"headerlink\" title=\"变量与方法\"></a>变量与方法</h3><p>使用 def 关键字来定义变量和方法，可以不指定变量的类型，默认访问修饰符为 public。Groovy 中使用双引号定义字符串的时候类型为<code>GString</code>而非<code>java.lang.String</code>，因此可以使用<code>$</code>输出表达式结果</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task t {</span><br><span class=\"line\">  <span class=\"comment\">//定义变量，可以使用 def，也可以使用具体类型，或者两者结合</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> a = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"keyword\">int</span> b = <span class=\"number\">1</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">//定义字符串，同 dart </span></span><br><span class=\"line\">  String s = <span class=\"string\">\"s\"</span>\t</span><br><span class=\"line\">  String ss = <span class=\"string\">'ss'</span></span><br><span class=\"line\">  String sss = <span class=\"string\">\"\"\"first row</span></span><br><span class=\"line\"><span class=\"string\">  second row\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  println <span class=\"string\">\"95-27=${minus(95,27)}\"</span></span><br><span class=\"line\">  println <span class=\"string\">\"95+27=${add 95,27}\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定返回类型则 def 可省略，且参数类型可省略</span></span><br><span class=\"line\"><span class=\"comment\">//不使用 return 则返回最后一行</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minus(a, b) {</span><br><span class=\"line\">  println <span class=\"string\">\"before return\"</span></span><br><span class=\"line\">  a - b</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义方法</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> add(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>控制台输出</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">before <span class=\"built_in\">return</span></span><br><span class=\"line\">95-27=68</span><br><span class=\"line\">95+27=122</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>Groovy 中的类与 Java 类似，不过由于没有访问修饰符，默认为<code>public</code>，要想实现 Java 默认的包访问权限（<code>default</code>），可以使用注解<code>@PackageScope</code>。对于没有可见性修饰的变量，Groovy 会隐式提供<code>setter/getter</code>方法。以下的两个类是等价的</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task t {</span><br><span class=\"line\">  <span class=\"keyword\">def</span> object = <span class=\"keyword\">new</span> ClassInGroovy()</span><br><span class=\"line\">  object.name = <span class=\"string\">\"Jack\"</span></span><br><span class=\"line\">  println <span class=\"string\">\"${object.name}\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassInJava</span> {</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String getName() {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setName(String name) {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassInGroovy</span> {</span></span><br><span class=\"line\">  String name</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>此外 Groovy 使用<code>asType</code>函数进行类型转换，支持<code>object.with{ }</code>进行级联操作，支持使用<code>?.</code>进行非空操作，都是些很眼熟的语法特性</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包在 Groovy 中是<code>groovy.lang.Closure</code>的实例，类似于 Dart 中的函数是 Function 的实例，因此可以像变量一样传递，其语法定义为</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//闭包的参数为可选项</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> closure = { [closureParameters -> ] statements }</span><br></pre></td></tr></tbody></table></figure>\n<p>闭包跟函数不同的地方在于其可以访问外部变量</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task t {</span><br><span class=\"line\">  <span class=\"keyword\">def</span> str = <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> closure0 = {</span><br><span class=\"line\">    println str  </span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> closure1 = { String name, <span class=\"keyword\">int</span> t -> </span><br><span class=\"line\">    println <span class=\"string\">\"before print\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"$name call $t times\"</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//调用，call 可省略</span></span><br><span class=\"line\">  closure0.call()\t</span><br><span class=\"line\">  closure1(<span class=\"string\">\"Jack\"</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>与 Java 中的 Lambda 表达式类似，闭包可以当做参数传递，当闭包为最后一个参数时可写在调用的括号后</p>\n<h3 id=\"文件读取\"><a href=\"#文件读取\" class=\"headerlink\" title=\"文件读取\"></a>文件读取</h3><p>相较于 Java，Groovy 的文件读写非常简洁友好。在当前文件夹新建一个文件<code>静夜思.txt</code></p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">task t {</span><br><span class=\"line\">  <span class=\"keyword\">def</span> path = <span class=\"string\">\"静夜思.txt\"</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> file = <span class=\"keyword\">new</span> File(path).eachLine { line -></span><br><span class=\"line\">    println line</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">//更简洁</span></span><br><span class=\"line\">  println file.text</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">//写入，该方法会打印并覆盖原来的内容</span></span><br><span class=\"line\">  file.withPrintWriter {</span><br><span class=\"line\">    it.println <span class=\"string\">\"表达了诗人对家乡的思念\"</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>Groovy 中的流程控制语句（比如<code>if/else</code>、<code>for/in</code>、<code>switch/case</code>）、数据结构（比如<code>List</code>、<code>Map</code>）与 Java/Dart 类似，在此便不过多费笔墨，参考官方文档即可。</p>\n<h2 id=\"Gradle-Wrapper\"><a href=\"#Gradle-Wrapper\" class=\"headerlink\" title=\"Gradle Wrapper\"></a>Gradle Wrapper</h2><p>Gradle 包装器。为了应对团队开发中 Gradle 环境和版本的差异会对编译结果带来的不确定性，使用 Gradle Wrapper，它是一个脚本，可以指定构建版本、快速运行项目，从而达到标准化、提到开发效率。Android Studio 新建项目时自带 Gradle Wrapper，因此 Android 开发者很少单独下载安装 Gradle</p>\n<p>Gradle Wrapper 的工作流程如下图</p>\n<p><img src=\"https://docs.gradle.org/current/userguide/img/wrapper-workflow.png\" alt></p>\n<p>使用 Gradle Wrapper 启动 Gradle 之后，如果指定版本的 Gradle 没有被下载关联，会先从官方仓库下载到用户本地，进行解包并执行批处理文件。后续的构建运行都会重用这个解包的运行时安装程序</p>\n<h3 id=\"构建-Gradle-Wrapper\"><a href=\"#构建-Gradle-Wrapper\" class=\"headerlink\" title=\"构建 Gradle Wrapper\"></a>构建 Gradle Wrapper</h3><p>Gradle 内置 Wrapper Task，执行 Wrapper Task 就可以在项目目录中生成对应的目录文件。在项目根目录执行<code>gradle wrapper</code> 命令即可。之后根目录的文件结构如下</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">└── gradlew.bat</span><br></pre></td></tr></tbody></table></figure>\n<p>文件含义为</p>\n<ul>\n<li>gradle-wrapper.jar ：包含 Gradle 运行时的逻辑代码。</li>\n<li>gradle-wrapper.properties ：负责配置包装器运行时行为的属性文件</li>\n<li>gradlew：Linux 平台下，用于执行 Gralde 命令的包装器脚本。</li>\n<li>gradlew.bat：Windows 平台下，用于执行 Gradle 命令的包装器脚本。</li>\n</ul>\n<p>查看<code>.properties</code>文件</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">distributionBase=GRADLE_USER_HOME</span><br><span class=\"line\">distributionPath=wrapper/dists</span><br><span class=\"line\">distributionUrl=https\\://services.gradle.org/distributions/gradle-5.4.1-bin.zip</span><br><span class=\"line\">zipStoreBase=GRADLE_USER_HOME</span><br><span class=\"line\">zipStorePath=wrapper/dists</span><br></pre></td></tr></tbody></table></figure>\n<p>属性含义为</p>\n<ul>\n<li>distributionBase：Gradle 解包后存储的主目录。</li>\n<li>distributionPath：distributionBase 指定目录的子目录。distributionBase+distributionPath 为 Gradle 解包后的存放位置。</li>\n<li>distributionUrl：Gradle 发行版压缩包的下载地址。</li>\n<li>zipStoreBase：Gradle 压缩包存储主目录。</li>\n<li>zipStorePath：zipStoreBase 指定目录的子目录。zipStoreBase+zipStorePath 为 Gradle 压缩包的存放位置。</li>\n</ul>\n<p>如果官方包发行版下载缓慢，可以手动更改<code>distributionUrl</code>为可用地址</p>\n<h3 id=\"使用-Gradle-Wrapper\"><a href=\"#使用-Gradle-Wrapper\" class=\"headerlink\" title=\"使用 Gradle Wrapper\"></a>使用 Gradle Wrapper</h3><p>使用<code>gradlew.bar</code>代替<code>gradle</code>运行 Gradle Project，首次使用会下载 Gradle 到配置文件指定的位置，作者的路径为<code>C:\\Users\\23033\\.gradle\\wrapper\\dists\\gradle-5.4.1-bin\\e75iq110yv9r9wt1a6619x2xm\\gradle-5.4.1</code></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">PS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat t</span><br><span class=\"line\">Downloading https://services.gradle.org/distributions/gradle-5.4.1-bin.zip</span><br><span class=\"line\">...................................................................................</span><br><span class=\"line\"></span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></tbody></table></figure>\n<p>再次使用该命令便不会重复下载。升级 Gradle 版本可以通过<code>gradlew wrapper –gradle-version 5.*.*</code>命令实现</p>\n<h2 id=\"Gradle-插件\"><a href=\"#Gradle-插件\" class=\"headerlink\" title=\"Gradle 插件\"></a>Gradle 插件</h2><p>Gradle 中的插件可分为两类</p>\n<ul>\n<li>脚本插件：额外的构建脚本，类似于一个 build.gradle</li>\n<li>对象插件：又叫二进制插件，是实现了 Plugin 接口的类</li>\n</ul>\n<p>应用插件又分为两个步骤，一是解析插件，二是通过<code>apply()</code>把插件应用到项目中。</p>\n<h3 id=\"脚本插件\"><a href=\"#脚本插件\" class=\"headerlink\" title=\"脚本插件\"></a>脚本插件</h3><p>在根目录新建一个<code>other.gradle</code>文件，内容如下</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ext {</span><br><span class=\"line\">  otherVersion = <span class=\"string\">'1.0'</span></span><br><span class=\"line\">  otherUrl = <span class=\"string\">'https://febers.github.io'</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>将<code>build.gradle</code>内容修改为</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'other.gradle'</span></span><br><span class=\"line\">task t {</span><br><span class=\"line\">  println <span class=\"string\">\"版本为: ${otherVersion},地址为: ${otherUrl}\"</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">PS D:\\Work\\Gradle\\gradle_demo> .\\gradlew.bat t</span><br><span class=\"line\"></span><br><span class=\"line\">> Configure project :</span><br><span class=\"line\">版本为: 1.0,地址为: https://febers.github.io</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"对象插件\"><a href=\"#对象插件\" class=\"headerlink\" title=\"对象插件\"></a>对象插件</h3><p>对象插件是实现了<code>org.gradle.api.plugin<Project></code>接口的插件，又可分为内部插件和第三方插件</p>\n<h4 id=\"内部插件\"><a href=\"#内部插件\" class=\"headerlink\" title=\"内部插件\"></a>内部插件</h4><p>使用以下方法应用 Java 插件（因为默认导入<code>org.gradle.api.plugin</code>包，所以可以去掉包名）</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> org.gradle.api.plugins.JavaPlugin</span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> JavaPlugin\t<span class=\"comment\">//去掉包名</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java'</span>\t<span class=\"comment\">//使用 pluginid（实现 plugin 接口的插件的属性）</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'cpp'</span>    <span class=\"comment\">//Gradle 中含有大量插件</span></span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"第三方插件\"><a href=\"#第三方插件\" class=\"headerlink\" title=\"第三方插件\"></a>第三方插件</h4><p>一般为 jar 文件，通过<code>buildscript</code>配置，此处引入 Android Gradle 插件</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">buildscript {</span><br><span class=\"line\">  repositories {</span><br><span class=\"line\">    google()</span><br><span class=\"line\">  }</span><br><span class=\"line\">  dependencies {</span><br><span class=\"line\">    classpath <span class=\"string\">'com.android.tools.build:gradle:3.4.1'</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br></pre></td></tr></tbody></table></figure>\n<p>如果第三方插件被托管到 <a href=\"Gradle - Plugins\nhttps://plugins.gradle.org/\">Gradle - Plugins</a>，也可以不使用<code>buildscript</code></p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">plugins {</span><br><span class=\"line\">  id <span class=\"string\">\"com.quittle.setup-android-sdk\"</span> version <span class=\"string\">\"1.2.0\"</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"自定义对象插件\"><a href=\"#自定义对象插件\" class=\"headerlink\" title=\"自定义对象插件\"></a>自定义对象插件</h4><p>Plugin 接口中定义了一个<code>apply</code>方法，重写该方法，在其中通过传进来的参数<code>Object o</code>（实际为 Project 类型）调用 task 新建一个任务</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span> {</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> apply(Object o) {</span><br><span class=\"line\">    o.task(<span class=\"string\">\"myTask\"</span>) {</span><br><span class=\"line\">      println <span class=\"string\">\"This is a custom task in custom plugin\"</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> MyPlugin</span><br></pre></td></tr></tbody></table></figure>\n<p>输入命令<code>gradle myTask</code>即可验证</p>\n<h2 id=\"Android-中的-Gradle\"><a href=\"#Android-中的-Gradle\" class=\"headerlink\" title=\"Android 中的 Gradle\"></a>Android 中的 Gradle</h2><p>为了支持 Android 项目的构建，Google 为 Gradle 编写了 Android 插件，组成 Android 构建系统。Android Studio+Gradle 是目前最流行的 Android 开发构建环境。关于 Android 构建配置可查阅官方文档 <a href=\"https://developer.android.com/studio/build?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">配置构建</a></p>\n<h3 id=\"模块类型\"><a href=\"#模块类型\" class=\"headerlink\" title=\"模块类型\"></a>模块类型</h3><p>Android Studio 中的每个项目包含一个或多个含有源代码文件和资源文件的模块，这些模块可以独立构建测试，模块类型包含以下几种</p>\n<ul>\n<li>Android 应用程序模块：可能依赖于库模块，构建系统会将其生成一个 apk 文件</li>\n<li>Android 库模块：包含可重用的特定于 Android 的代码和资源，构建系统将其生成一个 aar 文件</li>\n<li>App 引擎模块：包含应用程序引擎继承的代码和资源</li>\n<li>Java 库模块：包含可重用的代码，构建系统将其生成一个 jar 文件</li>\n</ul>\n<h3 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h3><p>在 Android Studio 中，Android 项目视图如下，以开发者个人项目 <a href=\"https://github.com/Febers/UESTC_BBS\" target=\"_blank\" rel=\"noopener\">UESTC_BBS</a> 为例</p>\n<p><img src=\"/Gradle-构建工具详解/项目结构.png\" alt></p>\n<p>所有构建稳健位于 Gradle Scripts 层级下，文件作用如下</p>\n<ul>\n<li>项目 build.gradle：配置项目整体属性，比如指定的代码仓库、依赖的 Gradle 版本等</li>\n<li>模块 build.gradle：配置当前模块的编译参数</li>\n<li>gradle-wrapper-properties：配置 Gradle Wrapper</li>\n<li>gradle-properties：配置 Gradle</li>\n<li>setting.gradle：配置 Gradle 的多项目管理</li>\n<li>local.properties：存放 Android 项目的私有属性配置，如 SDK 路径</li>\n<li>multiDexKeep.pro、proguard-rules.pro：可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类</li>\n</ul>\n<h3 id=\"项目-build-gradle\"><a href=\"#项目-build-gradle\" class=\"headerlink\" title=\"项目 build.gradle\"></a>项目 build.gradle</h3><p>典型的项目<code>build.gradle</code>文件如下</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">buildscript {</span><br><span class=\"line\">    ext.kotlin_version = <span class=\"string\">'1.3.10'</span></span><br><span class=\"line\">    repositories {</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    }</span><br><span class=\"line\">    dependencies {</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.4.0'</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\"</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">allprojects {</span><br><span class=\"line\">    repositories {</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">        maven { url <span class=\"string\">'https://jitpack.io'</span> }</span><br><span class=\"line\">        maven { url <span class=\"string\">\"https://maven.google.com\"</span> }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">task clean(<span class=\"string\">type:</span> Delete) {</span><br><span class=\"line\">    delete rootProject.buildDir</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>其中<code>google()</code>是配置 Google 的 Maven 仓库，<code>maven { url \"https://maven.google.com\" }</code>同理</p>\n<h3 id=\"模块-build-gradle\"><a href=\"#模块-build-gradle\" class=\"headerlink\" title=\"模块 build.gradle\"></a>模块 build.gradle</h3><p>典型的模块<code>build.gradle</code>文件如下</p>\n<figure class=\"highlight groovy\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android-extensions'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\">ext.anko_version = <span class=\"string\">'0.10.5'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies {</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>], <span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:multidex:1.0.3'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'androidx.appcompat:appcompat:1.0.2'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">android {</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">    defaultConfig {</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.febers.uestc_bbs\"</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">17</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">        versionCode <span class=\"number\">12</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.1.4\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"androidx.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">        multiDexEnabled <span class=\"literal\">true</span></span><br><span class=\"line\">        multiDexKeepProguard file(<span class=\"string\">'multiDexKeep.pro'</span>) <span class=\"comment\">// keep specific classes using proguard syntax</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    compileOptions {</span><br><span class=\"line\">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">    }</span><br><span class=\"line\">    buildTypes {</span><br><span class=\"line\">        release {</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>第一行 apply 的是一个<code>application</code>，说明当前模块为一个应用程序模块，Gradle 的 Android 插件分为以下几种</p>\n<ul>\n<li>应用程序插件：插件 id 为<code>com.android.application</code>，构建生成 apk</li>\n<li>库插件：插件 id 为<code>com.android.library</code>，构建生成 aar</li>\n<li>测试插件：插件 id 为<code>com.android.test</code>，用于测试其他模块</li>\n<li>feature 插件：插件 id 为<code>com.android.feature</code>，用于创建 Android Instant App</li>\n<li>instant App 插件：插件 id 为<code>com.android.instantapp</code>，是 Android Instant App 的入口</li>\n</ul>\n<p>很多属性都可以望文生义，此处不再赘述。</p>\n<hr>\n<p>参考</p>\n<p><a href=\"http://liuwangshu.cn/application/android-gradle/1-gradle-plug-in.html\" target=\"_blank\" rel=\"noopener\">Gradle的Android插件入门</a></p>\n<p><a href=\"http://liuwangshu.cn/tags/Gradle%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/\" target=\"_blank\" rel=\"noopener\">Gradle核心思想</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":12139,"excerpt":"<p>Gradle 是一个基于 JVM 的自动化构建工具，使用 Groovy  DSL 声明配置。现代软件开发包含众多步骤，包括编译、测试、打包等，如果需要手动重复每一过程，将会耗费大量时间、增加出错概率，项目自动化应运而生。在此之前，常见的 Java 构建工具包括 Ant、Gant 和 Maven 等，Gradle 结合了以上工具的优点，基于约定大于配置，通用灵活，是 Android 的官方构建工具。本文将介绍 Gradle 的基本知识、Groovy 基本语法以及 Android 开发中的 Gradle 知识。</p>\n<p><img src=\"https://plugins.gradle.org/shared-assets/shared/images/gradle-logo-horizontal.svg\" alt></p>","more":"<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><h3 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h3><p>确保系统已安装 JDK 1.7及以上，此处将介绍 Gradle 在 Windows 平台下的手动安装。在 <a href=\"https://gradle.org/releases/\" target=\"_blank\" rel=\"noopener\">https://gradle.org/releases/</a> 下载最新的 release 包并解压至相应文件夹，然后在系统环境变量添加<code>GRADLE_HOME</code>，作者的变量值为<code>D:\\gradle-5.4.1</code>，最后再将<code>%GRADLE_HOME%\\bin</code>添加进<code>Path</code>变量中即可。在命令行中键入<code>gradle -v</code>验证环境搭建结果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\Febers&gt; gradle -v</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to Gradle 5.4.1!</span><br><span class=\"line\"></span><br><span class=\"line\">Here are the highlights of this release:</span><br><span class=\"line\"> - Run builds with JDK12</span><br><span class=\"line\"> - New API <span class=\"keyword\">for</span> Incremental Tasks</span><br><span class=\"line\"> - Updates to native projects, including Swift 5 support</span><br><span class=\"line\"></span><br><span class=\"line\">For more details see https://docs.gradle.org/5.4.1/release-notes.html</span><br></pre></td></tr></table></figure>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>新建一个工程项目，比如<code>gradle_demo</code>，然后新建一个<code>build.gradle</code>文件，在其中输入</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">  doLast &#123;</span><br><span class=\"line\">    println <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在当前文件夹命令行中键入<code>gradle -q hello</code>即可输出<code>Hello  World!</code>。这里使用的是基于 Groovy 的 DSL（Domain Specific Language，领域特定语言）。</p>\n<p>task 和 action 是 Gradle 的重要元素，前者代表一个独立的原子操作，比如复制一个文件、编译一次 Java 代码，这里简单定义一个名为<code>hello</code>的 task；后者则是前者的组成部分，<code>doLast</code>代表 task 执行的最后一个 action，task 执行完毕之后会回调该 action。</p>\n<h3 id=\"日志级别\"><a href=\"#日志级别\" class=\"headerlink\" title=\"日志级别\"></a>日志级别</h3><p>和 Android 类似，Gradle 也定义了日志级别</p>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>用于</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ERROR</td>\n<td>错误信息</td>\n</tr>\n<tr>\n<td>QUIET</td>\n<td>重要信息</td>\n</tr>\n<tr>\n<td>WARNING</td>\n<td>警告信息</td>\n</tr>\n<tr>\n<td>LIFECYCLE</td>\n<td>进度信息</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>信息消息</td>\n</tr>\n<tr>\n<td>DEBUG</td>\n<td>调试消息</td>\n</tr>\n</tbody>\n</table>\n<p>上文运行任务所使用到的命令<code>gradle -q hello</code>中的<code>-q</code>即为日志的级别开关选项</p>\n<table>\n<thead>\n<tr>\n<th>开关选项</th>\n<th>输出级别</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无</td>\n<td>LIFECYCLE及以上</td>\n</tr>\n<tr>\n<td>-q 或 –quiet</td>\n<td>QUIET及以上</td>\n</tr>\n<tr>\n<td>-i 或 –info</td>\n<td>INFO及以上</td>\n</tr>\n<tr>\n<td>-d 或 –debug</td>\n<td>DEBUG及以上</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h3><p>每个 Gradle 项目都由一个或多个 Project 构成，每个 Project 又都由 Task 构成。一个 <code>build.gradle</code>文件便是对一个 Project 对象的配置。在 Android 项目中，根目录会存在一个<code>build.gradle</code>文件，每个模块下也会有一个该文件。</p>\n<p>在构建脚本中调用的没有在构建脚本中定义的方法和属性都委派给 Project 对象，比如<code>project.copy()</code>等价于<code>copy()</code>、<code>project.buildDir</code>等价于<code>buildDir</code> </p>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><h4 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h4><figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">  doLast &#123;</span><br><span class=\"line\">    println <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接用任务名称</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> Task helloo = task(helloo)</span><br><span class=\"line\">helloo.doLast &#123;</span><br><span class=\"line\">  println <span class=\"string\">'Helloo World!'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明任务配置</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> Task hellooo = task(hellooo, <span class=\"string\">group:</span> BasePlugin.BUILD_GROUP)</span><br><span class=\"line\">hellooo.doLast &#123;</span><br><span class=\"line\">  println <span class=\"string\">'Hellooo World!'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用 TaskContainer 的 create 方法创建，以上三种方式最终都会调用该方法</span></span><br><span class=\"line\">tasks.create(<span class=\"string\">name:</span> <span class=\"string\">'helloooo'</span>) &#123;</span><br><span class=\"line\">  doLast &#123;</span><br><span class=\"line\">    println <span class=\"string\">'helloooo World!'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入<code>gradle -q hello*</code>之后的结果为，说明成功创建任务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello World!</span><br><span class=\"line\">Helloo World!</span><br><span class=\"line\">Hellooo World!</span><br><span class=\"line\">helloooo World!</span><br></pre></td></tr></table></figure>\n<h4 id=\"任务顺序\"><a href=\"#任务顺序\" class=\"headerlink\" title=\"任务顺序\"></a>任务顺序</h4><p>通过<code>dependsOn</code>指定任务的依赖，通过一个例子理解</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">  println <span class=\"string\">'hello'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  doFirst &#123;</span><br><span class=\"line\">    println <span class=\"string\">'hello first'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  doLast &#123;</span><br><span class=\"line\">    println <span class=\"string\">'Hello last'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task go(<span class=\"string\">dependsOn:</span> hello) &#123;</span><br><span class=\"line\">  println <span class=\"string\">'go'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  doLast &#123;</span><br><span class=\"line\">    println <span class=\"string\">'go last 0'</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">  doFirst &#123;</span><br><span class=\"line\">    println <span class=\"string\">'go first'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  doLast &#123;</span><br><span class=\"line\">    println <span class=\"string\">'go last 1'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入<code>gradle -q go</code>之后的输出结果为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hello</span><br><span class=\"line\">go</span><br><span class=\"line\">hello first</span><br><span class=\"line\">Hello last</span><br><span class=\"line\">go first</span><br><span class=\"line\">go last 0</span><br><span class=\"line\">go last 1</span><br></pre></td></tr></table></figure>\n<h4 id=\"排除任务\"><a href=\"#排除任务\" class=\"headerlink\" title=\"排除任务\"></a>排除任务</h4><p>在命令行后添加<code>-x go</code>来排除任务 go，输入<code>gradle hello -x go</code>之后</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Task :hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello first</span><br><span class=\"line\">hello last</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL <span class=\"keyword\">in</span> 1s</span><br><span class=\"line\">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态任务\"><a href=\"#动态任务\" class=\"headerlink\" title=\"动态任务\"></a>动态任务</h4><p>可以通过拓展方法<code>times</code>动态创建任务</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3.</span>times &#123;</span><br><span class=\"line\">  count -&gt; task <span class=\"string\">\"task$count\"</span> &#123;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">      println <span class=\"string\">\"task $count\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入<code>gradle -q task0</code>之后将输出<code>task 0</code>，已创建的三个任务中的一个</p>\n<h4 id=\"任务属性\"><a href=\"#任务属性\" class=\"headerlink\" title=\"任务属性\"></a>任务属性</h4><p>标准属性有<code>group</code>、<code>description</code>等，除此之外的自定义属性需添加<code>ext</code>前缀</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task hello &#123;</span><br><span class=\"line\">  group = <span class=\"string\">'group0'</span></span><br><span class=\"line\">  description = <span class=\"string\">'description'</span></span><br><span class=\"line\">  ext.myTitle = <span class=\"string\">'title'</span></span><br><span class=\"line\">  ext.myId = <span class=\"number\">9527</span></span><br><span class=\"line\"></span><br><span class=\"line\">  doLast &#123;</span><br><span class=\"line\">    println <span class=\"string\">\"任务分组属性: $group\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"任务描述:属性 $description\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"自定义Title属性: $myTitle\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"自定义Id属性: $myId\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出正常</p>\n<h2 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h2><p><img src=\"/Gradle-构建工具详解/groovy.png\" alt=\"\"></p>\n<p>Gadle 使用 Groovy 的 DSL 编写，Groovy 是 Apache 推出的 JVM 语言。Groovy 的学习可以参考其<a href=\"http://cndoc.github.io/groovy-doc-cn/\" target=\"_blank\" rel=\"noopener\">官方文档</a>，写得相当友好。Groovy 可以与 Java 无缝连接，甚至可以在其中直接使用 Java 语法，Java 中调用 Groovy 也相当方便。此处只介绍一些与 Java 不同的地方。</p>\n<p>Groovy 会默认导入以下包，不需要显示导入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.io.*</span><br><span class=\"line\">java.lang.*</span><br><span class=\"line\">java.math.BigDecimal</span><br><span class=\"line\">java.math.BigInteger</span><br><span class=\"line\">java.net.*</span><br><span class=\"line\">java.util.*</span><br><span class=\"line\">groovy.lang.*</span><br><span class=\"line\">groovy.util.*</span><br></pre></td></tr></table></figure>\n<p>可以导入 SDK 之后在 IDE 中编写 Groovy 程序，也可以在 <code>build.gradle</code> 中编写代码，在 task</p>\n<p>中调用，使用 gradle 命令运行。以下的例子采用后一种方法。</p>\n<h3 id=\"变量与方法\"><a href=\"#变量与方法\" class=\"headerlink\" title=\"变量与方法\"></a>变量与方法</h3><p>使用 def 关键字来定义变量和方法，可以不指定变量的类型，默认访问修饰符为 public。Groovy 中使用双引号定义字符串的时候类型为<code>GString</code>而非<code>java.lang.String</code>，因此可以使用<code>$</code>输出表达式结果</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task t &#123;</span><br><span class=\"line\">  <span class=\"comment\">//定义变量，可以使用 def，也可以使用具体类型，或者两者结合</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> a = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"keyword\">int</span> b = <span class=\"number\">1</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">//定义字符串，同 dart </span></span><br><span class=\"line\">  String s = <span class=\"string\">\"s\"</span>\t</span><br><span class=\"line\">  String ss = <span class=\"string\">'ss'</span></span><br><span class=\"line\">  String sss = <span class=\"string\">\"\"\"first row</span></span><br><span class=\"line\"><span class=\"string\">  second row\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  println <span class=\"string\">\"95-27=$&#123;minus(95,27)&#125;\"</span></span><br><span class=\"line\">  println <span class=\"string\">\"95+27=$&#123;add 95,27&#125;\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定返回类型则 def 可省略，且参数类型可省略</span></span><br><span class=\"line\"><span class=\"comment\">//不使用 return 则返回最后一行</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minus(a, b) &#123;</span><br><span class=\"line\">  println <span class=\"string\">\"before return\"</span></span><br><span class=\"line\">  a - b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义方法</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> add(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">before <span class=\"built_in\">return</span></span><br><span class=\"line\">95-27=68</span><br><span class=\"line\">95+27=122</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>Groovy 中的类与 Java 类似，不过由于没有访问修饰符，默认为<code>public</code>，要想实现 Java 默认的包访问权限（<code>default</code>），可以使用注解<code>@PackageScope</code>。对于没有可见性修饰的变量，Groovy 会隐式提供<code>setter/getter</code>方法。以下的两个类是等价的</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task t &#123;</span><br><span class=\"line\">  <span class=\"keyword\">def</span> object = <span class=\"keyword\">new</span> ClassInGroovy()</span><br><span class=\"line\">  object.name = <span class=\"string\">\"Jack\"</span></span><br><span class=\"line\">  println <span class=\"string\">\"$&#123;object.name&#125;\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassInJava</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String getName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setName(String name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassInGroovy</span> &#123;</span></span><br><span class=\"line\">  String name</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外 Groovy 使用<code>asType</code>函数进行类型转换，支持<code>object.with{ }</code>进行级联操作，支持使用<code>?.</code>进行非空操作，都是些很眼熟的语法特性</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包在 Groovy 中是<code>groovy.lang.Closure</code>的实例，类似于 Dart 中的函数是 Function 的实例，因此可以像变量一样传递，其语法定义为</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//闭包的参数为可选项</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> closure = &#123; [closureParameters -&gt; ] statements &#125;</span><br></pre></td></tr></table></figure>\n<p>闭包跟函数不同的地方在于其可以访问外部变量</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task t &#123;</span><br><span class=\"line\">  <span class=\"keyword\">def</span> str = <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> closure0 = &#123;</span><br><span class=\"line\">    println str  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> closure1 = &#123; String name, <span class=\"keyword\">int</span> t -&gt; </span><br><span class=\"line\">    println <span class=\"string\">\"before print\"</span></span><br><span class=\"line\">    println <span class=\"string\">\"$name call $t times\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//调用，call 可省略</span></span><br><span class=\"line\">  closure0.call()\t</span><br><span class=\"line\">  closure1(<span class=\"string\">\"Jack\"</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与 Java 中的 Lambda 表达式类似，闭包可以当做参数传递，当闭包为最后一个参数时可写在调用的括号后</p>\n<h3 id=\"文件读取\"><a href=\"#文件读取\" class=\"headerlink\" title=\"文件读取\"></a>文件读取</h3><p>相较于 Java，Groovy 的文件读写非常简洁友好。在当前文件夹新建一个文件<code>静夜思.txt</code></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">task t &#123;</span><br><span class=\"line\">  <span class=\"keyword\">def</span> path = <span class=\"string\">\"静夜思.txt\"</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> file = <span class=\"keyword\">new</span> File(path).eachLine &#123; line -&gt;</span><br><span class=\"line\">    println line</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//更简洁</span></span><br><span class=\"line\">  println file.text</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">//写入，该方法会打印并覆盖原来的内容</span></span><br><span class=\"line\">  file.withPrintWriter &#123;</span><br><span class=\"line\">    it.println <span class=\"string\">\"表达了诗人对家乡的思念\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>Groovy 中的流程控制语句（比如<code>if/else</code>、<code>for/in</code>、<code>switch/case</code>）、数据结构（比如<code>List</code>、<code>Map</code>）与 Java/Dart 类似，在此便不过多费笔墨，参考官方文档即可。</p>\n<h2 id=\"Gradle-Wrapper\"><a href=\"#Gradle-Wrapper\" class=\"headerlink\" title=\"Gradle Wrapper\"></a>Gradle Wrapper</h2><p>Gradle 包装器。为了应对团队开发中 Gradle 环境和版本的差异会对编译结果带来的不确定性，使用 Gradle Wrapper，它是一个脚本，可以指定构建版本、快速运行项目，从而达到标准化、提到开发效率。Android Studio 新建项目时自带 Gradle Wrapper，因此 Android 开发者很少单独下载安装 Gradle</p>\n<p>Gradle Wrapper 的工作流程如下图</p>\n<p><img src=\"https://docs.gradle.org/current/userguide/img/wrapper-workflow.png\" alt=\"\"></p>\n<p>使用 Gradle Wrapper 启动 Gradle 之后，如果指定版本的 Gradle 没有被下载关联，会先从官方仓库下载到用户本地，进行解包并执行批处理文件。后续的构建运行都会重用这个解包的运行时安装程序</p>\n<h3 id=\"构建-Gradle-Wrapper\"><a href=\"#构建-Gradle-Wrapper\" class=\"headerlink\" title=\"构建 Gradle Wrapper\"></a>构建 Gradle Wrapper</h3><p>Gradle 内置 Wrapper Task，执行 Wrapper Task 就可以在项目目录中生成对应的目录文件。在项目根目录执行<code>gradle wrapper</code> 命令即可。之后根目录的文件结构如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">└── gradlew.bat</span><br></pre></td></tr></table></figure>\n<p>文件含义为</p>\n<ul>\n<li>gradle-wrapper.jar ：包含 Gradle 运行时的逻辑代码。</li>\n<li>gradle-wrapper.properties ：负责配置包装器运行时行为的属性文件</li>\n<li>gradlew：Linux 平台下，用于执行 Gralde 命令的包装器脚本。</li>\n<li>gradlew.bat：Windows 平台下，用于执行 Gradle 命令的包装器脚本。</li>\n</ul>\n<p>查看<code>.properties</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">distributionBase=GRADLE_USER_HOME</span><br><span class=\"line\">distributionPath=wrapper/dists</span><br><span class=\"line\">distributionUrl=https\\://services.gradle.org/distributions/gradle-5.4.1-bin.zip</span><br><span class=\"line\">zipStoreBase=GRADLE_USER_HOME</span><br><span class=\"line\">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure>\n<p>属性含义为</p>\n<ul>\n<li>distributionBase：Gradle 解包后存储的主目录。</li>\n<li>distributionPath：distributionBase 指定目录的子目录。distributionBase+distributionPath 为 Gradle 解包后的存放位置。</li>\n<li>distributionUrl：Gradle 发行版压缩包的下载地址。</li>\n<li>zipStoreBase：Gradle 压缩包存储主目录。</li>\n<li>zipStorePath：zipStoreBase 指定目录的子目录。zipStoreBase+zipStorePath 为 Gradle 压缩包的存放位置。</li>\n</ul>\n<p>如果官方包发行版下载缓慢，可以手动更改<code>distributionUrl</code>为可用地址</p>\n<h3 id=\"使用-Gradle-Wrapper\"><a href=\"#使用-Gradle-Wrapper\" class=\"headerlink\" title=\"使用 Gradle Wrapper\"></a>使用 Gradle Wrapper</h3><p>使用<code>gradlew.bar</code>代替<code>gradle</code>运行 Gradle Project，首次使用会下载 Gradle 到配置文件指定的位置，作者的路径为<code>C:\\Users\\23033\\.gradle\\wrapper\\dists\\gradle-5.4.1-bin\\e75iq110yv9r9wt1a6619x2xm\\gradle-5.4.1</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS D:\\Work\\Gradle\\gradle_demo&gt; .\\gradlew.bat t</span><br><span class=\"line\">Downloading https://services.gradle.org/distributions/gradle-5.4.1-bin.zip</span><br><span class=\"line\">...................................................................................</span><br><span class=\"line\"></span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n<p>再次使用该命令便不会重复下载。升级 Gradle 版本可以通过<code>gradlew wrapper –gradle-version 5.*.*</code>命令实现</p>\n<h2 id=\"Gradle-插件\"><a href=\"#Gradle-插件\" class=\"headerlink\" title=\"Gradle 插件\"></a>Gradle 插件</h2><p>Gradle 中的插件可分为两类</p>\n<ul>\n<li>脚本插件：额外的构建脚本，类似于一个 build.gradle</li>\n<li>对象插件：又叫二进制插件，是实现了 Plugin 接口的类</li>\n</ul>\n<p>应用插件又分为两个步骤，一是解析插件，二是通过<code>apply()</code>把插件应用到项目中。</p>\n<h3 id=\"脚本插件\"><a href=\"#脚本插件\" class=\"headerlink\" title=\"脚本插件\"></a>脚本插件</h3><p>在根目录新建一个<code>other.gradle</code>文件，内容如下</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">ext &#123;</span><br><span class=\"line\">  otherVersion = <span class=\"string\">'1.0'</span></span><br><span class=\"line\">  otherUrl = <span class=\"string\">'https://febers.github.io'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将<code>build.gradle</code>内容修改为</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">from:</span> <span class=\"string\">'other.gradle'</span></span><br><span class=\"line\">task t &#123;</span><br><span class=\"line\">  println <span class=\"string\">\"版本为: $&#123;otherVersion&#125;,地址为: $&#123;otherUrl&#125;\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS D:\\Work\\Gradle\\gradle_demo&gt; .\\gradlew.bat t</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Configure project :</span><br><span class=\"line\">版本为: 1.0,地址为: https://febers.github.io</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象插件\"><a href=\"#对象插件\" class=\"headerlink\" title=\"对象插件\"></a>对象插件</h3><p>对象插件是实现了<code>org.gradle.api.plugin&lt;Project&gt;</code>接口的插件，又可分为内部插件和第三方插件</p>\n<h4 id=\"内部插件\"><a href=\"#内部插件\" class=\"headerlink\" title=\"内部插件\"></a>内部插件</h4><p>使用以下方法应用 Java 插件（因为默认导入<code>org.gradle.api.plugin</code>包，所以可以去掉包名）</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> org.gradle.api.plugins.JavaPlugin</span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> JavaPlugin\t<span class=\"comment\">//去掉包名</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java'</span>\t<span class=\"comment\">//使用 pluginid（实现 plugin 接口的插件的属性）</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'cpp'</span>    <span class=\"comment\">//Gradle 中含有大量插件</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方插件\"><a href=\"#第三方插件\" class=\"headerlink\" title=\"第三方插件\"></a>第三方插件</h4><p>一般为 jar 文件，通过<code>buildscript</code>配置，此处引入 Android Gradle 插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">    google()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dependencies &#123;</span><br><span class=\"line\">    classpath <span class=\"string\">'com.android.tools.build:gradle:3.4.1'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br></pre></td></tr></table></figure>\n<p>如果第三方插件被托管到 <a href=\"Gradle - Plugins\nhttps://plugins.gradle.org/\">Gradle - Plugins</a>，也可以不使用<code>buildscript</code></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">  id <span class=\"string\">\"com.quittle.setup-android-sdk\"</span> version <span class=\"string\">\"1.2.0\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义对象插件\"><a href=\"#自定义对象插件\" class=\"headerlink\" title=\"自定义对象插件\"></a>自定义对象插件</h4><p>Plugin 接口中定义了一个<code>apply</code>方法，重写该方法，在其中通过传进来的参数<code>Object o</code>（实际为 Project 类型）调用 task 新建一个任务</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span> &#123;</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> apply(Object o) &#123;</span><br><span class=\"line\">    o.task(<span class=\"string\">\"myTask\"</span>) &#123;</span><br><span class=\"line\">      println <span class=\"string\">\"This is a custom task in custom plugin\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> MyPlugin</span><br></pre></td></tr></table></figure>\n<p>输入命令<code>gradle myTask</code>即可验证</p>\n<h2 id=\"Android-中的-Gradle\"><a href=\"#Android-中的-Gradle\" class=\"headerlink\" title=\"Android 中的 Gradle\"></a>Android 中的 Gradle</h2><p>为了支持 Android 项目的构建，Google 为 Gradle 编写了 Android 插件，组成 Android 构建系统。Android Studio+Gradle 是目前最流行的 Android 开发构建环境。关于 Android 构建配置可查阅官方文档 <a href=\"https://developer.android.com/studio/build?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">配置构建</a></p>\n<h3 id=\"模块类型\"><a href=\"#模块类型\" class=\"headerlink\" title=\"模块类型\"></a>模块类型</h3><p>Android Studio 中的每个项目包含一个或多个含有源代码文件和资源文件的模块，这些模块可以独立构建测试，模块类型包含以下几种</p>\n<ul>\n<li>Android 应用程序模块：可能依赖于库模块，构建系统会将其生成一个 apk 文件</li>\n<li>Android 库模块：包含可重用的特定于 Android 的代码和资源，构建系统将其生成一个 aar 文件</li>\n<li>App 引擎模块：包含应用程序引擎继承的代码和资源</li>\n<li>Java 库模块：包含可重用的代码，构建系统将其生成一个 jar 文件</li>\n</ul>\n<h3 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h3><p>在 Android Studio 中，Android 项目视图如下，以开发者个人项目 <a href=\"https://github.com/Febers/UESTC_BBS\" target=\"_blank\" rel=\"noopener\">UESTC_BBS</a> 为例</p>\n<p><img src=\"/Gradle-构建工具详解/项目结构.png\" alt=\"\"></p>\n<p>所有构建稳健位于 Gradle Scripts 层级下，文件作用如下</p>\n<ul>\n<li>项目 build.gradle：配置项目整体属性，比如指定的代码仓库、依赖的 Gradle 版本等</li>\n<li>模块 build.gradle：配置当前模块的编译参数</li>\n<li>gradle-wrapper-properties：配置 Gradle Wrapper</li>\n<li>gradle-properties：配置 Gradle</li>\n<li>setting.gradle：配置 Gradle 的多项目管理</li>\n<li>local.properties：存放 Android 项目的私有属性配置，如 SDK 路径</li>\n<li>multiDexKeep.pro、proguard-rules.pro：可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类</li>\n</ul>\n<h3 id=\"项目-build-gradle\"><a href=\"#项目-build-gradle\" class=\"headerlink\" title=\"项目 build.gradle\"></a>项目 build.gradle</h3><p>典型的项目<code>build.gradle</code>文件如下</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext.kotlin_version = <span class=\"string\">'1.3.10'</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.4.0'</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">'https://jitpack.io'</span> &#125;</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"https://maven.google.com\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task clean(<span class=\"string\">type:</span> Delete) &#123;</span><br><span class=\"line\">    delete rootProject.buildDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>google()</code>是配置 Google 的 Maven 仓库，<code>maven { url &quot;https://maven.google.com&quot; }</code>同理</p>\n<h3 id=\"模块-build-gradle\"><a href=\"#模块-build-gradle\" class=\"headerlink\" title=\"模块 build.gradle\"></a>模块 build.gradle</h3><p>典型的模块<code>build.gradle</code>文件如下</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android-extensions'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\">ext.anko_version = <span class=\"string\">'0.10.5'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>], <span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:multidex:1.0.3'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'androidx.appcompat:appcompat:1.0.2'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">\"com.febers.uestc_bbs\"</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">17</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">        versionCode <span class=\"number\">12</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.1.4\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"androidx.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">        multiDexEnabled <span class=\"literal\">true</span></span><br><span class=\"line\">        multiDexKeepProguard file(<span class=\"string\">'multiDexKeep.pro'</span>) <span class=\"comment\">// keep specific classes using proguard syntax</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    compileOptions &#123;</span><br><span class=\"line\">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一行 apply 的是一个<code>application</code>，说明当前模块为一个应用程序模块，Gradle 的 Android 插件分为以下几种</p>\n<ul>\n<li>应用程序插件：插件 id 为<code>com.android.application</code>，构建生成 apk</li>\n<li>库插件：插件 id 为<code>com.android.library</code>，构建生成 aar</li>\n<li>测试插件：插件 id 为<code>com.android.test</code>，用于测试其他模块</li>\n<li>feature 插件：插件 id 为<code>com.android.feature</code>，用于创建 Android Instant App</li>\n<li>instant App 插件：插件 id 为<code>com.android.instantapp</code>，是 Android Instant App 的入口</li>\n</ul>\n<p>很多属性都可以望文生义，此处不再赘述。</p>\n<hr>\n<p>参考</p>\n<p><a href=\"http://liuwangshu.cn/application/android-gradle/1-gradle-plug-in.html\" target=\"_blank\" rel=\"noopener\">Gradle的Android插件入门</a></p>\n<p><a href=\"http://liuwangshu.cn/tags/Gradle%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/\" target=\"_blank\" rel=\"noopener\">Gradle核心思想</a></p>"},{"title":"Spring-学习笔记（一）：基本理念和-Bean-装配","date":"2019-05-28T14:13:09.000Z","_content":"\n很早就接触 Java 后端开发，不过大都浅尝辄止，并没有深刻地理解和实践，时间一长倒也跟没学过差不了多少。由于职业规划是要从 Android 开发慢慢转到后端开发，拖到现在终于是要系统学习了。学习的路线初步定为，从 Spring 出发，不断回顾 Java Web 的知识，重点在 Spring Boot 项目，通过具体的项目实践掌握相关知识。这篇文章属于第一篇学习笔记，参考手上的《Spring 实战》和网络上的技术文章，主要记录 Spring 的基本知识和理念、Bean  的装配。\n\n![](https://github.com/spring-projects/spring-framework/raw/master/src/docs/asciidoc/images/spring-framework.png)\n\n<!--more-->\n\n## 关于 \n\n### Spring\n\n一个 Java EE 框架，同来替代更加重量级的企业级 Java 技术。其起源可以追溯到作者 Rod Johnson 2002年编写的《Expert One-to-One J2EE Design and Development》一书，书中他提出了一种基于普通 Java 类和依赖注入的解决方案。Rod Johnson 编写了超过30,000行基础结构代码，这便是最初的 Spring 框架。\n\nSpring 的基本理念在于：简化 Java 开发，为此采用了4种关键措施：\n\n- 基于 POJO 的轻量级和最小侵入性编程\n- 通过依赖注入和面向接口实现松耦合\n- 基于切面和惯例进行声明式编程\n- 通过切面和模板减少样板式代码\n\n### 依赖注入\n\n依赖注入（Dependency Injection，简称 DI）是最常见的控制反转（Inversion of Control，简称 IoC）方式，是面向对象编程中的一种设计原则，用于减少代码之间的耦合度。系统通过引入实现 IoC 模式的容器，管理对象的声明周期、依赖关系，常用的 IoC 容器有 Spring 、JBoss、EJB 等。可以把 IoC 模式看作工厂模式的升华，区别在于该工厂要生成的对象是通过 XML 文件、配置类或者注解来配置。\n\nJava 项目大都是由众多类组成，这些类相互协作来完成特定的业务逻辑。传统的做法是每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，导致代码高度耦合。耦合具有两面性，一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且修复 Bug 的过程中容易引发更多的 Bug；另一方面，一定的耦合又是必须的——完全无耦合的代码什么也做不了。通过 DI，对象的依赖关系交由系统中负责协调各对象的第三者在创建对象时设定，依赖关系被注入到需要它们的对象中。\n\n通过一个简单的 Spring Demo 引入依赖注入的思想。\n\n项目结构如下\n\n```bash\n├─src\n│  ├─main\n│  │  ├─java\n│  │  │  └─knigt\n│  │  │          BraveKnight.kt\n│  │  │          SlayDragonQuest.kt\n│  │  │          KnightConfig.kt\n│  │  │          KnightMain.kt\n│  │  │\n│  │  └─resources\n│  │          knights.xml\n\n```\n\n> 在 IDEA 内通过以下命令生成项目文档树\n>\n> tree  >>\tD:/tree.txt 输出文件夹\n> tree /f >>\tD:/tree.txt 输出文件夹和文件\n\n```kotlin\n//BraveKnight.kt\ninterface Knight {\n    fun embarkOnQuest()\n}\n\nclass BraveKnight(private val quest: Quest): Knight {\n\n    override fun embarkOnQuest() {\n        quest.embark()\n    }\n}\n\n//SlayDragonQuest.kt\ninterface Quest {\n    fun embark()\n}\n\nclass SlayDragonQuest(private val stream: PrintStream): Quest {\n\n    override fun embark() {\n        stream.println(\"Embarking on quest to slay the dragon!\")\n    }\n}\n\n//KnightConfig.kt\n@Configuration\nopen class KnightConfig {\n\n    @Bean\n    open fun knight(): Knight = BraveKnight(quest())\n\n    @Bean\n    open fun quest(): Quest = SlayDragonQuest(System.out)\n}\n\n//KnightMain.kt\nclass KnightMain {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val context: AnnotationConfigApplicationContext = AnnotationConfigApplicationContext(KnightConfig::class.java)\n            //val context: ClassPathXmlApplicationContext = ClassPathXmlApplicationContext(\"knights.xml\")   XML 方式配置\n            val knight: Knight = context.getBean(Knight::class.java)\n            knight.embarkOnQuest()\n            context.close()\n        }\n    }\n}\n```\n\nXML 的配置文件为\n\n```xml\n//knight.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n      http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n  <bean id=\"knight\" class=\"sia.knights.BraveKnight\">\n    <constructor-arg ref=\"quest\" />\n  </bean>\n\n  <bean id=\"quest\" class=\"sia.knights.SlayDragonQuest\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n</beans>\n```\n\n\n\n输出结果为\n\n```bash\nEmbarking on quest to slay the dragon!\n```\n\n### 面向切面编程\n\nAspect-Oriented Programming，AOP。DI 能够让相互协作的组件保持松耦合，而 AOP 则允许开发者把组件除自身核心功能之外，可重用的功能分离出来，比如日志、事务管理和安全等服务。AOP 思想中的相关术语包括\n\n- Joinpoint：连接点，目标对象中所有可增强的方法\n- Pointcut：切入点，目标对象中所有已增强的方法\n- Advice：增强/通知，增强的代码\n- Weaving：织入，将“通知”应用到切入点的过程\n- Proxy：将“通知”织入到目标对象后，形成代理对象\n- Aspect：切面，切入点+“通知”\n\n使用一个传唱骑士事迹的吟游诗人服务类作为一个 AOP 的应用\n\n```kotlin\n//Minstrel.kt\nopen class Minstrel(private val stream: PrintStream) {\n    open fun singBeforeQuest() {\n        stream.println(\"Fa la la, the knight is so brave!\")\n    }\n\n    open fun singAfterQuest() {\n        stream.println(\"Tee hee hee, the brave knight did embark on a quest!\")\n    }\n}\n```\n```xml\n//knights.xml 加入以下代码\n<bean id=\"minstrel\" class=\"Minstrel\">\n    <constructor-arg value=\"#{T(System).out}\" />\n</bean>\n\n<aop:config>\n\t<aop:aspect ref=\"minstrel\">\n\t\t<aop:pointcut id=\"embark\" expression=\"execution(* *.embarkOnQuest(..))\" />\n\n\t\t<aop:before pointcut-ref=\"embark\" method=\"singBeforeQuest\" />\n\n\t\t<aop:after pointcut-ref=\"embark\" method=\"singAfterQuest\" />\n\t</aop:aspect>\n</aop:config>\n```\n\n*默认缺少 org.aspectj.aspectjweaver，可以引入 maven，添加对应的依赖*\n\n运行之后，控制台输出结果为\n\n```bash\nFa la la, the knight is so brave!\nEmbarking on quest to slay the dragon!\nTee hee hee, the brave knight did embark on a quest!\n```\n\n不使用 BraveKnight 和 Minstrel 组合的方式而是使用 AOP，通过少量的 XML 配置，就可以把 Minstrel 声明为一个 Spring 切面，进而实现相应的功能。Minstrel 仍然只是一个 POJO，但可以被应用到任何需要它的地方，只需要修改配置文件中的 AspectJ 切点表达式语言即可。\n\n## 装配 Bean\n\n### 容器\n\nSpring 容器（Container）负责创建、装配和配置对象，并且管理它们的生命周期。Spring 的核心便是容器，它自带多个容器实现，可以归为两种不同的类型：Bean 工厂（由`org.springframework.beans.factory.BeanFactory`接口定义）是最简单的容器，提供基本的 DI 支持；应用上下文（由`org.springframework.context.ApplicationContext`接口定义），基于 BeanFactory 构建，并提供应用框架级别的服务，例如从属性文本解析文本信息以及发送应用事件给感兴趣的事件监听者。重点在于应用上下文上。\n\nSpring 自带多种应用上下文\n\n- AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文\n- AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文\n- ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源\n- FileSystemXmlApplicationContext：从文件系统的一个或多个 XML 配置文件中加载上下文定义\n- XmlWebApplicationContext：从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义\n\n### Bean 生命周期\n\n![](Spring-学习笔记（一）：基本理念和-Bean-装配\\生命周期.png)\n\n\n1. Spring 对 bean 进行实例化\n2. Spring 将值和 bean 的引用注入到 bean 对应的属性中\n3. 如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给`setBeanName`方法\n4. 如果 bean 实现了 BeanFactoryAware 接口，Spring 将调用`setBeanFactory`方法，将 BeanFactory 容器实例传入\n5. 如果 bean 实现了 ApplicationContextAware 接口， Spring 将调用`setApplicationContext`方法，将 bean 所在的应用上下文的引用传入\n6. 如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的`postProcessBeforeInitialization`方法\n7. 如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 `afterPropertiesSet`方法。类似的，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用\n8. 如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的`postProcessAfterInitialzation`方法\n9. 此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁\n10. 如果 bean 实现了 DisposablBean 接口，Spring 将调用它的`destroy`接口方法。同样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用\n\n### 可选装配方案\n\n有三种方式向 Spring 容器描述 Bean 如何装配\n\n- 在 XML 文件中进行显示配置\n- 在 Java 代码中进行显示配置\n- 隐式的 bean 发现机制和自动装配\n\n#### 自动化装配 bean\n\nSpring 从两个角度实现自动化装配\n\n- 组件扫描（Component Scanning）：Spring 会自动发现应用上下文中所创建的 bean\n- 自动装配（Autowiring）：Spring 自动满足 bean 之间的依赖\n\n通过一个 CD 播放的 Demo 说明，XML config 文件位于`/resources`目录下，Kotlin 文件位于`java/soundsystem`目录下\n\n```kotlin\n//conpactDisc.kt\n@Component\nclass CompactDisc {\n\n    private val title = \"Sgt. Pepper's Lonely Hearts Club Band\"\n    private val artist = \"The Beatles\"\n\n    fun play() {\n        println(\"Playing $title by $artist\")\n    }\n}\n\n//CDPlayer.kt\n@Component\nclass CDPlayer @Autowired\nconstructor(private val cd: CompactDisc) {\n\n    fun play() {\n        cd.play()\n    }\n}\n\n//CDPlayerTest.kt\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [CDPlayerConfig::class])\nclass CDPlayerTest {\n    @Autowired\n    lateinit var player: CDPlayer\n\n    @Test\n    fun play() {\n        player.play()\n    }\n}\n```\n\n以上便是准备好的工程文件，使用`@Autowired`注解在需要自动装配的任何属性、构造器、方法上，然后在 Java 代码或者 XML 配置文件启动自动装配。不同的自动装配方式需要修改 JUnit 测试框架的`@ContextConfiguration`注解参数\n\n- XML 方式：`locations = [\"classpath:spring-config.xml\"]`\n\n- Java 方式：`classes = [CDPlayerConfig::class]`\n\n  \n\n*JUnit 测试框架需要导入依赖*\n\n接下来的一步便是启用 Spring 的组件扫描，也就是配置以上的两种注解参数之一，搭配 Bean 类注解`@Component`便可以实现组件扫描。以下两种做法都可以，第一种是使用一个`Config`类并添加注解`@Configuration`和`@ConponentScan`，第二种则是在 XML 文件中配置`context:component-scan`\n\n```kotlin\n//Java 代码\n@Configuration\n@ComponentScan\nopen class CDPlayerConfig\n```\n\n```xml\n//XML 文件\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:component-scan base-package=\"soundsystem\" />\n\n</beans>\n```\n\n运行测试，控制台成功输出\n\n```bash\nPlaying Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n```\n\n#### Java 代码装配\n\n大多数情况下都可以通过自动化装配的方式完成配置，但是当我们使用第三方的类库组件时，无法在组件类上直接添加注解，只能使用显示装配。这种情况下，使用 JavaConfig 是最好的方式。通常将 JavaConfig 放到同一个包中，并且它应该不包含任何的业务逻辑。\n\n```kotlin\n@Configuration\nopen class CDPlayerConfig {\n    \n    @Bean\n    open fun sgtPeppers(): SgtPeppers = SgtPeppers()\n    \n    @Bean\n    open fun cdPlayer(): CDPlayer = CDPlayer(sgtPeppers())\n    \n    @Bean\n    open fun anotherCDPlayer(): CDPlayer = CDPlayer(sgtPeppers())\n    \n    @Bean\n    open fun cdPlayerUseParam(compactDisc: CompactDisc): CDPlayer {\n        val cdPlayer = CDPlayer(compactDisc)\n        cdPlayer.setCompactDisc(compactDisc)\n        return cdPlayer\n    }\n}\n```\n\n在上面的代码中，配置类`CDPlayerConfig`中提供了几种装配 Bean  的方式。`sgtPeppers`方法注入了一个 SgtPeppers 实例，`cdPlayer`和`anotherCDPlayer`需要调用该方法来注入 CDPlayer 实例。Spring 会拦截所有对该方法的调用，并直接返回该方法创建的 Bean，并且默认情况下 Bean 是单例的。\n\n最后一个方法则展现了一个更具可读性、更多样化的注入方式。\n\n#### XML 代码装配\n\n最简单的 Spring XML 配置如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    \n</beans>\n```\n\n需要在配置文件顶部声明多个 XML 模式（XSD）文件，这些文件定义了配置 Spring 的 XML 元素。`<beans>`配置文件的根元素。\n\n声明一个简单的 Bean 可以通过下面的方式实现\n\n```xml\n<bean id=\"cdPlayer\" class=\"sound_system.CDPlayer\">\n\t<constructor-arg ref=\"sgtPeppers\"/>\n</bean>\n    \n<bean id=\"sgtPeppers\" class=\"sound_system.SgtPeppers\" />\n```\n\n如果没有指定 id，该 Bean 将会根据全限定类名命名：`sound_system.CDPlayer#0`，`#0`为计数形式，用以区分相同类型的其他 Bean。\n\n`&lt;constructor-arg&gt;`元素告知 Spring 要将一个 id 为`sgtPeppers`的 bean 引用传递到 CDPlayer 的构造器中。作为替代，也可以使用 Spring 的 c-命名空间，不再赘述。关于`&lt;constructor-arg&gt; `元素的更多知识：[IOC 之解析 bean 标签：constructor-arg、property 子元素](http://cmsblogs.com/?p=2754)\n\n在该元素中，可以使用`value`属性将字面量传递给构造器，使用子元素`&lt;null/&gt;`空值，使用子元素`&lt;list&gt;`传递集合。\n\nXML 配置也提供了设置属性的接口，通过元素`property`可以将对象引用、字面量、集合等注入 Bean 中。比如为 SgtPeppers 添加新的属性并对外提供修改接口\n\n```kotlin\nclass SgtPeppers: CompactDisc {\n    var title = \"Sgt. Pepper's Lonely Hearts Club Band\"\n    var artist = \"The Beatles\"\n    var tracks: MutableList<String> = ArrayList()\n    \n    override fun play() {\n        println(\"Playing $title by $artist\")\n    }\n}\n```\n\n然后在 XML 文件中注入属性设置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"sgtPeppers\" class=\"sound_system.SgtPeppers\">\n        <property name=\"title\" value=\"new title\" />\n        <property name=\"artist\" value=\"new artist\" />\n        <property name=\"tracks\">\n            <list>\n                <value>track 1</value>\n                <value>track 2</value>\n                <value>track 3</value>\n                <value>track 4</value>\n            </list>\n        </property>\n    </bean>\n\n</beans>\n```\n\n\n\n### 导入和混合配置\n\n当开发者使用自动装配的时候，Spring 会考虑容器中的所有 Bean，因此不用考虑混合配置的问题。混合配置应用在显式装配时，比如 XML 和 Java 互相引用配置的 Bean。\n\n在 JavaConfig 中使用注解`@Import`导入其他 JavaConfig，使用注解`@ImportResource`混合 XML 配置，比如\n\n```kotlin\n@Configuration\n@Import(CDPlayerConfig::class)\n@ImportResource(\"classpath:sound_system.xml\")\nopen class SoundSystemConfig \n```\n\n在 XML 中使用元素`import`导入其他 XML 文件，而如果要导入 JavaConfig，做法很简单 ：将其声明为一个 bean 即可。\n\n","source":"_posts/Spring-学习笔记（一）：基本理念和-Bean-装配.md","raw":"---\ntitle: Spring-学习笔记（一）：基本理念和-Bean-装配\ndate: 2019-05-28 22:13:09\ntags:\n- Spring \n- DI\n- AOP\n- Java EE\ncategories:\n- Spring\n---\n\n很早就接触 Java 后端开发，不过大都浅尝辄止，并没有深刻地理解和实践，时间一长倒也跟没学过差不了多少。由于职业规划是要从 Android 开发慢慢转到后端开发，拖到现在终于是要系统学习了。学习的路线初步定为，从 Spring 出发，不断回顾 Java Web 的知识，重点在 Spring Boot 项目，通过具体的项目实践掌握相关知识。这篇文章属于第一篇学习笔记，参考手上的《Spring 实战》和网络上的技术文章，主要记录 Spring 的基本知识和理念、Bean  的装配。\n\n![](https://github.com/spring-projects/spring-framework/raw/master/src/docs/asciidoc/images/spring-framework.png)\n\n<!--more-->\n\n## 关于 \n\n### Spring\n\n一个 Java EE 框架，同来替代更加重量级的企业级 Java 技术。其起源可以追溯到作者 Rod Johnson 2002年编写的《Expert One-to-One J2EE Design and Development》一书，书中他提出了一种基于普通 Java 类和依赖注入的解决方案。Rod Johnson 编写了超过30,000行基础结构代码，这便是最初的 Spring 框架。\n\nSpring 的基本理念在于：简化 Java 开发，为此采用了4种关键措施：\n\n- 基于 POJO 的轻量级和最小侵入性编程\n- 通过依赖注入和面向接口实现松耦合\n- 基于切面和惯例进行声明式编程\n- 通过切面和模板减少样板式代码\n\n### 依赖注入\n\n依赖注入（Dependency Injection，简称 DI）是最常见的控制反转（Inversion of Control，简称 IoC）方式，是面向对象编程中的一种设计原则，用于减少代码之间的耦合度。系统通过引入实现 IoC 模式的容器，管理对象的声明周期、依赖关系，常用的 IoC 容器有 Spring 、JBoss、EJB 等。可以把 IoC 模式看作工厂模式的升华，区别在于该工厂要生成的对象是通过 XML 文件、配置类或者注解来配置。\n\nJava 项目大都是由众多类组成，这些类相互协作来完成特定的业务逻辑。传统的做法是每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，导致代码高度耦合。耦合具有两面性，一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且修复 Bug 的过程中容易引发更多的 Bug；另一方面，一定的耦合又是必须的——完全无耦合的代码什么也做不了。通过 DI，对象的依赖关系交由系统中负责协调各对象的第三者在创建对象时设定，依赖关系被注入到需要它们的对象中。\n\n通过一个简单的 Spring Demo 引入依赖注入的思想。\n\n项目结构如下\n\n```bash\n├─src\n│  ├─main\n│  │  ├─java\n│  │  │  └─knigt\n│  │  │          BraveKnight.kt\n│  │  │          SlayDragonQuest.kt\n│  │  │          KnightConfig.kt\n│  │  │          KnightMain.kt\n│  │  │\n│  │  └─resources\n│  │          knights.xml\n\n```\n\n> 在 IDEA 内通过以下命令生成项目文档树\n>\n> tree  >>\tD:/tree.txt 输出文件夹\n> tree /f >>\tD:/tree.txt 输出文件夹和文件\n\n```kotlin\n//BraveKnight.kt\ninterface Knight {\n    fun embarkOnQuest()\n}\n\nclass BraveKnight(private val quest: Quest): Knight {\n\n    override fun embarkOnQuest() {\n        quest.embark()\n    }\n}\n\n//SlayDragonQuest.kt\ninterface Quest {\n    fun embark()\n}\n\nclass SlayDragonQuest(private val stream: PrintStream): Quest {\n\n    override fun embark() {\n        stream.println(\"Embarking on quest to slay the dragon!\")\n    }\n}\n\n//KnightConfig.kt\n@Configuration\nopen class KnightConfig {\n\n    @Bean\n    open fun knight(): Knight = BraveKnight(quest())\n\n    @Bean\n    open fun quest(): Quest = SlayDragonQuest(System.out)\n}\n\n//KnightMain.kt\nclass KnightMain {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val context: AnnotationConfigApplicationContext = AnnotationConfigApplicationContext(KnightConfig::class.java)\n            //val context: ClassPathXmlApplicationContext = ClassPathXmlApplicationContext(\"knights.xml\")   XML 方式配置\n            val knight: Knight = context.getBean(Knight::class.java)\n            knight.embarkOnQuest()\n            context.close()\n        }\n    }\n}\n```\n\nXML 的配置文件为\n\n```xml\n//knight.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n      http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n  <bean id=\"knight\" class=\"sia.knights.BraveKnight\">\n    <constructor-arg ref=\"quest\" />\n  </bean>\n\n  <bean id=\"quest\" class=\"sia.knights.SlayDragonQuest\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n</beans>\n```\n\n\n\n输出结果为\n\n```bash\nEmbarking on quest to slay the dragon!\n```\n\n### 面向切面编程\n\nAspect-Oriented Programming，AOP。DI 能够让相互协作的组件保持松耦合，而 AOP 则允许开发者把组件除自身核心功能之外，可重用的功能分离出来，比如日志、事务管理和安全等服务。AOP 思想中的相关术语包括\n\n- Joinpoint：连接点，目标对象中所有可增强的方法\n- Pointcut：切入点，目标对象中所有已增强的方法\n- Advice：增强/通知，增强的代码\n- Weaving：织入，将“通知”应用到切入点的过程\n- Proxy：将“通知”织入到目标对象后，形成代理对象\n- Aspect：切面，切入点+“通知”\n\n使用一个传唱骑士事迹的吟游诗人服务类作为一个 AOP 的应用\n\n```kotlin\n//Minstrel.kt\nopen class Minstrel(private val stream: PrintStream) {\n    open fun singBeforeQuest() {\n        stream.println(\"Fa la la, the knight is so brave!\")\n    }\n\n    open fun singAfterQuest() {\n        stream.println(\"Tee hee hee, the brave knight did embark on a quest!\")\n    }\n}\n```\n```xml\n//knights.xml 加入以下代码\n<bean id=\"minstrel\" class=\"Minstrel\">\n    <constructor-arg value=\"#{T(System).out}\" />\n</bean>\n\n<aop:config>\n\t<aop:aspect ref=\"minstrel\">\n\t\t<aop:pointcut id=\"embark\" expression=\"execution(* *.embarkOnQuest(..))\" />\n\n\t\t<aop:before pointcut-ref=\"embark\" method=\"singBeforeQuest\" />\n\n\t\t<aop:after pointcut-ref=\"embark\" method=\"singAfterQuest\" />\n\t</aop:aspect>\n</aop:config>\n```\n\n*默认缺少 org.aspectj.aspectjweaver，可以引入 maven，添加对应的依赖*\n\n运行之后，控制台输出结果为\n\n```bash\nFa la la, the knight is so brave!\nEmbarking on quest to slay the dragon!\nTee hee hee, the brave knight did embark on a quest!\n```\n\n不使用 BraveKnight 和 Minstrel 组合的方式而是使用 AOP，通过少量的 XML 配置，就可以把 Minstrel 声明为一个 Spring 切面，进而实现相应的功能。Minstrel 仍然只是一个 POJO，但可以被应用到任何需要它的地方，只需要修改配置文件中的 AspectJ 切点表达式语言即可。\n\n## 装配 Bean\n\n### 容器\n\nSpring 容器（Container）负责创建、装配和配置对象，并且管理它们的生命周期。Spring 的核心便是容器，它自带多个容器实现，可以归为两种不同的类型：Bean 工厂（由`org.springframework.beans.factory.BeanFactory`接口定义）是最简单的容器，提供基本的 DI 支持；应用上下文（由`org.springframework.context.ApplicationContext`接口定义），基于 BeanFactory 构建，并提供应用框架级别的服务，例如从属性文本解析文本信息以及发送应用事件给感兴趣的事件监听者。重点在于应用上下文上。\n\nSpring 自带多种应用上下文\n\n- AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文\n- AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文\n- ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源\n- FileSystemXmlApplicationContext：从文件系统的一个或多个 XML 配置文件中加载上下文定义\n- XmlWebApplicationContext：从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义\n\n### Bean 生命周期\n\n![](Spring-学习笔记（一）：基本理念和-Bean-装配\\生命周期.png)\n\n\n1. Spring 对 bean 进行实例化\n2. Spring 将值和 bean 的引用注入到 bean 对应的属性中\n3. 如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给`setBeanName`方法\n4. 如果 bean 实现了 BeanFactoryAware 接口，Spring 将调用`setBeanFactory`方法，将 BeanFactory 容器实例传入\n5. 如果 bean 实现了 ApplicationContextAware 接口， Spring 将调用`setApplicationContext`方法，将 bean 所在的应用上下文的引用传入\n6. 如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的`postProcessBeforeInitialization`方法\n7. 如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 `afterPropertiesSet`方法。类似的，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用\n8. 如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的`postProcessAfterInitialzation`方法\n9. 此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁\n10. 如果 bean 实现了 DisposablBean 接口，Spring 将调用它的`destroy`接口方法。同样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用\n\n### 可选装配方案\n\n有三种方式向 Spring 容器描述 Bean 如何装配\n\n- 在 XML 文件中进行显示配置\n- 在 Java 代码中进行显示配置\n- 隐式的 bean 发现机制和自动装配\n\n#### 自动化装配 bean\n\nSpring 从两个角度实现自动化装配\n\n- 组件扫描（Component Scanning）：Spring 会自动发现应用上下文中所创建的 bean\n- 自动装配（Autowiring）：Spring 自动满足 bean 之间的依赖\n\n通过一个 CD 播放的 Demo 说明，XML config 文件位于`/resources`目录下，Kotlin 文件位于`java/soundsystem`目录下\n\n```kotlin\n//conpactDisc.kt\n@Component\nclass CompactDisc {\n\n    private val title = \"Sgt. Pepper's Lonely Hearts Club Band\"\n    private val artist = \"The Beatles\"\n\n    fun play() {\n        println(\"Playing $title by $artist\")\n    }\n}\n\n//CDPlayer.kt\n@Component\nclass CDPlayer @Autowired\nconstructor(private val cd: CompactDisc) {\n\n    fun play() {\n        cd.play()\n    }\n}\n\n//CDPlayerTest.kt\n@RunWith(SpringJUnit4ClassRunner::class)\n@ContextConfiguration(classes = [CDPlayerConfig::class])\nclass CDPlayerTest {\n    @Autowired\n    lateinit var player: CDPlayer\n\n    @Test\n    fun play() {\n        player.play()\n    }\n}\n```\n\n以上便是准备好的工程文件，使用`@Autowired`注解在需要自动装配的任何属性、构造器、方法上，然后在 Java 代码或者 XML 配置文件启动自动装配。不同的自动装配方式需要修改 JUnit 测试框架的`@ContextConfiguration`注解参数\n\n- XML 方式：`locations = [\"classpath:spring-config.xml\"]`\n\n- Java 方式：`classes = [CDPlayerConfig::class]`\n\n  \n\n*JUnit 测试框架需要导入依赖*\n\n接下来的一步便是启用 Spring 的组件扫描，也就是配置以上的两种注解参数之一，搭配 Bean 类注解`@Component`便可以实现组件扫描。以下两种做法都可以，第一种是使用一个`Config`类并添加注解`@Configuration`和`@ConponentScan`，第二种则是在 XML 文件中配置`context:component-scan`\n\n```kotlin\n//Java 代码\n@Configuration\n@ComponentScan\nopen class CDPlayerConfig\n```\n\n```xml\n//XML 文件\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:component-scan base-package=\"soundsystem\" />\n\n</beans>\n```\n\n运行测试，控制台成功输出\n\n```bash\nPlaying Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n```\n\n#### Java 代码装配\n\n大多数情况下都可以通过自动化装配的方式完成配置，但是当我们使用第三方的类库组件时，无法在组件类上直接添加注解，只能使用显示装配。这种情况下，使用 JavaConfig 是最好的方式。通常将 JavaConfig 放到同一个包中，并且它应该不包含任何的业务逻辑。\n\n```kotlin\n@Configuration\nopen class CDPlayerConfig {\n    \n    @Bean\n    open fun sgtPeppers(): SgtPeppers = SgtPeppers()\n    \n    @Bean\n    open fun cdPlayer(): CDPlayer = CDPlayer(sgtPeppers())\n    \n    @Bean\n    open fun anotherCDPlayer(): CDPlayer = CDPlayer(sgtPeppers())\n    \n    @Bean\n    open fun cdPlayerUseParam(compactDisc: CompactDisc): CDPlayer {\n        val cdPlayer = CDPlayer(compactDisc)\n        cdPlayer.setCompactDisc(compactDisc)\n        return cdPlayer\n    }\n}\n```\n\n在上面的代码中，配置类`CDPlayerConfig`中提供了几种装配 Bean  的方式。`sgtPeppers`方法注入了一个 SgtPeppers 实例，`cdPlayer`和`anotherCDPlayer`需要调用该方法来注入 CDPlayer 实例。Spring 会拦截所有对该方法的调用，并直接返回该方法创建的 Bean，并且默认情况下 Bean 是单例的。\n\n最后一个方法则展现了一个更具可读性、更多样化的注入方式。\n\n#### XML 代码装配\n\n最简单的 Spring XML 配置如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    \n</beans>\n```\n\n需要在配置文件顶部声明多个 XML 模式（XSD）文件，这些文件定义了配置 Spring 的 XML 元素。`<beans>`配置文件的根元素。\n\n声明一个简单的 Bean 可以通过下面的方式实现\n\n```xml\n<bean id=\"cdPlayer\" class=\"sound_system.CDPlayer\">\n\t<constructor-arg ref=\"sgtPeppers\"/>\n</bean>\n    \n<bean id=\"sgtPeppers\" class=\"sound_system.SgtPeppers\" />\n```\n\n如果没有指定 id，该 Bean 将会根据全限定类名命名：`sound_system.CDPlayer#0`，`#0`为计数形式，用以区分相同类型的其他 Bean。\n\n`&lt;constructor-arg&gt;`元素告知 Spring 要将一个 id 为`sgtPeppers`的 bean 引用传递到 CDPlayer 的构造器中。作为替代，也可以使用 Spring 的 c-命名空间，不再赘述。关于`&lt;constructor-arg&gt; `元素的更多知识：[IOC 之解析 bean 标签：constructor-arg、property 子元素](http://cmsblogs.com/?p=2754)\n\n在该元素中，可以使用`value`属性将字面量传递给构造器，使用子元素`&lt;null/&gt;`空值，使用子元素`&lt;list&gt;`传递集合。\n\nXML 配置也提供了设置属性的接口，通过元素`property`可以将对象引用、字面量、集合等注入 Bean 中。比如为 SgtPeppers 添加新的属性并对外提供修改接口\n\n```kotlin\nclass SgtPeppers: CompactDisc {\n    var title = \"Sgt. Pepper's Lonely Hearts Club Band\"\n    var artist = \"The Beatles\"\n    var tracks: MutableList<String> = ArrayList()\n    \n    override fun play() {\n        println(\"Playing $title by $artist\")\n    }\n}\n```\n\n然后在 XML 文件中注入属性设置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"sgtPeppers\" class=\"sound_system.SgtPeppers\">\n        <property name=\"title\" value=\"new title\" />\n        <property name=\"artist\" value=\"new artist\" />\n        <property name=\"tracks\">\n            <list>\n                <value>track 1</value>\n                <value>track 2</value>\n                <value>track 3</value>\n                <value>track 4</value>\n            </list>\n        </property>\n    </bean>\n\n</beans>\n```\n\n\n\n### 导入和混合配置\n\n当开发者使用自动装配的时候，Spring 会考虑容器中的所有 Bean，因此不用考虑混合配置的问题。混合配置应用在显式装配时，比如 XML 和 Java 互相引用配置的 Bean。\n\n在 JavaConfig 中使用注解`@Import`导入其他 JavaConfig，使用注解`@ImportResource`混合 XML 配置，比如\n\n```kotlin\n@Configuration\n@Import(CDPlayerConfig::class)\n@ImportResource(\"classpath:sound_system.xml\")\nopen class SoundSystemConfig \n```\n\n在 XML 中使用元素`import`导入其他 XML 文件，而如果要导入 JavaConfig，做法很简单 ：将其声明为一个 bean 即可。\n\n","slug":"Spring-学习笔记（一）：基本理念和-Bean-装配","published":1,"updated":"2019-06-01T12:16:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqyz005jy4upbhz9ytpe","content":"<p>很早就接触 Java 后端开发，不过大都浅尝辄止，并没有深刻地理解和实践，时间一长倒也跟没学过差不了多少。由于职业规划是要从 Android 开发慢慢转到后端开发，拖到现在终于是要系统学习了。学习的路线初步定为，从 Spring 出发，不断回顾 Java Web 的知识，重点在 Spring Boot 项目，通过具体的项目实践掌握相关知识。这篇文章属于第一篇学习笔记，参考手上的《Spring 实战》和网络上的技术文章，主要记录 Spring 的基本知识和理念、Bean  的装配。</p>\n<p><img src=\"https://github.com/spring-projects/spring-framework/raw/master/src/docs/asciidoc/images/spring-framework.png\" alt></p>\n<a id=\"more\"></a>\n<h2 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h2><h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><p>一个 Java EE 框架，同来替代更加重量级的企业级 Java 技术。其起源可以追溯到作者 Rod Johnson 2002年编写的《Expert One-to-One J2EE Design and Development》一书，书中他提出了一种基于普通 Java 类和依赖注入的解决方案。Rod Johnson 编写了超过30,000行基础结构代码，这便是最初的 Spring 框架。</p>\n<p>Spring 的基本理念在于：简化 Java 开发，为此采用了4种关键措施：</p>\n<ul>\n<li>基于 POJO 的轻量级和最小侵入性编程</li>\n<li>通过依赖注入和面向接口实现松耦合</li>\n<li>基于切面和惯例进行声明式编程</li>\n<li>通过切面和模板减少样板式代码</li>\n</ul>\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><p>依赖注入（Dependency Injection，简称 DI）是最常见的控制反转（Inversion of Control，简称 IoC）方式，是面向对象编程中的一种设计原则，用于减少代码之间的耦合度。系统通过引入实现 IoC 模式的容器，管理对象的声明周期、依赖关系，常用的 IoC 容器有 Spring 、JBoss、EJB 等。可以把 IoC 模式看作工厂模式的升华，区别在于该工厂要生成的对象是通过 XML 文件、配置类或者注解来配置。</p>\n<p>Java 项目大都是由众多类组成，这些类相互协作来完成特定的业务逻辑。传统的做法是每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，导致代码高度耦合。耦合具有两面性，一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且修复 Bug 的过程中容易引发更多的 Bug；另一方面，一定的耦合又是必须的——完全无耦合的代码什么也做不了。通过 DI，对象的依赖关系交由系统中负责协调各对象的第三者在创建对象时设定，依赖关系被注入到需要它们的对象中。</p>\n<p>通过一个简单的 Spring Demo 引入依赖注入的思想。</p>\n<p>项目结构如下</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">├─src</span><br><span class=\"line\">│  ├─main</span><br><span class=\"line\">│  │  ├─java</span><br><span class=\"line\">│  │  │  └─knigt</span><br><span class=\"line\">│  │  │          BraveKnight.kt</span><br><span class=\"line\">│  │  │          SlayDragonQuest.kt</span><br><span class=\"line\">│  │  │          KnightConfig.kt</span><br><span class=\"line\">│  │  │          KnightMain.kt</span><br><span class=\"line\">│  │  │</span><br><span class=\"line\">│  │  └─resources</span><br><span class=\"line\">│  │          knights.xml</span><br></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>在 IDEA 内通过以下命令生成项目文档树</p>\n<p>tree  >>    D:/tree.txt 输出文件夹<br>tree /f >>    D:/tree.txt 输出文件夹和文件</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//BraveKnight.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Knight</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span></span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BraveKnight</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> quest: Quest): Knight {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        quest.embark()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SlayDragonQuest.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Quest</span> </span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embark</span><span class=\"params\">()</span></span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SlayDragonQuest</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> stream: PrintStream): Quest {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embark</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        stream.println(<span class=\"string\">\"Embarking on quest to slay the dragon!\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//KnightConfig.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightConfig</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">knight</span><span class=\"params\">()</span></span>: Knight = BraveKnight(quest())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">quest</span><span class=\"params\">()</span></span>: Quest = SlayDragonQuest(System.<span class=\"keyword\">out</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//KnightMain.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightMain</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> {</span><br><span class=\"line\">        <span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span><<span class=\"type\">String</span>>)</span></span> {</span><br><span class=\"line\">            <span class=\"keyword\">val</span> context: AnnotationConfigApplicationContext = AnnotationConfigApplicationContext(KnightConfig::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">            <span class=\"comment\">//val context: ClassPathXmlApplicationContext = ClassPathXmlApplicationContext(\"knights.xml\")   XML 方式配置</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> knight: Knight = context.getBean(Knight::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">            knight.embarkOnQuest()</span><br><span class=\"line\">            context.close()</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>XML 的配置文件为</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">//knight.xml</span><br><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"knight\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.BraveKnight\"</span>></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"quest\"</span> /></span></span><br><span class=\"line\">  <span class=\"tag\"></<span class=\"name\">bean</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"quest\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.SlayDragonQuest\"</span>></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#{T(System).out}\"</span> /></span></span><br><span class=\"line\">  <span class=\"tag\"></<span class=\"name\">bean</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Embarking on quest to slay the dragon!</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"面向切面编程\"><a href=\"#面向切面编程\" class=\"headerlink\" title=\"面向切面编程\"></a>面向切面编程</h3><p>Aspect-Oriented Programming，AOP。DI 能够让相互协作的组件保持松耦合，而 AOP 则允许开发者把组件除自身核心功能之外，可重用的功能分离出来，比如日志、事务管理和安全等服务。AOP 思想中的相关术语包括</p>\n<ul>\n<li>Joinpoint：连接点，目标对象中所有可增强的方法</li>\n<li>Pointcut：切入点，目标对象中所有已增强的方法</li>\n<li>Advice：增强/通知，增强的代码</li>\n<li>Weaving：织入，将“通知”应用到切入点的过程</li>\n<li>Proxy：将“通知”织入到目标对象后，形成代理对象</li>\n<li>Aspect：切面，切入点+“通知”</li>\n</ul>\n<p>使用一个传唱骑士事迹的吟游诗人服务类作为一个 AOP 的应用</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Minstrel.kt</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Minstrel</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> stream: PrintStream) {</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singBeforeQuest</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        stream.println(<span class=\"string\">\"Fa la la, the knight is so brave!\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singAfterQuest</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        stream.println(<span class=\"string\">\"Tee hee hee, the brave knight did embark on a quest!\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">//knights.xml 加入以下代码</span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"minstrel\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"Minstrel\"</span>></span></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#{T(System).out}\"</span> /></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">bean</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">aop:config</span>></span></span><br><span class=\"line\">\t<span class=\"tag\"><<span class=\"name\">aop:aspect</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"minstrel\"</span>></span></span><br><span class=\"line\">\t\t<span class=\"tag\"><<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"embark\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* *.embarkOnQuest(..))\"</span> /></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\"><<span class=\"name\">aop:before</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"singBeforeQuest\"</span> /></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\"><<span class=\"name\">aop:after</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"singAfterQuest\"</span> /></span></span><br><span class=\"line\">\t<span class=\"tag\"></<span class=\"name\">aop:aspect</span>></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">aop:config</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<p><em>默认缺少 org.aspectj.aspectjweaver，可以引入 maven，添加对应的依赖</em></p>\n<p>运行之后，控制台输出结果为</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Fa la la, the knight is so brave!</span><br><span class=\"line\">Embarking on quest to slay the dragon!</span><br><span class=\"line\">Tee hee hee, the brave knight did embark on a quest!</span><br></pre></td></tr></tbody></table></figure>\n<p>不使用 BraveKnight 和 Minstrel 组合的方式而是使用 AOP，通过少量的 XML 配置，就可以把 Minstrel 声明为一个 Spring 切面，进而实现相应的功能。Minstrel 仍然只是一个 POJO，但可以被应用到任何需要它的地方，只需要修改配置文件中的 AspectJ 切点表达式语言即可。</p>\n<h2 id=\"装配-Bean\"><a href=\"#装配-Bean\" class=\"headerlink\" title=\"装配 Bean\"></a>装配 Bean</h2><h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>Spring 容器（Container）负责创建、装配和配置对象，并且管理它们的生命周期。Spring 的核心便是容器，它自带多个容器实现，可以归为两种不同的类型：Bean 工厂（由<code>org.springframework.beans.factory.BeanFactory</code>接口定义）是最简单的容器，提供基本的 DI 支持；应用上下文（由<code>org.springframework.context.ApplicationContext</code>接口定义），基于 BeanFactory 构建，并提供应用框架级别的服务，例如从属性文本解析文本信息以及发送应用事件给感兴趣的事件监听者。重点在于应用上下文上。</p>\n<p>Spring 自带多种应用上下文</p>\n<ul>\n<li>AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文</li>\n<li>AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文</li>\n<li>ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源</li>\n<li>FileSystemXmlApplicationContext：从文件系统的一个或多个 XML 配置文件中加载上下文定义</li>\n<li>XmlWebApplicationContext：从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义</li>\n</ul>\n<h3 id=\"Bean-生命周期\"><a href=\"#Bean-生命周期\" class=\"headerlink\" title=\"Bean 生命周期\"></a>Bean 生命周期</h3><p><img src=\"/Spring-学习笔记（一）：基本理念和-Bean-装配/生命周期.png\" alt></p>\n<ol>\n<li>Spring 对 bean 进行实例化</li>\n<li>Spring 将值和 bean 的引用注入到 bean 对应的属性中</li>\n<li>如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给<code>setBeanName</code>方法</li>\n<li>如果 bean 实现了 BeanFactoryAware 接口，Spring 将调用<code>setBeanFactory</code>方法，将 BeanFactory 容器实例传入</li>\n<li>如果 bean 实现了 ApplicationContextAware 接口， Spring 将调用<code>setApplicationContext</code>方法，将 bean 所在的应用上下文的引用传入</li>\n<li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的<code>postProcessBeforeInitialization</code>方法</li>\n<li>如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 <code>afterPropertiesSet</code>方法。类似的，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用</li>\n<li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的<code>postProcessAfterInitialzation</code>方法</li>\n<li>此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁</li>\n<li>如果 bean 实现了 DisposablBean 接口，Spring 将调用它的<code>destroy</code>接口方法。同样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h3 id=\"可选装配方案\"><a href=\"#可选装配方案\" class=\"headerlink\" title=\"可选装配方案\"></a>可选装配方案</h3><p>有三种方式向 Spring 容器描述 Bean 如何装配</p>\n<ul>\n<li>在 XML 文件中进行显示配置</li>\n<li>在 Java 代码中进行显示配置</li>\n<li>隐式的 bean 发现机制和自动装配</li>\n</ul>\n<h4 id=\"自动化装配-bean\"><a href=\"#自动化装配-bean\" class=\"headerlink\" title=\"自动化装配 bean\"></a>自动化装配 bean</h4><p>Spring 从两个角度实现自动化装配</p>\n<ul>\n<li>组件扫描（Component Scanning）：Spring 会自动发现应用上下文中所创建的 bean</li>\n<li>自动装配（Autowiring）：Spring 自动满足 bean 之间的依赖</li>\n</ul>\n<p>通过一个 CD 播放的 Demo 说明，XML config 文件位于<code>/resources</code>目录下，Kotlin 文件位于<code>java/soundsystem</code>目录下</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//conpactDisc.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompactDisc</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> artist = <span class=\"string\">\"The Beatles\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Playing <span class=\"variable\">$title</span> by <span class=\"variable\">$artist</span>\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CDPlayer.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayer</span> <span class=\"meta\">@Autowired</span></span></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cd: CompactDisc) {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        cd.play()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CDPlayerTest.kt</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [CDPlayerConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>{</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> player: CDPlayer</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        player.play()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>以上便是准备好的工程文件，使用<code>@Autowired</code>注解在需要自动装配的任何属性、构造器、方法上，然后在 Java 代码或者 XML 配置文件启动自动装配。不同的自动装配方式需要修改 JUnit 测试框架的<code>@ContextConfiguration</code>注解参数</p>\n<ul>\n<li><p>XML 方式：<code>locations = [\"classpath:spring-config.xml\"]</code></p>\n</li>\n<li><p>Java 方式：<code>classes = [CDPlayerConfig::class]</code></p>\n</li>\n</ul>\n<p><em>JUnit 测试框架需要导入依赖</em></p>\n<p>接下来的一步便是启用 Spring 的组件扫描，也就是配置以上的两种注解参数之一，搭配 Bean 类注解<code>@Component</code>便可以实现组件扫描。以下两种做法都可以，第一种是使用一个<code>Config</code>类并添加注解<code>@Configuration</code>和<code>@ConponentScan</code>，第二种则是在 XML 文件中配置<code>context:component-scan</code></p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Java 代码</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span></span></span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">//XML 文件</span><br><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"soundsystem\"</span> /></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<p>运行测试，控制台成功输出</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Playing Sgt. Pepper<span class=\"string\">'s Lonely Hearts Club Band by The Beatles</span></span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"Java-代码装配\"><a href=\"#Java-代码装配\" class=\"headerlink\" title=\"Java 代码装配\"></a>Java 代码装配</h4><p>大多数情况下都可以通过自动化装配的方式完成配置，但是当我们使用第三方的类库组件时，无法在组件类上直接添加注解，只能使用显示装配。这种情况下，使用 JavaConfig 是最好的方式。通常将 JavaConfig 放到同一个包中，并且它应该不包含任何的业务逻辑。</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">sgtPeppers</span><span class=\"params\">()</span></span>: SgtPeppers = SgtPeppers()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cdPlayer</span><span class=\"params\">()</span></span>: CDPlayer = CDPlayer(sgtPeppers())</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">anotherCDPlayer</span><span class=\"params\">()</span></span>: CDPlayer = CDPlayer(sgtPeppers())</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cdPlayerUseParam</span><span class=\"params\">(compactDisc: <span class=\"type\">CompactDisc</span>)</span></span>: CDPlayer {</span><br><span class=\"line\">        <span class=\"keyword\">val</span> cdPlayer = CDPlayer(compactDisc)</span><br><span class=\"line\">        cdPlayer.setCompactDisc(compactDisc)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cdPlayer</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>在上面的代码中，配置类<code>CDPlayerConfig</code>中提供了几种装配 Bean  的方式。<code>sgtPeppers</code>方法注入了一个 SgtPeppers 实例，<code>cdPlayer</code>和<code>anotherCDPlayer</code>需要调用该方法来注入 CDPlayer 实例。Spring 会拦截所有对该方法的调用，并直接返回该方法创建的 Bean，并且默认情况下 Bean 是单例的。</p>\n<p>最后一个方法则展现了一个更具可读性、更多样化的注入方式。</p>\n<h4 id=\"XML-代码装配\"><a href=\"#XML-代码装配\" class=\"headerlink\" title=\"XML 代码装配\"></a>XML 代码装配</h4><p>最简单的 Spring XML 配置如下</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<p>需要在配置文件顶部声明多个 XML 模式（XSD）文件，这些文件定义了配置 Spring 的 XML 元素。<code><beans></code>配置文件的根元素。</p>\n<p>声明一个简单的 Bean 可以通过下面的方式实现</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cdPlayer\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.CDPlayer\"</span>></span></span><br><span class=\"line\">\t<span class=\"tag\"><<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sgtPeppers\"</span>/></span></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">bean</span>></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sgtPeppers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.SgtPeppers\"</span> /></span></span><br></pre></td></tr></tbody></table></figure>\n<p>如果没有指定 id，该 Bean 将会根据全限定类名命名：<code>sound_system.CDPlayer#0</code>，<code>#0</code>为计数形式，用以区分相同类型的其他 Bean。</p>\n<p><code>&lt;constructor-arg&gt;</code>元素告知 Spring 要将一个 id 为<code>sgtPeppers</code>的 bean 引用传递到 CDPlayer 的构造器中。作为替代，也可以使用 Spring 的 c-命名空间，不再赘述。关于<code>&lt;constructor-arg&gt;</code>元素的更多知识：<a href=\"http://cmsblogs.com/?p=2754\" target=\"_blank\" rel=\"noopener\">IOC 之解析 bean 标签：constructor-arg、property 子元素</a></p>\n<p>在该元素中，可以使用<code>value</code>属性将字面量传递给构造器，使用子元素<code>&lt;null/&gt;</code>空值，使用子元素<code>&lt;list&gt;</code>传递集合。</p>\n<p>XML 配置也提供了设置属性的接口，通过元素<code>property</code>可以将对象引用、字面量、集合等注入 Bean 中。比如为 SgtPeppers 添加新的属性并对外提供修改接口</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc {</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> artist = <span class=\"string\">\"The Beatles\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tracks: MutableList<String> = ArrayList()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        println(<span class=\"string\">\"Playing <span class=\"variable\">$title</span> by <span class=\"variable\">$artist</span>\"</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>然后在 XML 文件中注入属性设置</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><?xml version=\"1.0\" encoding=\"UTF-8\"?></span></span><br><span class=\"line\"><span class=\"tag\"><<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\"><<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sgtPeppers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.SgtPeppers\"</span>></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"title\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"new title\"</span> /></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"artist\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"new artist\"</span> /></span></span><br><span class=\"line\">        <span class=\"tag\"><<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"tracks\"</span>></span></span><br><span class=\"line\">            <span class=\"tag\"><<span class=\"name\">list</span>></span></span><br><span class=\"line\">                <span class=\"tag\"><<span class=\"name\">value</span>></span>track 1<span class=\"tag\"></<span class=\"name\">value</span>></span></span><br><span class=\"line\">                <span class=\"tag\"><<span class=\"name\">value</span>></span>track 2<span class=\"tag\"></<span class=\"name\">value</span>></span></span><br><span class=\"line\">                <span class=\"tag\"><<span class=\"name\">value</span>></span>track 3<span class=\"tag\"></<span class=\"name\">value</span>></span></span><br><span class=\"line\">                <span class=\"tag\"><<span class=\"name\">value</span>></span>track 4<span class=\"tag\"></<span class=\"name\">value</span>></span></span><br><span class=\"line\">            <span class=\"tag\"></<span class=\"name\">list</span>></span></span><br><span class=\"line\">        <span class=\"tag\"></<span class=\"name\">property</span>></span></span><br><span class=\"line\">    <span class=\"tag\"></<span class=\"name\">bean</span>></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\"></<span class=\"name\">beans</span>></span></span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"导入和混合配置\"><a href=\"#导入和混合配置\" class=\"headerlink\" title=\"导入和混合配置\"></a>导入和混合配置</h3><p>当开发者使用自动装配的时候，Spring 会考虑容器中的所有 Bean，因此不用考虑混合配置的问题。混合配置应用在显式装配时，比如 XML 和 Java 互相引用配置的 Bean。</p>\n<p>在 JavaConfig 中使用注解<code>@Import</code>导入其他 JavaConfig，使用注解<code>@ImportResource</code>混合 XML 配置，比如</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(CDPlayerConfig::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource(<span class=\"meta-string\">\"classpath:sound_system.xml\"</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoundSystemConfig</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>在 XML 中使用元素<code>import</code>导入其他 XML 文件，而如果要导入 JavaConfig，做法很简单 ：将其声明为一个 bean 即可。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":11425,"excerpt":"<p>很早就接触 Java 后端开发，不过大都浅尝辄止，并没有深刻地理解和实践，时间一长倒也跟没学过差不了多少。由于职业规划是要从 Android 开发慢慢转到后端开发，拖到现在终于是要系统学习了。学习的路线初步定为，从 Spring 出发，不断回顾 Java Web 的知识，重点在 Spring Boot 项目，通过具体的项目实践掌握相关知识。这篇文章属于第一篇学习笔记，参考手上的《Spring 实战》和网络上的技术文章，主要记录 Spring 的基本知识和理念、Bean  的装配。</p>\n<p><img src=\"https://github.com/spring-projects/spring-framework/raw/master/src/docs/asciidoc/images/spring-framework.png\" alt></p>","more":"<h2 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h2><h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><p>一个 Java EE 框架，同来替代更加重量级的企业级 Java 技术。其起源可以追溯到作者 Rod Johnson 2002年编写的《Expert One-to-One J2EE Design and Development》一书，书中他提出了一种基于普通 Java 类和依赖注入的解决方案。Rod Johnson 编写了超过30,000行基础结构代码，这便是最初的 Spring 框架。</p>\n<p>Spring 的基本理念在于：简化 Java 开发，为此采用了4种关键措施：</p>\n<ul>\n<li>基于 POJO 的轻量级和最小侵入性编程</li>\n<li>通过依赖注入和面向接口实现松耦合</li>\n<li>基于切面和惯例进行声明式编程</li>\n<li>通过切面和模板减少样板式代码</li>\n</ul>\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><p>依赖注入（Dependency Injection，简称 DI）是最常见的控制反转（Inversion of Control，简称 IoC）方式，是面向对象编程中的一种设计原则，用于减少代码之间的耦合度。系统通过引入实现 IoC 模式的容器，管理对象的声明周期、依赖关系，常用的 IoC 容器有 Spring 、JBoss、EJB 等。可以把 IoC 模式看作工厂模式的升华，区别在于该工厂要生成的对象是通过 XML 文件、配置类或者注解来配置。</p>\n<p>Java 项目大都是由众多类组成，这些类相互协作来完成特定的业务逻辑。传统的做法是每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，导致代码高度耦合。耦合具有两面性，一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且修复 Bug 的过程中容易引发更多的 Bug；另一方面，一定的耦合又是必须的——完全无耦合的代码什么也做不了。通过 DI，对象的依赖关系交由系统中负责协调各对象的第三者在创建对象时设定，依赖关系被注入到需要它们的对象中。</p>\n<p>通过一个简单的 Spring Demo 引入依赖注入的思想。</p>\n<p>项目结构如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">├─src</span><br><span class=\"line\">│  ├─main</span><br><span class=\"line\">│  │  ├─java</span><br><span class=\"line\">│  │  │  └─knigt</span><br><span class=\"line\">│  │  │          BraveKnight.kt</span><br><span class=\"line\">│  │  │          SlayDragonQuest.kt</span><br><span class=\"line\">│  │  │          KnightConfig.kt</span><br><span class=\"line\">│  │  │          KnightMain.kt</span><br><span class=\"line\">│  │  │</span><br><span class=\"line\">│  │  └─resources</span><br><span class=\"line\">│  │          knights.xml</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在 IDEA 内通过以下命令生成项目文档树</p>\n<p>tree  &gt;&gt;    D:/tree.txt 输出文件夹<br>tree /f &gt;&gt;    D:/tree.txt 输出文件夹和文件</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//BraveKnight.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Knight</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BraveKnight</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> quest: Quest): Knight &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        quest.embark()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SlayDragonQuest.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Quest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embark</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SlayDragonQuest</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> stream: PrintStream): Quest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">embark</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        stream.println(<span class=\"string\">\"Embarking on quest to slay the dragon!\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//KnightConfig.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">knight</span><span class=\"params\">()</span></span>: Knight = BraveKnight(quest())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">quest</span><span class=\"params\">()</span></span>: Quest = SlayDragonQuest(System.<span class=\"keyword\">out</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//KnightMain.kt</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightMain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> context: AnnotationConfigApplicationContext = AnnotationConfigApplicationContext(KnightConfig::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">            <span class=\"comment\">//val context: ClassPathXmlApplicationContext = ClassPathXmlApplicationContext(\"knights.xml\")   XML 方式配置</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> knight: Knight = context.getBean(Knight::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">            knight.embarkOnQuest()</span><br><span class=\"line\">            context.close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>XML 的配置文件为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">//knight.xml</span><br><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"knight\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.BraveKnight\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"quest\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"quest\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.SlayDragonQuest\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Embarking on quest to slay the dragon!</span><br></pre></td></tr></table></figure>\n<h3 id=\"面向切面编程\"><a href=\"#面向切面编程\" class=\"headerlink\" title=\"面向切面编程\"></a>面向切面编程</h3><p>Aspect-Oriented Programming，AOP。DI 能够让相互协作的组件保持松耦合，而 AOP 则允许开发者把组件除自身核心功能之外，可重用的功能分离出来，比如日志、事务管理和安全等服务。AOP 思想中的相关术语包括</p>\n<ul>\n<li>Joinpoint：连接点，目标对象中所有可增强的方法</li>\n<li>Pointcut：切入点，目标对象中所有已增强的方法</li>\n<li>Advice：增强/通知，增强的代码</li>\n<li>Weaving：织入，将“通知”应用到切入点的过程</li>\n<li>Proxy：将“通知”织入到目标对象后，形成代理对象</li>\n<li>Aspect：切面，切入点+“通知”</li>\n</ul>\n<p>使用一个传唱骑士事迹的吟游诗人服务类作为一个 AOP 的应用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Minstrel.kt</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Minstrel</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> stream: PrintStream) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singBeforeQuest</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        stream.println(<span class=\"string\">\"Fa la la, the knight is so brave!\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">singAfterQuest</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        stream.println(<span class=\"string\">\"Tee hee hee, the brave knight did embark on a quest!\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">//knights.xml 加入以下代码</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"minstrel\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"Minstrel\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">aop:aspect</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"minstrel\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"embark\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* *.embarkOnQuest(..))\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:before</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"singBeforeQuest\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:after</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"singAfterQuest\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">aop:aspect</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>默认缺少 org.aspectj.aspectjweaver，可以引入 maven，添加对应的依赖</em></p>\n<p>运行之后，控制台输出结果为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Fa la la, the knight is so brave!</span><br><span class=\"line\">Embarking on quest to slay the dragon!</span><br><span class=\"line\">Tee hee hee, the brave knight did embark on a quest!</span><br></pre></td></tr></table></figure>\n<p>不使用 BraveKnight 和 Minstrel 组合的方式而是使用 AOP，通过少量的 XML 配置，就可以把 Minstrel 声明为一个 Spring 切面，进而实现相应的功能。Minstrel 仍然只是一个 POJO，但可以被应用到任何需要它的地方，只需要修改配置文件中的 AspectJ 切点表达式语言即可。</p>\n<h2 id=\"装配-Bean\"><a href=\"#装配-Bean\" class=\"headerlink\" title=\"装配 Bean\"></a>装配 Bean</h2><h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>Spring 容器（Container）负责创建、装配和配置对象，并且管理它们的生命周期。Spring 的核心便是容器，它自带多个容器实现，可以归为两种不同的类型：Bean 工厂（由<code>org.springframework.beans.factory.BeanFactory</code>接口定义）是最简单的容器，提供基本的 DI 支持；应用上下文（由<code>org.springframework.context.ApplicationContext</code>接口定义），基于 BeanFactory 构建，并提供应用框架级别的服务，例如从属性文本解析文本信息以及发送应用事件给感兴趣的事件监听者。重点在于应用上下文上。</p>\n<p>Spring 自带多种应用上下文</p>\n<ul>\n<li>AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文</li>\n<li>AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文</li>\n<li>ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源</li>\n<li>FileSystemXmlApplicationContext：从文件系统的一个或多个 XML 配置文件中加载上下文定义</li>\n<li>XmlWebApplicationContext：从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义</li>\n</ul>\n<h3 id=\"Bean-生命周期\"><a href=\"#Bean-生命周期\" class=\"headerlink\" title=\"Bean 生命周期\"></a>Bean 生命周期</h3><p><img src=\"/Spring-学习笔记（一）：基本理念和-Bean-装配/生命周期.png\" alt=\"\"></p>\n<ol>\n<li>Spring 对 bean 进行实例化</li>\n<li>Spring 将值和 bean 的引用注入到 bean 对应的属性中</li>\n<li>如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给<code>setBeanName</code>方法</li>\n<li>如果 bean 实现了 BeanFactoryAware 接口，Spring 将调用<code>setBeanFactory</code>方法，将 BeanFactory 容器实例传入</li>\n<li>如果 bean 实现了 ApplicationContextAware 接口， Spring 将调用<code>setApplicationContext</code>方法，将 bean 所在的应用上下文的引用传入</li>\n<li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的<code>postProcessBeforeInitialization</code>方法</li>\n<li>如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 <code>afterPropertiesSet</code>方法。类似的，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用</li>\n<li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的<code>postProcessAfterInitialzation</code>方法</li>\n<li>此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁</li>\n<li>如果 bean 实现了 DisposablBean 接口，Spring 将调用它的<code>destroy</code>接口方法。同样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h3 id=\"可选装配方案\"><a href=\"#可选装配方案\" class=\"headerlink\" title=\"可选装配方案\"></a>可选装配方案</h3><p>有三种方式向 Spring 容器描述 Bean 如何装配</p>\n<ul>\n<li>在 XML 文件中进行显示配置</li>\n<li>在 Java 代码中进行显示配置</li>\n<li>隐式的 bean 发现机制和自动装配</li>\n</ul>\n<h4 id=\"自动化装配-bean\"><a href=\"#自动化装配-bean\" class=\"headerlink\" title=\"自动化装配 bean\"></a>自动化装配 bean</h4><p>Spring 从两个角度实现自动化装配</p>\n<ul>\n<li>组件扫描（Component Scanning）：Spring 会自动发现应用上下文中所创建的 bean</li>\n<li>自动装配（Autowiring）：Spring 自动满足 bean 之间的依赖</li>\n</ul>\n<p>通过一个 CD 播放的 Demo 说明，XML config 文件位于<code>/resources</code>目录下，Kotlin 文件位于<code>java/soundsystem</code>目录下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//conpactDisc.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompactDisc</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> artist = <span class=\"string\">\"The Beatles\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Playing <span class=\"variable\">$title</span> by <span class=\"variable\">$artist</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CDPlayer.kt</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayer</span> <span class=\"meta\">@Autowired</span></span></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> cd: CompactDisc) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        cd.play()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CDPlayerTest.kt</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = [CDPlayerConfig::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> player: CDPlayer</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        player.play()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上便是准备好的工程文件，使用<code>@Autowired</code>注解在需要自动装配的任何属性、构造器、方法上，然后在 Java 代码或者 XML 配置文件启动自动装配。不同的自动装配方式需要修改 JUnit 测试框架的<code>@ContextConfiguration</code>注解参数</p>\n<ul>\n<li><p>XML 方式：<code>locations = [&quot;classpath:spring-config.xml&quot;]</code></p>\n</li>\n<li><p>Java 方式：<code>classes = [CDPlayerConfig::class]</code></p>\n</li>\n</ul>\n<p><em>JUnit 测试框架需要导入依赖</em></p>\n<p>接下来的一步便是启用 Spring 的组件扫描，也就是配置以上的两种注解参数之一，搭配 Bean 类注解<code>@Component</code>便可以实现组件扫描。以下两种做法都可以，第一种是使用一个<code>Config</code>类并添加注解<code>@Configuration</code>和<code>@ConponentScan</code>，第二种则是在 XML 文件中配置<code>context:component-scan</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Java 代码</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">//XML 文件</span><br><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"soundsystem\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行测试，控制台成功输出</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Playing Sgt. Pepper<span class=\"string\">'s Lonely Hearts Club Band by The Beatles</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Java-代码装配\"><a href=\"#Java-代码装配\" class=\"headerlink\" title=\"Java 代码装配\"></a>Java 代码装配</h4><p>大多数情况下都可以通过自动化装配的方式完成配置，但是当我们使用第三方的类库组件时，无法在组件类上直接添加注解，只能使用显示装配。这种情况下，使用 JavaConfig 是最好的方式。通常将 JavaConfig 放到同一个包中，并且它应该不包含任何的业务逻辑。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">sgtPeppers</span><span class=\"params\">()</span></span>: SgtPeppers = SgtPeppers()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cdPlayer</span><span class=\"params\">()</span></span>: CDPlayer = CDPlayer(sgtPeppers())</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">anotherCDPlayer</span><span class=\"params\">()</span></span>: CDPlayer = CDPlayer(sgtPeppers())</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cdPlayerUseParam</span><span class=\"params\">(compactDisc: <span class=\"type\">CompactDisc</span>)</span></span>: CDPlayer &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> cdPlayer = CDPlayer(compactDisc)</span><br><span class=\"line\">        cdPlayer.setCompactDisc(compactDisc)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cdPlayer</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，配置类<code>CDPlayerConfig</code>中提供了几种装配 Bean  的方式。<code>sgtPeppers</code>方法注入了一个 SgtPeppers 实例，<code>cdPlayer</code>和<code>anotherCDPlayer</code>需要调用该方法来注入 CDPlayer 实例。Spring 会拦截所有对该方法的调用，并直接返回该方法创建的 Bean，并且默认情况下 Bean 是单例的。</p>\n<p>最后一个方法则展现了一个更具可读性、更多样化的注入方式。</p>\n<h4 id=\"XML-代码装配\"><a href=\"#XML-代码装配\" class=\"headerlink\" title=\"XML 代码装配\"></a>XML 代码装配</h4><p>最简单的 Spring XML 配置如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>需要在配置文件顶部声明多个 XML 模式（XSD）文件，这些文件定义了配置 Spring 的 XML 元素。<code>&lt;beans&gt;</code>配置文件的根元素。</p>\n<p>声明一个简单的 Bean 可以通过下面的方式实现</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cdPlayer\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.CDPlayer\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sgtPeppers\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sgtPeppers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.SgtPeppers\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果没有指定 id，该 Bean 将会根据全限定类名命名：<code>sound_system.CDPlayer#0</code>，<code>#0</code>为计数形式，用以区分相同类型的其他 Bean。</p>\n<p><code>&amp;lt;constructor-arg&amp;gt;</code>元素告知 Spring 要将一个 id 为<code>sgtPeppers</code>的 bean 引用传递到 CDPlayer 的构造器中。作为替代，也可以使用 Spring 的 c-命名空间，不再赘述。关于<code>&amp;lt;constructor-arg&amp;gt;</code>元素的更多知识：<a href=\"http://cmsblogs.com/?p=2754\" target=\"_blank\" rel=\"noopener\">IOC 之解析 bean 标签：constructor-arg、property 子元素</a></p>\n<p>在该元素中，可以使用<code>value</code>属性将字面量传递给构造器，使用子元素<code>&amp;lt;null/&amp;gt;</code>空值，使用子元素<code>&amp;lt;list&amp;gt;</code>传递集合。</p>\n<p>XML 配置也提供了设置属性的接口，通过元素<code>property</code>可以将对象引用、字面量、集合等注入 Bean 中。比如为 SgtPeppers 添加新的属性并对外提供修改接口</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span>: <span class=\"type\">CompactDisc &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> artist = <span class=\"string\">\"The Beatles\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tracks: MutableList&lt;String&gt; = ArrayList()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">\"Playing <span class=\"variable\">$title</span> by <span class=\"variable\">$artist</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 XML 文件中注入属性设置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sgtPeppers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sound_system.SgtPeppers\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"title\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"new title\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"artist\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"new artist\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"tracks\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>track 1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>track 2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>track 3<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>track 4<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"导入和混合配置\"><a href=\"#导入和混合配置\" class=\"headerlink\" title=\"导入和混合配置\"></a>导入和混合配置</h3><p>当开发者使用自动装配的时候，Spring 会考虑容器中的所有 Bean，因此不用考虑混合配置的问题。混合配置应用在显式装配时，比如 XML 和 Java 互相引用配置的 Bean。</p>\n<p>在 JavaConfig 中使用注解<code>@Import</code>导入其他 JavaConfig，使用注解<code>@ImportResource</code>混合 XML 配置，比如</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(CDPlayerConfig::class)</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource(<span class=\"meta-string\">\"classpath:sound_system.xml\"</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoundSystemConfig</span></span></span><br></pre></td></tr></table></figure>\n<p>在 XML 中使用元素<code>import</code>导入其他 XML 文件，而如果要导入 JavaConfig，做法很简单 ：将其声明为一个 bean 即可。</p>"},{"title":"《剑指offer》题目 Java 实现","date":"2019-03-18T02:42:29.000Z","_content":"\n### Problem1：单例模式实现\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n<!--more-->\n### Problem2：二维数组中的查找\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n```java\n    /**\n     * 从二维数组的右上角开始选取与 key 比较的整数\n     * column 的变化:arr[0].length - 1 ---> 0\n     * row 的变化 0 ---> arr.length\n     *\n     * @param arr \n     * @param key \n     */\npublic static boolean find(int[][] arr, int key) {\n    int col = arr[0].length - 1;\n    int row = 0;\n    while (col >= 0 && row < arr.length) {\n        if (arr[row][col] == key) {\n            return true;\n        } else if (arr[row][col] > key) {   //大于查找值，则往前推一列\n            col--;\n        } else {    //小于查找值，则往下推一行\n            row++;\n        }\n    }\n    return false;\n}\n```\n\n\n\n### Problem3：替换空格\n\n请实现一个函数，将字符串的每个空格替换为\"%20\"。例如输入`We are happy`，则输出`We%20are%20happy`。\n\n```java\n    /**\n     * 使用 StringBuilder\n     * \n     * @param str\n     * @return\n     */\n    public static String replace(String str) {\n        if (str.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == ' ') {\n                builder.append(\"%20\");\n            } else {\n                builder.append(str.charAt(i));\n            }\n        }\n        return builder.toString();\n    }\n```\n\n\n\n### Problem4：从尾到头打印链表\n\n输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值\n\n```java\nstatic class ListNode<T> {\n    T value;\n    ListNode next;\n\n    public ListNode(T value) {\n        this.value = value;\n    }\n}\n\n/**\n * 使用栈实现\n *\n * @param headNode\n */\npublic static void printListReverse(ListNode headNode) {\n    Stack<ListNode> stack = new Stack<>();\n    while (headNode != null) {\n        stack.push(headNode);\n        headNode = headNode.next;\n    }\n    while (!stack.empty()) {\n        System.out.println(stack.pop().value + \" \");\n    }\n}\n\npublic static void main(String[] args) {\n    ListNode<Integer> node = new ListNode<>(1);\n    node.next = new ListNode<>(2);\n    node.next.next = new ListNode<>(3);\n    printListReverse(node);\n}\n```\n\n\n\n### Problem5：重建二叉树\n\n输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。\n\n假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。\n\n例如输入前序遍历序列： `{1, 2, 4, 7, 3, 5, 6, 8}`\n\n中序遍历序列：`{4, 7, 2, 1, 5, 3, 8, 6}`\n\n重建出所示二叉树并且输出它的头结点。\n\n```java\n                     1\n                   /   \\\n                  2     3\n                 /     / \\\n                4     5   6\n                 \\        /\n                 7        8\n```\n\n#### 知识点补充\n\n> 前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）\n>\n> 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）\n>\n> 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）\n\n> 二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。\n>\n> 二叉树的特例是**堆**和**红黑树**。\n>\n> 堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。\n>\n> 红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。\n\n### Problem6：用两个栈实现队列\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数\n`appendTail`和`deleteHead`,分别完成在队列尾部插入结点和在队列头部删除结点的功能\n```Java\npublic class ConstructQueue {\n    /*\n     s1 用来实现放入新的元素，直接放到栈顶\n     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2\n     然后删除底部元素，再将 s2 元素移回 s1\n     */\n    Stack<String> stack1 = new Stack<>();\n    Stack<String> stack2 = new Stack<>();\n\n    // 实现appendTail函数\n    public void appendTail(String s) {\n        stack1.push(s);\n    }\n\n    // 实现deleteHead函数\n    public String deleteHead() {\n        while (!stack1.empty()) {\n            stack2.push(stack1.pop());\n        }\n        String head = stack2.pop();\n        while (!stack2.empty()) {\n            stack1.push(stack2.pop());\n        }\n        return head;\n    }\n\n    public static void main(String[] args) {\n        ConstructQueue queue = new ConstructQueue();\n        queue.appendTail(\"a\");\n        queue.appendTail(\"b\");\n        queue.appendTail(\"c\");\n        queue.appendTail(\"d\");\n        System.out.println(queue.deleteHead());\n        System.out.println(queue.deleteHead());\n    }\n}\n```\n输出如下\n```\na\nb\n```\n### Problem7：旋转数组的最小数字\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。\n例如数组 `{3, 4, 5, 1, 2}`为`{1, 2, 3, 4, 5}`的一个旋转，该数组的最小值为 1;\n\n```Java\npublic static void main(String[] args) {\n    int[] a = {3, 4, 5, 1, 2};\n    System.out.println(minNumInRotateArray(a));\n}\n\n/**\n     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。\n     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。\n     *\n     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。\n     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，\n     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。\n     * 同理第二个指针的范围也将逐渐缩小\n     *\n     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。\n     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，\n     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。\n     * \n     * @param array\n     */\npublic static int minNumInRotateArray(int[] array) {\n    if (array == null) {\n        return 0;\n    }\n    int left = 0;\n    int right = array.length - 1;\n    int mid = 0;\n    while (array[left] >= array[right]) {\n        if (right - left == 1) {\n            mid = right;\n            break;\n        }\n        mid = (left + right) / 2;\n\n        // 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组\n        if (array[left] == array[right] && array[right] == array[mid]) {\n            return findInOrder(array, left, right);\n        }\n        \n        if (array[left] <= array[mid]) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    return array[mid];\n}\n\nstatic int findInOrder(int[] array, int left, int right) {\n    int k = array[left];\n    for (int i = 0; i < right; i++) {\n        if (array[i] < k) {\n            k = array[i];\n        }\n    }\n    return k;\n}\n```\n\n### Problem8：斐波那契数列\n写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： \n> n=0, f(n)=0;\n> n=1, f(n)=1; \n> n>1, f(n) = f(n-1) + f(n-2).\n\n```Java\npublic static void main(String[] args) {\n    for (int i = 0; i < 11; i++) {\n        System.out.print(fibonacci(i) + \" \");\n    }\n}\n\npublic static int fibonacci(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n```\n输出结果\n```\n0 1 1 2 3 5 8 13 21 34 55 \n```\n### Problem9：二进制中1的个数\n请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。\n\n例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。\n\n```\npublic static int oneCountsOfBinary(int i) {\n    char[] chars = Integer.toBinaryString(i).toCharArray();\n    int count = 0;\n    for (char c : chars) {\n        if (c == '1') {\n            count++;\n        }\n    }\n    return count;\n}\n\npublic static int _oneCountsOfBinary(int i) {\n    int count = 0;\n    int flag = 1;\n    while (flag != 0) {\n        if ((i & flag) != 0) {\n            count++;\n        }\n        flag = flag << 1;\n    }\n    return count;\n}\n```\n\n### Problem10：数值的整数次方\n 实现函数`double power(double base, int exponent)`，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。 \n```Java\npublic static double power(double base, int exponent) {\n    if (base <= 0) {\n        throw new RuntimeException(\"运算无意义\");\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if (exponent < 0) {\n        return 1 / powerUnsigned(base, -exponent);\n    } else {\n        return powerUnsigned(base, exponent);\n    }\n}\n\nstatic double powerUnsigned(double base, int exponent) {\n    double result = base;\n    for (int i = 1; i < exponent; i++) {\n        result = result * base;\n    }\n    return result;\n}\n```\n\n### Problem11：O（1）时间删除链表结点\n给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。\n```Java\nstatic class Node {\n    int value;\n    Node next;\n\n    public Node(int value) {\n        this.value = value;\n    }\n}\n\n/**\n * 只有一个节点时，直接置空\n * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null\n * 否则 p->next 的值赋值给p，把p->next删除掉\n *\n * @param head\n * @param delNode\n */\npublic static void deleteNode(Node head, Node delNode) {\n    if (head == null || delNode == null) {\n        return;\n    }\n    if (head == delNode) {\n        head = null;\n        return;\n    }\n    if (delNode.next == null) {\n        Node temp = head;\n        while (temp.next != delNode) {\n            temp = temp.next;\n        }\n        temp.next = null;\n        return;\n    }\n    delNode.value = delNode.next.value;\n    delNode.next = delNode.next.next;\n}\n```\n### Problem12：调整数组中奇数和偶数的先后顺序\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;\n```Java\npublic static void orderArray(int[] array) {\n    int left = 0;\n    int right = array.length - 1;\n    while (left < right) {\n        while (left < right && !isEven(array[left])) {\n            left ++;\n        }\n        while (left < right && isEven(array[right])) {\n            right --;\n        }\n        if (left < right) {\n            int temp = array[left];\n            array[left] = array[right];\n            array[right] = temp;\n        }\n    }\n}\n\nstatic boolean isEven(int i) {\n    return ((i & 1) == 0);\n}\n```\n\n### Problem13：链表中倒数第K个结点\n输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。\n\n例如一个链表有6个结点，从头结点开始它们的值依次是`1、2、3、4、5、6`。这个链表的倒数第三个结点是值为4的结点。\n\n```Java\n    /**\n     * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动\n     * 从第k步开始，第二个指针也开始从链表的头指针开始遍历\n     * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上\n     * \n     * @param head 头结点\n     * @param k 倒数第k个节点\n     */\n    public static int find(ListNode head, int k){\n        if (head == null) {\n            return 0;\n        }\n        ListNode first = head;\n        ListNode second = head;\n        for (int i = 1; i < k; i++) {\n            if (first.next != null) {\n                first = first.next;\n            } else {\n                return 0;\n            }\n        }\n        System.out.println(first.val);\n        while (first.next != null) {\n            first = first.next;\n            second = second.next;\n        }\n        System.out.println(first.val);\n        return second.val;\n    }\n\n    static class ListNode {\n        int val;\n        ListNode next;\n\n        public ListNode(int val) {\n            this.val = val;\n        }\n    }\n```\n### Problem14：翻转链表\n定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点\n\n\n\n![](《剑指offer》题目-Java-实现/翻转链表.png)\n\n```Java\n    /**\n     * 翻转单链表\n     * \n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode getReversedListHead(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        //current节点是head的下一个节点\n        ListNode current = head.next;\n        //当前的head变为链表的尾，所以next为空\n        head.next = null;\n        \n        while (current != null) {\n            //currentNext节点是current的下一个节点。\n            ListNode currentNext = current.next;\n            //current.next反方向指向以前的节点\n            current.next = head;\n            \n            //移动head和current指针，到后面head重新成为头节点\n            head = current;\n            current = currentNext;\n        }\n        return head;\n    }\n\n    /**\n     * 翻转单链表的递归实现\n     *\n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode reverseListByRecursion(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newList = reverseListByRecursion(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newList;\n    }\n```\n\n### Problem15：合并两个排序的链表\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。\n\n```java\n    public static ListNode merge(ListNode n1, ListNode n2) {\n        if (n1 == null) {\n            return n2;\n        }\n        if (n2 == null) {\n            return n1;\n        }\n        ListNode mergeNode = null;\n        if (n1.val < n2.val) {\n            mergeNode = n1;\n            mergeNode.next = merge(n1.next, n2);\n        } else {\n            mergeNode = n2;\n            mergeNode.next = merge(n1, n2.next);\n        }\n        return mergeNode;\n    }\n```\n\n\n\n### Problem16：树的子结构判断\n\n\n\n### Problem17：二叉树的镜像\n\n### Problem18：顺时针打印矩阵\n\n### Problem19：包含min函数的栈\n\n### Problem20：栈的压入、弹出序列\n\n### Problem21：从上往下打印二叉树\n\n### Problem22：二叉搜索树的后序遍历\n\n### Problem23：二叉树中和为某一值的路径\n\n### Problem24：字符串的排列\n\n### Problem25：数组中出现次数超过一半的数字\n\n### Problem26：连续子数组的最大和\n\n### Problem27：整数中1出现的次数\n\n### Problem28：把数组排成最小的数\n\n### Problem29：丑数\n\n### Problem30：第一个只出现一次的字符\n\n### Problem31：数组中的逆序对\n\n### Problem32：两个链表的第一个公共节点\n\n### Problem33：二叉树的深度&&平衡二叉树判断\n\n### Problem34：数字在排序数组中出现的次数\n\n### Problem35：数组中只出现一次的数字\n\n### Problem36：和为S的两个数字 \n\n### Problem37：和为S的连续正数序列\n\n### Problem38：翻转单词的顺序\n\n### Problem39：扑克牌的顺子\n\n### Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\n\n### Problem41：计算1+2+3+ ··· + n\n\n### Problem42：不用加减乘除做加法\n\n### Problem43：把字符串转换为整数\n\n### Problem44：数组中重复的数字\n\n### Problem45：构建乘积数组\n\n### Problem46：正则表达式匹配\n\n### Problem47：表示数值的字符串\n\n### Problem48：字符流中第一个不重复的字符\n\n### Problem49：链表中环的入口结点\n\n### Problem50：删除链表中欧冠重复的节点\n\n### Problem51：二叉树的下一个节点\n\n### Problem52：把二叉树打印成多行\n\n### Problem53：按之字形顺序打印二叉树\n\n### Problem54：序列化二叉树\n\n### Problem55：二叉搜索树的第K个节点\n\n### Problem56：滑动窗口的最大值大值","source":"_posts/《剑指offer》题目-Java-实现.md","raw":"---\ntitle: 《剑指offer》题目 Java 实现\ndate: 2019-03-18 10:42:29\ntags:\n- 算法\n- Java\ncategories:\n- 算法\n---\n\n### Problem1：单例模式实现\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n<!--more-->\n### Problem2：二维数组中的查找\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n```java\n    /**\n     * 从二维数组的右上角开始选取与 key 比较的整数\n     * column 的变化:arr[0].length - 1 ---> 0\n     * row 的变化 0 ---> arr.length\n     *\n     * @param arr \n     * @param key \n     */\npublic static boolean find(int[][] arr, int key) {\n    int col = arr[0].length - 1;\n    int row = 0;\n    while (col >= 0 && row < arr.length) {\n        if (arr[row][col] == key) {\n            return true;\n        } else if (arr[row][col] > key) {   //大于查找值，则往前推一列\n            col--;\n        } else {    //小于查找值，则往下推一行\n            row++;\n        }\n    }\n    return false;\n}\n```\n\n\n\n### Problem3：替换空格\n\n请实现一个函数，将字符串的每个空格替换为\"%20\"。例如输入`We are happy`，则输出`We%20are%20happy`。\n\n```java\n    /**\n     * 使用 StringBuilder\n     * \n     * @param str\n     * @return\n     */\n    public static String replace(String str) {\n        if (str.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == ' ') {\n                builder.append(\"%20\");\n            } else {\n                builder.append(str.charAt(i));\n            }\n        }\n        return builder.toString();\n    }\n```\n\n\n\n### Problem4：从尾到头打印链表\n\n输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值\n\n```java\nstatic class ListNode<T> {\n    T value;\n    ListNode next;\n\n    public ListNode(T value) {\n        this.value = value;\n    }\n}\n\n/**\n * 使用栈实现\n *\n * @param headNode\n */\npublic static void printListReverse(ListNode headNode) {\n    Stack<ListNode> stack = new Stack<>();\n    while (headNode != null) {\n        stack.push(headNode);\n        headNode = headNode.next;\n    }\n    while (!stack.empty()) {\n        System.out.println(stack.pop().value + \" \");\n    }\n}\n\npublic static void main(String[] args) {\n    ListNode<Integer> node = new ListNode<>(1);\n    node.next = new ListNode<>(2);\n    node.next.next = new ListNode<>(3);\n    printListReverse(node);\n}\n```\n\n\n\n### Problem5：重建二叉树\n\n输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。\n\n假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。\n\n例如输入前序遍历序列： `{1, 2, 4, 7, 3, 5, 6, 8}`\n\n中序遍历序列：`{4, 7, 2, 1, 5, 3, 8, 6}`\n\n重建出所示二叉树并且输出它的头结点。\n\n```java\n                     1\n                   /   \\\n                  2     3\n                 /     / \\\n                4     5   6\n                 \\        /\n                 7        8\n```\n\n#### 知识点补充\n\n> 前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）\n>\n> 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）\n>\n> 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）\n\n> 二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。\n>\n> 二叉树的特例是**堆**和**红黑树**。\n>\n> 堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。\n>\n> 红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。\n\n### Problem6：用两个栈实现队列\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数\n`appendTail`和`deleteHead`,分别完成在队列尾部插入结点和在队列头部删除结点的功能\n```Java\npublic class ConstructQueue {\n    /*\n     s1 用来实现放入新的元素，直接放到栈顶\n     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2\n     然后删除底部元素，再将 s2 元素移回 s1\n     */\n    Stack<String> stack1 = new Stack<>();\n    Stack<String> stack2 = new Stack<>();\n\n    // 实现appendTail函数\n    public void appendTail(String s) {\n        stack1.push(s);\n    }\n\n    // 实现deleteHead函数\n    public String deleteHead() {\n        while (!stack1.empty()) {\n            stack2.push(stack1.pop());\n        }\n        String head = stack2.pop();\n        while (!stack2.empty()) {\n            stack1.push(stack2.pop());\n        }\n        return head;\n    }\n\n    public static void main(String[] args) {\n        ConstructQueue queue = new ConstructQueue();\n        queue.appendTail(\"a\");\n        queue.appendTail(\"b\");\n        queue.appendTail(\"c\");\n        queue.appendTail(\"d\");\n        System.out.println(queue.deleteHead());\n        System.out.println(queue.deleteHead());\n    }\n}\n```\n输出如下\n```\na\nb\n```\n### Problem7：旋转数组的最小数字\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。\n例如数组 `{3, 4, 5, 1, 2}`为`{1, 2, 3, 4, 5}`的一个旋转，该数组的最小值为 1;\n\n```Java\npublic static void main(String[] args) {\n    int[] a = {3, 4, 5, 1, 2};\n    System.out.println(minNumInRotateArray(a));\n}\n\n/**\n     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。\n     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。\n     *\n     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。\n     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，\n     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。\n     * 同理第二个指针的范围也将逐渐缩小\n     *\n     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。\n     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，\n     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。\n     * \n     * @param array\n     */\npublic static int minNumInRotateArray(int[] array) {\n    if (array == null) {\n        return 0;\n    }\n    int left = 0;\n    int right = array.length - 1;\n    int mid = 0;\n    while (array[left] >= array[right]) {\n        if (right - left == 1) {\n            mid = right;\n            break;\n        }\n        mid = (left + right) / 2;\n\n        // 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组\n        if (array[left] == array[right] && array[right] == array[mid]) {\n            return findInOrder(array, left, right);\n        }\n        \n        if (array[left] <= array[mid]) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    return array[mid];\n}\n\nstatic int findInOrder(int[] array, int left, int right) {\n    int k = array[left];\n    for (int i = 0; i < right; i++) {\n        if (array[i] < k) {\n            k = array[i];\n        }\n    }\n    return k;\n}\n```\n\n### Problem8：斐波那契数列\n写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： \n> n=0, f(n)=0;\n> n=1, f(n)=1; \n> n>1, f(n) = f(n-1) + f(n-2).\n\n```Java\npublic static void main(String[] args) {\n    for (int i = 0; i < 11; i++) {\n        System.out.print(fibonacci(i) + \" \");\n    }\n}\n\npublic static int fibonacci(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n```\n输出结果\n```\n0 1 1 2 3 5 8 13 21 34 55 \n```\n### Problem9：二进制中1的个数\n请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。\n\n例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。\n\n```\npublic static int oneCountsOfBinary(int i) {\n    char[] chars = Integer.toBinaryString(i).toCharArray();\n    int count = 0;\n    for (char c : chars) {\n        if (c == '1') {\n            count++;\n        }\n    }\n    return count;\n}\n\npublic static int _oneCountsOfBinary(int i) {\n    int count = 0;\n    int flag = 1;\n    while (flag != 0) {\n        if ((i & flag) != 0) {\n            count++;\n        }\n        flag = flag << 1;\n    }\n    return count;\n}\n```\n\n### Problem10：数值的整数次方\n 实现函数`double power(double base, int exponent)`，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。 \n```Java\npublic static double power(double base, int exponent) {\n    if (base <= 0) {\n        throw new RuntimeException(\"运算无意义\");\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if (exponent < 0) {\n        return 1 / powerUnsigned(base, -exponent);\n    } else {\n        return powerUnsigned(base, exponent);\n    }\n}\n\nstatic double powerUnsigned(double base, int exponent) {\n    double result = base;\n    for (int i = 1; i < exponent; i++) {\n        result = result * base;\n    }\n    return result;\n}\n```\n\n### Problem11：O（1）时间删除链表结点\n给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。\n```Java\nstatic class Node {\n    int value;\n    Node next;\n\n    public Node(int value) {\n        this.value = value;\n    }\n}\n\n/**\n * 只有一个节点时，直接置空\n * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null\n * 否则 p->next 的值赋值给p，把p->next删除掉\n *\n * @param head\n * @param delNode\n */\npublic static void deleteNode(Node head, Node delNode) {\n    if (head == null || delNode == null) {\n        return;\n    }\n    if (head == delNode) {\n        head = null;\n        return;\n    }\n    if (delNode.next == null) {\n        Node temp = head;\n        while (temp.next != delNode) {\n            temp = temp.next;\n        }\n        temp.next = null;\n        return;\n    }\n    delNode.value = delNode.next.value;\n    delNode.next = delNode.next.next;\n}\n```\n### Problem12：调整数组中奇数和偶数的先后顺序\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;\n```Java\npublic static void orderArray(int[] array) {\n    int left = 0;\n    int right = array.length - 1;\n    while (left < right) {\n        while (left < right && !isEven(array[left])) {\n            left ++;\n        }\n        while (left < right && isEven(array[right])) {\n            right --;\n        }\n        if (left < right) {\n            int temp = array[left];\n            array[left] = array[right];\n            array[right] = temp;\n        }\n    }\n}\n\nstatic boolean isEven(int i) {\n    return ((i & 1) == 0);\n}\n```\n\n### Problem13：链表中倒数第K个结点\n输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。\n\n例如一个链表有6个结点，从头结点开始它们的值依次是`1、2、3、4、5、6`。这个链表的倒数第三个结点是值为4的结点。\n\n```Java\n    /**\n     * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动\n     * 从第k步开始，第二个指针也开始从链表的头指针开始遍历\n     * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上\n     * \n     * @param head 头结点\n     * @param k 倒数第k个节点\n     */\n    public static int find(ListNode head, int k){\n        if (head == null) {\n            return 0;\n        }\n        ListNode first = head;\n        ListNode second = head;\n        for (int i = 1; i < k; i++) {\n            if (first.next != null) {\n                first = first.next;\n            } else {\n                return 0;\n            }\n        }\n        System.out.println(first.val);\n        while (first.next != null) {\n            first = first.next;\n            second = second.next;\n        }\n        System.out.println(first.val);\n        return second.val;\n    }\n\n    static class ListNode {\n        int val;\n        ListNode next;\n\n        public ListNode(int val) {\n            this.val = val;\n        }\n    }\n```\n### Problem14：翻转链表\n定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点\n\n\n\n![](《剑指offer》题目-Java-实现/翻转链表.png)\n\n```Java\n    /**\n     * 翻转单链表\n     * \n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode getReversedListHead(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        //current节点是head的下一个节点\n        ListNode current = head.next;\n        //当前的head变为链表的尾，所以next为空\n        head.next = null;\n        \n        while (current != null) {\n            //currentNext节点是current的下一个节点。\n            ListNode currentNext = current.next;\n            //current.next反方向指向以前的节点\n            current.next = head;\n            \n            //移动head和current指针，到后面head重新成为头节点\n            head = current;\n            current = currentNext;\n        }\n        return head;\n    }\n\n    /**\n     * 翻转单链表的递归实现\n     *\n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode reverseListByRecursion(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newList = reverseListByRecursion(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newList;\n    }\n```\n\n### Problem15：合并两个排序的链表\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。\n\n```java\n    public static ListNode merge(ListNode n1, ListNode n2) {\n        if (n1 == null) {\n            return n2;\n        }\n        if (n2 == null) {\n            return n1;\n        }\n        ListNode mergeNode = null;\n        if (n1.val < n2.val) {\n            mergeNode = n1;\n            mergeNode.next = merge(n1.next, n2);\n        } else {\n            mergeNode = n2;\n            mergeNode.next = merge(n1, n2.next);\n        }\n        return mergeNode;\n    }\n```\n\n\n\n### Problem16：树的子结构判断\n\n\n\n### Problem17：二叉树的镜像\n\n### Problem18：顺时针打印矩阵\n\n### Problem19：包含min函数的栈\n\n### Problem20：栈的压入、弹出序列\n\n### Problem21：从上往下打印二叉树\n\n### Problem22：二叉搜索树的后序遍历\n\n### Problem23：二叉树中和为某一值的路径\n\n### Problem24：字符串的排列\n\n### Problem25：数组中出现次数超过一半的数字\n\n### Problem26：连续子数组的最大和\n\n### Problem27：整数中1出现的次数\n\n### Problem28：把数组排成最小的数\n\n### Problem29：丑数\n\n### Problem30：第一个只出现一次的字符\n\n### Problem31：数组中的逆序对\n\n### Problem32：两个链表的第一个公共节点\n\n### Problem33：二叉树的深度&&平衡二叉树判断\n\n### Problem34：数字在排序数组中出现的次数\n\n### Problem35：数组中只出现一次的数字\n\n### Problem36：和为S的两个数字 \n\n### Problem37：和为S的连续正数序列\n\n### Problem38：翻转单词的顺序\n\n### Problem39：扑克牌的顺子\n\n### Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\n\n### Problem41：计算1+2+3+ ··· + n\n\n### Problem42：不用加减乘除做加法\n\n### Problem43：把字符串转换为整数\n\n### Problem44：数组中重复的数字\n\n### Problem45：构建乘积数组\n\n### Problem46：正则表达式匹配\n\n### Problem47：表示数值的字符串\n\n### Problem48：字符流中第一个不重复的字符\n\n### Problem49：链表中环的入口结点\n\n### Problem50：删除链表中欧冠重复的节点\n\n### Problem51：二叉树的下一个节点\n\n### Problem52：把二叉树打印成多行\n\n### Problem53：按之字形顺序打印二叉树\n\n### Problem54：序列化二叉树\n\n### Problem55：二叉搜索树的第K个节点\n\n### Problem56：滑动窗口的最大值大值","slug":"《剑指offer》题目-Java-实现","published":1,"updated":"2019-03-25T09:17:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwgkzqz1005ly4updts4qygw","content":"<h3 id=\"Problem1：单例模式实现\"><a href=\"#Problem1：单例模式实现\" class=\"headerlink\" title=\"Problem1：单例模式实现\"></a>Problem1：单例模式实现</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>{}  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>{  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) {  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) {  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) {  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                }  </span><br><span class=\"line\">            }  </span><br><span class=\"line\">        }  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"Problem2：二维数组中的查找\"><a href=\"#Problem2：二维数组中的查找\" class=\"headerlink\" title=\"Problem2：二维数组中的查找\"></a>Problem2：二维数组中的查找</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从二维数组的右上角开始选取与 key 比较的整数</span></span><br><span class=\"line\"><span class=\"comment\">     * column 的变化:arr[0].length - 1 ---> 0</span></span><br><span class=\"line\"><span class=\"comment\">     * row 的变化 0 ---> arr.length</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] arr, <span class=\"keyword\">int</span> key)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> col = arr[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (col >= <span class=\"number\">0</span> && row < arr.length) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[row][col] == key) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[row][col] > key) {   <span class=\"comment\">//大于查找值，则往前推一列</span></span><br><span class=\"line\">            col--;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {    <span class=\"comment\">//小于查找值，则往下推一行</span></span><br><span class=\"line\">            row++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem3：替换空格\"><a href=\"#Problem3：替换空格\" class=\"headerlink\" title=\"Problem3：替换空格\"></a>Problem3：替换空格</h3><p>请实现一个函数，将字符串的每个空格替换为”%20”。例如输入<code>We are happy</code>，则输出<code>We%20are%20happy</code>。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 StringBuilder</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">replace</span><span class=\"params\">(String str)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str.isEmpty()) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < str.length(); i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(i) == <span class=\"string\">' '</span>) {</span><br><span class=\"line\">            builder.append(<span class=\"string\">\"%20\"</span>);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            builder.append(str.charAt(i));</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.toString();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem4：从尾到头打印链表\"><a href=\"#Problem4：从尾到头打印链表\" class=\"headerlink\" title=\"Problem4：从尾到头打印链表\"></a>Problem4：从尾到头打印链表</h3><p>输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span><<span class=\"title\">T</span>> </span>{</span><br><span class=\"line\">    T value;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(T value)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用栈实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> headNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printListReverse</span><span class=\"params\">(ListNode headNode)</span> </span>{</span><br><span class=\"line\">    Stack<ListNode> stack = <span class=\"keyword\">new</span> Stack<>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (headNode != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        stack.push(headNode);</span><br><span class=\"line\">        headNode = headNode.next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.empty()) {</span><br><span class=\"line\">        System.out.println(stack.pop().value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    ListNode<Integer> node = <span class=\"keyword\">new</span> ListNode<>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    node.next = <span class=\"keyword\">new</span> ListNode<>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    node.next.next = <span class=\"keyword\">new</span> ListNode<>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    printListReverse(node);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem5：重建二叉树\"><a href=\"#Problem5：重建二叉树\" class=\"headerlink\" title=\"Problem5：重建二叉树\"></a>Problem5：重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。</p>\n<p>假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。</p>\n<p>例如输入前序遍历序列： <code>{1, 2, 4, 7, 3, 5, 6, 8}</code></p>\n<p>中序遍历序列：<code>{4, 7, 2, 1, 5, 3, 8, 6}</code></p>\n<p>重建出所示二叉树并且输出它的头结点。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">1</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\"> /     / \\</span><br><span class=\"line\"><span class=\"number\">4</span>     <span class=\"number\">5</span>   <span class=\"number\">6</span></span><br><span class=\"line\"> \\        /</span><br><span class=\"line\"> <span class=\"number\">7</span>        <span class=\"number\">8</span></span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"知识点补充\"><a href=\"#知识点补充\" class=\"headerlink\" title=\"知识点补充\"></a>知识点补充</h4><blockquote>\n<p>前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）</p>\n<p>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）</p>\n<p>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）</p>\n</blockquote>\n<blockquote>\n<p>二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。</p>\n<p>二叉树的特例是<strong>堆</strong>和<strong>红黑树</strong>。</p>\n<p>堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。</p>\n<p>红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。</p>\n</blockquote>\n<h3 id=\"Problem6：用两个栈实现队列\"><a href=\"#Problem6：用两个栈实现队列\" class=\"headerlink\" title=\"Problem6：用两个栈实现队列\"></a>Problem6：用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<br><code>appendTail</code>和<code>deleteHead</code>,分别完成在队列尾部插入结点和在队列头部删除结点的功能<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConstructQueue</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     s1 用来实现放入新的元素，直接放到栈顶</span></span><br><span class=\"line\"><span class=\"comment\">     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2</span></span><br><span class=\"line\"><span class=\"comment\">     然后删除底部元素，再将 s2 元素移回 s1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Stack<String> stack1 = <span class=\"keyword\">new</span> Stack<>();</span><br><span class=\"line\">    Stack<String> stack2 = <span class=\"keyword\">new</span> Stack<>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现appendTail函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(String s)</span> </span>{</span><br><span class=\"line\">        stack1.push(s);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现deleteHead函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) {</span><br><span class=\"line\">            stack2.push(stack1.pop());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        String head = stack2.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) {</span><br><span class=\"line\">            stack1.push(stack2.pop());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">        ConstructQueue queue = <span class=\"keyword\">new</span> ConstructQueue();</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>输出如下<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"Problem7：旋转数组的最小数字\"><a href=\"#Problem7：旋转数组的最小数字\" class=\"headerlink\" title=\"Problem7：旋转数组的最小数字\"></a>Problem7：旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。<br>例如数组 <code>{3, 4, 5, 1, 2}</code>为<code>{1, 2, 3, 4, 5}</code>的一个旋转，该数组的最小值为 1;</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = {<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>};</span><br><span class=\"line\">    System.out.println(minNumInRotateArray(a));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。</span></span><br><span class=\"line\"><span class=\"comment\">     * 同理第二个指针的范围也将逐渐缩小</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">minNumInRotateArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (array[left] >= array[right]) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            mid = right;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] == array[right] && array[right] == array[mid]) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> findInOrder(array, left, right);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] <= array[mid]) {</span><br><span class=\"line\">            left = mid;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            right = mid;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array[mid];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">findInOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = array[left];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < right; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] < k) {</span><br><span class=\"line\">            k = array[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem8：斐波那契数列\"><a href=\"#Problem8：斐波那契数列\" class=\"headerlink\" title=\"Problem8：斐波那契数列\"></a>Problem8：斐波那契数列</h3><p>写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： </p>\n<blockquote>\n<p>n=0, f(n)=0;<br>n=1, f(n)=1;<br>n>1, f(n) = f(n-1) + f(n-2).</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i < <span class=\"number\">11</span>; i++) {</span><br><span class=\"line\">        System.out.print(fibonacci(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">fibonacci</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输出结果<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"Problem9：二进制中1的个数\"><a href=\"#Problem9：二进制中1的个数\" class=\"headerlink\" title=\"Problem9：二进制中1的个数\"></a>Problem9：二进制中1的个数</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。</p>\n<p>例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">public static int oneCountsOfBinary(int i) {</span><br><span class=\"line\">    char[] chars = Integer.toBinaryString(i).toCharArray();</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    for (char c : chars) {</span><br><span class=\"line\">        if (c == '1') {</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">public static int _oneCountsOfBinary(int i) {</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    int flag = 1;</span><br><span class=\"line\">    while (flag != 0) {</span><br><span class=\"line\">        if ((i & flag) != 0) {</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        flag = flag << 1;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem10：数值的整数次方\"><a href=\"#Problem10：数值的整数次方\" class=\"headerlink\" title=\"Problem10：数值的整数次方\"></a>Problem10：数值的整数次方</h3><p> 实现函数<code>double power(double base, int exponent)</code>，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">power</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base <= <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"运算无意义\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent < <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> / powerUnsigned(base, -exponent);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> powerUnsigned(base, exponent);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">powerUnsigned</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = base;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i < exponent; i++) {</span><br><span class=\"line\">        result = result * base;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"Problem11：O（1）时间删除链表结点\"><a href=\"#Problem11：O（1）时间删除链表结点\" class=\"headerlink\" title=\"Problem11：O（1）时间删除链表结点\"></a>Problem11：O（1）时间删除链表结点</h3><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 只有一个节点时，直接置空</span></span><br><span class=\"line\"><span class=\"comment\"> * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则 p->next 的值赋值给p，把p->next删除掉</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> delNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(Node head, Node delNode)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || delNode == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == delNode) {</span><br><span class=\"line\">        head = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delNode.next == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        Node temp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp.next != delNode) {</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        temp.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    delNode.value = delNode.next.value;</span><br><span class=\"line\">    delNode.next = delNode.next.next;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"Problem12：调整数组中奇数和偶数的先后顺序\"><a href=\"#Problem12：调整数组中奇数和偶数的先后顺序\" class=\"headerlink\" title=\"Problem12：调整数组中奇数和偶数的先后顺序\"></a>Problem12：调整数组中奇数和偶数的先后顺序</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;<br></p><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">orderArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left < right) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left < right && !isEven(array[left])) {</span><br><span class=\"line\">            left ++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left < right && isEven(array[right])) {</span><br><span class=\"line\">            right --;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left < right) {</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = array[left];</span><br><span class=\"line\">            array[left] = array[right];</span><br><span class=\"line\">            array[right] = temp;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEven</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i & <span class=\"number\">1</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"Problem13：链表中倒数第K个结点\"><a href=\"#Problem13：链表中倒数第K个结点\" class=\"headerlink\" title=\"Problem13：链表中倒数第K个结点\"></a>Problem13：链表中倒数第K个结点</h3><p>输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。</p>\n<p>例如一个链表有6个结点，从头结点开始它们的值依次是<code>1、2、3、4、5、6</code>。这个链表的倒数第三个结点是值为4的结点。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第k步开始，第二个指针也开始从链表的头指针开始遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 头结点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> k 倒数第k个节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> k)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ListNode first = head;</span><br><span class=\"line\">    ListNode second = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i < k; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.next != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (first.next != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        first = first.next;</span><br><span class=\"line\">        second = second.next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> second.val;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem14：翻转链表\"><a href=\"#Problem14：翻转链表\" class=\"headerlink\" title=\"Problem14：翻转链表\"></a>Problem14：翻转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>\n<p><img src=\"/《剑指offer》题目-Java-实现/翻转链表.png\" alt></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">getReversedListHead</span><span class=\"params\">(ListNode head)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//current节点是head的下一个节点</span></span><br><span class=\"line\">    ListNode current = head.next;</span><br><span class=\"line\">    <span class=\"comment\">//当前的head变为链表的尾，所以next为空</span></span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">//currentNext节点是current的下一个节点。</span></span><br><span class=\"line\">        ListNode currentNext = current.next;</span><br><span class=\"line\">        <span class=\"comment\">//current.next反方向指向以前的节点</span></span><br><span class=\"line\">        current.next = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//移动head和current指针，到后面head重新成为头节点</span></span><br><span class=\"line\">        head = current;</span><br><span class=\"line\">        current = currentNext;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表的递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">reverseListByRecursion</span><span class=\"params\">(ListNode head)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ListNode newList = reverseListByRecursion(head.next);</span><br><span class=\"line\">    head.next.next = head;</span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newList;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem15：合并两个排序的链表\"><a href=\"#Problem15：合并两个排序的链表\" class=\"headerlink\" title=\"Problem15：合并两个排序的链表\"></a>Problem15：合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1 == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n2 == <span class=\"keyword\">null</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ListNode mergeNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1.val < n2.val) {</span><br><span class=\"line\">        mergeNode = n1;</span><br><span class=\"line\">        mergeNode.next = merge(n1.next, n2);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        mergeNode = n2;</span><br><span class=\"line\">        mergeNode.next = merge(n1, n2.next);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeNode;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"Problem16：树的子结构判断\"><a href=\"#Problem16：树的子结构判断\" class=\"headerlink\" title=\"Problem16：树的子结构判断\"></a>Problem16：树的子结构判断</h3><h3 id=\"Problem17：二叉树的镜像\"><a href=\"#Problem17：二叉树的镜像\" class=\"headerlink\" title=\"Problem17：二叉树的镜像\"></a>Problem17：二叉树的镜像</h3><h3 id=\"Problem18：顺时针打印矩阵\"><a href=\"#Problem18：顺时针打印矩阵\" class=\"headerlink\" title=\"Problem18：顺时针打印矩阵\"></a>Problem18：顺时针打印矩阵</h3><h3 id=\"Problem19：包含min函数的栈\"><a href=\"#Problem19：包含min函数的栈\" class=\"headerlink\" title=\"Problem19：包含min函数的栈\"></a>Problem19：包含min函数的栈</h3><h3 id=\"Problem20：栈的压入、弹出序列\"><a href=\"#Problem20：栈的压入、弹出序列\" class=\"headerlink\" title=\"Problem20：栈的压入、弹出序列\"></a>Problem20：栈的压入、弹出序列</h3><h3 id=\"Problem21：从上往下打印二叉树\"><a href=\"#Problem21：从上往下打印二叉树\" class=\"headerlink\" title=\"Problem21：从上往下打印二叉树\"></a>Problem21：从上往下打印二叉树</h3><h3 id=\"Problem22：二叉搜索树的后序遍历\"><a href=\"#Problem22：二叉搜索树的后序遍历\" class=\"headerlink\" title=\"Problem22：二叉搜索树的后序遍历\"></a>Problem22：二叉搜索树的后序遍历</h3><h3 id=\"Problem23：二叉树中和为某一值的路径\"><a href=\"#Problem23：二叉树中和为某一值的路径\" class=\"headerlink\" title=\"Problem23：二叉树中和为某一值的路径\"></a>Problem23：二叉树中和为某一值的路径</h3><h3 id=\"Problem24：字符串的排列\"><a href=\"#Problem24：字符串的排列\" class=\"headerlink\" title=\"Problem24：字符串的排列\"></a>Problem24：字符串的排列</h3><h3 id=\"Problem25：数组中出现次数超过一半的数字\"><a href=\"#Problem25：数组中出现次数超过一半的数字\" class=\"headerlink\" title=\"Problem25：数组中出现次数超过一半的数字\"></a>Problem25：数组中出现次数超过一半的数字</h3><h3 id=\"Problem26：连续子数组的最大和\"><a href=\"#Problem26：连续子数组的最大和\" class=\"headerlink\" title=\"Problem26：连续子数组的最大和\"></a>Problem26：连续子数组的最大和</h3><h3 id=\"Problem27：整数中1出现的次数\"><a href=\"#Problem27：整数中1出现的次数\" class=\"headerlink\" title=\"Problem27：整数中1出现的次数\"></a>Problem27：整数中1出现的次数</h3><h3 id=\"Problem28：把数组排成最小的数\"><a href=\"#Problem28：把数组排成最小的数\" class=\"headerlink\" title=\"Problem28：把数组排成最小的数\"></a>Problem28：把数组排成最小的数</h3><h3 id=\"Problem29：丑数\"><a href=\"#Problem29：丑数\" class=\"headerlink\" title=\"Problem29：丑数\"></a>Problem29：丑数</h3><h3 id=\"Problem30：第一个只出现一次的字符\"><a href=\"#Problem30：第一个只出现一次的字符\" class=\"headerlink\" title=\"Problem30：第一个只出现一次的字符\"></a>Problem30：第一个只出现一次的字符</h3><h3 id=\"Problem31：数组中的逆序对\"><a href=\"#Problem31：数组中的逆序对\" class=\"headerlink\" title=\"Problem31：数组中的逆序对\"></a>Problem31：数组中的逆序对</h3><h3 id=\"Problem32：两个链表的第一个公共节点\"><a href=\"#Problem32：两个链表的第一个公共节点\" class=\"headerlink\" title=\"Problem32：两个链表的第一个公共节点\"></a>Problem32：两个链表的第一个公共节点</h3><h3 id=\"Problem33：二叉树的深度-amp-amp-平衡二叉树判断\"><a href=\"#Problem33：二叉树的深度-amp-amp-平衡二叉树判断\" class=\"headerlink\" title=\"Problem33：二叉树的深度&&平衡二叉树判断\"></a>Problem33：二叉树的深度&&平衡二叉树判断</h3><h3 id=\"Problem34：数字在排序数组中出现的次数\"><a href=\"#Problem34：数字在排序数组中出现的次数\" class=\"headerlink\" title=\"Problem34：数字在排序数组中出现的次数\"></a>Problem34：数字在排序数组中出现的次数</h3><h3 id=\"Problem35：数组中只出现一次的数字\"><a href=\"#Problem35：数组中只出现一次的数字\" class=\"headerlink\" title=\"Problem35：数组中只出现一次的数字\"></a>Problem35：数组中只出现一次的数字</h3><h3 id=\"Problem36：和为S的两个数字\"><a href=\"#Problem36：和为S的两个数字\" class=\"headerlink\" title=\"Problem36：和为S的两个数字\"></a>Problem36：和为S的两个数字</h3><h3 id=\"Problem37：和为S的连续正数序列\"><a href=\"#Problem37：和为S的连续正数序列\" class=\"headerlink\" title=\"Problem37：和为S的连续正数序列\"></a>Problem37：和为S的连续正数序列</h3><h3 id=\"Problem38：翻转单词的顺序\"><a href=\"#Problem38：翻转单词的顺序\" class=\"headerlink\" title=\"Problem38：翻转单词的顺序\"></a>Problem38：翻转单词的顺序</h3><h3 id=\"Problem39：扑克牌的顺子\"><a href=\"#Problem39：扑克牌的顺子\" class=\"headerlink\" title=\"Problem39：扑克牌的顺子\"></a>Problem39：扑克牌的顺子</h3><h3 id=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"><a href=\"#Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\" class=\"headerlink\" title=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"></a>Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）</h3><h3 id=\"Problem41：计算1-2-3-···-n\"><a href=\"#Problem41：计算1-2-3-···-n\" class=\"headerlink\" title=\"Problem41：计算1+2+3+ ··· + n\"></a>Problem41：计算1+2+3+ ··· + n</h3><h3 id=\"Problem42：不用加减乘除做加法\"><a href=\"#Problem42：不用加减乘除做加法\" class=\"headerlink\" title=\"Problem42：不用加减乘除做加法\"></a>Problem42：不用加减乘除做加法</h3><h3 id=\"Problem43：把字符串转换为整数\"><a href=\"#Problem43：把字符串转换为整数\" class=\"headerlink\" title=\"Problem43：把字符串转换为整数\"></a>Problem43：把字符串转换为整数</h3><h3 id=\"Problem44：数组中重复的数字\"><a href=\"#Problem44：数组中重复的数字\" class=\"headerlink\" title=\"Problem44：数组中重复的数字\"></a>Problem44：数组中重复的数字</h3><h3 id=\"Problem45：构建乘积数组\"><a href=\"#Problem45：构建乘积数组\" class=\"headerlink\" title=\"Problem45：构建乘积数组\"></a>Problem45：构建乘积数组</h3><h3 id=\"Problem46：正则表达式匹配\"><a href=\"#Problem46：正则表达式匹配\" class=\"headerlink\" title=\"Problem46：正则表达式匹配\"></a>Problem46：正则表达式匹配</h3><h3 id=\"Problem47：表示数值的字符串\"><a href=\"#Problem47：表示数值的字符串\" class=\"headerlink\" title=\"Problem47：表示数值的字符串\"></a>Problem47：表示数值的字符串</h3><h3 id=\"Problem48：字符流中第一个不重复的字符\"><a href=\"#Problem48：字符流中第一个不重复的字符\" class=\"headerlink\" title=\"Problem48：字符流中第一个不重复的字符\"></a>Problem48：字符流中第一个不重复的字符</h3><h3 id=\"Problem49：链表中环的入口结点\"><a href=\"#Problem49：链表中环的入口结点\" class=\"headerlink\" title=\"Problem49：链表中环的入口结点\"></a>Problem49：链表中环的入口结点</h3><h3 id=\"Problem50：删除链表中欧冠重复的节点\"><a href=\"#Problem50：删除链表中欧冠重复的节点\" class=\"headerlink\" title=\"Problem50：删除链表中欧冠重复的节点\"></a>Problem50：删除链表中欧冠重复的节点</h3><h3 id=\"Problem51：二叉树的下一个节点\"><a href=\"#Problem51：二叉树的下一个节点\" class=\"headerlink\" title=\"Problem51：二叉树的下一个节点\"></a>Problem51：二叉树的下一个节点</h3><h3 id=\"Problem52：把二叉树打印成多行\"><a href=\"#Problem52：把二叉树打印成多行\" class=\"headerlink\" title=\"Problem52：把二叉树打印成多行\"></a>Problem52：把二叉树打印成多行</h3><h3 id=\"Problem53：按之字形顺序打印二叉树\"><a href=\"#Problem53：按之字形顺序打印二叉树\" class=\"headerlink\" title=\"Problem53：按之字形顺序打印二叉树\"></a>Problem53：按之字形顺序打印二叉树</h3><h3 id=\"Problem54：序列化二叉树\"><a href=\"#Problem54：序列化二叉树\" class=\"headerlink\" title=\"Problem54：序列化二叉树\"></a>Problem54：序列化二叉树</h3><h3 id=\"Problem55：二叉搜索树的第K个节点\"><a href=\"#Problem55：二叉搜索树的第K个节点\" class=\"headerlink\" title=\"Problem55：二叉搜索树的第K个节点\"></a>Problem55：二叉搜索树的第K个节点</h3><h3 id=\"Problem56：滑动窗口的最大值大值\"><a href=\"#Problem56：滑动窗口的最大值大值\" class=\"headerlink\" title=\"Problem56：滑动窗口的最大值大值\"></a>Problem56：滑动窗口的最大值大值</h3><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{}},"length":12277,"excerpt":"<h3 id=\"Problem1：单例模式实现\"><a href=\"#Problem1：单例模式实现\" class=\"headerlink\" title=\"Problem1：单例模式实现\"></a>Problem1：单例模式实现</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>{  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>{}  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>{  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) {  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) {  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) {  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                }  </span><br><span class=\"line\">            }  </span><br><span class=\"line\">        }  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>","more":"<h3 id=\"Problem2：二维数组中的查找\"><a href=\"#Problem2：二维数组中的查找\" class=\"headerlink\" title=\"Problem2：二维数组中的查找\"></a>Problem2：二维数组中的查找</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从二维数组的右上角开始选取与 key 比较的整数</span></span><br><span class=\"line\"><span class=\"comment\">     * column 的变化:arr[0].length - 1 ---&gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">     * row 的变化 0 ---&gt; arr.length</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] arr, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> col = arr[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (col &gt;= <span class=\"number\">0</span> &amp;&amp; row &lt; arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[row][col] == key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[row][col] &gt; key) &#123;   <span class=\"comment\">//大于查找值，则往前推一列</span></span><br><span class=\"line\">            col--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">//小于查找值，则往下推一行</span></span><br><span class=\"line\">            row++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem3：替换空格\"><a href=\"#Problem3：替换空格\" class=\"headerlink\" title=\"Problem3：替换空格\"></a>Problem3：替换空格</h3><p>请实现一个函数，将字符串的每个空格替换为”%20”。例如输入<code>We are happy</code>，则输出<code>We%20are%20happy</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 StringBuilder</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">replace</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(i) == <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">            builder.append(<span class=\"string\">\"%20\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            builder.append(str.charAt(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem4：从尾到头打印链表\"><a href=\"#Problem4：从尾到头打印链表\" class=\"headerlink\" title=\"Problem4：从尾到头打印链表\"></a>Problem4：从尾到头打印链表</h3><p>输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T value;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用栈实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> headNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printListReverse</span><span class=\"params\">(ListNode headNode)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;ListNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (headNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        stack.push(headNode);</span><br><span class=\"line\">        headNode = headNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.empty()) &#123;</span><br><span class=\"line\">        System.out.println(stack.pop().value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ListNode&lt;Integer&gt; node = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">    node.next = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    node.next.next = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">    printListReverse(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem5：重建二叉树\"><a href=\"#Problem5：重建二叉树\" class=\"headerlink\" title=\"Problem5：重建二叉树\"></a>Problem5：重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。</p>\n<p>假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。</p>\n<p>例如输入前序遍历序列： <code>{1, 2, 4, 7, 3, 5, 6, 8}</code></p>\n<p>中序遍历序列：<code>{4, 7, 2, 1, 5, 3, 8, 6}</code></p>\n<p>重建出所示二叉树并且输出它的头结点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">1</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\"> /     / \\</span><br><span class=\"line\"><span class=\"number\">4</span>     <span class=\"number\">5</span>   <span class=\"number\">6</span></span><br><span class=\"line\"> \\        /</span><br><span class=\"line\"> <span class=\"number\">7</span>        <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"知识点补充\"><a href=\"#知识点补充\" class=\"headerlink\" title=\"知识点补充\"></a>知识点补充</h4><blockquote>\n<p>前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）</p>\n<p>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）</p>\n<p>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）</p>\n</blockquote>\n<blockquote>\n<p>二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。</p>\n<p>二叉树的特例是<strong>堆</strong>和<strong>红黑树</strong>。</p>\n<p>堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。</p>\n<p>红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。</p>\n</blockquote>\n<h3 id=\"Problem6：用两个栈实现队列\"><a href=\"#Problem6：用两个栈实现队列\" class=\"headerlink\" title=\"Problem6：用两个栈实现队列\"></a>Problem6：用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<br><code>appendTail</code>和<code>deleteHead</code>,分别完成在队列尾部插入结点和在队列头部删除结点的功能<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConstructQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     s1 用来实现放入新的元素，直接放到栈顶</span></span><br><span class=\"line\"><span class=\"comment\">     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2</span></span><br><span class=\"line\"><span class=\"comment\">     然后删除底部元素，再将 s2 元素移回 s1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Stack&lt;String&gt; stack1 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;String&gt; stack2 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现appendTail函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现deleteHead函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String head = stack2.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConstructQueue queue = <span class=\"keyword\">new</span> ConstructQueue();</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem7：旋转数组的最小数字\"><a href=\"#Problem7：旋转数组的最小数字\" class=\"headerlink\" title=\"Problem7：旋转数组的最小数字\"></a>Problem7：旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。<br>例如数组 <code>{3, 4, 5, 1, 2}</code>为<code>{1, 2, 3, 4, 5}</code>的一个旋转，该数组的最小值为 1;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    System.out.println(minNumInRotateArray(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。</span></span><br><span class=\"line\"><span class=\"comment\">     * 同理第二个指针的范围也将逐渐缩小</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">minNumInRotateArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (array[left] &gt;= array[right]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            mid = right;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] == array[right] &amp;&amp; array[right] == array[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> findInOrder(array, left, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] &lt;= array[mid]) &#123;</span><br><span class=\"line\">            left = mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array[mid];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">findInOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = array[left];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; right; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] &lt; k) &#123;</span><br><span class=\"line\">            k = array[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem8：斐波那契数列\"><a href=\"#Problem8：斐波那契数列\" class=\"headerlink\" title=\"Problem8：斐波那契数列\"></a>Problem8：斐波那契数列</h3><p>写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： </p>\n<blockquote>\n<p>n=0, f(n)=0;<br>n=1, f(n)=1;<br>n&gt;1, f(n) = f(n-1) + f(n-2).</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">        System.out.print(fibonacci(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">fibonacci</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem9：二进制中1的个数\"><a href=\"#Problem9：二进制中1的个数\" class=\"headerlink\" title=\"Problem9：二进制中1的个数\"></a>Problem9：二进制中1的个数</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。</p>\n<p>例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static int oneCountsOfBinary(int i) &#123;</span><br><span class=\"line\">    char[] chars = Integer.toBinaryString(i).toCharArray();</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    for (char c : chars) &#123;</span><br><span class=\"line\">        if (c == &apos;1&apos;) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static int _oneCountsOfBinary(int i) &#123;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    int flag = 1;</span><br><span class=\"line\">    while (flag != 0) &#123;</span><br><span class=\"line\">        if ((i &amp; flag) != 0) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        flag = flag &lt;&lt; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem10：数值的整数次方\"><a href=\"#Problem10：数值的整数次方\" class=\"headerlink\" title=\"Problem10：数值的整数次方\"></a>Problem10：数值的整数次方</h3><p> 实现函数<code>double power(double base, int exponent)</code>，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">power</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"运算无意义\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> / powerUnsigned(base, -exponent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> powerUnsigned(base, exponent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">powerUnsigned</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = base;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; exponent; i++) &#123;</span><br><span class=\"line\">        result = result * base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem11：O（1）时间删除链表结点\"><a href=\"#Problem11：O（1）时间删除链表结点\" class=\"headerlink\" title=\"Problem11：O（1）时间删除链表结点\"></a>Problem11：O（1）时间删除链表结点</h3><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 只有一个节点时，直接置空</span></span><br><span class=\"line\"><span class=\"comment\"> * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则 p-&gt;next 的值赋值给p，把p-&gt;next删除掉</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> delNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(Node head, Node delNode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || delNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == delNode) &#123;</span><br><span class=\"line\">        head = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delNode.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Node temp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp.next != delNode) &#123;</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delNode.value = delNode.next.value;</span><br><span class=\"line\">    delNode.next = delNode.next.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem12：调整数组中奇数和偶数的先后顺序\"><a href=\"#Problem12：调整数组中奇数和偶数的先后顺序\" class=\"headerlink\" title=\"Problem12：调整数组中奇数和偶数的先后顺序\"></a>Problem12：调整数组中奇数和偶数的先后顺序</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">orderArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; !isEven(array[left])) &#123;</span><br><span class=\"line\">            left ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; isEven(array[right])) &#123;</span><br><span class=\"line\">            right --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = array[left];</span><br><span class=\"line\">            array[left] = array[right];</span><br><span class=\"line\">            array[right] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEven</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem13：链表中倒数第K个结点\"><a href=\"#Problem13：链表中倒数第K个结点\" class=\"headerlink\" title=\"Problem13：链表中倒数第K个结点\"></a>Problem13：链表中倒数第K个结点</h3><p>输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。</p>\n<p>例如一个链表有6个结点，从头结点开始它们的值依次是<code>1、2、3、4、5、6</code>。这个链表的倒数第三个结点是值为4的结点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第k步开始，第二个指针也开始从链表的头指针开始遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 头结点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> k 倒数第k个节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode first = head;</span><br><span class=\"line\">    ListNode second = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (first.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        first = first.next;</span><br><span class=\"line\">        second = second.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> second.val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem14：翻转链表\"><a href=\"#Problem14：翻转链表\" class=\"headerlink\" title=\"Problem14：翻转链表\"></a>Problem14：翻转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>\n<p><img src=\"/《剑指offer》题目-Java-实现/翻转链表.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">getReversedListHead</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//current节点是head的下一个节点</span></span><br><span class=\"line\">    ListNode current = head.next;</span><br><span class=\"line\">    <span class=\"comment\">//当前的head变为链表的尾，所以next为空</span></span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//currentNext节点是current的下一个节点。</span></span><br><span class=\"line\">        ListNode currentNext = current.next;</span><br><span class=\"line\">        <span class=\"comment\">//current.next反方向指向以前的节点</span></span><br><span class=\"line\">        current.next = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//移动head和current指针，到后面head重新成为头节点</span></span><br><span class=\"line\">        head = current;</span><br><span class=\"line\">        current = currentNext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表的递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">reverseListByRecursion</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode newList = reverseListByRecursion(head.next);</span><br><span class=\"line\">    head.next.next = head;</span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem15：合并两个排序的链表\"><a href=\"#Problem15：合并两个排序的链表\" class=\"headerlink\" title=\"Problem15：合并两个排序的链表\"></a>Problem15：合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode mergeNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1.val &lt; n2.val) &#123;</span><br><span class=\"line\">        mergeNode = n1;</span><br><span class=\"line\">        mergeNode.next = merge(n1.next, n2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mergeNode = n2;</span><br><span class=\"line\">        mergeNode.next = merge(n1, n2.next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem16：树的子结构判断\"><a href=\"#Problem16：树的子结构判断\" class=\"headerlink\" title=\"Problem16：树的子结构判断\"></a>Problem16：树的子结构判断</h3><h3 id=\"Problem17：二叉树的镜像\"><a href=\"#Problem17：二叉树的镜像\" class=\"headerlink\" title=\"Problem17：二叉树的镜像\"></a>Problem17：二叉树的镜像</h3><h3 id=\"Problem18：顺时针打印矩阵\"><a href=\"#Problem18：顺时针打印矩阵\" class=\"headerlink\" title=\"Problem18：顺时针打印矩阵\"></a>Problem18：顺时针打印矩阵</h3><h3 id=\"Problem19：包含min函数的栈\"><a href=\"#Problem19：包含min函数的栈\" class=\"headerlink\" title=\"Problem19：包含min函数的栈\"></a>Problem19：包含min函数的栈</h3><h3 id=\"Problem20：栈的压入、弹出序列\"><a href=\"#Problem20：栈的压入、弹出序列\" class=\"headerlink\" title=\"Problem20：栈的压入、弹出序列\"></a>Problem20：栈的压入、弹出序列</h3><h3 id=\"Problem21：从上往下打印二叉树\"><a href=\"#Problem21：从上往下打印二叉树\" class=\"headerlink\" title=\"Problem21：从上往下打印二叉树\"></a>Problem21：从上往下打印二叉树</h3><h3 id=\"Problem22：二叉搜索树的后序遍历\"><a href=\"#Problem22：二叉搜索树的后序遍历\" class=\"headerlink\" title=\"Problem22：二叉搜索树的后序遍历\"></a>Problem22：二叉搜索树的后序遍历</h3><h3 id=\"Problem23：二叉树中和为某一值的路径\"><a href=\"#Problem23：二叉树中和为某一值的路径\" class=\"headerlink\" title=\"Problem23：二叉树中和为某一值的路径\"></a>Problem23：二叉树中和为某一值的路径</h3><h3 id=\"Problem24：字符串的排列\"><a href=\"#Problem24：字符串的排列\" class=\"headerlink\" title=\"Problem24：字符串的排列\"></a>Problem24：字符串的排列</h3><h3 id=\"Problem25：数组中出现次数超过一半的数字\"><a href=\"#Problem25：数组中出现次数超过一半的数字\" class=\"headerlink\" title=\"Problem25：数组中出现次数超过一半的数字\"></a>Problem25：数组中出现次数超过一半的数字</h3><h3 id=\"Problem26：连续子数组的最大和\"><a href=\"#Problem26：连续子数组的最大和\" class=\"headerlink\" title=\"Problem26：连续子数组的最大和\"></a>Problem26：连续子数组的最大和</h3><h3 id=\"Problem27：整数中1出现的次数\"><a href=\"#Problem27：整数中1出现的次数\" class=\"headerlink\" title=\"Problem27：整数中1出现的次数\"></a>Problem27：整数中1出现的次数</h3><h3 id=\"Problem28：把数组排成最小的数\"><a href=\"#Problem28：把数组排成最小的数\" class=\"headerlink\" title=\"Problem28：把数组排成最小的数\"></a>Problem28：把数组排成最小的数</h3><h3 id=\"Problem29：丑数\"><a href=\"#Problem29：丑数\" class=\"headerlink\" title=\"Problem29：丑数\"></a>Problem29：丑数</h3><h3 id=\"Problem30：第一个只出现一次的字符\"><a href=\"#Problem30：第一个只出现一次的字符\" class=\"headerlink\" title=\"Problem30：第一个只出现一次的字符\"></a>Problem30：第一个只出现一次的字符</h3><h3 id=\"Problem31：数组中的逆序对\"><a href=\"#Problem31：数组中的逆序对\" class=\"headerlink\" title=\"Problem31：数组中的逆序对\"></a>Problem31：数组中的逆序对</h3><h3 id=\"Problem32：两个链表的第一个公共节点\"><a href=\"#Problem32：两个链表的第一个公共节点\" class=\"headerlink\" title=\"Problem32：两个链表的第一个公共节点\"></a>Problem32：两个链表的第一个公共节点</h3><h3 id=\"Problem33：二叉树的深度-amp-amp-平衡二叉树判断\"><a href=\"#Problem33：二叉树的深度-amp-amp-平衡二叉树判断\" class=\"headerlink\" title=\"Problem33：二叉树的深度&amp;&amp;平衡二叉树判断\"></a>Problem33：二叉树的深度&amp;&amp;平衡二叉树判断</h3><h3 id=\"Problem34：数字在排序数组中出现的次数\"><a href=\"#Problem34：数字在排序数组中出现的次数\" class=\"headerlink\" title=\"Problem34：数字在排序数组中出现的次数\"></a>Problem34：数字在排序数组中出现的次数</h3><h3 id=\"Problem35：数组中只出现一次的数字\"><a href=\"#Problem35：数组中只出现一次的数字\" class=\"headerlink\" title=\"Problem35：数组中只出现一次的数字\"></a>Problem35：数组中只出现一次的数字</h3><h3 id=\"Problem36：和为S的两个数字\"><a href=\"#Problem36：和为S的两个数字\" class=\"headerlink\" title=\"Problem36：和为S的两个数字\"></a>Problem36：和为S的两个数字</h3><h3 id=\"Problem37：和为S的连续正数序列\"><a href=\"#Problem37：和为S的连续正数序列\" class=\"headerlink\" title=\"Problem37：和为S的连续正数序列\"></a>Problem37：和为S的连续正数序列</h3><h3 id=\"Problem38：翻转单词的顺序\"><a href=\"#Problem38：翻转单词的顺序\" class=\"headerlink\" title=\"Problem38：翻转单词的顺序\"></a>Problem38：翻转单词的顺序</h3><h3 id=\"Problem39：扑克牌的顺子\"><a href=\"#Problem39：扑克牌的顺子\" class=\"headerlink\" title=\"Problem39：扑克牌的顺子\"></a>Problem39：扑克牌的顺子</h3><h3 id=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"><a href=\"#Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\" class=\"headerlink\" title=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"></a>Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）</h3><h3 id=\"Problem41：计算1-2-3-···-n\"><a href=\"#Problem41：计算1-2-3-···-n\" class=\"headerlink\" title=\"Problem41：计算1+2+3+ ··· + n\"></a>Problem41：计算1+2+3+ ··· + n</h3><h3 id=\"Problem42：不用加减乘除做加法\"><a href=\"#Problem42：不用加减乘除做加法\" class=\"headerlink\" title=\"Problem42：不用加减乘除做加法\"></a>Problem42：不用加减乘除做加法</h3><h3 id=\"Problem43：把字符串转换为整数\"><a href=\"#Problem43：把字符串转换为整数\" class=\"headerlink\" title=\"Problem43：把字符串转换为整数\"></a>Problem43：把字符串转换为整数</h3><h3 id=\"Problem44：数组中重复的数字\"><a href=\"#Problem44：数组中重复的数字\" class=\"headerlink\" title=\"Problem44：数组中重复的数字\"></a>Problem44：数组中重复的数字</h3><h3 id=\"Problem45：构建乘积数组\"><a href=\"#Problem45：构建乘积数组\" class=\"headerlink\" title=\"Problem45：构建乘积数组\"></a>Problem45：构建乘积数组</h3><h3 id=\"Problem46：正则表达式匹配\"><a href=\"#Problem46：正则表达式匹配\" class=\"headerlink\" title=\"Problem46：正则表达式匹配\"></a>Problem46：正则表达式匹配</h3><h3 id=\"Problem47：表示数值的字符串\"><a href=\"#Problem47：表示数值的字符串\" class=\"headerlink\" title=\"Problem47：表示数值的字符串\"></a>Problem47：表示数值的字符串</h3><h3 id=\"Problem48：字符流中第一个不重复的字符\"><a href=\"#Problem48：字符流中第一个不重复的字符\" class=\"headerlink\" title=\"Problem48：字符流中第一个不重复的字符\"></a>Problem48：字符流中第一个不重复的字符</h3><h3 id=\"Problem49：链表中环的入口结点\"><a href=\"#Problem49：链表中环的入口结点\" class=\"headerlink\" title=\"Problem49：链表中环的入口结点\"></a>Problem49：链表中环的入口结点</h3><h3 id=\"Problem50：删除链表中欧冠重复的节点\"><a href=\"#Problem50：删除链表中欧冠重复的节点\" class=\"headerlink\" title=\"Problem50：删除链表中欧冠重复的节点\"></a>Problem50：删除链表中欧冠重复的节点</h3><h3 id=\"Problem51：二叉树的下一个节点\"><a href=\"#Problem51：二叉树的下一个节点\" class=\"headerlink\" title=\"Problem51：二叉树的下一个节点\"></a>Problem51：二叉树的下一个节点</h3><h3 id=\"Problem52：把二叉树打印成多行\"><a href=\"#Problem52：把二叉树打印成多行\" class=\"headerlink\" title=\"Problem52：把二叉树打印成多行\"></a>Problem52：把二叉树打印成多行</h3><h3 id=\"Problem53：按之字形顺序打印二叉树\"><a href=\"#Problem53：按之字形顺序打印二叉树\" class=\"headerlink\" title=\"Problem53：按之字形顺序打印二叉树\"></a>Problem53：按之字形顺序打印二叉树</h3><h3 id=\"Problem54：序列化二叉树\"><a href=\"#Problem54：序列化二叉树\" class=\"headerlink\" title=\"Problem54：序列化二叉树\"></a>Problem54：序列化二叉树</h3><h3 id=\"Problem55：二叉搜索树的第K个节点\"><a href=\"#Problem55：二叉搜索树的第K个节点\" class=\"headerlink\" title=\"Problem55：二叉搜索树的第K个节点\"></a>Problem55：二叉搜索树的第K个节点</h3><h3 id=\"Problem56：滑动窗口的最大值大值\"><a href=\"#Problem56：滑动窗口的最大值大值\" class=\"headerlink\" title=\"Problem56：滑动窗口的最大值大值\"></a>Problem56：滑动窗口的最大值大值</h3>"}],"PostAsset":[{"_id":"source/_posts/Dart 基础入门/dart_core.png","slug":"dart_core.png","post":"cjwgkzquw0007y4upvxnjqttm","modified":0,"renderable":0},{"_id":"source/_posts/Dart 基础入门/idea_category.png","slug":"idea_category.png","post":"cjwgkzquw0007y4upvxnjqttm","modified":0,"renderable":0},{"_id":"source/_posts/Dart 基础入门/idea_create.png","slug":"idea_create.png","post":"cjwgkzquw0007y4upvxnjqttm","modified":0,"renderable":0},{"_id":"source/_posts/Android-LruCache-缓存详解/LruCache.png","slug":"LruCache.png","post":"cjwgkzqw5001fy4upc9ink8ck","modified":0,"renderable":0},{"_id":"source/_posts/Android-消息机制详解/消息流程图.jpg","slug":"消息流程图.jpg","post":"cjwgkzqw7001hy4upiqzjqqoo","modified":0,"renderable":0},{"_id":"source/_posts/Dart-异步编程/事件循环.png.jpg","slug":"事件循环.png.jpg","post":"cjwgkzqwa001ky4upbi8xvpnt","modified":0,"renderable":0},{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png","slug":"i-center-right.png","post":"cjwgkzqwo0021y4ups0ns4b4l","modified":0,"renderable":0},{"_id":"source/_posts/Dart-面向对象/ABP继承图.png","slug":"ABP继承图.png","post":"cjwgkzqwb001my4up5nhqo8hz","modified":0,"renderable":0},{"_id":"source/_posts/Dart-面向对象/继承歧义.png","slug":"继承歧义.png","post":"cjwgkzqwb001my4up5nhqo8hz","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/工厂方法.jpg","slug":"工厂方法.jpg","post":"cjwgkzqwi001ty4upusfyycyp","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/抽象工厂.jpg","slug":"抽象工厂.jpg","post":"cjwgkzqwi001ty4upusfyycyp","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/简单工厂.jpg","slug":"简单工厂.jpg","post":"cjwgkzqwi001ty4upusfyycyp","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/设计模式之间的关系.jpg","slug":"设计模式之间的关系.jpg","post":"cjwgkzqwi001ty4upusfyycyp","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/spring-mvc-request.jpeg","slug":"spring-mvc-request.jpeg","post":"cjwgkzqwq0026y4uppseh97dx","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_deploy.png","slug":"tomcat_deploy.png","post":"cjwgkzqwq0026y4uppseh97dx","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_put.jpg","slug":"tomcat_put.jpg","post":"cjwgkzqwq0026y4uppseh97dx","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/tomcat_server.png","slug":"tomcat_server.png","post":"cjwgkzqwq0026y4uppseh97dx","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（四）：构建-Web-应用程序/项目结构.png","slug":"项目结构.png","post":"cjwgkzqwq0026y4uppseh97dx","modified":0,"renderable":0},{"_id":"source/_posts/基本数据结构的简单Java实现/HashMap.png","slug":"HashMap.png","post":"cjwgkzqy40047y4upy06toyoc","modified":0,"renderable":0},{"_id":"source/_posts/基本数据结构的简单Java实现/二叉搜索树.png","slug":"二叉搜索树.png","post":"cjwgkzqy40047y4upy06toyoc","modified":0,"renderable":0},{"_id":"source/_posts/Android-View-的工作原理/MeasureSpec创建规则.png","slug":"MeasureSpec创建规则.png","post":"cjwgkzqxm003dy4upg5p3y5bb","modified":0,"renderable":0},{"_id":"source/_posts/Android-View-的工作原理/performTraversals.png","slug":"performTraversals.png","post":"cjwgkzqxm003dy4upg5p3y5bb","modified":0,"renderable":0},{"_id":"source/_posts/Android-View-的工作原理/整体布局.webp.jpg","slug":"整体布局.webp.jpg","post":"cjwgkzqxm003dy4upg5p3y5bb","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（三）：面向切面/AOP_1.jpg","slug":"AOP_1.jpg","post":"cjwgkzqxw003uy4upi7qyv0pc","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（三）：面向切面/AOP_2.jpg","slug":"AOP_2.jpg","post":"cjwgkzqxw003uy4upi7qyv0pc","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（三）：面向切面/Compiler.png","slug":"Compiler.png","post":"cjwgkzqxw003uy4upi7qyv0pc","modified":0,"renderable":0},{"_id":"source/_posts/Markdown-语法详解/kotlin.png","slug":"kotlin.png","post":"cjwgkzqxv003ry4upw1dmpgzv","modified":0,"renderable":0},{"_id":"source/_posts/Markdown-语法详解/markdown.png","slug":"markdown.png","post":"cjwgkzqxv003ry4upw1dmpgzv","modified":0,"renderable":0},{"_id":"source/_posts/Markdown-语法详解/todo-list.png","slug":"todo-list.png","post":"cjwgkzqxv003ry4upw1dmpgzv","modified":0,"renderable":0},{"_id":"source/_posts/Markdown-语法详解/编辑器.png","slug":"编辑器.png","post":"cjwgkzqxv003ry4upw1dmpgzv","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/GFW内部结构.jpg","slug":"GFW内部结构.jpg","post":"cjwgkzqy9004ey4upf25lq8d0","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/GFW存在后的连接方式.png","slug":"GFW存在后的连接方式.png","post":"cjwgkzqy9004ey4upf25lq8d0","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/SSH连接方式.png","slug":"SSH连接方式.png","post":"cjwgkzqy9004ey4upf25lq8d0","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/SS连接方式.png","slug":"SS连接方式.png","post":"cjwgkzqy9004ey4upf25lq8d0","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/原始连接方式.png","slug":"原始连接方式.png","post":"cjwgkzqy9004ey4upf25lq8d0","modified":0,"renderable":0},{"_id":"source/_posts/Spring-学习笔记（一）：基本理念和-Bean-装配/生命周期.png","slug":"生命周期.png","post":"cjwgkzqyz005jy4upbhz9ytpe","modified":0,"renderable":0},{"_id":"source/_posts/Gradle-构建工具详解/groovy.png","slug":"groovy.png","post":"cjwgkzqyw005hy4upqkthukpj","modified":0,"renderable":0},{"_id":"source/_posts/Gradle-构建工具详解/项目结构.png","slug":"项目结构.png","post":"cjwgkzqyw005hy4upqkthukpj","modified":0,"renderable":0},{"_id":"source/_posts/《剑指offer》题目-Java-实现/rebt.png","slug":"rebt.png","post":"cjwgkzqz1005ly4updts4qygw","modified":0,"renderable":0},{"_id":"source/_posts/《剑指offer》题目-Java-实现/翻转链表.png","slug":"翻转链表.png","post":"cjwgkzqz1005ly4updts4qygw","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/线程池流程.png","slug":"线程池流程.png","post":"cjwgkzqyv005gy4up42gdsjfa","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/线程状态1.png","slug":"线程状态1.png","post":"cjwgkzqyv005gy4up42gdsjfa","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/线程状态2.png","slug":"线程状态2.png","post":"cjwgkzqyv005gy4up42gdsjfa","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/继承图.png","slug":"继承图.png","post":"cjwgkzqyv005gy4up42gdsjfa","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjwgkzquj0001y4up8iprhb2p","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqv7000ey4uphup8i6oi"},{"post_id":"cjwgkzqup0003y4upjwhs1x46","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqva000iy4upryaquzp8"},{"post_id":"cjwgkzquu0006y4uppc9t873x","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqvc000ly4upleanw5m4"},{"post_id":"cjwgkzquw0007y4upvxnjqttm","category_id":"cjwgkzqva000hy4uphwzfh0dl","_id":"cjwgkzqvd000py4up2gkeni72"},{"post_id":"cjwgkzqv00008y4up8dihh18f","category_id":"cjwgkzqva000hy4uphwzfh0dl","_id":"cjwgkzqve000sy4up86ydvzw1"},{"post_id":"cjwgkzqv5000by4upbwybpjwm","category_id":"cjwgkzqvd000oy4up7j3pnk1o","_id":"cjwgkzqvg000xy4upew786g43"},{"post_id":"cjwgkzqv6000cy4upnizm40t7","category_id":"cjwgkzqvd000oy4up7j3pnk1o","_id":"cjwgkzqvh0010y4up1wxx3hcy"},{"post_id":"cjwgkzqw5001fy4upc9ink8ck","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqwc001ny4upfjsn3wnb"},{"post_id":"cjwgkzqw7001hy4upiqzjqqoo","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqwh001qy4upgov4wnov"},{"post_id":"cjwgkzqwa001ky4upbi8xvpnt","category_id":"cjwgkzqva000hy4uphwzfh0dl","_id":"cjwgkzqwj001uy4upalrzlaj4"},{"post_id":"cjwgkzqwb001my4up5nhqo8hz","category_id":"cjwgkzqva000hy4uphwzfh0dl","_id":"cjwgkzqwl001xy4upvltm0cqm"},{"post_id":"cjwgkzqwi001ty4upusfyycyp","category_id":"cjwgkzqvd000oy4up7j3pnk1o","_id":"cjwgkzqwo0022y4upswzjkr95"},{"post_id":"cjwgkzqwl001wy4uprq3tbvwe","category_id":"cjwgkzqvd000oy4up7j3pnk1o","_id":"cjwgkzqwr0027y4up0i3him6j"},{"post_id":"cjwgkzqwd001py4upte679ejp","category_id":"cjwgkzqwk001vy4upc2ez5i7d","_id":"cjwgkzqwt002ay4upw8taqww7"},{"post_id":"cjwgkzqwo0021y4ups0ns4b4l","category_id":"cjwgkzqwk001vy4upc2ez5i7d","_id":"cjwgkzqwv002ey4upke6uya4z"},{"post_id":"cjwgkzqwm001zy4upghesgt27","category_id":"cjwgkzqwp0025y4upf4qmfdro","_id":"cjwgkzqww002hy4upstauhqz0"},{"post_id":"cjwgkzqwq0026y4uppseh97dx","category_id":"cjwgkzqwv002dy4upxb2m863b","_id":"cjwgkzqwy002ny4upnaek2jt0"},{"post_id":"cjwgkzqws0029y4upzxcg01qz","category_id":"cjwgkzqwx002ky4upwbmklezj","_id":"cjwgkzqx1002sy4upyylan4jl"},{"post_id":"cjwgkzqxj003ay4up6ghy4259","category_id":"cjwgkzqvd000oy4up7j3pnk1o","_id":"cjwgkzqxp003hy4upeld9esu0"},{"post_id":"cjwgkzqxk003by4upk9fk9wgr","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqxr003ky4upw3p2c68g"},{"post_id":"cjwgkzqxm003dy4upg5p3y5bb","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqxt003oy4up4yjmsbfh"},{"post_id":"cjwgkzqxo003gy4up15ydtx0p","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqxv003sy4up21jpidtl"},{"post_id":"cjwgkzqxs003my4uppfhdga4n","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqxy003xy4upm23l5l1k"},{"post_id":"cjwgkzqxw003uy4upi7qyv0pc","category_id":"cjwgkzqwv002dy4upxb2m863b","_id":"cjwgkzqy30044y4uphxt5pkz0"},{"post_id":"cjwgkzqxq003jy4updovqjxck","category_id":"cjwgkzqxu003py4up8gimzk40","_id":"cjwgkzqy50048y4ups2et65jd"},{"post_id":"cjwgkzqxy003wy4upw0z9dyea","category_id":"cjwgkzqwv002dy4upxb2m863b","_id":"cjwgkzqy8004cy4upyqizzc5g"},{"post_id":"cjwgkzqxv003ry4upw1dmpgzv","category_id":"cjwgkzqxz003yy4upmbg71mgo","_id":"cjwgkzqya004fy4upiwpxls46"},{"post_id":"cjwgkzqy20043y4uptdn7bpia","category_id":"cjwgkzqur0004y4upfsidwc6g","_id":"cjwgkzqyb004iy4upmex9abyk"},{"post_id":"cjwgkzqy40047y4upy06toyoc","category_id":"cjwgkzqvd000oy4up7j3pnk1o","_id":"cjwgkzqyc004ly4up3a12kok8"},{"post_id":"cjwgkzqxz0040y4upvn33631d","category_id":"cjwgkzqy30046y4up7551bidq","_id":"cjwgkzqyc004my4upkf2dj5bv"},{"post_id":"cjwgkzqy9004ey4upf25lq8d0","category_id":"cjwgkzqwp0025y4upf4qmfdro","_id":"cjwgkzqyd004oy4up6mnsyxm3"},{"post_id":"cjwgkzqy7004by4upax1xywdg","category_id":"cjwgkzqya004gy4up8dgltsl9","_id":"cjwgkzqye004qy4uporc5d2sq"},{"post_id":"cjwgkzqyv005gy4up42gdsjfa","category_id":"cjwgkzqvd000oy4up7j3pnk1o","_id":"cjwgkzqz1005my4upjx80ev0u"},{"post_id":"cjwgkzqyz005jy4upbhz9ytpe","category_id":"cjwgkzqwv002dy4upxb2m863b","_id":"cjwgkzqz4005py4updjak0om1"},{"post_id":"cjwgkzqz1005ly4updts4qygw","category_id":"cjwgkzqwk001vy4upc2ez5i7d","_id":"cjwgkzqz4005ry4updz5ojcys"},{"post_id":"cjwgkzqyw005hy4upqkthukpj","category_id":"cjwgkzqz0005ky4upcrvzz2sj","_id":"cjwgkzqz5005uy4upp8aib41b"}],"PostTag":[{"post_id":"cjwgkzquj0001y4up8iprhb2p","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqv9000gy4upohj6hzh4"},{"post_id":"cjwgkzquj0001y4up8iprhb2p","tag_id":"cjwgkzqv1000ay4upvh5lv0hr","_id":"cjwgkzqvb000jy4upoql4gj1p"},{"post_id":"cjwgkzqup0003y4upjwhs1x46","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqve000ry4upny798jhy"},{"post_id":"cjwgkzqup0003y4upjwhs1x46","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqvf000uy4up45ceios7"},{"post_id":"cjwgkzqup0003y4upjwhs1x46","tag_id":"cjwgkzqvc000ny4up072me796","_id":"cjwgkzqvg000wy4up4r36ubf7"},{"post_id":"cjwgkzquu0006y4uppc9t873x","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqvh000zy4upwmn5wxfw"},{"post_id":"cjwgkzquu0006y4uppc9t873x","tag_id":"cjwgkzqvf000vy4uparv1if3m","_id":"cjwgkzqvi0011y4up3ntk8x8j"},{"post_id":"cjwgkzquw0007y4upvxnjqttm","tag_id":"cjwgkzqvh000yy4upzjc3r5p6","_id":"cjwgkzqvi0013y4up6sgxeit9"},{"post_id":"cjwgkzqv00008y4up8dihh18f","tag_id":"cjwgkzqvh000yy4upzjc3r5p6","_id":"cjwgkzqvk0016y4upo741w1e5"},{"post_id":"cjwgkzqv00008y4up8dihh18f","tag_id":"cjwgkzqvj0014y4upfwip8zwk","_id":"cjwgkzqvk0017y4up13x9bucs"},{"post_id":"cjwgkzqv5000by4upbwybpjwm","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqvl001ay4upbf9qvnz5"},{"post_id":"cjwgkzqv5000by4upbwybpjwm","tag_id":"cjwgkzqvj0014y4upfwip8zwk","_id":"cjwgkzqvl001by4up26rdvjll"},{"post_id":"cjwgkzqv6000cy4upnizm40t7","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqvm001dy4up3ofn59f6"},{"post_id":"cjwgkzqv6000cy4upnizm40t7","tag_id":"cjwgkzqvm001cy4uppyi0ygne","_id":"cjwgkzqvm001ey4upv5yqpzoi"},{"post_id":"cjwgkzqwb001my4up5nhqo8hz","tag_id":"cjwgkzqvh000yy4upzjc3r5p6","_id":"cjwgkzqwi001sy4upx7w5dbyn"},{"post_id":"cjwgkzqw5001fy4upc9ink8ck","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqwn0020y4upu56w4wx2"},{"post_id":"cjwgkzqw5001fy4upc9ink8ck","tag_id":"cjwgkzqw9001jy4upmnl0a6g3","_id":"cjwgkzqwp0023y4upz19ioqfe"},{"post_id":"cjwgkzqw5001fy4upc9ink8ck","tag_id":"cjwgkzqwh001ry4up0j1i63s3","_id":"cjwgkzqwr0028y4upx715423r"},{"post_id":"cjwgkzqw7001hy4upiqzjqqoo","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqwt002by4up9bvvj7ui"},{"post_id":"cjwgkzqw7001hy4upiqzjqqoo","tag_id":"cjwgkzqwm001yy4up4gq2m752","_id":"cjwgkzqwv002fy4upqu872mp4"},{"post_id":"cjwgkzqwa001ky4upbi8xvpnt","tag_id":"cjwgkzqvh000yy4upzjc3r5p6","_id":"cjwgkzqww002gy4up689y21ms"},{"post_id":"cjwgkzqwa001ky4upbi8xvpnt","tag_id":"cjwgkzqwp0024y4upv04es5e4","_id":"cjwgkzqwx002jy4upu806bd2u"},{"post_id":"cjwgkzqwd001py4upte679ejp","tag_id":"cjwgkzqwu002cy4upq4npa1pp","_id":"cjwgkzqwy002ly4upr4oova5c"},{"post_id":"cjwgkzqwd001py4upte679ejp","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqwy002my4upngbbjis9"},{"post_id":"cjwgkzqwi001ty4upusfyycyp","tag_id":"cjwgkzqwx002iy4upbxdd205h","_id":"cjwgkzqx0002py4up2dqcdxhr"},{"post_id":"cjwgkzqwi001ty4upusfyycyp","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqx0002qy4uphryvql8d"},{"post_id":"cjwgkzqwl001wy4uprq3tbvwe","tag_id":"cjwgkzqwx002iy4upbxdd205h","_id":"cjwgkzqx1002ty4upw3xee9xz"},{"post_id":"cjwgkzqwl001wy4uprq3tbvwe","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqx1002uy4upet0hdt6e"},{"post_id":"cjwgkzqwm001zy4upghesgt27","tag_id":"cjwgkzqx0002ry4upbn1q89mx","_id":"cjwgkzqx3002xy4upolt4k472"},{"post_id":"cjwgkzqwm001zy4upghesgt27","tag_id":"cjwgkzqx2002vy4upn49k41wg","_id":"cjwgkzqx4002yy4upq0t5237u"},{"post_id":"cjwgkzqwo0021y4ups0ns4b4l","tag_id":"cjwgkzqwu002cy4upq4npa1pp","_id":"cjwgkzqx50031y4up79mtvwzs"},{"post_id":"cjwgkzqwo0021y4ups0ns4b4l","tag_id":"cjwgkzqx4002zy4up6aeuqaf0","_id":"cjwgkzqx50032y4uph5gxroku"},{"post_id":"cjwgkzqwq0026y4uppseh97dx","tag_id":"cjwgkzqx50030y4up83ax8ekh","_id":"cjwgkzqx70035y4uptw6pd6el"},{"post_id":"cjwgkzqwq0026y4uppseh97dx","tag_id":"cjwgkzqx60033y4up4i5v9h8g","_id":"cjwgkzqx70036y4upt04k4qmu"},{"post_id":"cjwgkzqws0029y4upzxcg01qz","tag_id":"cjwgkzqx60034y4upnoa7t6sz","_id":"cjwgkzqx80038y4uperpn6kih"},{"post_id":"cjwgkzqws0029y4upzxcg01qz","tag_id":"cjwgkzqx80037y4up24nxb6hb","_id":"cjwgkzqx90039y4upckwms137"},{"post_id":"cjwgkzqxj003ay4up6ghy4259","tag_id":"cjwgkzqwx002iy4upbxdd205h","_id":"cjwgkzqxm003cy4upq4lv0cby"},{"post_id":"cjwgkzqxj003ay4up6ghy4259","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqxo003fy4upcqj0vbj2"},{"post_id":"cjwgkzqxm003dy4upg5p3y5bb","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqxq003iy4upjgxy30wm"},{"post_id":"cjwgkzqxm003dy4upg5p3y5bb","tag_id":"cjwgkzqvf000vy4uparv1if3m","_id":"cjwgkzqxs003ly4upzipe5kkc"},{"post_id":"cjwgkzqxk003by4upk9fk9wgr","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqxu003qy4upn10zjivx"},{"post_id":"cjwgkzqxk003by4upk9fk9wgr","tag_id":"cjwgkzqxn003ey4upbbmuhtfz","_id":"cjwgkzqxw003ty4upwytkfvp3"},{"post_id":"cjwgkzqxo003gy4up15ydtx0p","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqxz003zy4upvdvr51i3"},{"post_id":"cjwgkzqxo003gy4up15ydtx0p","tag_id":"cjwgkzqxt003ny4upueprwasd","_id":"cjwgkzqy10041y4up4l22f1xp"},{"post_id":"cjwgkzqxy003wy4upw0z9dyea","tag_id":"cjwgkzqx50030y4up83ax8ekh","_id":"cjwgkzqy30045y4up71dio93p"},{"post_id":"cjwgkzqy20043y4uptdn7bpia","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqy50049y4upcmaw7p7m"},{"post_id":"cjwgkzqy20043y4uptdn7bpia","tag_id":"cjwgkzqvj0014y4upfwip8zwk","_id":"cjwgkzqy9004dy4upj4iraa6c"},{"post_id":"cjwgkzqxq003jy4updovqjxck","tag_id":"cjwgkzqxx003vy4upqjquxgaq","_id":"cjwgkzqya004hy4up02uua69u"},{"post_id":"cjwgkzqxq003jy4updovqjxck","tag_id":"cjwgkzqy20042y4up7esat587","_id":"cjwgkzqyc004ky4upgcurs385"},{"post_id":"cjwgkzqxs003my4uppfhdga4n","tag_id":"cjwgkzqy6004ay4upi7pnjx7r","_id":"cjwgkzqyd004py4upwcw377cp"},{"post_id":"cjwgkzqxs003my4uppfhdga4n","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqye004ry4upl64vaz43"},{"post_id":"cjwgkzqxs003my4uppfhdga4n","tag_id":"cjwgkzqyb004jy4upgt5cnggt","_id":"cjwgkzqyf004ty4up5bqi47u4"},{"post_id":"cjwgkzqxv003ry4upw1dmpgzv","tag_id":"cjwgkzqyd004ny4upycwetk8u","_id":"cjwgkzqyf004uy4upqyvci209"},{"post_id":"cjwgkzqxw003uy4upi7qyv0pc","tag_id":"cjwgkzqx50030y4up83ax8ekh","_id":"cjwgkzqyf004wy4upilg9i656"},{"post_id":"cjwgkzqxw003uy4upi7qyv0pc","tag_id":"cjwgkzqye004sy4uprf6dgoi7","_id":"cjwgkzqyg004xy4up0xml14pk"},{"post_id":"cjwgkzqxz0040y4upvn33631d","tag_id":"cjwgkzqyf004vy4upj9fj1al9","_id":"cjwgkzqyh0051y4upj2xk5coy"},{"post_id":"cjwgkzqxz0040y4upvn33631d","tag_id":"cjwgkzqyg004yy4up4r59a80w","_id":"cjwgkzqyi0052y4up9kpirdeb"},{"post_id":"cjwgkzqxz0040y4upvn33631d","tag_id":"cjwgkzqyg004zy4upxiqp8x3k","_id":"cjwgkzqyi0054y4up84lgehp3"},{"post_id":"cjwgkzqy40047y4upy06toyoc","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqyi0055y4uplo2938wg"},{"post_id":"cjwgkzqy40047y4upy06toyoc","tag_id":"cjwgkzqyh0050y4upyldo41kb","_id":"cjwgkzqyj0057y4upnpcg68fx"},{"post_id":"cjwgkzqy7004by4upax1xywdg","tag_id":"cjwgkzqyi0053y4upgh74xay8","_id":"cjwgkzqyk005ay4up28xiymtl"},{"post_id":"cjwgkzqy7004by4upax1xywdg","tag_id":"cjwgkzqyj0056y4upnr6m91hp","_id":"cjwgkzqyk005by4up2a7fn0so"},{"post_id":"cjwgkzqy7004by4upax1xywdg","tag_id":"cjwgkzqyj0058y4uptwgco3ux","_id":"cjwgkzqyl005dy4upblzsgp5t"},{"post_id":"cjwgkzqy9004ey4upf25lq8d0","tag_id":"cjwgkzqyk0059y4uppcykb3d4","_id":"cjwgkzqym005ey4up2bgvc2hg"},{"post_id":"cjwgkzqy9004ey4upf25lq8d0","tag_id":"cjwgkzqyk005cy4upglfjjpr5","_id":"cjwgkzqym005fy4upale9awr9"},{"post_id":"cjwgkzqz1005ly4updts4qygw","tag_id":"cjwgkzqwu002cy4upq4npa1pp","_id":"cjwgkzqz4005oy4uprle6zsaw"},{"post_id":"cjwgkzqz1005ly4updts4qygw","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqz4005qy4up3lytvzhn"},{"post_id":"cjwgkzqyv005gy4up42gdsjfa","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqz5005ty4up6iqpph39"},{"post_id":"cjwgkzqyv005gy4up42gdsjfa","tag_id":"cjwgkzqvc000ny4up072me796","_id":"cjwgkzqz5005vy4upd1ooqeoq"},{"post_id":"cjwgkzqyv005gy4up42gdsjfa","tag_id":"cjwgkzqyy005iy4upvkcjoq4f","_id":"cjwgkzqz6005xy4up1l6h8mkr"},{"post_id":"cjwgkzqyw005hy4upqkthukpj","tag_id":"cjwgkzqz3005ny4upfse0rutl","_id":"cjwgkzqz7005zy4uppfru46uj"},{"post_id":"cjwgkzqyw005hy4upqkthukpj","tag_id":"cjwgkzqz4005sy4upo1h22yaa","_id":"cjwgkzqz70060y4upoqk7cfg9"},{"post_id":"cjwgkzqyw005hy4upqkthukpj","tag_id":"cjwgkzqz6005wy4upl4b68q1d","_id":"cjwgkzqz70062y4upa8tixiep"},{"post_id":"cjwgkzqyw005hy4upqkthukpj","tag_id":"cjwgkzqut0005y4upp6jcymzi","_id":"cjwgkzqz70063y4upb27lv8x2"},{"post_id":"cjwgkzqyw005hy4upqkthukpj","tag_id":"cjwgkzqvb000ky4upmtoqy4vi","_id":"cjwgkzqz80064y4up69o9d9gv"},{"post_id":"cjwgkzqyz005jy4upbhz9ytpe","tag_id":"cjwgkzqx50030y4up83ax8ekh","_id":"cjwgkzqz80065y4uprkxurvyo"},{"post_id":"cjwgkzqyz005jy4upbhz9ytpe","tag_id":"cjwgkzqz6005yy4upq6mpcpen","_id":"cjwgkzqz80066y4upovfc0dbo"},{"post_id":"cjwgkzqyz005jy4upbhz9ytpe","tag_id":"cjwgkzqye004sy4uprf6dgoi7","_id":"cjwgkzqz80067y4upnbcl8ryk"},{"post_id":"cjwgkzqyz005jy4upbhz9ytpe","tag_id":"cjwgkzqz70061y4upvs6obqy1","_id":"cjwgkzqz90068y4upxb89i77o"}],"Tag":[{"name":"Android","_id":"cjwgkzqut0005y4upp6jcymzi"},{"name":"Binder","_id":"cjwgkzqv1000ay4upvh5lv0hr"},{"name":"Java","_id":"cjwgkzqvb000ky4upmtoqy4vi"},{"name":"多线程","_id":"cjwgkzqvc000ny4up072me796"},{"name":"View","_id":"cjwgkzqvf000vy4uparv1if3m"},{"name":"Dart","_id":"cjwgkzqvh000yy4upzjc3r5p6"},{"name":"反射","_id":"cjwgkzqvj0014y4upfwip8zwk"},{"name":"数据库","_id":"cjwgkzqvm001cy4uppyi0ygne"},{"name":"LRU","_id":"cjwgkzqw9001jy4upmnl0a6g3"},{"name":"缓存","_id":"cjwgkzqwh001ry4up0j1i63s3"},{"name":"Handler","_id":"cjwgkzqwm001yy4up4gq2m752"},{"name":"异步","_id":"cjwgkzqwp0024y4upv04es5e4"},{"name":"算法","_id":"cjwgkzqwu002cy4upq4npa1pp"},{"name":"设计模式","_id":"cjwgkzqwx002iy4upbxdd205h"},{"name":"GitHub","_id":"cjwgkzqx0002ry4upbn1q89mx"},{"name":"Hexo","_id":"cjwgkzqx2002vy4upn49k41wg"},{"name":"LeetCode","_id":"cjwgkzqx4002zy4up6aeuqaf0"},{"name":"Spring","_id":"cjwgkzqx50030y4up83ax8ekh"},{"name":"Web","_id":"cjwgkzqx60033y4up4i5v9h8g"},{"name":"随笔","_id":"cjwgkzqx60034y4upnoa7t6sz"},{"name":"诗歌","_id":"cjwgkzqx80037y4up24nxb6hb"},{"name":"多进程通信","_id":"cjwgkzqxn003ey4upbbmuhtfz"},{"name":"动画开发","_id":"cjwgkzqxt003ny4upueprwasd"},{"name":"Kotlin","_id":"cjwgkzqxx003vy4upqjquxgaq"},{"name":"委托属性","_id":"cjwgkzqy20042y4up7esat587"},{"name":"内存泄漏","_id":"cjwgkzqy6004ay4upi7pnjx7r"},{"name":"源码","_id":"cjwgkzqyb004jy4upgt5cnggt"},{"name":"Markdown","_id":"cjwgkzqyd004ny4upycwetk8u"},{"name":"AOP","_id":"cjwgkzqye004sy4uprf6dgoi7"},{"name":"文学","_id":"cjwgkzqyf004vy4upj9fj1al9"},{"name":"笔记","_id":"cjwgkzqyg004yy4up4r59a80w"},{"name":"红楼梦","_id":"cjwgkzqyg004zy4upxiqp8x3k"},{"name":"数据结构","_id":"cjwgkzqyh0050y4upyldo41kb"},{"name":"音乐","_id":"cjwgkzqyi0053y4upgh74xay8"},{"name":"巴洛克","_id":"cjwgkzqyj0056y4upnr6m91hp"},{"name":"巴赫","_id":"cjwgkzqyj0058y4uptwgco3ux"},{"name":"翻墙","_id":"cjwgkzqyk0059y4uppcykb3d4"},{"name":"互联网","_id":"cjwgkzqyk005cy4upglfjjpr5"},{"name":"线程池","_id":"cjwgkzqyy005iy4upvkcjoq4f"},{"name":"Gradle","_id":"cjwgkzqz3005ny4upfse0rutl"},{"name":"构建工具","_id":"cjwgkzqz4005sy4upo1h22yaa"},{"name":"Groovy","_id":"cjwgkzqz6005wy4upl4b68q1d"},{"name":"DI","_id":"cjwgkzqz6005yy4upq6mpcpen"},{"name":"Java EE","_id":"cjwgkzqz70061y4upvs6obqy1"}]}}