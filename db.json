{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1514806390000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1514806390000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1514806390000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1514806390000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1514806390000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1514806390000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1514806390000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1514806390000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1514806390000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1514806390000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1514806390000},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1514806390000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1514806390000},{"_id":"themes/next/_config.yml","hash":"97e8b78d9536cfe21a33d5f7f486576a4f82f44b","modified":1553959696000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1514806390000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1514806390000},{"_id":"source/categories/index.md","hash":"ec919064ec63dd78207bee18e4723073f9f0fb0f","modified":1547225098000},{"_id":"source/_posts/Android-Binder-源码解析.md","hash":"f6df5dc68c070a2192f235922794d5295d85d4ed","modified":1553314734000},{"_id":"source/_posts/Android-IPC-机制详解.md","hash":"923ac2c0ba8afb46d6a7684433643e5939495a0a","modified":1553316790000},{"_id":"source/_posts/Android-LruCache-缓存详解.md","hash":"91c23a6be7b94d8e41421ff8bc8acc757ffc92b2","modified":1552794212000},{"_id":"source/_posts/Android-动画详解.md","hash":"03a1e0631ea8341ca6143ff9da5c1e6e2781ce8a","modified":1552663724000},{"_id":"source/_posts/Android-View-的工作原理.md","hash":"16e0900b24be2342e7d45a7ae07c6ff6e11ffc83","modified":1552717336000},{"_id":"source/_posts/Android-多线程技术.md","hash":"b836f29fe5da6f7e2c0ed43ff1cacd0f370ccc15","modified":1552797826000},{"_id":"source/_posts/Dart笔记（一）：基本语法和数据类型.md","hash":"a655ab199748b00d217489a5ab5feef84af6ccec","modified":1555927762000},{"_id":"source/_posts/Android-消息机制详解.md","hash":"7ff54d5e38938a5f85966e39c399afb50fe4e0ed","modified":1552794596000},{"_id":"source/_posts/Github-Pages-Hexo搭建个人博客.md","hash":"4d3d49dad82566780b00388bc2f16aa3dfefc542","modified":1552665850000},{"_id":"source/_posts/Java-反射详解.md","hash":"72203410a213ac0150c94364d45ebe3d57a440b6","modified":1552790876000},{"_id":"source/_posts/Java-排序算法.md","hash":"66df511827bee1e1524fe4e72c388ad414483dd1","modified":1552665198000},{"_id":"source/_posts/Java-数据库知识整理.md","hash":"467bfdc9f5654664744eee65e0b535f80c408780","modified":1552877128000},{"_id":"source/_posts/Java-线程和线程池详解.md","hash":"8f4ec7a91855a551ff55215667f4af05c4ceb2fd","modified":1553162528000},{"_id":"source/_posts/Java设计模式：创建型模式.md","hash":"30634f1895fd6a78f837509544a22fb8e3256e32","modified":1552663676000},{"_id":"source/_posts/Java设计模式：结构型模式.md","hash":"996d65a0e4736c5bbb783216335146f5aefedc7f","modified":1552663652000},{"_id":"source/_posts/LeakCanary源码解析.md","hash":"aa52a8916c38f8e23def3dc7ac012a5f2f706241","modified":1552663626000},{"_id":"source/_posts/Java设计模式：行为型模式.md","hash":"2e9aef0d23cedf22dc9baa3202ca1d41de2b53e3","modified":1552663666000},{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法.md","hash":"9ea33c7070a7884af1a3d948e3b8e39ee7eac400","modified":1552663600000},{"_id":"source/_posts/《剑指offer》题目-Java-实现.md","hash":"4b63457e80bf290463bd1b63de04a98d261d4c88","modified":1553505426000},{"_id":"source/_posts/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》.md","hash":"94869df9ee34fbf407004c645043bc7f382c12d8","modified":1552663580000},{"_id":"source/_posts/基本数据结构的简单Java实现.md","hash":"b21c4d9ef26afc877f5ef97b3559940d5da0121e","modified":1552747226000},{"_id":"source/_posts/坐过山车的人.md","hash":"d333a4cfc97459b9ece3eacd9b2e33e82cbd0b15","modified":1552663522000},{"_id":"source/_posts/翻越GFW记.md","hash":"54dda9535df354ceb37634a3ec6e3edaf11c22fb","modified":1552663546000},{"_id":"source/tags/index.md","hash":"f852c5b4f0b945cd2fc74d3bdb87cb37964d6a03","modified":1552664794000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1514806390000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1514806390000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1514806390000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1514806390000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1514806390000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1514806390000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1514806390000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1514806390000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1514806390000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1514806390000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1514806390000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1514806390000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1514806390000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1514806390000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1514806390000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1514806390000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1514806390000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1514806390000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1514806390000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1514806390000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1514806390000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1514806390000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1514806390000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1514806390000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1514806390000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1514806390000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1514806390000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1514806390000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1514806390000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1514806390000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1514806390000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1514806390000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1514806390000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"source/_posts/Android-消息机制详解/消息流程图.jpg","hash":"f9d3d2d0f3db61e333627904b0ff271c3101f69c","modified":1552713678000},{"_id":"source/_posts/Java-线程和线程池详解/线程池流程.png","hash":"69fd1b5147720b08181d86c974a6665291a9d955","modified":1553161474000},{"_id":"source/_posts/Java-线程和线程池详解/线程状态1.png","hash":"800238efba01bcddd8c73f7dea2aea47c2c7598a","modified":1553161040000},{"_id":"source/_posts/Java-线程和线程池详解/继承图.png","hash":"27658f399a862ef867bc1cc81def896bf3840614","modified":1553071334000},{"_id":"source/_posts/Java设计模式：创建型模式/工厂方法.jpg","hash":"45d94d745f90e7cf75056fdd16728670d942a993","modified":1552354506000},{"_id":"source/_posts/Java设计模式：创建型模式/抽象工厂.jpg","hash":"e64d7c7297a60b86aa678a046f376e20f77a69cf","modified":1552354506000},{"_id":"source/_posts/Java设计模式：创建型模式/简单工厂.jpg","hash":"076bb6f2a96ac7086129a9f5f01a567b13cbe81c","modified":1552354506000},{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png","hash":"7008b7b5185e554ed4af858996d5a2c7f5433d5f","modified":1547287346000},{"_id":"source/_posts/《剑指offer》题目-Java-实现/rebt.png","hash":"45137b4701b658acb58103aa7539913bf517c753","modified":1552894066000},{"_id":"source/_posts/《剑指offer》题目-Java-实现/翻转链表.png","hash":"4bca505073c7d4fd05511298f61ddf917b0a38d6","modified":1553483904000},{"_id":"source/_posts/基本数据结构的简单Java实现/二叉搜索树.png","hash":"a86203a32532d499793f076453363c16efc424ff","modified":1552747382000},{"_id":"source/_posts/翻越GFW记/GFW存在后的连接方式.png","hash":"6062a7474e26fd92ad2bbbcfa854409c64c621b9","modified":1547352940000},{"_id":"source/_posts/翻越GFW记/GFW内部结构.jpg","hash":"1b4b3287216eb9d2d543b6075630482b2c14a789","modified":1547352958000},{"_id":"source/_posts/翻越GFW记/SSH连接方式.png","hash":"4613fcc1932182816aa1734354cca2e2e2f87fc7","modified":1547352970000},{"_id":"source/_posts/翻越GFW记/原始连接方式.png","hash":"a18e72d5ed67fbaddc9736039df9c7168fd98544","modified":1547352922000},{"_id":"source/_posts/翻越GFW记/SS连接方式.png","hash":"5189639e3bb1beaa834d1cd2a10a113858015410","modified":1547352980000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806390000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1514806390000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1514806390000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806390000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1514806390000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1514806390000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1514806390000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1514806390000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1514806390000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1514806390000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1514806390000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1514806390000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1514806390000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1514806390000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1514806390000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1514806390000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1514806390000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1514806390000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1514806390000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1514806390000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1514806390000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1514806390000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1514806390000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1514806390000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1514806390000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1514806390000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1514806390000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1514806390000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1514806390000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1514806390000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1514806390000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1514806390000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1514806390000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1514806390000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1514806390000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1514806390000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514806390000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1514806390000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1514806390000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514806390000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1514806390000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1514806390000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806390000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514806390000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806390000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1514806390000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1514806390000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1514806390000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514806390000},{"_id":"source/_posts/Java-线程和线程池详解/线程状态2.png","hash":"28e11bf820c48dba6211483af7822d2f7028847c","modified":1553161052000},{"_id":"source/_posts/Java设计模式：创建型模式/设计模式之间的关系.jpg","hash":"5533c4baa4a9ee3e2315d805f40f42fe7d4af6ce","modified":1552354506000},{"_id":"source/_posts/基本数据结构的简单Java实现/HashMap.png","hash":"5a39016f1245a3bbe61f00728f4d289055751318","modified":1552745558000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806390000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1514806390000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806390000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1514806390000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806390000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1514806390000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1514806390000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1514806390000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1514806390000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1514806390000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1514806390000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1514806390000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1514806390000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1514806390000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1514806390000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1514806390000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514806390000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514806390000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514806390000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514806390000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514806390000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514806390000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1514806390000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514806390000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514806390000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514806390000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1514806390000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514806390000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1514806390000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1514806390000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514806390000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514806390000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514806390000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514806390000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514806390000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514806390000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514806390000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514806390000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514806390000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1514806390000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1514806390000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1514806390000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1514806390000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514806390000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514806390000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514806390000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514806390000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1514806390000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806390000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514806390000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514806390000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514806390000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514806390000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514806390000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514806390000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1514806390000},{"_id":"source/_posts/Dart笔记（一）：基本语法和数据类型/idea_category.png","hash":"d831a1565d741a9e1025ffc4a3160f495f9e219e","modified":1555915508000},{"_id":"source/_posts/Dart笔记（一）：基本语法和数据类型/idea_create.png","hash":"728ab0225ad56c3c89550fe6d2b47474d8e5e35f","modified":1555915472000},{"_id":"source/_posts/Dart笔记（一）：基本语法和数据类型/dart_core.png","hash":"4a35f81f0ba0d0f745140191d0bc0dc5113be823","modified":1555916080000},{"_id":"source/_posts/Dart 笔记之基本语法和数据类型/idea_category.png","hash":"d831a1565d741a9e1025ffc4a3160f495f9e219e","modified":1555915508000},{"_id":"source/_posts/Dart 笔记之基本语法和数据类型/idea_create.png","hash":"728ab0225ad56c3c89550fe6d2b47474d8e5e35f","modified":1555915472000},{"_id":"source/_posts/Dart 笔记之基本语法和数据类型/dart_core.png","hash":"4a35f81f0ba0d0f745140191d0bc0dc5113be823","modified":1555916080000}],"Category":[{"name":"Android","_id":"cjurzavac0005i0upi8a26yrh"},{"name":"互联网","_id":"cjurzavaq000ei0uptqgz8kkv"},{"name":"Java","_id":"cjurzavau000mi0upadlalb6s"},{"name":"算法","_id":"cjurzavaw000ri0upr54z8lg3"},{"name":"随笔","_id":"cjurzavax000xi0up6zthqbqs"},{"name":"艺术","_id":"cjurzavce0024i0up2rxtjlxv"},{"name":"Dart","_id":"cjurze33s003ji0upr7wjlg7i"}],"Data":[],"Page":[{"title":"categories","date":"2019-01-11T16:43:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-01-12 00:43:43\ntype: \"categories\"\n---\n","updated":"2019-01-11T16:44:58.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjurzava00000i0upfwwbr30b","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","date":"2019-03-15T15:33:56.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ndate: 2019-03-15 23:33:56\n---\n","updated":"2019-03-15T15:46:34.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjurzava60002i0upo00zywbk","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Android Binder 源码解析","date":"2019-03-23T04:18:53.000Z","_content":"","source":"_posts/Android-Binder-源码解析.md","raw":"---\ntitle: Android Binder 源码解析\ndate: 2019-03-23 12:18:53\ntags:\n---\n","slug":"Android-Binder-源码解析","published":1,"updated":"2019-03-23T04:18:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzava10001i0upjv91v3ht","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Android View 的工作原理","date":"2019-03-01T05:10:14.000Z","_content":"\n## 引言\n<!--more-->\n## 工作原理\n\n## ViewRoot 和 DecorView\n\n## MeasureSpec\n\n## 工作流程\n\n### measure 过程\n### layout 过程\n### draw 过程\n\n## 自定义 View","source":"_posts/Android-View-的工作原理.md","raw":"---\ntitle: Android View 的工作原理\ndate: 2019-03-01 13:10:14\ntags:\n- Android \n- View\ncategories:\n- Android\n---\n\n## 引言\n<!--more-->\n## 工作原理\n\n## ViewRoot 和 DecorView\n\n## MeasureSpec\n\n## 工作流程\n\n### measure 过程\n### layout 过程\n### draw 过程\n\n## 自定义 View","slug":"Android-View-的工作原理","published":1,"updated":"2019-03-16T06:22:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzava70003i0upupxbn0i2","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><a id=\"more\"></a>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h2 id=\"ViewRoot-和-DecorView\"><a href=\"#ViewRoot-和-DecorView\" class=\"headerlink\" title=\"ViewRoot 和 DecorView\"></a>ViewRoot 和 DecorView</h2><h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><h3 id=\"measure-过程\"><a href=\"#measure-过程\" class=\"headerlink\" title=\"measure 过程\"></a>measure 过程</h3><h3 id=\"layout-过程\"><a href=\"#layout-过程\" class=\"headerlink\" title=\"layout 过程\"></a>layout 过程</h3><h3 id=\"draw-过程\"><a href=\"#draw-过程\" class=\"headerlink\" title=\"draw 过程\"></a>draw 过程</h3><h2 id=\"自定义-View\"><a href=\"#自定义-View\" class=\"headerlink\" title=\"自定义 View\"></a>自定义 View</h2>","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2>","more":"<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h2 id=\"ViewRoot-和-DecorView\"><a href=\"#ViewRoot-和-DecorView\" class=\"headerlink\" title=\"ViewRoot 和 DecorView\"></a>ViewRoot 和 DecorView</h2><h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><h3 id=\"measure-过程\"><a href=\"#measure-过程\" class=\"headerlink\" title=\"measure 过程\"></a>measure 过程</h3><h3 id=\"layout-过程\"><a href=\"#layout-过程\" class=\"headerlink\" title=\"layout 过程\"></a>layout 过程</h3><h3 id=\"draw-过程\"><a href=\"#draw-过程\" class=\"headerlink\" title=\"draw 过程\"></a>draw 过程</h3><h2 id=\"自定义-View\"><a href=\"#自定义-View\" class=\"headerlink\" title=\"自定义 View\"></a>自定义 View</h2>"},{"title":"Android 多线程技术","date":"2019-03-17T03:56:59.000Z","_content":"\n多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。<!--more--> \n\n","source":"_posts/Android-多线程技术.md","raw":"---\ntitle: Android 多线程技术\ndate: 2019-03-17 11:56:59\ntags:\n- Android\n- Java \n- 多线程\ncategories:\n- Android\n---\n\n多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。<!--more--> \n\n","slug":"Android-多线程技术","published":1,"updated":"2019-03-17T04:43:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavab0004i0upkkct6gkx","content":"<p>多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。<a id=\"more\"></a> </p>\n","site":{"data":{}},"excerpt":"<p>多线程技术一直是软件开发中的重点，本文将介绍 Java 中的线程和线程池使用，然后再详细分析 Android 中的多线程机制，包括 AsyncTask、IntentService 以及 HandlerThread 等等。</p>","more":"<p></p>"},{"title":"Github Pages+Hexo搭建个人博客","date":"2019-01-11T15:22:07.000Z","_content":"\n## 引言\n\n&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<!--more-->\n\n&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。\n\n## 准备工作\n\n### Github Pages\n\n&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为`{账户名}.github.io`，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：`https://{账户名}.github.io`便可以看到缺省的界面。\n\n### Hexo\n\n&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：\n- 安装Git客户端，前往Git主页下载，安装后登录帐号。\n- 安装Node.js环境，前往Node主页下载。\n- 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：\n```\nnpm install -g hexo-cli\n```\n\n- 初始化Hexo，`projectname`省略时，要求当前文件夹为空。\n```\nhexo init [projectname]\n```\n\n## 关联\n\n&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。\n在博客的文件夹中有`_config.yml`文件，为Hexo的配置文件，打开并将相应位置设置为：\n```\ndeploy: \ntype: git\nrepo: 该处填写仓库的完整路径\nbranch: master\n```\n该过程其实是给`hexo d`这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。\n保存文件之后，安装Git部署插件，在Git Bash中键入命令：\n```\nnpm install hexo-deployer-git --save\n```\n\n接下来就是清除hexo缓存：\n```\nhexo clean \n```\n\n生成静态文件\n```\nhexo g\n```\n\n部署网站，d的意思是deploy\n\n```\nhexo d\n```\n\n后两个命令可以合并为一条，关于Hexo的命令请访问：[Hexo指令](https://hexo.io/zh-cn/docs/commands.html)。\n\n```\nhexo g -d\n```\n\n&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入`https://{账户名}.github.io`，发现打开了一个使用Hexo搭建的Github Pages博客。\n\n## 配置\n\n&emsp;&emsp;博客文件夹下的`_config.yml`文件可以配置整个博客的名称、主题等基本功能，`/theme/`文件夹下的`_config.yml`文件则用于配置具体的主题配置。\n\n### 发表与删除\n\n&emsp;&emsp;在博客文件夹打开Git Bash，键入\n\n```\nhexo n \"文章的标题\"\n```\n\n之后便会生成一个md文件，在md文件中编辑文章保存，然后键入`hexo g -d`便会发布文章。\n\n&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。\n\n### 主题\n\n&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：[有哪些好看的 Hexo主题](https://www.zhihu.com/question/24422335)。笔者使用的是[NexT](https://github.com/iissnan/hexo-theme-next)。\n\n&emsp;&emsp;在博客文件夹下的`_config.yml`文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客`_config.yml`文件的更改，保存片刻即生效。\n\n### 域名绑定\n\n&emsp;&emsp;具体过程如下：\n- 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，`{账户名}.github.io`的IP地址，还有一个的记录类型为`CNAME`，记录值为：`{账户名}.github.io`。\n- 进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。\n- 进入博客文件夹中的`/source/`，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为**所有文件**，名称为**CNAME**。\n\n## 备份与恢复\n\n&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。\n\n### 备份\n\n&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:\n- 新建一个分支，如hexo，并将其设置为默认\n- 本地clone你的Github Pages仓库，得到一个io文件夹：`{账户名}.github.io`的文件夹。\n- 将原来博客文件夹中的`_config.yml，themes/，source/，scffolds/，package.json，.gitignore`复制到clone下来的文件夹，注意要将`theme/`主题的`.git/`删除。\n- 在clone下的文件夹执行`npm install`，`npm install hexo-deployer-git`。\n\n此时`{账户名}.github.io`文件夹已经成为包含你博客所有文件的工作文件夹，在部署(`hexo g -d`)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:\n```\ngit add .\ngit commit -m \"更新源文件\"\ngit push origin hexo\n```\n\n这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。\n\n### 恢复\n\n&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:\n- clone你的Github Pages仓库，得到一个io文件夹。\n- 在文件夹中打开Git Bash，键入以下命令:\n```\nnpm install hexo-cli -g\nnpm install \nnpm install hexo-deployer-git \n```\n现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。\n\n如果在拉取过程中提示本地分支与远程仓库冲突，可以使用`git reset --hard`命令重置之后再次pull。如果提示\n> The following untracked working tree files would be overwritten by merge\n\n可以使用`git clean -d -fx`，关于该命令\n\n> git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。\n git clean -f            //该命令会移除所有上一条命令中显示的文件。\n git clean -fd           //移除文件夹，使用选项-d。\n git clean -fX           //只想移除已被忽略的文件，使用选项-X。\n git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。\n\n## Hexo各文件（夹）说明\n\n- _config.yml：站点的配置文件，备份过程中需要拷贝；\n- themes/：主题文件夹，需要拷贝；\n- source：博客文章的.md文件，需要拷贝；\n- scaffolds/：文章的模板，需要拷贝；\n- package.json：安装包的名称，需要拷贝；\n-  .gitignore：限定在push时哪些文件可以忽略，需要拷贝；\n-  .git/：主题和站点都有，标志这是一个git项目，不需要拷贝；\n- node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；\n- public：hexo g生成的静态网页，不需要拷贝；\n-  .deploy_git：同上，hexo g也会生成，不需要拷贝；\n- db.json：文件，不需要拷贝。","source":"_posts/Github-Pages-Hexo搭建个人博客.md","raw":"---\ntitle: Github Pages+Hexo搭建个人博客\ndate: 2019-01-11 23:22:07\ntags:\n- GitHub\n- Hexo\ncategories: \n- 互联网\n---\n\n## 引言\n\n&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<!--more-->\n\n&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。\n\n## 准备工作\n\n### Github Pages\n\n&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为`{账户名}.github.io`，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：`https://{账户名}.github.io`便可以看到缺省的界面。\n\n### Hexo\n\n&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：\n- 安装Git客户端，前往Git主页下载，安装后登录帐号。\n- 安装Node.js环境，前往Node主页下载。\n- 安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：\n```\nnpm install -g hexo-cli\n```\n\n- 初始化Hexo，`projectname`省略时，要求当前文件夹为空。\n```\nhexo init [projectname]\n```\n\n## 关联\n\n&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。\n在博客的文件夹中有`_config.yml`文件，为Hexo的配置文件，打开并将相应位置设置为：\n```\ndeploy: \ntype: git\nrepo: 该处填写仓库的完整路径\nbranch: master\n```\n该过程其实是给`hexo d`这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。\n保存文件之后，安装Git部署插件，在Git Bash中键入命令：\n```\nnpm install hexo-deployer-git --save\n```\n\n接下来就是清除hexo缓存：\n```\nhexo clean \n```\n\n生成静态文件\n```\nhexo g\n```\n\n部署网站，d的意思是deploy\n\n```\nhexo d\n```\n\n后两个命令可以合并为一条，关于Hexo的命令请访问：[Hexo指令](https://hexo.io/zh-cn/docs/commands.html)。\n\n```\nhexo g -d\n```\n\n&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入`https://{账户名}.github.io`，发现打开了一个使用Hexo搭建的Github Pages博客。\n\n## 配置\n\n&emsp;&emsp;博客文件夹下的`_config.yml`文件可以配置整个博客的名称、主题等基本功能，`/theme/`文件夹下的`_config.yml`文件则用于配置具体的主题配置。\n\n### 发表与删除\n\n&emsp;&emsp;在博客文件夹打开Git Bash，键入\n\n```\nhexo n \"文章的标题\"\n```\n\n之后便会生成一个md文件，在md文件中编辑文章保存，然后键入`hexo g -d`便会发布文章。\n\n&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。\n\n### 主题\n\n&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：[有哪些好看的 Hexo主题](https://www.zhihu.com/question/24422335)。笔者使用的是[NexT](https://github.com/iissnan/hexo-theme-next)。\n\n&emsp;&emsp;在博客文件夹下的`_config.yml`文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客`_config.yml`文件的更改，保存片刻即生效。\n\n### 域名绑定\n\n&emsp;&emsp;具体过程如下：\n- 需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，`{账户名}.github.io`的IP地址，还有一个的记录类型为`CNAME`，记录值为：`{账户名}.github.io`。\n- 进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。\n- 进入博客文件夹中的`/source/`，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为**所有文件**，名称为**CNAME**。\n\n## 备份与恢复\n\n&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。\n\n### 备份\n\n&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:\n- 新建一个分支，如hexo，并将其设置为默认\n- 本地clone你的Github Pages仓库，得到一个io文件夹：`{账户名}.github.io`的文件夹。\n- 将原来博客文件夹中的`_config.yml，themes/，source/，scffolds/，package.json，.gitignore`复制到clone下来的文件夹，注意要将`theme/`主题的`.git/`删除。\n- 在clone下的文件夹执行`npm install`，`npm install hexo-deployer-git`。\n\n此时`{账户名}.github.io`文件夹已经成为包含你博客所有文件的工作文件夹，在部署(`hexo g -d`)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:\n```\ngit add .\ngit commit -m \"更新源文件\"\ngit push origin hexo\n```\n\n这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。\n\n### 恢复\n\n&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:\n- clone你的Github Pages仓库，得到一个io文件夹。\n- 在文件夹中打开Git Bash，键入以下命令:\n```\nnpm install hexo-cli -g\nnpm install \nnpm install hexo-deployer-git \n```\n现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。\n\n如果在拉取过程中提示本地分支与远程仓库冲突，可以使用`git reset --hard`命令重置之后再次pull。如果提示\n> The following untracked working tree files would be overwritten by merge\n\n可以使用`git clean -d -fx`，关于该命令\n\n> git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。\n git clean -f            //该命令会移除所有上一条命令中显示的文件。\n git clean -fd           //移除文件夹，使用选项-d。\n git clean -fX           //只想移除已被忽略的文件，使用选项-X。\n git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。\n\n## Hexo各文件（夹）说明\n\n- _config.yml：站点的配置文件，备份过程中需要拷贝；\n- themes/：主题文件夹，需要拷贝；\n- source：博客文章的.md文件，需要拷贝；\n- scaffolds/：文章的模板，需要拷贝；\n- package.json：安装包的名称，需要拷贝；\n-  .gitignore：限定在push时哪些文件可以忽略，需要拷贝；\n-  .git/：主题和站点都有，标志这是一个git项目，不需要拷贝；\n- node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；\n- public：hexo g生成的静态网页，不需要拷贝；\n-  .deploy_git：同上，hexo g也会生成，不需要拷贝；\n- db.json：文件，不需要拷贝。","slug":"Github-Pages-Hexo搭建个人博客","published":1,"updated":"2019-03-15T16:04:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavag0008i0upuqnzyt6o","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。<a id=\"more\"></a></p>\n<p>&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为<code>{账户名}.github.io</code>，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：<code>https://{账户名}.github.io</code>便可以看到缺省的界面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：</p>\n<ul>\n<li>安装Git客户端，前往Git主页下载，安装后登录帐号。</li>\n<li>安装Node.js环境，前往Node主页下载。</li>\n<li><p>安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化Hexo，<code>projectname</code>省略时，要求当前文件夹为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init [projectname]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h2><p>&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。<br>在博客的文件夹中有<code>_config.yml</code>文件，为Hexo的配置文件，打开并将相应位置设置为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy: </span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: 该处填写仓库的完整路径</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure></p>\n<p>该过程其实是给<code>hexo d</code>这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。<br>保存文件之后，安装Git部署插件，在Git Bash中键入命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>接下来就是清除hexo缓存：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure></p>\n<p>生成静态文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<p>部署网站，d的意思是deploy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>后两个命令可以合并为一条，关于Hexo的命令请访问：<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">Hexo指令</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入<code>https://{账户名}.github.io</code>，发现打开了一个使用Hexo搭建的Github Pages博客。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>&emsp;&emsp;博客文件夹下的<code>_config.yml</code>文件可以配置整个博客的名称、主题等基本功能，<code>/theme/</code>文件夹下的<code>_config.yml</code>文件则用于配置具体的主题配置。</p>\n<h3 id=\"发表与删除\"><a href=\"#发表与删除\" class=\"headerlink\" title=\"发表与删除\"></a>发表与删除</h3><p>&emsp;&emsp;在博客文件夹打开Git Bash，键入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n &quot;文章的标题&quot;</span><br></pre></td></tr></table></figure>\n<p>之后便会生成一个md文件，在md文件中编辑文章保存，然后键入<code>hexo g -d</code>便会发布文章。</p>\n<p>&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：<a href=\"https://www.zhihu.com/question/24422335\" target=\"_blank\" rel=\"noopener\">有哪些好看的 Hexo主题</a>。笔者使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>。</p>\n<p>&emsp;&emsp;在博客文件夹下的<code>_config.yml</code>文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客<code>_config.yml</code>文件的更改，保存片刻即生效。</p>\n<h3 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h3><p>&emsp;&emsp;具体过程如下：</p>\n<ul>\n<li>需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，<code>{账户名}.github.io</code>的IP地址，还有一个的记录类型为<code>CNAME</code>，记录值为：<code>{账户名}.github.io</code>。</li>\n<li>进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。</li>\n<li>进入博客文件夹中的<code>/source/</code>，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为<strong>所有文件</strong>，名称为<strong>CNAME</strong>。</li>\n</ul>\n<h2 id=\"备份与恢复\"><a href=\"#备份与恢复\" class=\"headerlink\" title=\"备份与恢复\"></a>备份与恢复</h2><p>&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:</p>\n<ul>\n<li>新建一个分支，如hexo，并将其设置为默认</li>\n<li>本地clone你的Github Pages仓库，得到一个io文件夹：<code>{账户名}.github.io</code>的文件夹。</li>\n<li>将原来博客文件夹中的<code>_config.yml，themes/，source/，scffolds/，package.json，.gitignore</code>复制到clone下来的文件夹，注意要将<code>theme/</code>主题的<code>.git/</code>删除。</li>\n<li>在clone下的文件夹执行<code>npm install</code>，<code>npm install hexo-deployer-git</code>。</li>\n</ul>\n<p>此时<code>{账户名}.github.io</code>文件夹已经成为包含你博客所有文件的工作文件夹，在部署(<code>hexo g -d</code>)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;更新源文件&quot;</span><br><span class=\"line\">git push origin hexo</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:</p>\n<ul>\n<li>clone你的Github Pages仓库，得到一个io文件夹。</li>\n<li>在文件夹中打开Git Bash，键入以下命令:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install </span><br><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。</p>\n<p>如果在拉取过程中提示本地分支与远程仓库冲突，可以使用<code>git reset --hard</code>命令重置之后再次pull。如果提示</p>\n<blockquote>\n<p>The following untracked working tree files would be overwritten by merge</p>\n</blockquote>\n<p>可以使用<code>git clean -d -fx</code>，关于该命令</p>\n<blockquote>\n<p>git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。<br> git clean -f            //该命令会移除所有上一条命令中显示的文件。<br> git clean -fd           //移除文件夹，使用选项-d。<br> git clean -fX           //只想移除已被忽略的文件，使用选项-X。<br> git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。</p>\n</blockquote>\n<h2 id=\"Hexo各文件（夹）说明\"><a href=\"#Hexo各文件（夹）说明\" class=\"headerlink\" title=\"Hexo各文件（夹）说明\"></a>Hexo各文件（夹）说明</h2><ul>\n<li>_config.yml：站点的配置文件，备份过程中需要拷贝；</li>\n<li>themes/：主题文件夹，需要拷贝；</li>\n<li>source：博客文章的.md文件，需要拷贝；</li>\n<li>scaffolds/：文章的模板，需要拷贝；</li>\n<li>package.json：安装包的名称，需要拷贝；</li>\n<li>.gitignore：限定在push时哪些文件可以忽略，需要拷贝；</li>\n<li>.git/：主题和站点都有，标志这是一个git项目，不需要拷贝；</li>\n<li>node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li>\n<li>public：hexo g生成的静态网页，不需要拷贝；</li>\n<li>.deploy_git：同上，hexo g也会生成，不需要拷贝；</li>\n<li>db.json：文件，不需要拷贝。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>&emsp;&emsp;上一个博客是使用WordPress搭建在云服务器上的，郁闷的是这个位于美国的服务器ip被墙了，无奈放弃。正好最近抽出时间，又迫切地想记录点东西，选择了基本不会被墙的Github Pages，搭配Hexo框架，构建了一个轻量级的博客，在此将其过程记录下来。</p>","more":"<p></p>\n<p>&emsp;&emsp;作者的环境基于Windows，其他环境的搭建过程大同小异。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>&emsp;&emsp;创建Github Pages，首先需要一个Github帐号，新建一个仓库，仓库名为<code>{账户名}.github.io</code>，系统会自动识别并将其设为Github Pages。注意的是仓库权限要设置为public。之后浏览器打开：<code>https://{账户名}.github.io</code>便可以看到缺省的界面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>&emsp;&emsp;Hexo是一个基于Node.js的静态博客框架，快速、高效且简洁。需要安装在本地，具体过程如下：</p>\n<ul>\n<li>安装Git客户端，前往Git主页下载，安装后登录帐号。</li>\n<li>安装Node.js环境，前往Node主页下载。</li>\n<li><p>安装Hexo，新建一个命名任意的文件夹，在其中打开Git Bash，键入Hexo的安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化Hexo，<code>projectname</code>省略时，要求当前文件夹为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init [projectname]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h2><p>&emsp;&emsp;经过前面的过程，已经获得了Github Pages和本地的Hexo环境，接下来就是关联两者。<br>在博客的文件夹中有<code>_config.yml</code>文件，为Hexo的配置文件，打开并将相应位置设置为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy: </span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: 该处填写仓库的完整路径</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure></p>\n<p>该过程其实是给<code>hexo d</code>这一命令做相应的配置，让hexo知道blog部署的位置，显然部署在GitHub的仓库里。<br>保存文件之后，安装Git部署插件，在Git Bash中键入命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>接下来就是清除hexo缓存：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure></p>\n<p>生成静态文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<p>部署网站，d的意思是deploy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>后两个命令可以合并为一条，关于Hexo的命令请访问：<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">Hexo指令</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;至此，博客已经搭建完毕，浏览器键入<code>https://{账户名}.github.io</code>，发现打开了一个使用Hexo搭建的Github Pages博客。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>&emsp;&emsp;博客文件夹下的<code>_config.yml</code>文件可以配置整个博客的名称、主题等基本功能，<code>/theme/</code>文件夹下的<code>_config.yml</code>文件则用于配置具体的主题配置。</p>\n<h3 id=\"发表与删除\"><a href=\"#发表与删除\" class=\"headerlink\" title=\"发表与删除\"></a>发表与删除</h3><p>&emsp;&emsp;在博客文件夹打开Git Bash，键入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n &quot;文章的标题&quot;</span><br></pre></td></tr></table></figure>\n<p>之后便会生成一个md文件，在md文件中编辑文章保存，然后键入<code>hexo g -d</code>便会发布文章。</p>\n<p>&emsp;&emsp;如果要删除文章，直接删除对应的md文件。基本上每一次对博客的修改，都需要生成静态文件和部署命令。</p>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>&emsp;&emsp;网络上有很多优秀的Hexo主题，关于主题选择，可以查看这个知乎问答：<a href=\"https://www.zhihu.com/question/24422335\" target=\"_blank\" rel=\"noopener\">有哪些好看的 Hexo主题</a>。笔者使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>。</p>\n<p>&emsp;&emsp;在博客文件夹下的<code>_config.yml</code>文件中，将theme选项设置为下载的主题，注意的是所有的选项冒号之后要有一个半角空格，否则设置将失效。Hexo会自动检测博客<code>_config.yml</code>文件的更改，保存片刻即生效。</p>\n<h3 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h3><p>&emsp;&emsp;具体过程如下：</p>\n<ul>\n<li>需要一个域名，可以前往万网等提供商购买，之后在后台设置添加解析，一般需要解析三个，Github的IP地址，<code>{账户名}.github.io</code>的IP地址，还有一个的记录类型为<code>CNAME</code>，记录值为：<code>{账户名}.github.io</code>。</li>\n<li>进入GitHub Pages的仓库，点击settings，设置Custom domain，输入购买的域名，保存。</li>\n<li>进入博客文件夹中的<code>/source/</code>，新建一个记事本文件，只需填写域名即可。如果在域名前填了www，则每次浏览器访问都要填入www，不填则没这个必要。之后将该文件保存为<strong>所有文件</strong>，名称为<strong>CNAME</strong>。</li>\n</ul>\n<h2 id=\"备份与恢复\"><a href=\"#备份与恢复\" class=\"headerlink\" title=\"备份与恢复\"></a>备份与恢复</h2><p>&emsp;&emsp;由于在Github Pages的仓库中，只有生成的静态网页的文件，没有整个博客的源文件，如果当前电脑出现问题，或者需要多设备操作时，就会很麻烦。所以需要对博客进行备份与恢复。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>&emsp;&emsp;创建一个分支，用来保存网站源文件，具体步骤如下:</p>\n<ul>\n<li>新建一个分支，如hexo，并将其设置为默认</li>\n<li>本地clone你的Github Pages仓库，得到一个io文件夹：<code>{账户名}.github.io</code>的文件夹。</li>\n<li>将原来博客文件夹中的<code>_config.yml，themes/，source/，scffolds/，package.json，.gitignore</code>复制到clone下来的文件夹，注意要将<code>theme/</code>主题的<code>.git/</code>删除。</li>\n<li>在clone下的文件夹执行<code>npm install</code>，<code>npm install hexo-deployer-git</code>。</li>\n</ul>\n<p>此时<code>{账户名}.github.io</code>文件夹已经成为包含你博客所有文件的工作文件夹，在部署(<code>hexo g -d</code>)之前，执行下面三条命令，以使用hexo分支更新git上的源文件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;更新源文件&quot;</span><br><span class=\"line\">git push origin hexo</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，达到了在master分支上部署网页静态文件，在hexo分支上备份网站源文件的目的。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>&emsp;&emsp;当在新的环境中需要对博客进行操作，包括写文章、配置博客时，需要获取整个网站的源文件，当然前提是Node.js的安装，步骤如下:</p>\n<ul>\n<li>clone你的Github Pages仓库，得到一个io文件夹。</li>\n<li>在文件夹中打开Git Bash，键入以下命令:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install </span><br><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在就可以在该文件夹进行博客的操作了，如果多终端同时工作时，记得使用pull命令更新本地文件，且分支始终为hexo。</p>\n<p>如果在拉取过程中提示本地分支与远程仓库冲突，可以使用<code>git reset --hard</code>命令重置之后再次pull。如果提示</p>\n<blockquote>\n<p>The following untracked working tree files would be overwritten by merge</p>\n</blockquote>\n<p>可以使用<code>git clean -d -fx</code>，关于该命令</p>\n<blockquote>\n<p>git clean -f -n       //选项-n将显示执行下一步时将会移除哪些文件。<br> git clean -f            //该命令会移除所有上一条命令中显示的文件。<br> git clean -fd           //移除文件夹，使用选项-d。<br> git clean -fX           //只想移除已被忽略的文件，使用选项-X。<br> git clean -fx           //想移除已被忽略和未被忽略的文件，使用选项-x。</p>\n</blockquote>\n<h2 id=\"Hexo各文件（夹）说明\"><a href=\"#Hexo各文件（夹）说明\" class=\"headerlink\" title=\"Hexo各文件（夹）说明\"></a>Hexo各文件（夹）说明</h2><ul>\n<li>_config.yml：站点的配置文件，备份过程中需要拷贝；</li>\n<li>themes/：主题文件夹，需要拷贝；</li>\n<li>source：博客文章的.md文件，需要拷贝；</li>\n<li>scaffolds/：文章的模板，需要拷贝；</li>\n<li>package.json：安装包的名称，需要拷贝；</li>\n<li>.gitignore：限定在push时哪些文件可以忽略，需要拷贝；</li>\n<li>.git/：主题和站点都有，标志这是一个git项目，不需要拷贝；</li>\n<li>node_modules/：是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li>\n<li>public：hexo g生成的静态网页，不需要拷贝；</li>\n<li>.deploy_git：同上，hexo g也会生成，不需要拷贝；</li>\n<li>db.json：文件，不需要拷贝。</li>\n</ul>"},{"title":"Java 反射详解","date":"2019-03-16T15:25:47.000Z","_content":"\n## 引言\n反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。<!--more-->\n\n## 使用\n### Example\n```Java\npublic class Apple {\n\n    private int price;\n\n    public Apple(){}\n\n    public Apple(int price) {\n        this.price = price;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, \n            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //正常调用\n        Apple apple = new Apple();\n        apple.setPrice(10);\n        System.out.println(\"Price is \" + apple.getPrice());\n\n        //反射调用\n        Class clazz = Class.forName(\"Apple\");\n\n        //使用 getFields() 无法获取私有属性\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field: fields) {\n            System.out.println(\"Field is \" + field.getName());\n        }\n        Method setPriceMethod = clazz.getMethod(\"setPrice\", int.class);\n\n        Constructor appleConstructor = clazz.getConstructor();\n        Object appleObj = appleConstructor.newInstance();\n        //Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器\n        //Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器\n\n        setPriceMethod.invoke(appleObj, 12);\n\n        Method getPriceMethod = clazz.getMethod(\"getPrice\");\n        System.out.println(\"Price is \" + getPriceMethod.invoke(appleObj));\n    }\n}\n```\n### API\n#### 类的实例化和构造函数\n\n> 获取公有构造函数，不包括父类，Class.class\n> public Constructor<?>[] getConstructors() \n> public Constructor<T> getConstructor(Class<?>... parameterTypes)\n>\n> 获取当前类构造函数，忽略修饰符\n> public Constructor<?>[] getDeclaredConstructors()\n> public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)\n\n> 构造函数调用，Constructor.class\n> public T newInstance(Object... initargs)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类成员变量的获取\n\n> 获取公有变量，包括父类，Class.class\n> public Field[] getFields()\n> public Field getField(String name)\n>\n> 获取当前类成员变量，忽略修饰符\n> public Field[] getDeclaredFields()\n> public Field getDeclaredField(String name)\n\n> 成员变量赋值，Field.class\n> //obj为实例对象\n> public void set(Object obj,Object value)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类方法的获取\n\n> 获取公有方法，包括父类，Class.class\n> public Method[] getMethods()\n> public Method getMethod(String name, Class<?>... parameterTypes)\n>\n> 获取当前类方法，忽略修饰符\n> public Method[] getDeclaredMethods()\n> public Method getDeclaredMethod(String name, Class<?>... parameterTypes)\n\n> 方法调用，Method.class\n> //obj为类实例化对象，如果为静态方法obj为Null\n> invoke(Object obj, Object... args)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类注解的获取\n\n> 获取类的\"annotationClass\"类型的注解，包括父类\n> public Annotation<A>    getAnnotation(Class annotationClass)\n>\n> // 获取类的全部注解 ，包括父类\n> public Annotation[]    getAnnotations()\n>\n> // 获取类自身声明的全部注解 ，忽略修饰符\n> public Annotation[]    getDeclaredAnnotations()\n\n#### 类父类的获取\n\n> 获取实现的全部接口\n> public Type[]    getGenericInterfaces()\n>\n> 获取父类\n> public Type    getGenericSuperclass()\n\n## 原理\n\n### RTTI和Class对象\n\nRTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。\n\n很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。\n\n而这些类型信息是通过一个特殊对象**Class（java.lang.Class）**实现的，它包含跟类相关的信息。\n\n当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。\n\n- 加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。\n- 连接：\n  - 验证 是否有正确的内部结构，并和其他类协调一致\n  - 准备 负责为类的静态成员分配内存，并设置默认初始化值\n  - 解析 将类的二进制数据中的符号引用替换为直接引用\n\n- 初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。\n\n获取 Class 对象的方式有三种\n\n1. Object 类的 getClass() 方法，执行静态块和动态构造块\n\n2. 数据类型的静态属性 class ，不会初始化该类\n\n3. Class类中的静态方法`public static Class forName(String className)`，执行静态块，不执行动态构造块\n\n### RTTI和反射\n\nJava 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。\n\nRTTI和反射之间的真正区别只在于：\n\n> RTTI：编译器在编译时打开和检查.class文件\n> 反射：运行时打开和检查.class文件\n\n严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能\n\n未完待续","source":"_posts/Java-反射详解.md","raw":"---\ntitle: Java 反射详解\ndate: 2019-03-16 23:25:47\ntags:\n- Java\n- 反射\ncategories:\n- Java\n---\n\n## 引言\n反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。<!--more-->\n\n## 使用\n### Example\n```Java\npublic class Apple {\n\n    private int price;\n\n    public Apple(){}\n\n    public Apple(int price) {\n        this.price = price;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, \n            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //正常调用\n        Apple apple = new Apple();\n        apple.setPrice(10);\n        System.out.println(\"Price is \" + apple.getPrice());\n\n        //反射调用\n        Class clazz = Class.forName(\"Apple\");\n\n        //使用 getFields() 无法获取私有属性\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field: fields) {\n            System.out.println(\"Field is \" + field.getName());\n        }\n        Method setPriceMethod = clazz.getMethod(\"setPrice\", int.class);\n\n        Constructor appleConstructor = clazz.getConstructor();\n        Object appleObj = appleConstructor.newInstance();\n        //Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器\n        //Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器\n\n        setPriceMethod.invoke(appleObj, 12);\n\n        Method getPriceMethod = clazz.getMethod(\"getPrice\");\n        System.out.println(\"Price is \" + getPriceMethod.invoke(appleObj));\n    }\n}\n```\n### API\n#### 类的实例化和构造函数\n\n> 获取公有构造函数，不包括父类，Class.class\n> public Constructor<?>[] getConstructors() \n> public Constructor<T> getConstructor(Class<?>... parameterTypes)\n>\n> 获取当前类构造函数，忽略修饰符\n> public Constructor<?>[] getDeclaredConstructors()\n> public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)\n\n> 构造函数调用，Constructor.class\n> public T newInstance(Object... initargs)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类成员变量的获取\n\n> 获取公有变量，包括父类，Class.class\n> public Field[] getFields()\n> public Field getField(String name)\n>\n> 获取当前类成员变量，忽略修饰符\n> public Field[] getDeclaredFields()\n> public Field getDeclaredField(String name)\n\n> 成员变量赋值，Field.class\n> //obj为实例对象\n> public void set(Object obj,Object value)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类方法的获取\n\n> 获取公有方法，包括父类，Class.class\n> public Method[] getMethods()\n> public Method getMethod(String name, Class<?>... parameterTypes)\n>\n> 获取当前类方法，忽略修饰符\n> public Method[] getDeclaredMethods()\n> public Method getDeclaredMethod(String name, Class<?>... parameterTypes)\n\n> 方法调用，Method.class\n> //obj为类实例化对象，如果为静态方法obj为Null\n> invoke(Object obj, Object... args)\n>\n> 忽略修饰符，强制调用\n> public void setAccessible(boolean flag)\n\n#### 类注解的获取\n\n> 获取类的\"annotationClass\"类型的注解，包括父类\n> public Annotation<A>    getAnnotation(Class annotationClass)\n>\n> // 获取类的全部注解 ，包括父类\n> public Annotation[]    getAnnotations()\n>\n> // 获取类自身声明的全部注解 ，忽略修饰符\n> public Annotation[]    getDeclaredAnnotations()\n\n#### 类父类的获取\n\n> 获取实现的全部接口\n> public Type[]    getGenericInterfaces()\n>\n> 获取父类\n> public Type    getGenericSuperclass()\n\n## 原理\n\n### RTTI和Class对象\n\nRTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。\n\n很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。\n\n而这些类型信息是通过一个特殊对象**Class（java.lang.Class）**实现的，它包含跟类相关的信息。\n\n当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。\n\n- 加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。\n- 连接：\n  - 验证 是否有正确的内部结构，并和其他类协调一致\n  - 准备 负责为类的静态成员分配内存，并设置默认初始化值\n  - 解析 将类的二进制数据中的符号引用替换为直接引用\n\n- 初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。\n\n获取 Class 对象的方式有三种\n\n1. Object 类的 getClass() 方法，执行静态块和动态构造块\n\n2. 数据类型的静态属性 class ，不会初始化该类\n\n3. Class类中的静态方法`public static Class forName(String className)`，执行静态块，不执行动态构造块\n\n### RTTI和反射\n\nJava 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。\n\nRTTI和反射之间的真正区别只在于：\n\n> RTTI：编译器在编译时打开和检查.class文件\n> 反射：运行时打开和检查.class文件\n\n严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能\n\n未完待续","slug":"Java-反射详解","published":1,"updated":"2019-03-17T02:47:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavai0009i0upgeu538ee","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。<a id=\"more\"></a></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPrice</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, </span></span><br><span class=\"line\"><span class=\"function\">            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//正常调用</span></span><br><span class=\"line\">        Apple apple = <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        apple.setPrice(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + apple.getPrice());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//反射调用</span></span><br><span class=\"line\">        Class clazz = Class.forName(<span class=\"string\">\"Apple\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用 getFields() 无法获取私有属性</span></span><br><span class=\"line\">        Field[] fields = clazz.getDeclaredFields();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field field: fields) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Field is \"</span> + field.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Method setPriceMethod = clazz.getMethod(<span class=\"string\">\"setPrice\"</span>, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        Constructor appleConstructor = clazz.getConstructor();</span><br><span class=\"line\">        Object appleObj = appleConstructor.newInstance();</span><br><span class=\"line\">        <span class=\"comment\">//Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器</span></span><br><span class=\"line\">        <span class=\"comment\">//Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        setPriceMethod.invoke(appleObj, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method getPriceMethod = clazz.getMethod(<span class=\"string\">\"getPrice\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + getPriceMethod.invoke(appleObj));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"类的实例化和构造函数\"><a href=\"#类的实例化和构造函数\" class=\"headerlink\" title=\"类的实例化和构造函数\"></a>类的实例化和构造函数</h4><blockquote>\n<p>获取公有构造函数，不包括父类，Class.class<br>public Constructor&lt;?&gt;[] getConstructors()<br>public Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)</t></p>\n<p>获取当前类构造函数，忽略修饰符<br>public Constructor&lt;?&gt;[] getDeclaredConstructors()<br>public Constructor<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</t></p>\n</blockquote>\n<blockquote>\n<p>构造函数调用，Constructor.class<br>public T newInstance(Object… initargs)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类成员变量的获取\"><a href=\"#类成员变量的获取\" class=\"headerlink\" title=\"类成员变量的获取\"></a>类成员变量的获取</h4><blockquote>\n<p>获取公有变量，包括父类，Class.class<br>public Field[] getFields()<br>public Field getField(String name)</p>\n<p>获取当前类成员变量，忽略修饰符<br>public Field[] getDeclaredFields()<br>public Field getDeclaredField(String name)</p>\n</blockquote>\n<blockquote>\n<p>成员变量赋值，Field.class<br>//obj为实例对象<br>public void set(Object obj,Object value)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类方法的获取\"><a href=\"#类方法的获取\" class=\"headerlink\" title=\"类方法的获取\"></a>类方法的获取</h4><blockquote>\n<p>获取公有方法，包括父类，Class.class<br>public Method[] getMethods()<br>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</p>\n<p>获取当前类方法，忽略修饰符<br>public Method[] getDeclaredMethods()<br>public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</p>\n</blockquote>\n<blockquote>\n<p>方法调用，Method.class<br>//obj为类实例化对象，如果为静态方法obj为Null<br>invoke(Object obj, Object… args)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类注解的获取\"><a href=\"#类注解的获取\" class=\"headerlink\" title=\"类注解的获取\"></a>类注解的获取</h4><blockquote>\n<p>获取类的”annotationClass”类型的注解，包括父类<br>public Annotation<a>    getAnnotation(Class annotationClass)</a></p>\n<p>// 获取类的全部注解 ，包括父类<br>public Annotation[]    getAnnotations()</p>\n<p>// 获取类自身声明的全部注解 ，忽略修饰符<br>public Annotation[]    getDeclaredAnnotations()</p>\n</blockquote>\n<h4 id=\"类父类的获取\"><a href=\"#类父类的获取\" class=\"headerlink\" title=\"类父类的获取\"></a>类父类的获取</h4><blockquote>\n<p>获取实现的全部接口<br>public Type[]    getGenericInterfaces()</p>\n<p>获取父类<br>public Type    getGenericSuperclass()</p>\n</blockquote>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"RTTI和Class对象\"><a href=\"#RTTI和Class对象\" class=\"headerlink\" title=\"RTTI和Class对象\"></a>RTTI和Class对象</h3><p>RTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。</p>\n<p>很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。</p>\n<p>而这些类型信息是通过一个特殊对象<strong>Class（java.lang.Class）</strong>实现的，它包含跟类相关的信息。</p>\n<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。</p>\n<ul>\n<li>加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。</li>\n<li><p>连接：</p>\n<ul>\n<li>验证 是否有正确的内部结构，并和其他类协调一致</li>\n<li>准备 负责为类的静态成员分配内存，并设置默认初始化值</li>\n<li>解析 将类的二进制数据中的符号引用替换为直接引用</li>\n</ul>\n</li>\n<li><p>初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。</p>\n</li>\n</ul>\n<p>获取 Class 对象的方式有三种</p>\n<ol>\n<li><p>Object 类的 getClass() 方法，执行静态块和动态构造块</p>\n</li>\n<li><p>数据类型的静态属性 class ，不会初始化该类</p>\n</li>\n<li><p>Class类中的静态方法<code>public static Class forName(String className)</code>，执行静态块，不执行动态构造块</p>\n</li>\n</ol>\n<h3 id=\"RTTI和反射\"><a href=\"#RTTI和反射\" class=\"headerlink\" title=\"RTTI和反射\"></a>RTTI和反射</h3><p>Java 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。</p>\n<p>RTTI和反射之间的真正区别只在于：</p>\n<blockquote>\n<p>RTTI：编译器在编译时打开和检查.class文件<br>反射：运行时打开和检查.class文件</p>\n</blockquote>\n<p>严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能</p>\n<p>未完待续</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>反射是一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力。Java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的属性、方法、构造函数等信息。反射使 Java 这一静态语言有了动态的特性。</p>","more":"<p></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> price;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPrice</span><span class=\"params\">(<span class=\"keyword\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, </span></span><br><span class=\"line\"><span class=\"function\">            NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//正常调用</span></span><br><span class=\"line\">        Apple apple = <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        apple.setPrice(<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + apple.getPrice());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//反射调用</span></span><br><span class=\"line\">        Class clazz = Class.forName(<span class=\"string\">\"Apple\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用 getFields() 无法获取私有属性</span></span><br><span class=\"line\">        Field[] fields = clazz.getDeclaredFields();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field field: fields) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Field is \"</span> + field.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Method setPriceMethod = clazz.getMethod(<span class=\"string\">\"setPrice\"</span>, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        Constructor appleConstructor = clazz.getConstructor();</span><br><span class=\"line\">        Object appleObj = appleConstructor.newInstance();</span><br><span class=\"line\">        <span class=\"comment\">//Constructor appleConstructor = clazz.getConstructor(int.class);   //获得有参构造器</span></span><br><span class=\"line\">        <span class=\"comment\">//Object appleObj = appleConstructor.newInstance(int.class)     //调用有参构造器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        setPriceMethod.invoke(appleObj, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method getPriceMethod = clazz.getMethod(<span class=\"string\">\"getPrice\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Price is \"</span> + getPriceMethod.invoke(appleObj));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"类的实例化和构造函数\"><a href=\"#类的实例化和构造函数\" class=\"headerlink\" title=\"类的实例化和构造函数\"></a>类的实例化和构造函数</h4><blockquote>\n<p>获取公有构造函数，不包括父类，Class.class<br>public Constructor&lt;?&gt;[] getConstructors()<br>public Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)</t></p>\n<p>获取当前类构造函数，忽略修饰符<br>public Constructor&lt;?&gt;[] getDeclaredConstructors()<br>public Constructor<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</t></p>\n</blockquote>\n<blockquote>\n<p>构造函数调用，Constructor.class<br>public T newInstance(Object… initargs)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类成员变量的获取\"><a href=\"#类成员变量的获取\" class=\"headerlink\" title=\"类成员变量的获取\"></a>类成员变量的获取</h4><blockquote>\n<p>获取公有变量，包括父类，Class.class<br>public Field[] getFields()<br>public Field getField(String name)</p>\n<p>获取当前类成员变量，忽略修饰符<br>public Field[] getDeclaredFields()<br>public Field getDeclaredField(String name)</p>\n</blockquote>\n<blockquote>\n<p>成员变量赋值，Field.class<br>//obj为实例对象<br>public void set(Object obj,Object value)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类方法的获取\"><a href=\"#类方法的获取\" class=\"headerlink\" title=\"类方法的获取\"></a>类方法的获取</h4><blockquote>\n<p>获取公有方法，包括父类，Class.class<br>public Method[] getMethods()<br>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</p>\n<p>获取当前类方法，忽略修饰符<br>public Method[] getDeclaredMethods()<br>public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</p>\n</blockquote>\n<blockquote>\n<p>方法调用，Method.class<br>//obj为类实例化对象，如果为静态方法obj为Null<br>invoke(Object obj, Object… args)</p>\n<p>忽略修饰符，强制调用<br>public void setAccessible(boolean flag)</p>\n</blockquote>\n<h4 id=\"类注解的获取\"><a href=\"#类注解的获取\" class=\"headerlink\" title=\"类注解的获取\"></a>类注解的获取</h4><blockquote>\n<p>获取类的”annotationClass”类型的注解，包括父类<br>public Annotation<a>    getAnnotation(Class annotationClass)</a></p>\n<p>// 获取类的全部注解 ，包括父类<br>public Annotation[]    getAnnotations()</p>\n<p>// 获取类自身声明的全部注解 ，忽略修饰符<br>public Annotation[]    getDeclaredAnnotations()</p>\n</blockquote>\n<h4 id=\"类父类的获取\"><a href=\"#类父类的获取\" class=\"headerlink\" title=\"类父类的获取\"></a>类父类的获取</h4><blockquote>\n<p>获取实现的全部接口<br>public Type[]    getGenericInterfaces()</p>\n<p>获取父类<br>public Type    getGenericSuperclass()</p>\n</blockquote>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"RTTI和Class对象\"><a href=\"#RTTI和Class对象\" class=\"headerlink\" title=\"RTTI和Class对象\"></a>RTTI和Class对象</h3><p>RTTI，即 Run-Time Type Identification，运行时类型识别。RTTI 能在运行时就能够自动识别每个编译时已知的类型。</p>\n<p>很多时候需要进行向上转型，比如 Fruit 类派生出 Apple 类，当现有的方法将 Fruit 作为参数时，如果我们传入其派生类的引用，那么 RTTI 就会起作用。通过 RTTI 识别出 Apple 类是 Fruit 的派生类，然后向上转型。特别是在用接口类型作为参数的时候，这一特性更是被频繁使用。</p>\n<p>而这些类型信息是通过一个特殊对象<strong>Class（java.lang.Class）</strong>实现的，它包含跟类相关的信息。</p>\n<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。</p>\n<ul>\n<li>加载 ：将 class 文件读入内存，并为之创建一个 Class 对象。任何类被使用时系统都会建立一个 Class 对象。</li>\n<li><p>连接：</p>\n<ul>\n<li>验证 是否有正确的内部结构，并和其他类协调一致</li>\n<li>准备 负责为类的静态成员分配内存，并设置默认初始化值</li>\n<li>解析 将类的二进制数据中的符号引用替换为直接引用</li>\n</ul>\n</li>\n<li><p>初始化：如果该类有超类，则对其初始化，执行静态域和静态初始化块。</p>\n</li>\n</ul>\n<p>获取 Class 对象的方式有三种</p>\n<ol>\n<li><p>Object 类的 getClass() 方法，执行静态块和动态构造块</p>\n</li>\n<li><p>数据类型的静态属性 class ，不会初始化该类</p>\n</li>\n<li><p>Class类中的静态方法<code>public static Class forName(String className)</code>，执行静态块，不执行动态构造块</p>\n</li>\n</ol>\n<h3 id=\"RTTI和反射\"><a href=\"#RTTI和反射\" class=\"headerlink\" title=\"RTTI和反射\"></a>RTTI和反射</h3><p>Java 有两种 RTTI 方式，一种是传统的，假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。</p>\n<p>RTTI和反射之间的真正区别只在于：</p>\n<blockquote>\n<p>RTTI：编译器在编译时打开和检查.class文件<br>反射：运行时打开和检查.class文件</p>\n</blockquote>\n<p>严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为 RTTI指的是传统的 RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能</p>\n<p>未完待续</p>"},{"title":"Java 数据库知识整理","date":"2019-03-18T02:45:26.000Z","_content":"","source":"_posts/Java-数据库知识整理.md","raw":"---\ntitle: Java 数据库知识整理\ndate: 2019-03-18 10:45:26\ntags:\n---\n","slug":"Java-数据库知识整理","published":1,"updated":"2019-03-18T02:45:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavan000ci0ups1hqd93l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Java设计模式：行为型模式","date":"2019-01-20T16:57:00.000Z","_content":"\n## 责任链模式\n责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<!--more-->\n\n创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。\n\n```Java\nabstract class AbstractLogger {\n    public static int INFO = 1;\n    public static int DEBUG = 2;\n    public static int ERROR = 3;\n\n    protected int level;\n\n    //责任链中的下一个元素\n    protected AbstractLogger nextLogger;\n\n    public void setNextLogger(AbstractLogger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    public void logMessage(int level, String message) {\n        if (this.level <= level) {\n            write(message);\n        }\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    abstract protected void write(String message);\n}\n```\n在 DebugLogger 中\n```Java\nclass DebugLogger extends AbstractLogger {\n\n    public DebugLogger() {\n        super();\n        level = 2;\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"DebugLogger: \" + message);\n    }\n}\n```\n调用\n```Java\n    static AbstractLogger getChainOfLogger() {\n        AbstractLogger infoLogger = new InfoLogger();\n        AbstractLogger debugLogger = new DebugLogger();\n        AbstractLogger errorLogger = new ErrorLogger();\n        \n        infoLogger.setNextLogger(debugLogger);\n        debugLogger.setNextLogger(errorLogger);\n        return infoLogger;\n    }\n    \n    public static void main(String[] args) {\n        AbstractLogger logger = getChainOfLogger();\n\n        logger.logMessage(AbstractLogger.INFO, \"an info msg\");\n        logger.logMessage(AbstractLogger.DEBUG, \"a debug msg\");\n        logger.logMessage(AbstractLogger.ERROR, \"an error msg\");\n    }\n```\n控制台输出结果为\n```\nInfoLogger: an info msg\nInfoLogger: a debug msg\nDebugLogger: a debug msg\nInfoLogger: an error msg\nDebugLogger: an error msg\nErrorLogger: an error msg\n```\n\n## 其他\n\n### 命令模式\n一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：[Java设计模式--命令模式（以管理智能家电为例）](http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&p=8b2a971c87dd11a05db0e63c49&newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&user=baidu&fm=sc&query=java%C3%FC%C1%EE%C4%A3%CA%BD&qid=c0e757ac00089354&p1=5)\n","source":"_posts/Java设计模式：行为型模式.md","raw":"---\ntitle: Java设计模式：行为型模式\ndate: 2019-01-21 00:57:00\ntags:\n- 设计模式\n- Java\ncategories:\n- Java\n---\n\n## 责任链模式\n责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<!--more-->\n\n创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。\n\n```Java\nabstract class AbstractLogger {\n    public static int INFO = 1;\n    public static int DEBUG = 2;\n    public static int ERROR = 3;\n\n    protected int level;\n\n    //责任链中的下一个元素\n    protected AbstractLogger nextLogger;\n\n    public void setNextLogger(AbstractLogger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    public void logMessage(int level, String message) {\n        if (this.level <= level) {\n            write(message);\n        }\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    abstract protected void write(String message);\n}\n```\n在 DebugLogger 中\n```Java\nclass DebugLogger extends AbstractLogger {\n\n    public DebugLogger() {\n        super();\n        level = 2;\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"DebugLogger: \" + message);\n    }\n}\n```\n调用\n```Java\n    static AbstractLogger getChainOfLogger() {\n        AbstractLogger infoLogger = new InfoLogger();\n        AbstractLogger debugLogger = new DebugLogger();\n        AbstractLogger errorLogger = new ErrorLogger();\n        \n        infoLogger.setNextLogger(debugLogger);\n        debugLogger.setNextLogger(errorLogger);\n        return infoLogger;\n    }\n    \n    public static void main(String[] args) {\n        AbstractLogger logger = getChainOfLogger();\n\n        logger.logMessage(AbstractLogger.INFO, \"an info msg\");\n        logger.logMessage(AbstractLogger.DEBUG, \"a debug msg\");\n        logger.logMessage(AbstractLogger.ERROR, \"an error msg\");\n    }\n```\n控制台输出结果为\n```\nInfoLogger: an info msg\nInfoLogger: a debug msg\nDebugLogger: a debug msg\nInfoLogger: an error msg\nDebugLogger: an error msg\nErrorLogger: an error msg\n```\n\n## 其他\n\n### 命令模式\n一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：[Java设计模式--命令模式（以管理智能家电为例）](http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&p=8b2a971c87dd11a05db0e63c49&newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&user=baidu&fm=sc&query=java%C3%FC%C1%EE%C4%A3%CA%BD&qid=c0e757ac00089354&p1=5)\n","slug":"Java设计模式：行为型模式","published":1,"updated":"2019-03-15T15:27:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavao000di0up9disnq5o","content":"<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。<a id=\"more\"></a></p>\n<p>创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> INFO = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> DEBUG = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> ERROR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//责任链中的下一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AbstractLogger nextLogger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextLogger</span><span class=\"params\">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextLogger = nextLogger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.level &lt;= level) &#123;</span><br><span class=\"line\">            write(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLogger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nextLogger.logMessage(level, message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 DebugLogger 中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        level = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DebugLogger: \"</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> AbstractLogger <span class=\"title\">getChainOfLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger infoLogger = <span class=\"keyword\">new</span> InfoLogger();</span><br><span class=\"line\">    AbstractLogger debugLogger = <span class=\"keyword\">new</span> DebugLogger();</span><br><span class=\"line\">    AbstractLogger errorLogger = <span class=\"keyword\">new</span> ErrorLogger();</span><br><span class=\"line\">    </span><br><span class=\"line\">    infoLogger.setNextLogger(debugLogger);</span><br><span class=\"line\">    debugLogger.setNextLogger(errorLogger);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> infoLogger;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger logger = getChainOfLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.logMessage(AbstractLogger.INFO, <span class=\"string\">\"an info msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.DEBUG, <span class=\"string\">\"a debug msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.ERROR, <span class=\"string\">\"an error msg\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InfoLogger: an info msg</span><br><span class=\"line\">InfoLogger: a debug msg</span><br><span class=\"line\">DebugLogger: a debug msg</span><br><span class=\"line\">InfoLogger: an error msg</span><br><span class=\"line\">DebugLogger: an error msg</span><br><span class=\"line\">ErrorLogger: an error msg</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：<a href=\"http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&amp;p=8b2a971c87dd11a05db0e63c49&amp;newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&amp;user=baidu&amp;fm=sc&amp;query=java%C3%FC%C1%EE%C4%A3%CA%BD&amp;qid=c0e757ac00089354&amp;p1=5\" target=\"_blank\" rel=\"noopener\">Java设计模式–命令模式（以管理智能家电为例）</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果不能处理该请求，那么它会把相同的请求传给下一个接收者。该模式在 Java Web中有很多应用，如 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP Servlet 的 Filter等等。</p>","more":"<p></p>\n<p>创建抽象类 AbstractLogger，带有详细的日志记录级别，在其基础上拓展出三个记录器，如果消息的级别属于自己，则记录器将其打印，否则把消息传给下一个记录器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> INFO = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> DEBUG = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> ERROR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//责任链中的下一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AbstractLogger nextLogger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextLogger</span><span class=\"params\">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextLogger = nextLogger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.level &lt;= level) &#123;</span><br><span class=\"line\">            write(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLogger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nextLogger.logMessage(level, message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 DebugLogger 中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugLogger</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLogger</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        level = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DebugLogger: \"</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> AbstractLogger <span class=\"title\">getChainOfLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger infoLogger = <span class=\"keyword\">new</span> InfoLogger();</span><br><span class=\"line\">    AbstractLogger debugLogger = <span class=\"keyword\">new</span> DebugLogger();</span><br><span class=\"line\">    AbstractLogger errorLogger = <span class=\"keyword\">new</span> ErrorLogger();</span><br><span class=\"line\">    </span><br><span class=\"line\">    infoLogger.setNextLogger(debugLogger);</span><br><span class=\"line\">    debugLogger.setNextLogger(errorLogger);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> infoLogger;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    AbstractLogger logger = getChainOfLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.logMessage(AbstractLogger.INFO, <span class=\"string\">\"an info msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.DEBUG, <span class=\"string\">\"a debug msg\"</span>);</span><br><span class=\"line\">    logger.logMessage(AbstractLogger.ERROR, <span class=\"string\">\"an error msg\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InfoLogger: an info msg</span><br><span class=\"line\">InfoLogger: a debug msg</span><br><span class=\"line\">DebugLogger: a debug msg</span><br><span class=\"line\">InfoLogger: an error msg</span><br><span class=\"line\">DebugLogger: an error msg</span><br><span class=\"line\">ErrorLogger: an error msg</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并将命令传给它以执行命令。调用对象寻找合适对象的过程就像开关控制电器，它并不需要知道电器的具体情况，只需要根据命令，控制不同电线的连通状态。模式实现的代码较繁琐，具体的例子移步：<a href=\"http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c4380146d8b804b2281d25f93130a1c187babf37d714c518a82213a1cfc091ab1a16825761e2bb490c38f40d7ac925f75ce786a6459db0144dc41fc8f1532c050872be8b86d96ad813184d9a5c4de2444bb55120981e7fa291764bc&amp;p=8b2a971c87dd11a05db0e63c49&amp;newp=882a900d959603ee19be9b7c4553d8224216ed6039d0c44324b9d71fd325001c1b69e7bf20271707d7ce786d0ba54f5beefa3476301766dada9fca458ae7c4606cdd657531&amp;user=baidu&amp;fm=sc&amp;query=java%C3%FC%C1%EE%C4%A3%CA%BD&amp;qid=c0e757ac00089354&amp;p1=5\" target=\"_blank\" rel=\"noopener\">Java设计模式–命令模式（以管理智能家电为例）</a></p>"},{"title":"LeetCode：最长回文子串（Longest Palindromic Substring）的解法","date":"2019-01-12T06:32:23.000Z","_content":"\n## 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n\n> Input: \"babcd\"\nOutput: \"bab\"\n\n<!--more-->\n\n本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。\n\n## O(n^3)算法\n\n### 思路\n- 从最长的子串开始，遍历所有该原字符串的子串；\n- 每找出一个字符串，就判断该字符串是否为回文；\n- 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。\n\n### 时间复杂度\n- 遍历字符串子串：嵌套一个循环：O(n^2)；   \n- 判断是否为回文：再次嵌套一个循环：O(n^3)。\n\n### 代码\n\n```java\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n    for(int i = s.length();i > 0; i--) {//子串长度\n        for(int j = 0; j <= s.length() - i; j++) {\n            String sub = s.substring(j , i + j);//子串位置\n            int count = 0;//计数，用来判断是否对称\n            for (int k = 0; k < sub.length() / 2; k++) {//左右对称判断\n                if (sub.charAt(k) == sub.charAt(sub.length() - k - 1))\n                    count++;\n            }\n            if (count == sub.length() / 2)\n                return sub;\n        }\n    }\n    return \"\";//表示字符串中无回文子串\n}\n```\n\n## O(n^2)算法\n\n### 思路\n\n- 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；\n- 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；\n- 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；\n- 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。\n\n### 时间复杂度\n\n- 遍历字符：一层循环——O(n-1)；\n\n- 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)\n\n\n### 代码\n```java\nprivate static int maxLen = 0;\n\nprivate static String sub = \"\";\n\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n\n    for(int i = 0;i < s.length()-1;i++){\n        findLongestPalindrome(s,i,i);//单核回文\n        findLongestPalindrome(s,i,i+1);//双核回文\n    }\n    return sub;\n}\n\npublic static void findLongestPalindrome(String s,int low,int high) {\n    while (low >= 0 && high <= s.length()-1){\n        if(s.charAt(low) == s.charAt(high)){\n            if(high - low + 1 > maxLen){\n                maxLen = high - low + 1;\n                sub = s.substring(low , high+1);\n            }\n            low --;//向两边扩散找当前字符为中心的最大回文子串\n            high ++;\n        } else\n            break;\n    }\n}\n```\n\n## O(n)算法——Manacher算法\n\n### 思路\nManacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br>\n这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以`＃`号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：\n\n> a -> #a# \nabaf -> #a#b#a#f#\n\n可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。\n\n借助两个变量center、right分别记录回文子串对应的中心点和右端点\n\n![你想输入的替代文字](LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png)\n\n可以直接看出，right就是`2*center-i`（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br>\n反之，就只能从1个长度开始匹配了，就是下面的这行代码:\n\n```\nr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1\n```\n\n这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br>\n进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。\n\n### 时间复杂度\n只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。\n\n### 代码\n```java\npublic static String longestPalindrome(String s) {\n\tif(s == null || s.length() < 1) {\n\t\treturn s;\n\t}\n\tStringBuilder builder = new StringBuilder();\n\t// 防止左端点越界\n\tbuilder.append(\"&#\");\n\tchar[] c = s.toCharArray();\n\tfor (char a : c) {\n\t\tbuilder.append(a).append(\"#\");\n\t}\n\tString newStr = builder.toString();\n\tc = newStr.toCharArray();\n\t// 回文半径\n\tint[] r = new int[newStr.length()];\n\t// 回文子串最大右端点、中心点\n\tint right=0, center=0;\n\t// 最大回文半径、最大中心点\n\tint maxR=0, maxC=0;\n\tfor (int i=1;i < c.length;i++) {\n\t\t// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径\n\t\tr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1;\n\t\twhile (i+r[i]<c.length && c[i+r[i]]==c[i-r[i]]) {\n\t\t\t++r[i];\n\t\t}\n\t\t// 更新右端点和中心点\n\t\tif (right < i+r[i]) {\n\t\t\tright = i+r[i];\n\t\t\tcenter = i;\n\t\t}\n\t\t// 更新最大半径和最大中心点\n\t\tif (maxR < r[i]) {\n\t\t\tmaxR = r[i];\n\t\t\tmaxC = i;\n\t\t}\n\t}\n    //计算在原字符串中的起始点\n\tint start = (maxC-maxR)/2;\n\treturn s.substring(start, start+maxR-1);\n}\n```","source":"_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法.md","raw":"---\ntitle: LeetCode：最长回文子串（Longest Palindromic Substring）的解法\ndate: 2019-01-12 14:32:23\ntags:\n- 算法\n- LeetCode\ncategories:\n- 算法\n---\n\n## 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n\n> Input: \"babcd\"\nOutput: \"bab\"\n\n<!--more-->\n\n本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。\n\n## O(n^3)算法\n\n### 思路\n- 从最长的子串开始，遍历所有该原字符串的子串；\n- 每找出一个字符串，就判断该字符串是否为回文；\n- 子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。\n\n### 时间复杂度\n- 遍历字符串子串：嵌套一个循环：O(n^2)；   \n- 判断是否为回文：再次嵌套一个循环：O(n^3)。\n\n### 代码\n\n```java\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n    for(int i = s.length();i > 0; i--) {//子串长度\n        for(int j = 0; j <= s.length() - i; j++) {\n            String sub = s.substring(j , i + j);//子串位置\n            int count = 0;//计数，用来判断是否对称\n            for (int k = 0; k < sub.length() / 2; k++) {//左右对称判断\n                if (sub.charAt(k) == sub.charAt(sub.length() - k - 1))\n                    count++;\n            }\n            if (count == sub.length() / 2)\n                return sub;\n        }\n    }\n    return \"\";//表示字符串中无回文子串\n}\n```\n\n## O(n^2)算法\n\n### 思路\n\n- 将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；\n- 遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；\n- 每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；\n- 重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。\n\n### 时间复杂度\n\n- 遍历字符：一层循环——O(n-1)；\n\n- 找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)\n\n\n### 代码\n```java\nprivate static int maxLen = 0;\n\nprivate static String sub = \"\";\n\npublic static String longestPalindrome(String s) {\n    if(s.length() <= 1)\n        return s;\n\n    for(int i = 0;i < s.length()-1;i++){\n        findLongestPalindrome(s,i,i);//单核回文\n        findLongestPalindrome(s,i,i+1);//双核回文\n    }\n    return sub;\n}\n\npublic static void findLongestPalindrome(String s,int low,int high) {\n    while (low >= 0 && high <= s.length()-1){\n        if(s.charAt(low) == s.charAt(high)){\n            if(high - low + 1 > maxLen){\n                maxLen = high - low + 1;\n                sub = s.substring(low , high+1);\n            }\n            low --;//向两边扩散找当前字符为中心的最大回文子串\n            high ++;\n        } else\n            break;\n    }\n}\n```\n\n## O(n)算法——Manacher算法\n\n### 思路\nManacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br>\n这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以`＃`号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：\n\n> a -> #a# \nabaf -> #a#b#a#f#\n\n可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。\n\n借助两个变量center、right分别记录回文子串对应的中心点和右端点\n\n![你想输入的替代文字](LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png)\n\n可以直接看出，right就是`2*center-i`（也就是i关于center的对称点），既然是对称点，那么当端点right > i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br>\n反之，就只能从1个长度开始匹配了，就是下面的这行代码:\n\n```\nr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1\n```\n\n这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br>\n进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。\n\n### 时间复杂度\n只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。\n\n### 代码\n```java\npublic static String longestPalindrome(String s) {\n\tif(s == null || s.length() < 1) {\n\t\treturn s;\n\t}\n\tStringBuilder builder = new StringBuilder();\n\t// 防止左端点越界\n\tbuilder.append(\"&#\");\n\tchar[] c = s.toCharArray();\n\tfor (char a : c) {\n\t\tbuilder.append(a).append(\"#\");\n\t}\n\tString newStr = builder.toString();\n\tc = newStr.toCharArray();\n\t// 回文半径\n\tint[] r = new int[newStr.length()];\n\t// 回文子串最大右端点、中心点\n\tint right=0, center=0;\n\t// 最大回文半径、最大中心点\n\tint maxR=0, maxC=0;\n\tfor (int i=1;i < c.length;i++) {\n\t\t// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径\n\t\tr[i] = right > i ? (Math.min(r[2*center-i], right-i)) : 1;\n\t\twhile (i+r[i]<c.length && c[i+r[i]]==c[i-r[i]]) {\n\t\t\t++r[i];\n\t\t}\n\t\t// 更新右端点和中心点\n\t\tif (right < i+r[i]) {\n\t\t\tright = i+r[i];\n\t\t\tcenter = i;\n\t\t}\n\t\t// 更新最大半径和最大中心点\n\t\tif (maxR < r[i]) {\n\t\t\tmaxR = r[i];\n\t\t\tmaxC = i;\n\t\t}\n\t}\n    //计算在原字符串中的起始点\n\tint start = (maxC-maxR)/2;\n\treturn s.substring(start, start+maxR-1);\n}\n```","slug":"LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法","published":1,"updated":"2019-03-15T15:26:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavar000hi0up4kd3nj10","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>\n<blockquote>\n<p>Input: “babcd”<br>Output: “bab”</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。</p>\n<h2 id=\"O-n-3-算法\"><a href=\"#O-n-3-算法\" class=\"headerlink\" title=\"O(n^3)算法\"></a>O(n^3)算法</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>从最长的子串开始，遍历所有该原字符串的子串；</li>\n<li>每找出一个字符串，就判断该字符串是否为回文；</li>\n<li>子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li>遍历字符串子串：嵌套一个循环：O(n^2)；   </li>\n<li>判断是否为回文：再次嵌套一个循环：O(n^3)。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length();i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">//子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= s.length() - i; j++) &#123;</span><br><span class=\"line\">            String sub = s.substring(j , i + j);<span class=\"comment\">//子串位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//计数，用来判断是否对称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; sub.length() / <span class=\"number\">2</span>; k++) &#123;<span class=\"comment\">//左右对称判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sub.charAt(k) == sub.charAt(sub.length() - k - <span class=\"number\">1</span>))</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == sub.length() / <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;<span class=\"comment\">//表示字符串中无回文子串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-2-算法\"><a href=\"#O-n-2-算法\" class=\"headerlink\" title=\"O(n^2)算法\"></a>O(n^2)算法</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；</li>\n<li>遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；</li>\n<li>每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；</li>\n<li>重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。</li>\n</ul>\n<h3 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li><p>遍历字符：一层循环——O(n-1)；</p>\n</li>\n<li><p>找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)</p>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.length()-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">        findLongestPalindrome(s,i,i);<span class=\"comment\">//单核回文</span></span><br><span class=\"line\">        findLongestPalindrome(s,i,i+<span class=\"number\">1</span>);<span class=\"comment\">//双核回文</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">findLongestPalindrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &gt;= <span class=\"number\">0</span> &amp;&amp; high &lt;= s.length()-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(low) == s.charAt(high))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(high - low + <span class=\"number\">1</span> &gt; maxLen)&#123;</span><br><span class=\"line\">                maxLen = high - low + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub = s.substring(low , high+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            low --;<span class=\"comment\">//向两边扩散找当前字符为中心的最大回文子串</span></span><br><span class=\"line\">            high ++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-算法——Manacher算法\"><a href=\"#O-n-算法——Manacher算法\" class=\"headerlink\" title=\"O(n)算法——Manacher算法\"></a>O(n)算法——Manacher算法</h2><h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br><br>这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以<code>＃</code>号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：</p>\n<blockquote>\n<p>a -&gt; #a#<br>abaf -&gt; #a#b#a#f#</p>\n</blockquote>\n<p>可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。</p>\n<p>借助两个变量center、right分别记录回文子串对应的中心点和右端点</p>\n<p><img src=\"/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png\" alt=\"你想输入的替代文字\"></p>\n<p>可以直接看出，right就是<code>2*center-i</code>（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br><br>反之，就只能从1个长度开始匹配了，就是下面的这行代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1</span><br></pre></td></tr></table></figure>\n<p>这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br><br>进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。</p>\n<h3 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span> || s.length() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tStringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t<span class=\"comment\">// 防止左端点越界</span></span><br><span class=\"line\">\tbuilder.append(<span class=\"string\">\"&amp;#\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] c = s.toCharArray();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a : c) &#123;</span><br><span class=\"line\">\t\tbuilder.append(a).append(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tString newStr = builder.toString();</span><br><span class=\"line\">\tc = newStr.toCharArray();</span><br><span class=\"line\">\t<span class=\"comment\">// 回文半径</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[newStr.length()];</span><br><span class=\"line\">\t<span class=\"comment\">// 回文子串最大右端点、中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> right=<span class=\"number\">0</span>, center=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 最大回文半径、最大中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxR=<span class=\"number\">0</span>, maxC=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i &lt; c.length;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径</span></span><br><span class=\"line\">\t\tr[i] = right &gt; i ? (Math.min(r[<span class=\"number\">2</span>*center-i], right-i)) : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123;</span><br><span class=\"line\">\t\t\t++r[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新右端点和中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (right &lt; i+r[i]) &#123;</span><br><span class=\"line\">\t\t\tright = i+r[i];</span><br><span class=\"line\">\t\t\tcenter = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大半径和最大中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxR &lt; r[i]) &#123;</span><br><span class=\"line\">\t\t\tmaxR = r[i];</span><br><span class=\"line\">\t\t\tmaxC = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//计算在原字符串中的起始点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = (maxC-maxR)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.substring(start, start+maxR-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>\n<blockquote>\n<p>Input: “babcd”<br>Output: “bab”</p>\n</blockquote>","more":"<p>本文将介绍三种解法，重点介绍时间复杂度最低的Manacher算法。</p>\n<h2 id=\"O-n-3-算法\"><a href=\"#O-n-3-算法\" class=\"headerlink\" title=\"O(n^3)算法\"></a>O(n^3)算法</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>从最长的子串开始，遍历所有该原字符串的子串；</li>\n<li>每找出一个字符串，就判断该字符串是否为回文；</li>\n<li>子串为回文时，则找到了最长的回文子串，因此结束；反之，继续遍历。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li>遍历字符串子串：嵌套一个循环：O(n^2)；   </li>\n<li>判断是否为回文：再次嵌套一个循环：O(n^3)。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length();i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">//子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= s.length() - i; j++) &#123;</span><br><span class=\"line\">            String sub = s.substring(j , i + j);<span class=\"comment\">//子串位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//计数，用来判断是否对称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; sub.length() / <span class=\"number\">2</span>; k++) &#123;<span class=\"comment\">//左右对称判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sub.charAt(k) == sub.charAt(sub.length() - k - <span class=\"number\">1</span>))</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == sub.length() / <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;<span class=\"comment\">//表示字符串中无回文子串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-2-算法\"><a href=\"#O-n-2-算法\" class=\"headerlink\" title=\"O(n^2)算法\"></a>O(n^2)算法</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>将子串分为单核和双核的情况，单核即指子串长度为奇数，双核则为偶数；</li>\n<li>遍历每个除最后一个位置的字符index(字符位置)，单核：初始low = 初始high = index，low和high均不超过原字符串的下限和上限；判断low和high处的字符是否相等，相等则low++、high++（双核：初始high = 初始low+1 = index + 1）；</li>\n<li>每次low与high处的字符相等时，都将当前最长的回文子串长度与high-low+1比较。后者大时，将最长的回文子串改为low与high之间的；</li>\n<li>重复执行第二、三步，直至high-low+1 等于原字符串长度或者遍历到最后一个字符，取当前截取到的回文子串，该子串即为最长的回文子串。</li>\n</ul>\n<h3 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><ul>\n<li><p>遍历字符：一层循环——O(n-1)；</p>\n</li>\n<li><p>找以当前字符为中心的最长回文子串：嵌套两个独立循环——O(2n*(n-1)) = O(n^2)</p>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; s.length()-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">        findLongestPalindrome(s,i,i);<span class=\"comment\">//单核回文</span></span><br><span class=\"line\">        findLongestPalindrome(s,i,i+<span class=\"number\">1</span>);<span class=\"comment\">//双核回文</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">findLongestPalindrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &gt;= <span class=\"number\">0</span> &amp;&amp; high &lt;= s.length()-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(low) == s.charAt(high))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(high - low + <span class=\"number\">1</span> &gt; maxLen)&#123;</span><br><span class=\"line\">                maxLen = high - low + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub = s.substring(low , high+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            low --;<span class=\"comment\">//向两边扩散找当前字符为中心的最大回文子串</span></span><br><span class=\"line\">            high ++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"O-n-算法——Manacher算法\"><a href=\"#O-n-算法——Manacher算法\" class=\"headerlink\" title=\"O(n)算法——Manacher算法\"></a>O(n)算法——Manacher算法</h2><h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>Manacher算法是通过求解一个中心点，在距离这个点R长度以内都是关于这个点左右对称的，也就是说这个长度为2R的字符串是一个回文串，最后再比较大小，求出最大的长度2R及其中心点。整个过程只扫描整个字符串一遍。<br><br>这里也可以看出，因为要求回文子串的中心点，这个中心点也是唯一的，所以它只能处理字符串是奇数位的情况。因此第一步就是把字符串长度变为奇数，这里使用一个非常巧妙的方式，把字符串中每个字符使用一个其它字符号包围起来，这里以<code>＃</code>号为例，可以想象一下，要把每个字符都使用#号包裹，那么需要的#号总是要比原来的字符串长度多一位，才能保证每个字符都能被插入到#与#中间，比如：</p>\n<blockquote>\n<p>a -&gt; #a#<br>abaf -&gt; #a#b#a#f#</p>\n</blockquote>\n<p>可以看出，不管原来的字符串长度是什么，奇数加偶数结果肯定为奇数，在这之后，就可以开始求最长回文子串的半径R了。</p>\n<p>借助两个变量center、right分别记录回文子串对应的中心点和右端点</p>\n<p><img src=\"/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png\" alt=\"你想输入的替代文字\"></p>\n<p>可以直接看出，right就是<code>2*center-i</code>（也就是i关于center的对称点），既然是对称点，那么当端点right &gt; i时，端点i需要进行计算回文子串R，但它的对称点有可能也进行过计算，所以可以无需从头开始匹配，因为这些点都包含在一个已经进行过匹配的父回文串中，所以这里可以直接取right-i和它的对称点回文子串半径长度较小的，用来保证绝对进行过计算的回文子串的部分;<br><br>反之，就只能从1个长度开始匹配了，就是下面的这行代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r[i] = right &gt; i ? (Math.min(r[2*center-i], right-i)) : 1</span><br></pre></td></tr></table></figure>\n<p>这里借助一个辅助的数组r[]来记录回文子串的半径R，r[i]表示的是以i为中心点的回文字符串的半径长度(初始情况下为1)，知道r[i]后，就可以继续把索引向左右两边扩充，也就是看i+r[i]与i-r[i]左右端点的位置所对应的字符是否相等，相等的话就把回文半径r[i]继续扩充，直到不相等为止。<br><br>进行这一轮扩充后，观察之前的右端点right是否小于回文子串扩充后的右端点i+r[i],小于就直接更新右端点和中心点，不小于就说明当前回文子串还是在当前right端点的内部。</p>\n<h3 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>只需进行一次遍历，时间复杂度为O(n)，具体的证明过程省略。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span> || s.length() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tStringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t<span class=\"comment\">// 防止左端点越界</span></span><br><span class=\"line\">\tbuilder.append(<span class=\"string\">\"&amp;#\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>[] c = s.toCharArray();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a : c) &#123;</span><br><span class=\"line\">\t\tbuilder.append(a).append(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tString newStr = builder.toString();</span><br><span class=\"line\">\tc = newStr.toCharArray();</span><br><span class=\"line\">\t<span class=\"comment\">// 回文半径</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[newStr.length()];</span><br><span class=\"line\">\t<span class=\"comment\">// 回文子串最大右端点、中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> right=<span class=\"number\">0</span>, center=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 最大回文半径、最大中心点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxR=<span class=\"number\">0</span>, maxC=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i &lt; c.length;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心点的回文半径，可以重复利用以及匹配过对称点的半径</span></span><br><span class=\"line\">\t\tr[i] = right &gt; i ? (Math.min(r[<span class=\"number\">2</span>*center-i], right-i)) : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i+r[i]&lt;c.length &amp;&amp; c[i+r[i]]==c[i-r[i]]) &#123;</span><br><span class=\"line\">\t\t\t++r[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新右端点和中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (right &lt; i+r[i]) &#123;</span><br><span class=\"line\">\t\t\tright = i+r[i];</span><br><span class=\"line\">\t\t\tcenter = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大半径和最大中心点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxR &lt; r[i]) &#123;</span><br><span class=\"line\">\t\t\tmaxR = r[i];</span><br><span class=\"line\">\t\t\tmaxC = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//计算在原字符串中的起始点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = (maxC-maxR)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.substring(start, start+maxR-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"坐过山车的人","date":"2019-01-10T09:57:55.000Z","_content":"\n&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<!--more-->\n&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。\n\n> 我们乘坐过山车飞向未来，  \n> 他和我的手里各捏着一张票，  \n> 那是飞向未来的小舢板，  \n> 起伏的波浪是我无畏的想象力。  \n> 乘坐我的想象力，\n> 他们尽情蹂躏  \n> 这些无辜的女孩和男孩，  \n> 这些无辜的小狗和小猫。  \n> 在波浪之下，在波浪的下面  \n> 一直匍匐着衰弱的故事人， \n> 他曾经是最伟大的创造者，  \n> 匍匐在最下面的飞得最高，  \n> 全是痛苦，全部都是痛苦。  \n> 那些与我耳语者，个个聪明无比， \n> 他们说智慧来自痛苦，他们说：  \n> 来，给你智慧之路。  \n> 哦，每一个坐过山车的人  \n> 都是过山车建造厂的工人，  \n> 每一双手都充满智慧，是痛苦的 \n> 工艺匠。他们也制造不同的心灵，  \n> 这些心灵里孕育着奖励，  \n> 那些渴望奖励的人，那些最智慧的人，  \n> 他们总在沉默，不停地被从过山车上 \n> 推下去，在空中飘荡，在飘荡中，  \n> 我们接吻，就像那些恋人，  \n> 那些被压缩在词典册页中的爱情故事，  \n> 还有家庭，人间的互相拯救。 \n> 如果存在一个空间，漂浮着  \n> 无数列过山车，痛苦的过山车…… \n>\n> ——马雁：《我们乘坐着过山车飞向未来》\n\n&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。\n&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。\n&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。\n&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。\n&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。\n&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。\n&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","source":"_posts/坐过山车的人.md","raw":"---\ntitle: 坐过山车的人\ndate: 2019-01-10 17:57:55\ntags:\n- 随笔\n- 诗歌\ncategories: \n- 随笔\n---\n\n&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<!--more-->\n&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。\n\n> 我们乘坐过山车飞向未来，  \n> 他和我的手里各捏着一张票，  \n> 那是飞向未来的小舢板，  \n> 起伏的波浪是我无畏的想象力。  \n> 乘坐我的想象力，\n> 他们尽情蹂躏  \n> 这些无辜的女孩和男孩，  \n> 这些无辜的小狗和小猫。  \n> 在波浪之下，在波浪的下面  \n> 一直匍匐着衰弱的故事人， \n> 他曾经是最伟大的创造者，  \n> 匍匐在最下面的飞得最高，  \n> 全是痛苦，全部都是痛苦。  \n> 那些与我耳语者，个个聪明无比， \n> 他们说智慧来自痛苦，他们说：  \n> 来，给你智慧之路。  \n> 哦，每一个坐过山车的人  \n> 都是过山车建造厂的工人，  \n> 每一双手都充满智慧，是痛苦的 \n> 工艺匠。他们也制造不同的心灵，  \n> 这些心灵里孕育着奖励，  \n> 那些渴望奖励的人，那些最智慧的人，  \n> 他们总在沉默，不停地被从过山车上 \n> 推下去，在空中飘荡，在飘荡中，  \n> 我们接吻，就像那些恋人，  \n> 那些被压缩在词典册页中的爱情故事，  \n> 还有家庭，人间的互相拯救。 \n> 如果存在一个空间，漂浮着  \n> 无数列过山车，痛苦的过山车…… \n>\n> ——马雁：《我们乘坐着过山车飞向未来》\n\n&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。\n&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。\n&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。\n&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。\n&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。\n&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。\n&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。","slug":"坐过山车的人","published":1,"updated":"2019-03-15T15:25:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavas000ji0upfs7ry01u","content":"<p>&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。<a id=\"more\"></a><br>&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。</p>\n<blockquote>\n<p>我们乘坐过山车飞向未来，<br>他和我的手里各捏着一张票，<br>那是飞向未来的小舢板，<br>起伏的波浪是我无畏的想象力。<br>乘坐我的想象力，<br>他们尽情蹂躏<br>这些无辜的女孩和男孩，<br>这些无辜的小狗和小猫。<br>在波浪之下，在波浪的下面<br>一直匍匐着衰弱的故事人，<br>他曾经是最伟大的创造者，<br>匍匐在最下面的飞得最高，<br>全是痛苦，全部都是痛苦。<br>那些与我耳语者，个个聪明无比，<br>他们说智慧来自痛苦，他们说：<br>来，给你智慧之路。<br>哦，每一个坐过山车的人<br>都是过山车建造厂的工人，<br>每一双手都充满智慧，是痛苦的<br>工艺匠。他们也制造不同的心灵，<br>这些心灵里孕育着奖励，<br>那些渴望奖励的人，那些最智慧的人，<br>他们总在沉默，不停地被从过山车上<br>推下去，在空中飘荡，在飘荡中，<br>我们接吻，就像那些恋人，<br>那些被压缩在词典册页中的爱情故事，<br>还有家庭，人间的互相拯救。<br>如果存在一个空间，漂浮着<br>无数列过山车，痛苦的过山车…… </p>\n<p>——马雁：《我们乘坐着过山车飞向未来》</p>\n</blockquote>\n<p>&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。<br>&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。<br>&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。<br>&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。<br>&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。<br>&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。<br>&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;距离2019年的开始，已经过去了十天，标题起的似乎不那么准确。</p>","more":"<br>&emsp;&emsp;前几天读完了新一年的第一本书——村上春树的《1Q84》，作者“浩浩汤汤”扯了三大卷，看到最后，才发现讲了一对男女的“互相追寻”，顿感颓败。书中的宗教、科幻、暴力等元素没让人生出太多兴趣，最大亮点，可能是贯穿全书的双线甚至后期的三线叙事，有一种在看盖里奇的电影的感觉。文学性方面，高中时读过作者的《挪威的森林》，语言风格似乎没有变化，很多比喻都有作者——也许是大多数日本作家——的特点，整体节奏过于缓慢，当然，这也更能锤炼读者的心态。我是在马克思原理期末考试前一晚读到最后一页的，之后松了口气，大感愉悦——自己终于没有丢掉长文本阅读的能力。<p></p>\n<blockquote>\n<p>我们乘坐过山车飞向未来，<br>他和我的手里各捏着一张票，<br>那是飞向未来的小舢板，<br>起伏的波浪是我无畏的想象力。<br>乘坐我的想象力，<br>他们尽情蹂躏<br>这些无辜的女孩和男孩，<br>这些无辜的小狗和小猫。<br>在波浪之下，在波浪的下面<br>一直匍匐着衰弱的故事人，<br>他曾经是最伟大的创造者，<br>匍匐在最下面的飞得最高，<br>全是痛苦，全部都是痛苦。<br>那些与我耳语者，个个聪明无比，<br>他们说智慧来自痛苦，他们说：<br>来，给你智慧之路。<br>哦，每一个坐过山车的人<br>都是过山车建造厂的工人，<br>每一双手都充满智慧，是痛苦的<br>工艺匠。他们也制造不同的心灵，<br>这些心灵里孕育着奖励，<br>那些渴望奖励的人，那些最智慧的人，<br>他们总在沉默，不停地被从过山车上<br>推下去，在空中飘荡，在飘荡中，<br>我们接吻，就像那些恋人，<br>那些被压缩在词典册页中的爱情故事，<br>还有家庭，人间的互相拯救。<br>如果存在一个空间，漂浮着<br>无数列过山车，痛苦的过山车…… </p>\n<p>——马雁：《我们乘坐着过山车飞向未来》</p>\n</blockquote>\n<p>&emsp;&emsp;元旦将至，收到一篇推送，来自逝世9年的年轻诗人的一首小诗，很是喜欢。<br>&emsp;&emsp;在远离阅读的日子，完全是靠看一些小诗维持着文学的习惯。上一次完整的看完一本书，还是在去年的六七月份，读完了毛姆的《月亮与六便士》以及《刀锋》。其间，偶尔也翻阅金庸先生的武侠小说，其中《笑傲江湖》最是喜欢，《天龙》也甚好。《天龙八部》应该是金庸的作品中评价最高的一部，所谓“无人不冤”，富有西方戏剧的悲剧色彩。可惜读到《神雕》，往往是读几页便放下，次数多了，兴趣也消磨的差不多。最初如果先从《神雕》开始读，或许就不会又这么大的失落感。也许绝大多数我这个年纪的人，认识金庸的武侠江湖，都是从小时候的电视剧开始，知道阅读了原著，我才明白，金庸武侠的文学魅力，远远不是电视剧所能展现的，不读原著，不识金庸。<br>&emsp;&emsp;武侠小说的重点大都在故事的光怪离奇，其实越读越慌，也许是因为，在其中很难找到归宿——所谓的找到归宿，说不清道不明，然而我也不敢在此时妄论“武侠小说”的文学意义。去年，有幸读了沈从文先生的《边城》，在始终弥漫一层淡淡雾纱的湘西，时间缓缓流淌，风景如梦似幻。此时回想，脑中浮现出雷声大作的雨夜，渡船的小姑娘在睡梦中失去了相依为命的爷爷，月色下河对岸梦中人唱情歌的身影也永远的离她而去，远处的小城茶峒在雷声中一闪而过，默默无言。在读完《边城》的一段时间里，我都恍恍不安，每次走过图书馆的过道，都要小心翼翼，生怕破坏了心中那美好而平淡的“异世界”。<br>&emsp;&emsp;这种习惯在下半年消失的一干二净，为了来年的夏天能够找到一份心仪的实习，不得不追寻时间的脚步，更加地投身到代码与算法的世界，课程又实在不是轻松，纵然海绵里还有水，也再没力气再去挤弄。其间只能在公众号的诗歌推送里，略解饥渴。在紧凑快节奏的生活中，读诗确实不容易。<br>&emsp;&emsp;等到新一年的钟声敲响，发现时间已然悄悄地走远，行动隐蔽自如，不为人察觉。原来自己有半年，没有好好读过一本书。也许人就是这样，等到日历被翻过一页，才恍然大悟，开始感慨光阴似箭，生出警觉，不由自主地要回忆过去，悔恨和愧疚也会应景地涌上心头，过后照旧。<br>&emsp;&emsp;生活也许如过山车，载着无需门票的乘客，飞向未来。然而未来如何，起伏与波折在哪里会出现，却无人知晓，每个生来便失去选择的旅客，有些使劲抓着安全杆，害怕被甩下，有些则敞开怀抱，享受刺激与尖叫。<br>&emsp;&emsp;和譬如音乐、电影之类的兴趣不同，阅读是我一生都追随的目标，经典的文学作品，不仅赐予你逃避生活的空间，也鼓舞每一个人勇敢面对狂风暴雨；怅然若失时，陪你旅行，春风得意时便无言沉默；你孤独，书中有更孤独寂寞者，你悲苦，世人皆悲无不苦。有人说过，“读书人是世间幸福人，因为他除了拥有现实的世界之外，还拥有另一个更为浩瀚也更为丰富的世界”——以此，激励自己，在越来越繁忙的生活中，永远记得拿起一本书。</p>"},{"title":"Android LruCache 缓存详解","date":"2019-03-17T02:49:27.000Z","_content":"\n![](https://upload-images.jianshu.io/upload_images/3392635-584d9b129fd4132c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n<!--more-->\n## Android 缓存策略\n一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。\n\nLRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。\n\nLRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：\n\n![](https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp)\n\n## 使用\nLruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。\n\n讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。\n\nLinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数\n\n```java\npublic LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)\n```\n\n中的最后一个参数 accessOrder 来指定。\n\n对于`get`、`put`、`remove`等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 `get`(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用`put` 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。\n\n![](https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp)\n\nLruCache 的使用非常简单，以图片缓存为例：\n```Java\nint maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);\nint cacheSize = maxMemory/8;\n\nmMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n    @Override\n    protected int sizeOf(String key, Bitmap value) {\n        return value.getRowBytes() * value.getHeight() / 1024;\n    }\n};\n```\n\n1. 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。\n2. 重写sizeOf方法，计算出要缓存的每张图片的大小。\n\n注意：缓存的总容量和每个缓存对象的大小所用单位要一致。\n\n## 原理\nLruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。\n这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的`<key,value>`对按照一定顺序排列起来。\n\n通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。\n\n```Java\npublic LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {\n    super(initialCapacity, loadFactor);\n    this.accessOrder = accessOrder;\n}\n```\naccessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。\n\n以具体例子解释，当设置为true时\n\n```Java\npublic static final void main(String[] args) {\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>(0, 0.75f, true);\n    map.put(0, 0);\n    map.put(1, 1);\n    map.put(2, 2);\n    map.put(3, 3);\n    map.put(4, 4);\n    map.put(5, 5);\n    map.put(6, 6);\n    map.get(1);\n    map.get(2);\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n}\n```\n输出结果为:\n```Java\n0:0\n3:3\n4:4\n5:5\n6:6\n1:1\n2:2\n```\n即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。\n\n下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除\n\n构造方法\n\n````Java\npublic LruCache(int maxSize) {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    this.maxSize = maxSize;\n    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n}\n```\n`put`方法\n\n```Java\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n    \n    V previous;\n    synchronized (this) {\n        //插入的缓存对象值加1\n        putCount++;\n        //增加已有缓存的大小\n        size += safeSizeOf(key, value);\n        //向map中加入缓存对象\n        previous = map.put(key, value);\n        //如果已有缓存对象，则缓存大小恢复到之前\n        if (previous != null) {\n            size -= safeSizeOf(key, previous);\n        }\n    }\n    \n    //entryRemoved()是个空方法，可以自行实现\n    if (previous != null) {\n        entryRemoved(false, key, previous, value);\n    }\n    \n    //调整缓存大小(关键方法)\n    trimToSize(maxSize);\n    return previous;\n}\n```\n可以看到，添加过缓存对象后会调用`trimToSize`方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象\n\n`trimToSize`方法\n\n```Java\npublic void trimToSize(int maxSize) {\n    //死循环\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(getClass().getName()\n                        + \".sizeOf() is reporting inconsistent results!\");\n            }\n            \n            //如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            \n            //迭代器获取第一个对象，即队尾的元素，近期最少访问的元素\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            \n            //删除该对象，并更新缓存大小\n            map.remove(key);\n            size -= safeSizeOf(key, value);\n            evictionCount++;\n        }\n        entryRemoved(true, key, value, null);\n    }\n}\n```\n该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。\n\n当调用 LruCache 的`get`方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的`get`方法中完成的。\n\n先看 LruCache 的`get`方法\n\n```Java\npublic final V get(K key) {\n    //key为空抛出异常\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n    //获取对应的缓存对象\n    //get()方法会实现将访问的元素更新到队列头部的功能\n    mapValue = map.get(key);\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        missCount++;\n    }\n}\n```\n\n\nLinkedHashMap 的`get`方法如下：\n\n```Java\npublic V get(Object key) {\n    LinkedHashMapEntry<K,V> e = (LinkedHashMapEntry<K,V>)getEntry(key);\n    if (e == null)\n        return null;\n    //实现排序的关键方法\n    e.recordAccess(this);\n    return e.value;\n}\n```\n\n```Java\n void recordAccess(HashMap<K,V> m) {\n    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n    //判断是否是访问排序\n    if (lm.accessOrder) {\n        lm.modCount++;\n        //删除此元素\n        remove();\n        //将此元素移动到队列的头部\n        addBefore(lm.header);\n    }\n}\n```\n\n\n\n**由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用`put`方法时，就会在队列中添加元素，并调用`trimToSize`判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用`get(`方法访问缓存对象时，就会调用 LinkedHashMap 的`get`方法获得对应集合元素，同时更新该元素到队头。**\n\n以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。\n\n本文转自 [彻底解析Android缓存机制——LruCache](https://www.jianshu.com/p/b49a111147ee)","source":"_posts/Android-LruCache-缓存详解.md","raw":"---\ntitle: Android LruCache 缓存详解\ndate: 2019-03-17 10:49:27\ntags:\n- Android\n- LRU\n- 缓存\ncategories:\n- Android \n---\n\n![](https://upload-images.jianshu.io/upload_images/3392635-584d9b129fd4132c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n<!--more-->\n## Android 缓存策略\n一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。\n\nLRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。\n\nLRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：\n\n![](https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp)\n\n## 使用\nLruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。\n\n讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。\n\nLinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数\n\n```java\npublic LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)\n```\n\n中的最后一个参数 accessOrder 来指定。\n\n对于`get`、`put`、`remove`等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 `get`(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用`put` 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。\n\n![](https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp)\n\nLruCache 的使用非常简单，以图片缓存为例：\n```Java\nint maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);\nint cacheSize = maxMemory/8;\n\nmMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n    @Override\n    protected int sizeOf(String key, Bitmap value) {\n        return value.getRowBytes() * value.getHeight() / 1024;\n    }\n};\n```\n\n1. 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。\n2. 重写sizeOf方法，计算出要缓存的每张图片的大小。\n\n注意：缓存的总容量和每个缓存对象的大小所用单位要一致。\n\n## 原理\nLruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。\n这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的`<key,value>`对按照一定顺序排列起来。\n\n通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。\n\n```Java\npublic LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {\n    super(initialCapacity, loadFactor);\n    this.accessOrder = accessOrder;\n}\n```\naccessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。\n\n以具体例子解释，当设置为true时\n\n```Java\npublic static final void main(String[] args) {\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>(0, 0.75f, true);\n    map.put(0, 0);\n    map.put(1, 1);\n    map.put(2, 2);\n    map.put(3, 3);\n    map.put(4, 4);\n    map.put(5, 5);\n    map.put(6, 6);\n    map.get(1);\n    map.get(2);\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n}\n```\n输出结果为:\n```Java\n0:0\n3:3\n4:4\n5:5\n6:6\n1:1\n2:2\n```\n即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。\n\n下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除\n\n构造方法\n\n````Java\npublic LruCache(int maxSize) {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    this.maxSize = maxSize;\n    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n}\n```\n`put`方法\n\n```Java\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n    \n    V previous;\n    synchronized (this) {\n        //插入的缓存对象值加1\n        putCount++;\n        //增加已有缓存的大小\n        size += safeSizeOf(key, value);\n        //向map中加入缓存对象\n        previous = map.put(key, value);\n        //如果已有缓存对象，则缓存大小恢复到之前\n        if (previous != null) {\n            size -= safeSizeOf(key, previous);\n        }\n    }\n    \n    //entryRemoved()是个空方法，可以自行实现\n    if (previous != null) {\n        entryRemoved(false, key, previous, value);\n    }\n    \n    //调整缓存大小(关键方法)\n    trimToSize(maxSize);\n    return previous;\n}\n```\n可以看到，添加过缓存对象后会调用`trimToSize`方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象\n\n`trimToSize`方法\n\n```Java\npublic void trimToSize(int maxSize) {\n    //死循环\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(getClass().getName()\n                        + \".sizeOf() is reporting inconsistent results!\");\n            }\n            \n            //如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            \n            //迭代器获取第一个对象，即队尾的元素，近期最少访问的元素\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            \n            //删除该对象，并更新缓存大小\n            map.remove(key);\n            size -= safeSizeOf(key, value);\n            evictionCount++;\n        }\n        entryRemoved(true, key, value, null);\n    }\n}\n```\n该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。\n\n当调用 LruCache 的`get`方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的`get`方法中完成的。\n\n先看 LruCache 的`get`方法\n\n```Java\npublic final V get(K key) {\n    //key为空抛出异常\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n    //获取对应的缓存对象\n    //get()方法会实现将访问的元素更新到队列头部的功能\n    mapValue = map.get(key);\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        missCount++;\n    }\n}\n```\n\n\nLinkedHashMap 的`get`方法如下：\n\n```Java\npublic V get(Object key) {\n    LinkedHashMapEntry<K,V> e = (LinkedHashMapEntry<K,V>)getEntry(key);\n    if (e == null)\n        return null;\n    //实现排序的关键方法\n    e.recordAccess(this);\n    return e.value;\n}\n```\n\n```Java\n void recordAccess(HashMap<K,V> m) {\n    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n    //判断是否是访问排序\n    if (lm.accessOrder) {\n        lm.modCount++;\n        //删除此元素\n        remove();\n        //将此元素移动到队列的头部\n        addBefore(lm.header);\n    }\n}\n```\n\n\n\n**由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用`put`方法时，就会在队列中添加元素，并调用`trimToSize`判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用`get(`方法访问缓存对象时，就会调用 LinkedHashMap 的`get`方法获得对应集合元素，同时更新该元素到队头。**\n\n以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。\n\n本文转自 [彻底解析Android缓存机制——LruCache](https://www.jianshu.com/p/b49a111147ee)","slug":"Android-LruCache-缓存详解","published":1,"updated":"2019-03-17T03:43:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavc3001ki0upnx41nfmk","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-584d9b129fd4132c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"Android-缓存策略\"><a href=\"#Android-缓存策略\" class=\"headerlink\" title=\"Android 缓存策略\"></a>Android 缓存策略</h2><p>一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。</p>\n<p>LRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。</p>\n<p>LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp\" alt=\"\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>LruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。</p>\n<p>讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。</p>\n<p>LinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,<span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></table></figure>\n<p>中的最后一个参数 accessOrder 来指定。</p>\n<p>对于<code>get</code>、<code>put</code>、<code>remove</code>等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 <code>get</code>(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用<code>put</code> 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp\" alt=\"\"></p>\n<p>LruCache 的使用非常简单，以图片缓存为例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().totalMemory()/<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> cacheSize = maxMemory/<span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.getRowBytes() * value.getHeight() / <span class=\"number\">1024</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>设置LruCache缓存的大小，一般为当前进程可用容量的1/8。</li>\n<li>重写sizeOf方法，计算出要缓存的每张图片的大小。</li>\n</ol>\n<p>注意：缓存的总容量和每个缓存对象的大小所用单位要一致。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>LruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。<br>这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的<code>&lt;key,value&gt;</code>对按照一定顺序排列起来。</p>\n<p>通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>accessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。</p>\n<p>以具体例子解释，当设置为true时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">6</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">        System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>:<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">3</span>:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span>:<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span>:<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>:<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">1</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span>:<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。</p>\n<p>下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除</p>\n<p>构造方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public LruCache(int maxSize) &#123;</span><br><span class=\"line\">    if (maxSize &lt;= 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.maxSize = maxSize;</span><br><span class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>put</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    V previous;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//插入的缓存对象值加1</span></span><br><span class=\"line\">        putCount++;</span><br><span class=\"line\">        <span class=\"comment\">//增加已有缓存的大小</span></span><br><span class=\"line\">        size += safeSizeOf(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//向map中加入缓存对象</span></span><br><span class=\"line\">        previous = map.put(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//如果已有缓存对象，则缓存大小恢复到之前</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            size -= safeSizeOf(key, previous);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//entryRemoved()是个空方法，可以自行实现</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//调整缓存大小(关键方法)</span></span><br><span class=\"line\">    trimToSize(maxSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，添加过缓存对象后会调用<code>trimToSize</code>方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象</p>\n<p><code>trimToSize</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                        + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//迭代器获取第一个对象，即队尾的元素，近期最少访问的元素</span></span><br><span class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">            key = toEvict.getKey();</span><br><span class=\"line\">            value = toEvict.getValue();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//删除该对象，并更新缓存大小</span></span><br><span class=\"line\">            map.remove(key);</span><br><span class=\"line\">            size -= safeSizeOf(key, value);</span><br><span class=\"line\">            evictionCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。</p>\n<p>当调用 LruCache 的<code>get</code>方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的<code>get</code>方法中完成的。</p>\n<p>先看 LruCache 的<code>get</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//key为空抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    V mapValue;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取对应的缓存对象</span></span><br><span class=\"line\">    <span class=\"comment\">//get()方法会实现将访问的元素更新到队列头部的功能</span></span><br><span class=\"line\">    mapValue = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hitCount++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        missCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LinkedHashMap 的<code>get</code>方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//实现排序的关键方法</span></span><br><span class=\"line\">    e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordAccess</span><span class=\"params\">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否是访问排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lm.accessOrder) &#123;</span><br><span class=\"line\">        lm.modCount++;</span><br><span class=\"line\">        <span class=\"comment\">//删除此元素</span></span><br><span class=\"line\">        remove();</span><br><span class=\"line\">        <span class=\"comment\">//将此元素移动到队列的头部</span></span><br><span class=\"line\">        addBefore(lm.header);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用<code>put</code>方法时，就会在队列中添加元素，并调用<code>trimToSize</code>判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用<code>get(</code>方法访问缓存对象时，就会调用 LinkedHashMap 的<code>get</code>方法获得对应集合元素，同时更新该元素到队头。</strong></p>\n<p>以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。</p>\n<p>本文转自 <a href=\"https://www.jianshu.com/p/b49a111147ee\" target=\"_blank\" rel=\"noopener\">彻底解析Android缓存机制——LruCache</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-584d9b129fd4132c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp\" alt=\"\"><br></p>","more":"<p></p>\n<h2 id=\"Android-缓存策略\"><a href=\"#Android-缓存策略\" class=\"headerlink\" title=\"Android 缓存策略\"></a>Android 缓存策略</h2><p>一般来说，缓存策略主要包含缓存的添加、获取和删除。如何添加和获取缓存这个比较好理解，那为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再向其添加缓存，就需要先删除旧的缓存。因此 LRU 缓存算法应运而生。</p>\n<p>LRU（Least Recently Used），最近最少使用算法，核心思想是当缓存满时，优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。Android 中采用 LRU 算法的常用缓存有两种：LruCache 和 DisLruCache，分别用于实现内存缓存和硬盘缓存。</p>\n<p>LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-bb6c6461e8d01701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp\" alt=\"\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>LruCache 是Android 3.1所提供的一个缓存类，可以直接使用。而  DisLruCache  目前还不是 Android SDK的一部分，但 Android 官方文档推荐使用该算法来实现硬盘缓存。</p>\n<p>讲到 LruCache 不得不提一下 LinkedHashMap，因为 LruCache 中 Lru 算法就是通过 LinkedHashMap 来实现的。</p>\n<p>LinkedHashMap 继承于 HashMap，使用了一个双向链表来存储 Map 中的 Entry 顺序关系，这种顺序有两种，一种是 LRU 顺序，一种是插入顺序，由其构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,<span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></table></figure>\n<p>中的最后一个参数 accessOrder 来指定。</p>\n<p>对于<code>get</code>、<code>put</code>、<code>remove</code>等操作，LinkedHashMap 除了要做 HashMap 做的事情，还会做些调整 Entry 顺序链表的工作。LruCache 中将 LinkedHashMap 的顺序设置为 LRU 顺序来实现 LRU 缓存，每次调用 <code>get</code>(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用<code>put</code> 插入新的对象，则存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3392635-af28ceea733149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp\" alt=\"\"></p>\n<p>LruCache 的使用非常简单，以图片缓存为例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().totalMemory()/<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> cacheSize = maxMemory/<span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.getRowBytes() * value.getHeight() / <span class=\"number\">1024</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>设置LruCache缓存的大小，一般为当前进程可用容量的1/8。</li>\n<li>重写sizeOf方法，计算出要缓存的每张图片的大小。</li>\n</ol>\n<p>注意：缓存的总容量和每个缓存对象的大小所用单位要一致。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>LruCache 的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象会放在队尾，即将被淘汰。而最近访问的对象会放在队头，最后被淘汰。<br>这个队列由 LinkedHashMap 来维护。LinkedHashMap 由数组+双向链表的数据结构实现，其中双向链表的结构可以实现访问顺序和插入顺序，使得 LinkedHashMap 中的<code>&lt;key,value&gt;</code>对按照一定顺序排列起来。</p>\n<p>通过下面的构造函数来指定 LinkedHashMap 中双向链表的结构是访问顺序还是插入顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>accessOrder 设置为 true 则为访问顺序；为 false，则为插入顺序。</p>\n<p>以具体例子解释，当设置为true时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">6</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">    map.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">        System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>:<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">3</span>:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span>:<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span>:<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>:<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">1</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span>:<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>即最近访问的最后输出，正好满足 LRU 缓存算法的思想。可见 LruCache 的巧妙实现，就是利用了LinkedHashMap 的这种数据结构。</p>\n<p>下面我们在 LruCache 源码中具体看看，怎样应用 LinkedHashMap 来实现缓存的添加，获得和删除</p>\n<p>构造方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public LruCache(int maxSize) &#123;</span><br><span class=\"line\">    if (maxSize &lt;= 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.maxSize = maxSize;</span><br><span class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>put</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    V previous;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//插入的缓存对象值加1</span></span><br><span class=\"line\">        putCount++;</span><br><span class=\"line\">        <span class=\"comment\">//增加已有缓存的大小</span></span><br><span class=\"line\">        size += safeSizeOf(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//向map中加入缓存对象</span></span><br><span class=\"line\">        previous = map.put(key, value);</span><br><span class=\"line\">        <span class=\"comment\">//如果已有缓存对象，则缓存大小恢复到之前</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            size -= safeSizeOf(key, previous);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//entryRemoved()是个空方法，可以自行实现</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//调整缓存大小(关键方法)</span></span><br><span class=\"line\">    trimToSize(maxSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，添加过缓存对象后会调用<code>trimToSize</code>方法，来判断缓存是否已满，如果满了就删除近期最少使用的对象</p>\n<p><code>trimToSize</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                        + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//迭代器获取第一个对象，即队尾的元素，近期最少访问的元素</span></span><br><span class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">            key = toEvict.getKey();</span><br><span class=\"line\">            value = toEvict.getValue();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//删除该对象，并更新缓存大小</span></span><br><span class=\"line\">            map.remove(key);</span><br><span class=\"line\">            size -= safeSizeOf(key, value);</span><br><span class=\"line\">            evictionCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法不断地删除 LinkedHashMap 中队尾的元素，直到缓存大小小于最大值。</p>\n<p>当调用 LruCache 的<code>get</code>方法获取集合中的缓存对象时，就代表访问了一次该元素，队列将会更新，保持其按照访问顺序的排序的规则。这个更新过程是在 LinkedHashMap 中的<code>get</code>方法中完成的。</p>\n<p>先看 LruCache 的<code>get</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//key为空抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    V mapValue;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取对应的缓存对象</span></span><br><span class=\"line\">    <span class=\"comment\">//get()方法会实现将访问的元素更新到队列头部的功能</span></span><br><span class=\"line\">    mapValue = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hitCount++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        missCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LinkedHashMap 的<code>get</code>方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//实现排序的关键方法</span></span><br><span class=\"line\">    e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordAccess</span><span class=\"params\">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否是访问排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lm.accessOrder) &#123;</span><br><span class=\"line\">        lm.modCount++;</span><br><span class=\"line\">        <span class=\"comment\">//删除此元素</span></span><br><span class=\"line\">        remove();</span><br><span class=\"line\">        <span class=\"comment\">//将此元素移动到队列的头部</span></span><br><span class=\"line\">        addBefore(lm.header);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>由此可见 LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用<code>put</code>方法时，就会在队列中添加元素，并调用<code>trimToSize</code>判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队尾元素，即近期最少访问的元素。当调用<code>get(</code>方法访问缓存对象时，就会调用 LinkedHashMap 的<code>get</code>方法获得对应集合元素，同时更新该元素到队头。</strong></p>\n<p>以上便是 LruCache 实现的原理，理解了 LinkedHashMap 的数据结构就能理解整个原理。</p>\n<p>本文转自 <a href=\"https://www.jianshu.com/p/b49a111147ee\" target=\"_blank\" rel=\"noopener\">彻底解析Android缓存机制——LruCache</a></p>"},{"title":"Android 消息机制详解","date":"2019-03-16T06:13:19.000Z","_content":"\n## 引言\nAndroid 的消息机制，主要是指 Handler 的运行机制。<!--more-->\n\n## ANR\nApplication Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。\n\n### 原因 \nAndroid系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。\n\n以下四种条件都可以造成 ANR\n- InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件\n- BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的`onReceive`方法中10秒没有处理完成，后台则为60秒。\n- Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。\n- ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。\n\n### 分析和解决\n#### 分析\n- 查看 log 信息\n- Java 线程调用分析，`jstack {pid}`，其中 pid 为虚拟机进程 id，可以通过`jps`查看当前所有线程。\n- 查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令`./adb pull /data/anr/traces.txt`查看\n\n#### 解决\n- 避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。\n- 避免在主线程 query provider、不要滥用SharePreferences\n- 文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。\n- BroadcastReciever 的`onRecieve`不要进行耗时操作。\n\n## Handler 机制\n由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的`checkThread`进行验证\n```Java\nvoid checkThread() {\n    if (mThread != Thread.currrentThread()) {\n        throw new CalledFromWrongThreadException(\n            \"Only the original thread that created a view hierarchy can\n            touch its views\");\n    }\n}\n```\n使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。\n那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？\n\n答案是使用 Handler 。\n\n### 创建\n```Java\n//接收消息\n@SuppressLint(\"HandlerLeak\")\nprivate Handler mHandler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n        super.handleMessage(msg);\n        if (msg.what == 1) {\n            log.e(\"MSG\", \"收到消息\")；\n        }\n    }\n};\n\n//发送消息\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(1000);\n            mHandler.sendEmptyMessage(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}).start();\n```\n使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用\n```Java\nMyHandler hander = new MyHandler(context);\n\nstatic class MyHandler extends Handler {\n    private WeakReference<Context> out;\n    \n    MyHandler(Context ctx) {\n        super();\n        out = new WeakReference<>(ctx);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        if (out.get() != null) {\n            //进行消息处理\n        }\n    }\n}\n```\n\nHandler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。\n\n### Handler\n观察 Handler 的构造函数\n```Java\npublic Handler(Callback callback, boolean async) {\n    ......\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()  + \" that has not called\" \n            + \" Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用`Looper.prepare`的线程内创建 handler。\n\n不过，为什么在主线程中创建 Handler 不需要调用`Looper.prepare`和`Looper.loop`方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的`main`方法，在其中调用了`prepareMainLooper`\n```Java\npublic static void main(String[] args) {\n        ......\n        Looper.prepareMainLooper();\n        ......\n        Looper.loop();\n        ......\n}\n\npublic static void prepareMainLooper() {\n    prepare(false);     //quitAllowed 参数传false\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(\"The main Looper has already been prepared.\");\n        }\n        sMainLooper = myLooper();\n    }\n}\n```\n关于 ActivityThread：[Android线程管理（二）——ActivityThread](http://www.cnblogs.com/younghao/p/5126408.html)\n\n### MessageQueue\n顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。\n\n由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。\n\n当 Handler 调用`sendMessage`时，最后会调用到\n\n```Java\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n查看`enqueueMessage`方法，\n\n```Java\nboolean enqueueMessage(Message msg, long when) {\n    ......\n    synchronized (this) {\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n        ......\n    }\n    return true;\n}\n```\n- 首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒\n- 如果队列已有消息，则根据 Message 创建的时间进行插入\n\n### Looper\n通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用`Looper.prepare`方法使消息循环初始化，并且调用`Looper.loop`使消息循环一直处于运行状态，**取出 MessageQueue 中的消息分发给 Handler**。\n\n```Java\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n可以看到，`prepare(boolean quitAllowed)`实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当`Looper.prepare`执行完毕之后才可以执行`loop`方法\n```Java\npublic static void loop() {\n        //获取当前线程绑定的Looper\n        final Looper me = myLooper();\n        \n        //当前线程的MessageQueue\n        final MessageQueue queue = me.mQueue;\n        ......\n        //循环从 MessageQueue 取出消息.\n        for (;;) {\n            Message msg = queue.next();\n            ......\n            //将消息分发出去\n            msg.target.dispatchMessage(msg);\n            ......\n            //将消息回收\n            msg.recycle();\n        }\n}\n```\n可以看到，如果消息队列的 next 返回了新消息，就会调用`msg.target.dispatchMessage(msg)`，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。\n\n```Java\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n- 首先检查 Message 的 callBack 是否为空，不为空则`handlerCallback(msg)`，最终调用 callback 的`run`方法\n- 如果为空，检查 mCallBack 是否为空，不为空则调用它的`handleMassage`，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。\n- 如果都为空，调用 Handler 内部的`handleMessage`，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。\n\n### ThreadLocal\n一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。\n\n使用一个简单的例子演示 ThreadLocal 的真正含义\n```Java\n//新建一个 boolean 类型的变量\nprivate ThreadLocal<Boolean> value = new ThreadLocal<>();\n\n//在主线程中将其设为 true\nvalue.set(true);\nlog.e(\"MainThread\", value.get());\n\n//子线程中设为 false\nnew Thread(\"Thread1\") {\n    @Override\n    public void run() {\n        value.set(false);\n        log.e(\"Thread1\", value.get());\n    }\n}\n\n//另一个子线程直接读取\nnew Thread(\"Thread2\") {\n    @Override\n    public void run() {\n        log.e(\"Thread2\", value.get());\n    }\n}\n```\n运行日志如下\n> MainThread, true\n> Thread1, false\n> Thread2, null\n\n由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：[Java并发编程：深入剖析ThreadLocal](https://www.cnblogs.com/dolphin0520/p/3920407.html)\n\n## 总结\n\nHandler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的`runOnUiThread`\n\n```Java\npublic final void runOnUiThread(Runnable action) { \n\tif (Thread.currentThread() != mUiThread) { \n\t\tmHandler.post(action); \n\t} else { \n\t\taction.run(); \n\t} \n\t...... \n}\n```\n\n比如 View 的`post`\n\n```Java\npublic boolean post(Runnable action) {\n\tfinal AttachInfo attachInfo = mAttachInfo;\n    \tif (attachInfo != null) {\n            return attachInfo.mHandler.post(action);         ①\n        }\n        // Assume that post will succeed later\n        ViewRootImpl.getRunQueue().post(action);        ②\n        return true;\n    }\n```\n\n\n\n最后用一张图来结束本文\n\n![流程图](Android-消息机制详解\\消息流程图.jpg)","source":"_posts/Android-消息机制详解.md","raw":"---\ntitle: Android 消息机制详解\ndate: 2019-03-16 14:13:19\ntags:\n- Android \n- Handler\ncategories:\n- Android \n---\n\n## 引言\nAndroid 的消息机制，主要是指 Handler 的运行机制。<!--more-->\n\n## ANR\nApplication Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。\n\n### 原因 \nAndroid系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。\n\n以下四种条件都可以造成 ANR\n- InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件\n- BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的`onReceive`方法中10秒没有处理完成，后台则为60秒。\n- Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。\n- ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。\n\n### 分析和解决\n#### 分析\n- 查看 log 信息\n- Java 线程调用分析，`jstack {pid}`，其中 pid 为虚拟机进程 id，可以通过`jps`查看当前所有线程。\n- 查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令`./adb pull /data/anr/traces.txt`查看\n\n#### 解决\n- 避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。\n- 避免在主线程 query provider、不要滥用SharePreferences\n- 文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。\n- BroadcastReciever 的`onRecieve`不要进行耗时操作。\n\n## Handler 机制\n由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的`checkThread`进行验证\n```Java\nvoid checkThread() {\n    if (mThread != Thread.currrentThread()) {\n        throw new CalledFromWrongThreadException(\n            \"Only the original thread that created a view hierarchy can\n            touch its views\");\n    }\n}\n```\n使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。\n那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？\n\n答案是使用 Handler 。\n\n### 创建\n```Java\n//接收消息\n@SuppressLint(\"HandlerLeak\")\nprivate Handler mHandler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n        super.handleMessage(msg);\n        if (msg.what == 1) {\n            log.e(\"MSG\", \"收到消息\")；\n        }\n    }\n};\n\n//发送消息\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(1000);\n            mHandler.sendEmptyMessage(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}).start();\n```\n使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用\n```Java\nMyHandler hander = new MyHandler(context);\n\nstatic class MyHandler extends Handler {\n    private WeakReference<Context> out;\n    \n    MyHandler(Context ctx) {\n        super();\n        out = new WeakReference<>(ctx);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        if (out.get() != null) {\n            //进行消息处理\n        }\n    }\n}\n```\n\nHandler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。\n\n### Handler\n观察 Handler 的构造函数\n```Java\npublic Handler(Callback callback, boolean async) {\n    ......\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()  + \" that has not called\" \n            + \" Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用`Looper.prepare`的线程内创建 handler。\n\n不过，为什么在主线程中创建 Handler 不需要调用`Looper.prepare`和`Looper.loop`方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的`main`方法，在其中调用了`prepareMainLooper`\n```Java\npublic static void main(String[] args) {\n        ......\n        Looper.prepareMainLooper();\n        ......\n        Looper.loop();\n        ......\n}\n\npublic static void prepareMainLooper() {\n    prepare(false);     //quitAllowed 参数传false\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(\"The main Looper has already been prepared.\");\n        }\n        sMainLooper = myLooper();\n    }\n}\n```\n关于 ActivityThread：[Android线程管理（二）——ActivityThread](http://www.cnblogs.com/younghao/p/5126408.html)\n\n### MessageQueue\n顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。\n\n由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。\n\n当 Handler 调用`sendMessage`时，最后会调用到\n\n```Java\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n查看`enqueueMessage`方法，\n\n```Java\nboolean enqueueMessage(Message msg, long when) {\n    ......\n    synchronized (this) {\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n        ......\n    }\n    return true;\n}\n```\n- 首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒\n- 如果队列已有消息，则根据 Message 创建的时间进行插入\n\n### Looper\n通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用`Looper.prepare`方法使消息循环初始化，并且调用`Looper.loop`使消息循环一直处于运行状态，**取出 MessageQueue 中的消息分发给 Handler**。\n\n```Java\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n可以看到，`prepare(boolean quitAllowed)`实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当`Looper.prepare`执行完毕之后才可以执行`loop`方法\n```Java\npublic static void loop() {\n        //获取当前线程绑定的Looper\n        final Looper me = myLooper();\n        \n        //当前线程的MessageQueue\n        final MessageQueue queue = me.mQueue;\n        ......\n        //循环从 MessageQueue 取出消息.\n        for (;;) {\n            Message msg = queue.next();\n            ......\n            //将消息分发出去\n            msg.target.dispatchMessage(msg);\n            ......\n            //将消息回收\n            msg.recycle();\n        }\n}\n```\n可以看到，如果消息队列的 next 返回了新消息，就会调用`msg.target.dispatchMessage(msg)`，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。\n\n```Java\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n- 首先检查 Message 的 callBack 是否为空，不为空则`handlerCallback(msg)`，最终调用 callback 的`run`方法\n- 如果为空，检查 mCallBack 是否为空，不为空则调用它的`handleMassage`，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。\n- 如果都为空，调用 Handler 内部的`handleMessage`，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。\n\n### ThreadLocal\n一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。\n\n使用一个简单的例子演示 ThreadLocal 的真正含义\n```Java\n//新建一个 boolean 类型的变量\nprivate ThreadLocal<Boolean> value = new ThreadLocal<>();\n\n//在主线程中将其设为 true\nvalue.set(true);\nlog.e(\"MainThread\", value.get());\n\n//子线程中设为 false\nnew Thread(\"Thread1\") {\n    @Override\n    public void run() {\n        value.set(false);\n        log.e(\"Thread1\", value.get());\n    }\n}\n\n//另一个子线程直接读取\nnew Thread(\"Thread2\") {\n    @Override\n    public void run() {\n        log.e(\"Thread2\", value.get());\n    }\n}\n```\n运行日志如下\n> MainThread, true\n> Thread1, false\n> Thread2, null\n\n由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：[Java并发编程：深入剖析ThreadLocal](https://www.cnblogs.com/dolphin0520/p/3920407.html)\n\n## 总结\n\nHandler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的`runOnUiThread`\n\n```Java\npublic final void runOnUiThread(Runnable action) { \n\tif (Thread.currentThread() != mUiThread) { \n\t\tmHandler.post(action); \n\t} else { \n\t\taction.run(); \n\t} \n\t...... \n}\n```\n\n比如 View 的`post`\n\n```Java\npublic boolean post(Runnable action) {\n\tfinal AttachInfo attachInfo = mAttachInfo;\n    \tif (attachInfo != null) {\n            return attachInfo.mHandler.post(action);         ①\n        }\n        // Assume that post will succeed later\n        ViewRootImpl.getRunQueue().post(action);        ②\n        return true;\n    }\n```\n\n\n\n最后用一张图来结束本文\n\n![流程图](Android-消息机制详解\\消息流程图.jpg)","slug":"Android-消息机制详解","published":1,"updated":"2019-03-17T03:49:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavc4001li0upzt7z1k8h","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Android 的消息机制，主要是指 Handler 的运行机制。<a id=\"more\"></a></p>\n<h2 id=\"ANR\"><a href=\"#ANR\" class=\"headerlink\" title=\"ANR\"></a>ANR</h2><p>Application Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>Android系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。</p>\n<p>以下四种条件都可以造成 ANR</p>\n<ul>\n<li>InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件</li>\n<li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的<code>onReceive</code>方法中10秒没有处理完成，后台则为60秒。</li>\n<li>Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。</li>\n<li>ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。</li>\n</ul>\n<h3 id=\"分析和解决\"><a href=\"#分析和解决\" class=\"headerlink\" title=\"分析和解决\"></a>分析和解决</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>查看 log 信息</li>\n<li>Java 线程调用分析，<code>jstack {pid}</code>，其中 pid 为虚拟机进程 id，可以通过<code>jps</code>查看当前所有线程。</li>\n<li>查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令<code>./adb pull /data/anr/traces.txt</code>查看</li>\n</ul>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ul>\n<li>避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。</li>\n<li>避免在主线程 query provider、不要滥用SharePreferences</li>\n<li>文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。</li>\n<li>BroadcastReciever 的<code>onRecieve</code>不要进行耗时操作。</li>\n</ul>\n<h2 id=\"Handler-机制\"><a href=\"#Handler-机制\" class=\"headerlink\" title=\"Handler 机制\"></a>Handler 机制</h2><p>由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的<code>checkThread</code>进行验证<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThread != Thread.currrentThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CalledFromWrongThreadException(</span><br><span class=\"line\">            <span class=\"string\">\"Only the original thread that created a view hierarchy can</span></span><br><span class=\"line\"><span class=\"string\">            touch its views\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。<br>那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？</p>\n<p>答案是使用 Handler 。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接收消息</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"HandlerLeak\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> Handler mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            log.e(<span class=\"string\">\"MSG\"</span>, <span class=\"string\">\"收到消息\"</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            mHandler.sendEmptyMessage(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyHandler hander = <span class=\"keyword\">new</span> MyHandler(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference&lt;Context&gt; out;</span><br><span class=\"line\">    </span><br><span class=\"line\">    MyHandler(Context ctx) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        out = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (out.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//进行消息处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Handler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><p>观察 Handler 的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread \"</span> + Thread.currentThread()  + <span class=\"string\">\" that has not called\"</span> </span><br><span class=\"line\">            + <span class=\"string\">\" Looper.prepare()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用<code>Looper.prepare</code>的线程内创建 handler。</p>\n<p>不过，为什么在主线程中创建 Handler 不需要调用<code>Looper.prepare</code>和<code>Looper.loop</code>方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的<code>main</code>方法，在其中调用了<code>prepareMainLooper</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">false</span>);     <span class=\"comment\">//quitAllowed 参数传false</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sMainLooper = myLooper();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 ActivityThread：<a href=\"http://www.cnblogs.com/younghao/p/5126408.html\" target=\"_blank\" rel=\"noopener\">Android线程管理（二）——ActivityThread</a></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><p>顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。</p>\n<p>由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。</p>\n<p>当 Handler 调用<code>sendMessage</code>时，最后会调用到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看<code>enqueueMessage</code>方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒</li>\n<li>如果队列已有消息，则根据 Message 创建的时间进行插入</li>\n</ul>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用<code>Looper.prepare</code>方法使消息循环初始化，并且调用<code>Looper.loop</code>使消息循环一直处于运行状态，<strong>取出 MessageQueue 中的消息分发给 Handler</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>prepare(boolean quitAllowed)</code>实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当<code>Looper.prepare</code>执行完毕之后才可以执行<code>loop</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程绑定的Looper</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//当前线程的MessageQueue</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">//循环从 MessageQueue 取出消息.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Message msg = queue.next();</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息分发出去</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息回收</span></span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，如果消息队列的 next 返回了新消息，就会调用<code>msg.target.dispatchMessage(msg)</code>，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先检查 Message 的 callBack 是否为空，不为空则<code>handlerCallback(msg)</code>，最终调用 callback 的<code>run</code>方法</li>\n<li>如果为空，检查 mCallBack 是否为空，不为空则调用它的<code>handleMassage</code>，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。</li>\n<li>如果都为空，调用 Handler 内部的<code>handleMessage</code>，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。</p>\n<p>使用一个简单的例子演示 ThreadLocal 的真正含义<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新建一个 boolean 类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ThreadLocal&lt;Boolean&gt; value = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在主线程中将其设为 true</span></span><br><span class=\"line\">value.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">log.e(<span class=\"string\">\"MainThread\"</span>, value.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//子线程中设为 false</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread1\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        value.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread1\"</span>, value.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另一个子线程直接读取</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread2\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread2\"</span>, value.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行日志如下</p>\n<blockquote>\n<p>MainThread, true<br>Thread1, false<br>Thread2, null</p>\n</blockquote>\n<p>由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920407.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：深入剖析ThreadLocal</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Handler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的<code>runOnUiThread</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runOnUiThread</span><span class=\"params\">(Runnable action)</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Thread.currentThread() != mUiThread) &#123; </span><br><span class=\"line\">\t\tmHandler.post(action); </span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\t\taction.run(); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t...... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如 View 的<code>post</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(Runnable action)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> attachInfo.mHandler.post(action);         ①</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Assume that post will succeed later</span></span><br><span class=\"line\">        ViewRootImpl.getRunQueue().post(action);        ②</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>最后用一张图来结束本文</p>\n<p><img src=\"/Android-消息机制详解/消息流程图.jpg\" alt=\"流程图\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Android 的消息机制，主要是指 Handler 的运行机制。</p>","more":"<p></p>\n<h2 id=\"ANR\"><a href=\"#ANR\" class=\"headerlink\" title=\"ANR\"></a>ANR</h2><p>Application Not Responding，即应用程序无响应，在介绍消息机制的相关知识之前先了解 ANR。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>Android系统中，ActivityManagerService(AMS) 和 WindowManagerService(WMS) 会检测 App 的响应时间，如果App在特定时间无法响应屏幕触摸或键盘输入事件，或者特定事件没有处理完毕，就会出现ANR。</p>\n<p>以下四种条件都可以造成 ANR</p>\n<ul>\n<li>InputDispatching Timeout：5秒内无法响应屏幕触摸或键盘输入事件</li>\n<li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的<code>onReceive</code>方法中10秒没有处理完成，后台则为60秒。</li>\n<li>Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。</li>\n<li>ContentProvider Timeout ：ContentProvider 的 publish 在10s内没进行完。</li>\n</ul>\n<h3 id=\"分析和解决\"><a href=\"#分析和解决\" class=\"headerlink\" title=\"分析和解决\"></a>分析和解决</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>查看 log 信息</li>\n<li>Java 线程调用分析，<code>jstack {pid}</code>，其中 pid 为虚拟机进程 id，可以通过<code>jps</code>查看当前所有线程。</li>\n<li>查看 trace.txt 文件，其导出目录为 Android SDK 的 /platform-tools 目录，Windows 下在该目录使用命令<code>./adb pull /data/anr/traces.txt</code>查看</li>\n</ul>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ul>\n<li>避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。</li>\n<li>避免在主线程 query provider、不要滥用SharePreferences</li>\n<li>文件读写或数据库操作放在子线程异步操作，操作完成之后及时关闭流。</li>\n<li>BroadcastReciever 的<code>onRecieve</code>不要进行耗时操作。</li>\n</ul>\n<h2 id=\"Handler-机制\"><a href=\"#Handler-机制\" class=\"headerlink\" title=\"Handler 机制\"></a>Handler 机制</h2><p>由上文我们知道，在主线程进行耗时操作将会引发 ANR，而且 Android 禁止在子线程中直接 UI 操作，该机制由 ViewRootImpl 的<code>checkThread</code>进行验证<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mThread != Thread.currrentThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CalledFromWrongThreadException(</span><br><span class=\"line\">            <span class=\"string\">\"Only the original thread that created a view hierarchy can</span></span><br><span class=\"line\"><span class=\"string\">            touch its views\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用该机制的原因，一是多线程中并发访问 UI 会造成不可预知状态；二是对控件使用锁机制会降低 UI 访问的效率。<br>那么，当我们使用多线程技术结束数据的存储、获取，想回到主线程操作 UI 该怎么切换？</p>\n<p>答案是使用 Handler 。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接收消息</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"HandlerLeak\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> Handler mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            log.e(<span class=\"string\">\"MSG\"</span>, <span class=\"string\">\"收到消息\"</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            mHandler.sendEmptyMessage(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>使用成员变量创建 Handler 的方式很有可能造成内存泄漏，正确的做法是使用静态内部类和弱引用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyHandler hander = <span class=\"keyword\">new</span> MyHandler(context);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference&lt;Context&gt; out;</span><br><span class=\"line\">    </span><br><span class=\"line\">    MyHandler(Context ctx) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        out = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (out.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//进行消息处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Handler 的运行机制底层由 MessageQueue 和 Looper 支撑。简单概括，Handler 把一个线程消息发送给当前线程的消息队列，即 MessageQueue，而 Looper 负责管理消息队列的。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><p>观察 Handler 的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread \"</span> + Thread.currentThread()  + <span class=\"string\">\" that has not called\"</span> </span><br><span class=\"line\">            + <span class=\"string\">\" Looper.prepare()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在其中给 MessageQueue 、Callback 和 Asynchronous 赋值。观察 if 语句，如果 mLooper 为 null，则抛出异常，其实就是无法在未调用<code>Looper.prepare</code>的线程内创建 handler。</p>\n<p>不过，为什么在主线程中创建 Handler 不需要调用<code>Looper.prepare</code>和<code>Looper.loop</code>方法呢？其实是因为在创建 Activity 的时候，会经过一系列调用过程，最终执行 ActivityThread 的<code>main</code>方法，在其中调用了<code>prepareMainLooper</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">false</span>);     <span class=\"comment\">//quitAllowed 参数传false</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sMainLooper = myLooper();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 ActivityThread：<a href=\"http://www.cnblogs.com/younghao/p/5126408.html\" target=\"_blank\" rel=\"noopener\">Android线程管理（二）——ActivityThread</a></p>\n<h3 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h3><p>顾名思义，指消息队列。首先认识 Message，当用户在UI界面时点击一个按钮，该事件会被封装成一条 Message，被添加到 MessageQueue 中。Message 内部封装了一个属性 taget，其实质是一个 Handler 对象。</p>\n<p>由于一个线程在一段时间只能对一种操作进行相关的处理，因此使用 MessageQueue 来管理所有消息的先后顺序，其内部维护一个单链表用以存储消息列表。</p>\n<p>当 Handler 调用<code>sendMessage</code>时，最后会调用到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看<code>enqueueMessage</code>方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先判断消息队列里有没有消息，没有则将当前插入的消息作为队头，并且如果此时消息队列处于等待状态则将其唤醒</li>\n<li>如果队列已有消息，则根据 Message 创建的时间进行插入</li>\n</ul>\n<h3 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h3><p>通常运行在一个消息的循环队列当中，线程默认不会提供消息循环去管理消息队列，需要在线程当中调用<code>Looper.prepare</code>方法使消息循环初始化，并且调用<code>Looper.loop</code>使消息循环一直处于运行状态，<strong>取出 MessageQueue 中的消息分发给 Handler</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>prepare(boolean quitAllowed)</code>实例化了一个 Looper ，然后将其设置进 sThreadLocal 中。当<code>Looper.prepare</code>执行完毕之后才可以执行<code>loop</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程绑定的Looper</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//当前线程的MessageQueue</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">//循环从 MessageQueue 取出消息.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Message msg = queue.next();</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息分发出去</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">//将消息回收</span></span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，如果消息队列的 next 返回了新消息，就会调用<code>msg.target.dispatchMessage(msg)</code>，target 即为发送消息的 Handler 对象。成功将代码逻辑切换到指定的线程中执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先检查 Message 的 callBack 是否为空，不为空则<code>handlerCallback(msg)</code>，最终调用 callback 的<code>run</code>方法</li>\n<li>如果为空，检查 mCallBack 是否为空，不为空则调用它的<code>handleMassage</code>，CallBack 是一个接口，利用它我们可以传一个 Callback 来创建 Handler。</li>\n<li>如果都为空，调用 Handler 内部的<code>handleMessage</code>，也就是大多数时候我们创建 Handler 实例的时候需要重写的方法。</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个线程内部的数据存储类，当某些数据是以线程为作用域而且不同线程具有不同的数据副本的时候，可以采用 ThreadLocal。对于 Handler 来说，它需要获取当前线程的 Looper，很明显不同的线程具有各自的 Looper，此时就可以通过 ThreadLocal 实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找 Looper，再提供一个类似 LooperManager 的类。</p>\n<p>使用一个简单的例子演示 ThreadLocal 的真正含义<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新建一个 boolean 类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ThreadLocal&lt;Boolean&gt; value = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在主线程中将其设为 true</span></span><br><span class=\"line\">value.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">log.e(<span class=\"string\">\"MainThread\"</span>, value.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//子线程中设为 false</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread1\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        value.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread1\"</span>, value.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另一个子线程直接读取</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"string\">\"Thread2\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.e(<span class=\"string\">\"Thread2\"</span>, value.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行日志如下</p>\n<blockquote>\n<p>MainThread, true<br>Thread1, false<br>Thread2, null</p>\n</blockquote>\n<p>由此可以看出，虽然访问的是同一个 ThreadLocal 对象，但是不同线程获取的值是不一样的。ThreadLocal 的实现原理：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920407.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：深入剖析ThreadLocal</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Handler 机制是如此重要，开发中我们总会显式或隐式的用到它，比如 Activity 的<code>runOnUiThread</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runOnUiThread</span><span class=\"params\">(Runnable action)</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Thread.currentThread() != mUiThread) &#123; </span><br><span class=\"line\">\t\tmHandler.post(action); </span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\t\taction.run(); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t...... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如 View 的<code>post</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(Runnable action)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> attachInfo.mHandler.post(action);         ①</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Assume that post will succeed later</span></span><br><span class=\"line\">        ViewRootImpl.getRunQueue().post(action);        ②</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>最后用一张图来结束本文</p>\n<p><img src=\"/Android-消息机制详解/消息流程图.jpg\" alt=\"流程图\"></p>"},{"title":"Java 排序算法","date":"2019-03-15T10:36:47.000Z","mathjax":true,"_content":"\n## 引言\n排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。<!--more-->\n\n## 稳定性\n对于一个数组`a {6,2,4,6,1}`，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种\n\n|  1   |  2   |  4   |    6    |    6    |\n| :--: | :--: | :--: | :-----: | :-----: |\n| a[4] | a[1] | a[2] | <b>a[0] | <b>a[3] |\n| a[4] | a[1] | a[2] | <b>a[3] | <B>a[0] |\n\n如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法\n> 冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等\n\n否则，属于不稳定的排序算法\n> 选择排序，希尔排序，堆排序，快速排序等\n\n## 冒泡排序\n```Java\n/**\n * 冒泡排序，O(n^2)\n * 每一次内层循环中，两两比较，将较大的数放到后面\n * \n * @param a 待排序数据\n */\npublic static void bubbleSort(int[] a) {\n    int length = a.length;\n    int i = 0;\n    int temp;\n\n    for ( ; i < length - 1; i++) {\n        int j = 0;\n\n        for ( ; j < length - 1 - i; j++) {\n            if (a[j] > a[j+1]) {\n                temp = a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序\n\n### 直接插入排序\n```Java\n/**\n * 直接插入排序，O(n^2)\n * i从第一个元素开始，默认i前面的序列已经排好序\n * 取出i的下一个元素，从后往前比较，找到适合的位置就插入\n *\n * @param a 待排序序列\n */\npublic static void insertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n\n        for (int j = i; j > 0; j--) {\n            if (a[j] < a[j-1]) {\n                a[j] = a[j-1];\n                a[j-1] = temp;\n            }\n        }\n    }\n}\n```\n\n### 折半插入排序\n```Java\n/**\n * 折半插入排序，O(n^2)\n * 对直接插入排序算法进行了改进\n * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要\n * 折半插入排序则使用了折半查找/二分查找\n *\n * Arrays类的binarySearch()方法便是折半查找的实现\n *\n * @param a 待排序序列\n */\npublic static void binaryInsertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n        int low = 0;\n        int high = i-1;\n        while (low <= high) {\n            int middle = (low+high) / 2;\n            if (a[middle] < temp) {\n                low = middle+1;\n            } else {\n                high = middle-1;\n            }\n        }\n        for(int j = i-1; j >= low; j--) {\n             //元素后移，为插入temp做准备\n            a[j+1] = a[j];\n        }\n        a[low] = temp;\n    }\n}\n```\n### 希尔排序\n```Java\n/**\n * 希尔排序，也称 递减增量排序，O(n*(logn)^2)\n * 对于n个元素的序列，假设增量为increment\n * 从第一个元素开始，每隔increment取一个元素组成一个子序列\n * 对每个子序列进行直接插入排序，increment /= 2\n * 重复上述过程，直至increment为1\n *\n * @param a 待排序序列\n */\npublic static void shellSort(int[] a) {\n    int length = a.length;\n\n    // increment为增量，每次减为原来的一半，直至为1\n    for (int increment = length / 2; increment > 0; increment /= 2) {\n\n        // 共increment个组，对每一组都执行直接插入排序\n        for (int i = 0; i < increment; i++) {\n\n            for (int j = i + increment; j < length; j += increment) {\n\n                // 如果a[j] < a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。\n                if (a[j] < a[j - increment]) {\n\n                    int temp = a[j];\n                    int k = j - increment;\n                    while (k >= 0 && a[k] > temp) {\n                        a[k + increment] = a[k];\n                        k -= increment;\n                    }\n                    a[k + increment] = temp;\n                }\n            }\n        }\n    }\n}\n```\n## 桶排序（基数排序）\n```Java\n/**\n * 基数排序，也称桶排序，O(d(k+n))\n * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。\n * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n *\n * @param a 待排序数组\n * @param d 位数，如果最大数为9527，则d为10000，如果为7，则d为10\n */\npublic static void radixSort(int[] a,int d) {\n    int n = 1;  //代表位数对应的数：1,10,100...\n    int k = 0;  //保存每一位排序后的结果用于下一位的排序输入\n    int length = a.length;\n\n    int[][] bucket = new int[10][length];  //排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n    int[] order = new int[length];  //用于保存每个桶里有多少个数字\n\n    while(n < d) {\n        for(int num : a) { //将数组array里的每个数字放在相应的桶里\n            int digit = (num/n)%10;\n            bucket[digit][order[digit]] = num;\n            order[digit]++;\n        }\n        int i = 0;\n        for( ; i<length; i++) { //将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            if(order[i] != 0) {  //这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                int j = 0;\n                for( ; j < order[i]; j++) {\n                    a[k] = bucket[i][j];\n                    k++;\n                }\n            }\n            order[i]=0;  //将桶里计数器置0，用于下一次位排序\n        }\n        n *= 10;\n        k = 0;  //将k置0，用于下一轮保存位排序结果\n    }\n}\n```\n\n## 归并排序\n```Java\n/**\n * 归并排序，O(nlog(n))\n * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1\n * 然合并以上序列\n *\n * @param array\n * @param left\n * @param right\n */\npublic static void mergeSort(int[] array, int left, int right) {\n   if (left < right) {\n       int center = (left + right) / 2;\n       mergeSort(array, left, center);\n       mergeSort(array, center+1, right);\n       merge(array, left, center, right);\n   }\n}\n\nstatic void merge(int[] array, int low, int mid, int high) {\n    int[] tempArray = new int[high - low + 1];\n    int temp = 0;\n    int i = low;\n    int j = mid + 1;\n\n    while (i <= mid && j <= high) {\n        if (array[i] <= array[j]) {\n            tempArray[temp++] = array[i++];\n        } else {\n            tempArray[temp++] = array[j++];\n        }\n    }\n\n    while (i <= mid) {  //此时右边已到底\n        tempArray[temp++] = array[i++];\n    }\n    while (j <= high) { //此时左边已到底\n        tempArray[temp++] = array[j++];\n    }\n    //将新数组中的数 覆盖原数组low之后的数据\n    for (int k = 0; k < tempArray.length; k++) {\n        array[k+low] = tempArray[k];\n    }\n}\n```\n\n## 选择排序\n```Java\n/**\n  * 选择排序，O(n^2)\n  * 遍历整个序列，将最小的数放在最前面\n  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程\n  *\n  * @param a 待排序序列\n  */\n public static void selectSort(int[] a){\n     int length = a.length;\n     int i = 0;\n\n     for( ; i < length; i++){  //外层循环\n         int temp = a[i];\n         int position = i;\n         int j = i+1;\n\n         for( ; j < length; j++) {  //往后遍历，找到最小的值以及其位置\n             if(a[j] < temp) {\n                 temp = a[j];\n                 position = j;\n             }\n         }\n         a[position]=a[i];  //进行交换\n         a[i] = temp;\n     }\n \n```\n\n## 快速排序\n```Java\n/**\n * 快速排序，O(nlog(n))\n * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分\n * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序\n *\n * @param a 待排序序列\n * @param start 序列开始值\n * @param end 序列结束值\n */\npublic static void quickSort(int[] a, int start, int end) {\n    int baseNum = a[start];\n    int temp;\n    int left = start;\n    int right = end;\n    do {\n        while (a[left] < baseNum && left < end) {\n            left++;\n        }\n        while (a[right] > baseNum && right > start) {\n            right--;\n        }\n\n        if (left <= right) {  //左边出现大于基准值或者右边出现小于基准值，且left<=right\n            temp = a[left];\n            a[left] = a[right];\n            a[right] = temp;\n            left++; right--;\n        }\n    } while (left <= right);\n\n    if (start < right) {\n        quickSort(a, start, right);\n    }\n    if (end > left) {\n        quickSort(a, left, end);\n    }\n}\n```\n\n## 二叉树排序\n通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$\n近似于折半查找。\n\n如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$\n```Java\npublic class BinarySortTree {\n    static class Node {\n        private Comparable data;\n        private Node left;\n        private Node right;\n\n        public Node(Comparable data) {\n            this.data = data;\n        }\n\n        public void addNode(Node newNode) {\n            if (newNode.data.compareTo(this.data) < 0) {\n                if (left == null) {\n                    left = newNode;\n                } else {\n                    left.addNode(newNode);\n                }\n            } else {\n                if (right == null) {\n                    right = newNode;\n                } else {\n                    right.addNode(newNode);\n                }\n            }\n        }\n\n        public void printNode() {   //中序遍历\n            if (left != null) {\n                left.printNode();\n            }\n            System.out.println(this.data);\n            if (right != null) {\n                right.printNode();\n            }\n        }\n    }\n\n    private Node root;\n\n    public void add(Comparable data) {  //向二叉树中插入元素\n        Node node = new Node(data);\n        if (root == null) {\n            root = node;\n        } else {\n            root.addNode(node);\n        }\n    }\n\n    public void print() {\n        root.printNode();\n    }\n}\n```\n调用如下\n```Java\npublic static void main(String[] args) {\n    int[] a = {12,0,34,5,2,8,456};\n    BinarySortTree tree = new BinarySortTree();\n    for (int i : a) {            \n        tree.add(i);\n    }\n    tree.print();\n}\n```\n\n## 查找算法\n\n### 二分查找\n只能对有序序列进行查找\n```Java\npublic static int binarySearch(int[] array, int low, int high, int target) {\n    if (low > high) return -1;\n    int mid = low + (high - low) / 2;\n    \n    if (array[mid] > target)\n        return binarySearch(array, low, mid - 1, target);\n\n    if (array[mid] < target)\n        return binarySearch(array, mid + 1, high, target);\n\n    return mid;\n}\n\npublic static int bSearchWithoutRecursion(int a[], int key) {\n    int low = 0;\n    int high = a.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (a[mid] > key)\n            high = mid - 1;\n        else if (a[mid] < key)\n            low = mid + 1;\n        else\n            return mid;\n    }\n    return -1;\n}\n```\n\n### 顺序查找\n实现较简单，略过\n\n### 二叉树查找\n可以通过构建一个二叉搜索树实现","source":"_posts/Java-排序算法.md","raw":"---\ntitle: Java 排序算法\ndate: 2019-03-15 18:36:47\nmathjax: true\ntags:\n- 算法\n- Java\ncategories:\n- 算法\n---\n\n## 引言\n排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。<!--more-->\n\n## 稳定性\n对于一个数组`a {6,2,4,6,1}`，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种\n\n|  1   |  2   |  4   |    6    |    6    |\n| :--: | :--: | :--: | :-----: | :-----: |\n| a[4] | a[1] | a[2] | <b>a[0] | <b>a[3] |\n| a[4] | a[1] | a[2] | <b>a[3] | <B>a[0] |\n\n如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法\n> 冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等\n\n否则，属于不稳定的排序算法\n> 选择排序，希尔排序，堆排序，快速排序等\n\n## 冒泡排序\n```Java\n/**\n * 冒泡排序，O(n^2)\n * 每一次内层循环中，两两比较，将较大的数放到后面\n * \n * @param a 待排序数据\n */\npublic static void bubbleSort(int[] a) {\n    int length = a.length;\n    int i = 0;\n    int temp;\n\n    for ( ; i < length - 1; i++) {\n        int j = 0;\n\n        for ( ; j < length - 1 - i; j++) {\n            if (a[j] > a[j+1]) {\n                temp = a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序\n\n### 直接插入排序\n```Java\n/**\n * 直接插入排序，O(n^2)\n * i从第一个元素开始，默认i前面的序列已经排好序\n * 取出i的下一个元素，从后往前比较，找到适合的位置就插入\n *\n * @param a 待排序序列\n */\npublic static void insertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n\n        for (int j = i; j > 0; j--) {\n            if (a[j] < a[j-1]) {\n                a[j] = a[j-1];\n                a[j-1] = temp;\n            }\n        }\n    }\n}\n```\n\n### 折半插入排序\n```Java\n/**\n * 折半插入排序，O(n^2)\n * 对直接插入排序算法进行了改进\n * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要\n * 折半插入排序则使用了折半查找/二分查找\n *\n * Arrays类的binarySearch()方法便是折半查找的实现\n *\n * @param a 待排序序列\n */\npublic static void binaryInsertSort(int[] a) {\n    int length = a.length;\n\n    for (int i = 0; i < length; i++) {\n        int temp = a[i];\n        int low = 0;\n        int high = i-1;\n        while (low <= high) {\n            int middle = (low+high) / 2;\n            if (a[middle] < temp) {\n                low = middle+1;\n            } else {\n                high = middle-1;\n            }\n        }\n        for(int j = i-1; j >= low; j--) {\n             //元素后移，为插入temp做准备\n            a[j+1] = a[j];\n        }\n        a[low] = temp;\n    }\n}\n```\n### 希尔排序\n```Java\n/**\n * 希尔排序，也称 递减增量排序，O(n*(logn)^2)\n * 对于n个元素的序列，假设增量为increment\n * 从第一个元素开始，每隔increment取一个元素组成一个子序列\n * 对每个子序列进行直接插入排序，increment /= 2\n * 重复上述过程，直至increment为1\n *\n * @param a 待排序序列\n */\npublic static void shellSort(int[] a) {\n    int length = a.length;\n\n    // increment为增量，每次减为原来的一半，直至为1\n    for (int increment = length / 2; increment > 0; increment /= 2) {\n\n        // 共increment个组，对每一组都执行直接插入排序\n        for (int i = 0; i < increment; i++) {\n\n            for (int j = i + increment; j < length; j += increment) {\n\n                // 如果a[j] < a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。\n                if (a[j] < a[j - increment]) {\n\n                    int temp = a[j];\n                    int k = j - increment;\n                    while (k >= 0 && a[k] > temp) {\n                        a[k + increment] = a[k];\n                        k -= increment;\n                    }\n                    a[k + increment] = temp;\n                }\n            }\n        }\n    }\n}\n```\n## 桶排序（基数排序）\n```Java\n/**\n * 基数排序，也称桶排序，O(d(k+n))\n * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。\n * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n *\n * @param a 待排序数组\n * @param d 位数，如果最大数为9527，则d为10000，如果为7，则d为10\n */\npublic static void radixSort(int[] a,int d) {\n    int n = 1;  //代表位数对应的数：1,10,100...\n    int k = 0;  //保存每一位排序后的结果用于下一位的排序输入\n    int length = a.length;\n\n    int[][] bucket = new int[10][length];  //排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n    int[] order = new int[length];  //用于保存每个桶里有多少个数字\n\n    while(n < d) {\n        for(int num : a) { //将数组array里的每个数字放在相应的桶里\n            int digit = (num/n)%10;\n            bucket[digit][order[digit]] = num;\n            order[digit]++;\n        }\n        int i = 0;\n        for( ; i<length; i++) { //将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            if(order[i] != 0) {  //这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                int j = 0;\n                for( ; j < order[i]; j++) {\n                    a[k] = bucket[i][j];\n                    k++;\n                }\n            }\n            order[i]=0;  //将桶里计数器置0，用于下一次位排序\n        }\n        n *= 10;\n        k = 0;  //将k置0，用于下一轮保存位排序结果\n    }\n}\n```\n\n## 归并排序\n```Java\n/**\n * 归并排序，O(nlog(n))\n * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1\n * 然合并以上序列\n *\n * @param array\n * @param left\n * @param right\n */\npublic static void mergeSort(int[] array, int left, int right) {\n   if (left < right) {\n       int center = (left + right) / 2;\n       mergeSort(array, left, center);\n       mergeSort(array, center+1, right);\n       merge(array, left, center, right);\n   }\n}\n\nstatic void merge(int[] array, int low, int mid, int high) {\n    int[] tempArray = new int[high - low + 1];\n    int temp = 0;\n    int i = low;\n    int j = mid + 1;\n\n    while (i <= mid && j <= high) {\n        if (array[i] <= array[j]) {\n            tempArray[temp++] = array[i++];\n        } else {\n            tempArray[temp++] = array[j++];\n        }\n    }\n\n    while (i <= mid) {  //此时右边已到底\n        tempArray[temp++] = array[i++];\n    }\n    while (j <= high) { //此时左边已到底\n        tempArray[temp++] = array[j++];\n    }\n    //将新数组中的数 覆盖原数组low之后的数据\n    for (int k = 0; k < tempArray.length; k++) {\n        array[k+low] = tempArray[k];\n    }\n}\n```\n\n## 选择排序\n```Java\n/**\n  * 选择排序，O(n^2)\n  * 遍历整个序列，将最小的数放在最前面\n  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程\n  *\n  * @param a 待排序序列\n  */\n public static void selectSort(int[] a){\n     int length = a.length;\n     int i = 0;\n\n     for( ; i < length; i++){  //外层循环\n         int temp = a[i];\n         int position = i;\n         int j = i+1;\n\n         for( ; j < length; j++) {  //往后遍历，找到最小的值以及其位置\n             if(a[j] < temp) {\n                 temp = a[j];\n                 position = j;\n             }\n         }\n         a[position]=a[i];  //进行交换\n         a[i] = temp;\n     }\n \n```\n\n## 快速排序\n```Java\n/**\n * 快速排序，O(nlog(n))\n * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分\n * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序\n *\n * @param a 待排序序列\n * @param start 序列开始值\n * @param end 序列结束值\n */\npublic static void quickSort(int[] a, int start, int end) {\n    int baseNum = a[start];\n    int temp;\n    int left = start;\n    int right = end;\n    do {\n        while (a[left] < baseNum && left < end) {\n            left++;\n        }\n        while (a[right] > baseNum && right > start) {\n            right--;\n        }\n\n        if (left <= right) {  //左边出现大于基准值或者右边出现小于基准值，且left<=right\n            temp = a[left];\n            a[left] = a[right];\n            a[right] = temp;\n            left++; right--;\n        }\n    } while (left <= right);\n\n    if (start < right) {\n        quickSort(a, start, right);\n    }\n    if (end > left) {\n        quickSort(a, left, end);\n    }\n}\n```\n\n## 二叉树排序\n通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$\n近似于折半查找。\n\n如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$\n```Java\npublic class BinarySortTree {\n    static class Node {\n        private Comparable data;\n        private Node left;\n        private Node right;\n\n        public Node(Comparable data) {\n            this.data = data;\n        }\n\n        public void addNode(Node newNode) {\n            if (newNode.data.compareTo(this.data) < 0) {\n                if (left == null) {\n                    left = newNode;\n                } else {\n                    left.addNode(newNode);\n                }\n            } else {\n                if (right == null) {\n                    right = newNode;\n                } else {\n                    right.addNode(newNode);\n                }\n            }\n        }\n\n        public void printNode() {   //中序遍历\n            if (left != null) {\n                left.printNode();\n            }\n            System.out.println(this.data);\n            if (right != null) {\n                right.printNode();\n            }\n        }\n    }\n\n    private Node root;\n\n    public void add(Comparable data) {  //向二叉树中插入元素\n        Node node = new Node(data);\n        if (root == null) {\n            root = node;\n        } else {\n            root.addNode(node);\n        }\n    }\n\n    public void print() {\n        root.printNode();\n    }\n}\n```\n调用如下\n```Java\npublic static void main(String[] args) {\n    int[] a = {12,0,34,5,2,8,456};\n    BinarySortTree tree = new BinarySortTree();\n    for (int i : a) {            \n        tree.add(i);\n    }\n    tree.print();\n}\n```\n\n## 查找算法\n\n### 二分查找\n只能对有序序列进行查找\n```Java\npublic static int binarySearch(int[] array, int low, int high, int target) {\n    if (low > high) return -1;\n    int mid = low + (high - low) / 2;\n    \n    if (array[mid] > target)\n        return binarySearch(array, low, mid - 1, target);\n\n    if (array[mid] < target)\n        return binarySearch(array, mid + 1, high, target);\n\n    return mid;\n}\n\npublic static int bSearchWithoutRecursion(int a[], int key) {\n    int low = 0;\n    int high = a.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (a[mid] > key)\n            high = mid - 1;\n        else if (a[mid] < key)\n            low = mid + 1;\n        else\n            return mid;\n    }\n    return -1;\n}\n```\n\n### 顺序查找\n实现较简单，略过\n\n### 二叉树查找\n可以通过构建一个二叉搜索树实现","slug":"Java-排序算法","published":1,"updated":"2019-03-15T15:53:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavc5001ni0up4iytqr3y","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。<a id=\"more\"></a></p>\n<h2 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h2><p>对于一个数组<code>a {6,2,4,6,1}</code>，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n</tr>\n</tbody>\n</table>\n<p>如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法</p>\n<blockquote>\n<p>冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等</p>\n</blockquote>\n<p>否则，属于不稳定的排序算法</p>\n<blockquote>\n<p>选择排序，希尔排序，堆排序，快速排序等</p>\n</blockquote>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 冒泡排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 每一次内层循环中，两两比较，将较大的数放到后面</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &gt; a[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                temp = a[j];</span><br><span class=\"line\">                a[j] = a[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序</p>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * i从第一个元素开始，默认i前面的序列已经排好序</span></span><br><span class=\"line\"><span class=\"comment\"> * 取出i的下一个元素，从后往前比较，找到适合的位置就插入</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &lt; a[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                a[j] = a[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对直接插入排序算法进行了改进</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序则使用了折半查找/二分查找</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Arrays类的binarySearch()方法便是折半查找的实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">binaryInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = i-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (low+high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[middle] &lt; temp) &#123;</span><br><span class=\"line\">                low = middle+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                high = middle-<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i-<span class=\"number\">1</span>; j &gt;= low; j--) &#123;</span><br><span class=\"line\">             <span class=\"comment\">//元素后移，为插入temp做准备</span></span><br><span class=\"line\">            a[j+<span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[low] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 希尔排序，也称 递减增量排序，O(n*(logn)^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于n个元素的序列，假设增量为increment</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第一个元素开始，每隔increment取一个元素组成一个子序列</span></span><br><span class=\"line\"><span class=\"comment\"> * 对每个子序列进行直接插入排序，increment /= 2</span></span><br><span class=\"line\"><span class=\"comment\"> * 重复上述过程，直至increment为1</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increment为增量，每次减为原来的一半，直至为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> increment = length / <span class=\"number\">2</span>; increment &gt; <span class=\"number\">0</span>; increment /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 共increment个组，对每一组都执行直接插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; increment; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + increment; j &lt; length; j += increment) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果a[j] &lt; a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[j] &lt; a[j - increment]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = a[j];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> k = j - increment;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span> &amp;&amp; a[k] &gt; temp) &#123;</span><br><span class=\"line\">                        a[k + increment] = a[k];</span><br><span class=\"line\">                        k -= increment;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    a[k + increment] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"桶排序（基数排序）\"><a href=\"#桶排序（基数排序）\" class=\"headerlink\" title=\"桶排序（基数排序）\"></a>桶排序（基数排序）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基数排序，也称桶排序，O(d(k+n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。</span></span><br><span class=\"line\"><span class=\"comment\"> * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> d 位数，如果最大数为9527，则d为10000，如果为7，则d为10</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a,<span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">1</span>;  <span class=\"comment\">//代表位数对应的数：1,10,100...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;  <span class=\"comment\">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] bucket = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][length];  <span class=\"comment\">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] order = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];  <span class=\"comment\">//用于保存每个桶里有多少个数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &lt; d) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : a) &#123; <span class=\"comment\">//将数组array里的每个数字放在相应的桶里</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> digit = (num/n)%<span class=\"number\">10</span>;</span><br><span class=\"line\">            bucket[digit][order[digit]] = num;</span><br><span class=\"line\">            order[digit]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( ; i&lt;length; i++) &#123; <span class=\"comment\">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(order[i] != <span class=\"number\">0</span>) &#123;  <span class=\"comment\">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>( ; j &lt; order[i]; j++) &#123;</span><br><span class=\"line\">                    a[k] = bucket[i][j];</span><br><span class=\"line\">                    k++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            order[i]=<span class=\"number\">0</span>;  <span class=\"comment\">//将桶里计数器置0，用于下一次位排序</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        k = <span class=\"number\">0</span>;  <span class=\"comment\">//将k置0，用于下一轮保存位排序结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 归并排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1</span></span><br><span class=\"line\"><span class=\"comment\"> * 然合并以上序列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> left</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> right</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">       mergeSort(array, left, center);</span><br><span class=\"line\">       mergeSort(array, center+<span class=\"number\">1</span>, right);</span><br><span class=\"line\">       merge(array, left, center, right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] tempArray = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[high - low + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class=\"line\">            tempArray[temp++] = array[i++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tempArray[temp++] = array[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= mid) &#123;  <span class=\"comment\">//此时右边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt;= high) &#123; <span class=\"comment\">//此时左边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将新数组中的数 覆盖原数组low之后的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; tempArray.length; k++) &#123;</span><br><span class=\"line\">        array[k+low] = tempArray[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 选择排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历整个序列，将最小的数放在最前面</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>( ; i &lt; length; i++)&#123;  <span class=\"comment\">//外层循环</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">         <span class=\"keyword\">int</span> position = i;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span>( ; j &lt; length; j++) &#123;  <span class=\"comment\">//往后遍历，找到最小的值以及其位置</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span>(a[j] &lt; temp) &#123;</span><br><span class=\"line\">                 temp = a[j];</span><br><span class=\"line\">                 position = j;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         a[position]=a[i];  <span class=\"comment\">//进行交换</span></span><br><span class=\"line\">         a[i] = temp;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分</span></span><br><span class=\"line\"><span class=\"comment\"> * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 序列开始值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end 序列结束值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> baseNum = a[start];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = end;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[left] &lt; baseNum &amp;&amp; left &lt; end) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[right] &gt; baseNum &amp;&amp; right &gt; start) &#123;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= right) &#123;  <span class=\"comment\">//左边出现大于基准值或者右边出现小于基准值，且left&lt;=right</span></span><br><span class=\"line\">            temp = a[left];</span><br><span class=\"line\">            a[left] = a[right];</span><br><span class=\"line\">            a[right] = temp;</span><br><span class=\"line\">            left++; right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (left &lt;= right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; right) &#123;</span><br><span class=\"line\">        quickSort(a, start, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt; left) &#123;</span><br><span class=\"line\">        quickSort(a, left, end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树排序\"><a href=\"#二叉树排序\" class=\"headerlink\" title=\"二叉树排序\"></a>二叉树排序</h2><p>通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$<br>近似于折半查找。</p>\n<p>如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySortTree</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Comparable data;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node left;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(Comparable data)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(Node newNode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newNode.data.compareTo(<span class=\"keyword\">this</span>.data) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    left = newNode;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    left.addNode(newNode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    right = newNode;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    right.addNode(newNode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printNode</span><span class=\"params\">()</span> </span>&#123;   <span class=\"comment\">//中序遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                left.printNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                right.printNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Comparable data)</span> </span>&#123;  <span class=\"comment\">//向二叉树中插入元素</span></span><br><span class=\"line\">        Node node = <span class=\"keyword\">new</span> Node(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root = node;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root.addNode(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        root.printNode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">12</span>,<span class=\"number\">0</span>,<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">    BinarySortTree tree = <span class=\"keyword\">new</span> BinarySortTree();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : a) &#123;            </span><br><span class=\"line\">        tree.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree.print();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"查找算法\"><a href=\"#查找算法\" class=\"headerlink\" title=\"查找算法\"></a>查找算法</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>只能对有序序列进行查找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; high) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] &gt; target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, low, mid - <span class=\"number\">1</span>, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] &lt; target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, mid + <span class=\"number\">1</span>, high, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bSearchWithoutRecursion</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = a.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[mid] &gt; key)</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[mid] &lt; key)</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"顺序查找\"><a href=\"#顺序查找\" class=\"headerlink\" title=\"顺序查找\"></a>顺序查找</h3><p>实现较简单，略过</p>\n<h3 id=\"二叉树查找\"><a href=\"#二叉树查找\" class=\"headerlink\" title=\"二叉树查找\"></a>二叉树查找</h3><p>可以通过构建一个二叉搜索树实现</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>排序算法一直是程序员开发和面试的重点，本文将重点讲解几种常用的排序算法。</p>","more":"<p></p>\n<h2 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h2><p>对于一个数组<code>a {6,2,4,6,1}</code>，其中有两个值为 6，为 a[0] 和 a[3]，排序之后的结果有两种</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a[4]</td>\n<td style=\"text-align:center\">a[1]</td>\n<td style=\"text-align:center\">a[2]</td>\n<td style=\"text-align:center\"><b>a[3]</b></td>\n<td style=\"text-align:center\"><b>a[0]</b></td>\n</tr>\n</tbody>\n</table>\n<p>如果排序结束之后，a[0] 可以保证一定在 a[3] 前面，即原有的顺序不变，则该算法属于稳定的排序算法</p>\n<blockquote>\n<p>冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等</p>\n</blockquote>\n<p>否则，属于不稳定的排序算法</p>\n<blockquote>\n<p>选择排序，希尔排序，堆排序，快速排序等</p>\n</blockquote>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 冒泡排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 每一次内层循环中，两两比较，将较大的数放到后面</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &gt; a[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                temp = a[j];</span><br><span class=\"line\">                a[j] = a[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序可以分为直接插入排序，以及其变种——折半插入排序、希尔排序</p>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * i从第一个元素开始，默认i前面的序列已经排好序</span></span><br><span class=\"line\"><span class=\"comment\"> * 取出i的下一个元素，从后往前比较，找到适合的位置就插入</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &lt; a[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                a[j] = a[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对直接插入排序算法进行了改进</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接插入算法采用遍历一个有序序列的方式插入待排序元素，完全没必要</span></span><br><span class=\"line\"><span class=\"comment\"> * 折半插入排序则使用了折半查找/二分查找</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Arrays类的binarySearch()方法便是折半查找的实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">binaryInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = i-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (low+high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[middle] &lt; temp) &#123;</span><br><span class=\"line\">                low = middle+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                high = middle-<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i-<span class=\"number\">1</span>; j &gt;= low; j--) &#123;</span><br><span class=\"line\">             <span class=\"comment\">//元素后移，为插入temp做准备</span></span><br><span class=\"line\">            a[j+<span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[low] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 希尔排序，也称 递减增量排序，O(n*(logn)^2)</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于n个元素的序列，假设增量为increment</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第一个元素开始，每隔increment取一个元素组成一个子序列</span></span><br><span class=\"line\"><span class=\"comment\"> * 对每个子序列进行直接插入排序，increment /= 2</span></span><br><span class=\"line\"><span class=\"comment\"> * 重复上述过程，直至increment为1</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increment为增量，每次减为原来的一半，直至为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> increment = length / <span class=\"number\">2</span>; increment &gt; <span class=\"number\">0</span>; increment /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 共increment个组，对每一组都执行直接插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; increment; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + increment; j &lt; length; j += increment) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果a[j] &lt; a[j-increment]，则寻找a[j]位置，并将后面数据的位置都后移。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[j] &lt; a[j - increment]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = a[j];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> k = j - increment;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span> &amp;&amp; a[k] &gt; temp) &#123;</span><br><span class=\"line\">                        a[k + increment] = a[k];</span><br><span class=\"line\">                        k -= increment;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    a[k + increment] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"桶排序（基数排序）\"><a href=\"#桶排序（基数排序）\" class=\"headerlink\" title=\"桶排序（基数排序）\"></a>桶排序（基数排序）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基数排序，也称桶排序，O(d(k+n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。</span></span><br><span class=\"line\"><span class=\"comment\"> * 具体做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> d 位数，如果最大数为9527，则d为10000，如果为7，则d为10</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a,<span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">1</span>;  <span class=\"comment\">//代表位数对应的数：1,10,100...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;  <span class=\"comment\">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] bucket = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][length];  <span class=\"comment\">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] order = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];  <span class=\"comment\">//用于保存每个桶里有多少个数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &lt; d) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : a) &#123; <span class=\"comment\">//将数组array里的每个数字放在相应的桶里</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> digit = (num/n)%<span class=\"number\">10</span>;</span><br><span class=\"line\">            bucket[digit][order[digit]] = num;</span><br><span class=\"line\">            order[digit]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( ; i&lt;length; i++) &#123; <span class=\"comment\">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(order[i] != <span class=\"number\">0</span>) &#123;  <span class=\"comment\">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>( ; j &lt; order[i]; j++) &#123;</span><br><span class=\"line\">                    a[k] = bucket[i][j];</span><br><span class=\"line\">                    k++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            order[i]=<span class=\"number\">0</span>;  <span class=\"comment\">//将桶里计数器置0，用于下一次位排序</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        k = <span class=\"number\">0</span>;  <span class=\"comment\">//将k置0，用于下一轮保存位排序结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 归并排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 典型的分治算法，把一个序列的排序分成两个子序列的排序，对子序列重复以上操作直至序列长度为1</span></span><br><span class=\"line\"><span class=\"comment\"> * 然合并以上序列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> left</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> right</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">       mergeSort(array, left, center);</span><br><span class=\"line\">       mergeSort(array, center+<span class=\"number\">1</span>, right);</span><br><span class=\"line\">       merge(array, left, center, right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] tempArray = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[high - low + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class=\"line\">            tempArray[temp++] = array[i++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tempArray[temp++] = array[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= mid) &#123;  <span class=\"comment\">//此时右边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt;= high) &#123; <span class=\"comment\">//此时左边已到底</span></span><br><span class=\"line\">        tempArray[temp++] = array[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将新数组中的数 覆盖原数组low之后的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; tempArray.length; k++) &#123;</span><br><span class=\"line\">        array[k+low] = tempArray[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 选择排序，O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历整个序列，将最小的数放在最前面</span></span><br><span class=\"line\"><span class=\"comment\">  * 遍历剩下的序列，将最小的数放在最前面，重复上述过程</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> length = a.length;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>( ; i &lt; length; i++)&#123;  <span class=\"comment\">//外层循环</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> temp = a[i];</span><br><span class=\"line\">         <span class=\"keyword\">int</span> position = i;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span>( ; j &lt; length; j++) &#123;  <span class=\"comment\">//往后遍历，找到最小的值以及其位置</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span>(a[j] &lt; temp) &#123;</span><br><span class=\"line\">                 temp = a[j];</span><br><span class=\"line\">                 position = j;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         a[position]=a[i];  <span class=\"comment\">//进行交换</span></span><br><span class=\"line\">         a[i] = temp;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序，O(nlog(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 对冒泡排序的改进，选取一个记录作为基准，经过一趟排序后，将整段序列分成两部分</span></span><br><span class=\"line\"><span class=\"comment\"> * 前半部分小于基准值，后半部分大于基准值，然后递归前、后两部分，继续排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> a 待排序序列</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 序列开始值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end 序列结束值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> baseNum = a[start];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = end;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[left] &lt; baseNum &amp;&amp; left &lt; end) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[right] &gt; baseNum &amp;&amp; right &gt; start) &#123;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= right) &#123;  <span class=\"comment\">//左边出现大于基准值或者右边出现小于基准值，且left&lt;=right</span></span><br><span class=\"line\">            temp = a[left];</span><br><span class=\"line\">            a[left] = a[right];</span><br><span class=\"line\">            a[right] = temp;</span><br><span class=\"line\">            left++; right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (left &lt;= right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; right) &#123;</span><br><span class=\"line\">        quickSort(a, start, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt; left) &#123;</span><br><span class=\"line\">        quickSort(a, left, end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树排序\"><a href=\"#二叉树排序\" class=\"headerlink\" title=\"二叉树排序\"></a>二叉树排序</h2><p>通过二叉树的中序遍历实现。如果二叉排序树是平衡的，则时间复杂度为 $O(\\log_2 n)$<br>近似于折半查找。</p>\n<p>如果二叉排序树完全不平衡，则时间复杂度为 $O(n)$<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySortTree</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Comparable data;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node left;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(Comparable data)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(Node newNode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newNode.data.compareTo(<span class=\"keyword\">this</span>.data) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    left = newNode;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    left.addNode(newNode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    right = newNode;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    right.addNode(newNode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printNode</span><span class=\"params\">()</span> </span>&#123;   <span class=\"comment\">//中序遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                left.printNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                right.printNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Comparable data)</span> </span>&#123;  <span class=\"comment\">//向二叉树中插入元素</span></span><br><span class=\"line\">        Node node = <span class=\"keyword\">new</span> Node(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root = node;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root.addNode(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        root.printNode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">12</span>,<span class=\"number\">0</span>,<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">456</span>&#125;;</span><br><span class=\"line\">    BinarySortTree tree = <span class=\"keyword\">new</span> BinarySortTree();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : a) &#123;            </span><br><span class=\"line\">        tree.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree.print();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"查找算法\"><a href=\"#查找算法\" class=\"headerlink\" title=\"查找算法\"></a>查找算法</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>只能对有序序列进行查找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; high) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] &gt; target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, low, mid - <span class=\"number\">1</span>, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[mid] &lt; target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array, mid + <span class=\"number\">1</span>, high, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bSearchWithoutRecursion</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = a.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[mid] &gt; key)</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[mid] &lt; key)</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"顺序查找\"><a href=\"#顺序查找\" class=\"headerlink\" title=\"顺序查找\"></a>顺序查找</h3><p>实现较简单，略过</p>\n<h3 id=\"二叉树查找\"><a href=\"#二叉树查找\" class=\"headerlink\" title=\"二叉树查找\"></a>二叉树查找</h3><p>可以通过构建一个二叉搜索树实现</p>"},{"title":"Java设计模式：创建型模式","date":"2019-01-20T16:58:21.000Z","_content":"## 设计模式及其分类\n\n### 设计模式\n设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<!--more-->\n\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n- 对接口编程而不是对实现编程。\n- 优先使用对象组合而不是继承。\n\n### 分类\n<html>\n<table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr>\n</table>\n</html>\n\n可以使用一张图来展示设计模式之间的关系：\n\n![设计模式之间的关系](Java设计模式：创建型模式/设计模式之间的关系.jpg)\n\n### 六个原则：\n\n- 开闭原则（Open Close Principle）\n> 对扩展开放，对修改关闭。\n\n\n- 里氏代换原则（Liskov Substitution Principle）\n> 基类可以出现的任何地方，子类一定可以出现。\n\n- 依赖倒转原则（Dependence Inversion Principle）\n> 针对接口编程，依赖于抽象而不依赖于具体。\n\n- 接口隔离原则（Interface Segregation Principle）\n> 降低类之间的耦合度。\n\n- 迪米特法则，又称最少知道原则（Demeter Principle）\n> 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。\n\n- 合成复用原则（Composite Reuse Principle）\n> 尽量使用合成/聚合的方式，而不是使用继承。\n\n三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。\n\n## 创建者模式\n\n### 工厂模式\n创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。\n\n工厂模式可分为简单工厂、工厂方法、抽象工厂。\n\n#### 简单工厂\n工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。\n\n![简单工厂](Java设计模式：创建型模式/简单工厂.jpg)\n\n简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。\n\n#### 工厂方法\n工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。\n\n![工厂方法](Java设计模式：创建型模式/工厂方法.jpg)\n\n从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。\n\n#### 抽象工厂\n工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。\n\n![抽象工厂](Java设计模式：创建型模式/抽象工厂.jpg)\n\n\n以上介绍的三种工厂方法各有优缺点\n>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  \n\n### 单例模式\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。\n\n单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。\n\n#### 懒汉式\n支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n要支持多线程，可以给`getInstance`方法加锁`synchronized`，但是效率会变得很低。\n\n#### 饿汉式\n不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}  \n```\n\n#### 双检式\n双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。`getInstance` 的性能对应用程序很关键。\n\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n\n该方法使用了关键字`volatile`，关于该关键字的分析：[Java并发编程：volatile关键字解析\n](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n> 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。\nvolatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。\n\n\n#### 静态内部类式\n能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n与双检式方式一样利用`ClassLoder`机制来保证初始化`instance`时只有一个线程。\n关于 ClassLoader：[一看你就懂，超详细java中的ClassLoader详解](https://blog.csdn.net/briblue/article/details/54973413)\n\n```Java\npublic class Singleton {  \n\n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n} \n```\n\n相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用`getInstance`之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。\n\n#### 枚举\n实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。\n\n```Java\npublic enum Singleton {  \n\n    INSTANCE;  \n    public void whateverMethod() {}  \n    \n}  \n```\n\n### 建造者模式\n使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。\n\n```Java\npublic class Human {\n\n    private final String name;\n    private final int height;\n    private final int weight;\n\n    public static class Builder {\n        // 必要参数\n        private final int name;\n\n        // 可选参数\n        private int height = 170;\n        private int weight = 60;\n\n        public Builder(String name) {\n            this.name = name\n        }\n\n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n\n        public Builder weight(int weight) {\n            this.weight = weight;\n            return this;\n        }\n\n        public Human build() {\n            return new Human(this);\n        }\n    }\n\n    private Human(Builder builder) {\n        name = builder.name;\n        height = builder.height;\n        weight = builder.weight;\n    }\n\n    public static void main(String[] args) {\n        Human human = new Human.Builder(\"Jack\")\n                    .height(175)\n                    .weight(60)\n                    .build();\n    }\n}\n```\n\n### 原型模式\n当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。\n\nJava的`clone`方法便是使用了这种方法，关于该方法：[java对象克隆以及深拷贝和浅拷贝](https://www.cnblogs.com/xuanxufeng/p/6558330.html)\n\n```Java\npublic inteface Prototype {\n    Prototype clone();\n}\n\npublic class ConcretePrototype implement Prototype {\n    \n    public override Prototype clone() {\n        Prototype prototype = new ConcretePrototype();\n        return prototype;\n    }\n    \n    public static void main(String[] args) {\n        Prototype p1 = new ConcretePrototype();\n        Prototype p2 = p1.clone();\n    }\n}\n```","source":"_posts/Java设计模式：创建型模式.md","raw":"---\ntitle: Java设计模式：创建型模式\ndate: 2019-01-21 00:58:21\ntags:\n- 设计模式\n- Java\ncategories: \n- Java\n---\n## 设计模式及其分类\n\n### 设计模式\n设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<!--more-->\n\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n- 对接口编程而不是对实现编程。\n- 优先使用对象组合而不是继承。\n\n### 分类\n<html>\n<table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr>\n</table>\n</html>\n\n可以使用一张图来展示设计模式之间的关系：\n\n![设计模式之间的关系](Java设计模式：创建型模式/设计模式之间的关系.jpg)\n\n### 六个原则：\n\n- 开闭原则（Open Close Principle）\n> 对扩展开放，对修改关闭。\n\n\n- 里氏代换原则（Liskov Substitution Principle）\n> 基类可以出现的任何地方，子类一定可以出现。\n\n- 依赖倒转原则（Dependence Inversion Principle）\n> 针对接口编程，依赖于抽象而不依赖于具体。\n\n- 接口隔离原则（Interface Segregation Principle）\n> 降低类之间的耦合度。\n\n- 迪米特法则，又称最少知道原则（Demeter Principle）\n> 实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。\n\n- 合成复用原则（Composite Reuse Principle）\n> 尽量使用合成/聚合的方式，而不是使用继承。\n\n三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。\n\n## 创建者模式\n\n### 工厂模式\n创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。\n\n工厂模式可分为简单工厂、工厂方法、抽象工厂。\n\n#### 简单工厂\n工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。\n\n![简单工厂](Java设计模式：创建型模式/简单工厂.jpg)\n\n简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。\n\n#### 工厂方法\n工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。\n\n![工厂方法](Java设计模式：创建型模式/工厂方法.jpg)\n\n从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。\n\n#### 抽象工厂\n工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。\n\n![抽象工厂](Java设计模式：创建型模式/抽象工厂.jpg)\n\n\n以上介绍的三种工厂方法各有优缺点\n>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  \n\n### 单例模式\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。\n\n单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。\n\n#### 懒汉式\n支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n要支持多线程，可以给`getInstance`方法加锁`synchronized`，但是效率会变得很低。\n\n#### 饿汉式\n不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。\n\n```Java\npublic class Singleton {  \n\n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}  \n```\n\n#### 双检式\n双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。`getInstance` 的性能对应用程序很关键。\n\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n\n该方法使用了关键字`volatile`，关于该关键字的分析：[Java并发编程：volatile关键字解析\n](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n> 在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。\nvolatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。\n\n\n#### 静态内部类式\n能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n与双检式方式一样利用`ClassLoder`机制来保证初始化`instance`时只有一个线程。\n关于 ClassLoader：[一看你就懂，超详细java中的ClassLoader详解](https://blog.csdn.net/briblue/article/details/54973413)\n\n```Java\npublic class Singleton {  \n\n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n} \n```\n\n相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用`getInstance`之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。\n\n#### 枚举\n实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。\n\n```Java\npublic enum Singleton {  \n\n    INSTANCE;  \n    public void whateverMethod() {}  \n    \n}  \n```\n\n### 建造者模式\n使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。\n\n```Java\npublic class Human {\n\n    private final String name;\n    private final int height;\n    private final int weight;\n\n    public static class Builder {\n        // 必要参数\n        private final int name;\n\n        // 可选参数\n        private int height = 170;\n        private int weight = 60;\n\n        public Builder(String name) {\n            this.name = name\n        }\n\n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n\n        public Builder weight(int weight) {\n            this.weight = weight;\n            return this;\n        }\n\n        public Human build() {\n            return new Human(this);\n        }\n    }\n\n    private Human(Builder builder) {\n        name = builder.name;\n        height = builder.height;\n        weight = builder.weight;\n    }\n\n    public static void main(String[] args) {\n        Human human = new Human.Builder(\"Jack\")\n                    .height(175)\n                    .weight(60)\n                    .build();\n    }\n}\n```\n\n### 原型模式\n当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。\n\nJava的`clone`方法便是使用了这种方法，关于该方法：[java对象克隆以及深拷贝和浅拷贝](https://www.cnblogs.com/xuanxufeng/p/6558330.html)\n\n```Java\npublic inteface Prototype {\n    Prototype clone();\n}\n\npublic class ConcretePrototype implement Prototype {\n    \n    public override Prototype clone() {\n        Prototype prototype = new ConcretePrototype();\n        return prototype;\n    }\n    \n    public static void main(String[] args) {\n        Prototype p1 = new ConcretePrototype();\n        Prototype p2 = p1.clone();\n    }\n}\n```","slug":"Java设计模式：创建型模式","published":1,"updated":"2019-03-15T15:27:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavc6001oi0up9yqnk0nl","content":"<h2 id=\"设计模式及其分类\"><a href=\"#设计模式及其分类\" class=\"headerlink\" title=\"设计模式及其分类\"></a>设计模式及其分类</h2><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p>设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n<p>1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。<a id=\"more\"></a></p>\n<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>\n<ul>\n<li>对接口编程而不是对实现编程。</li>\n<li>优先使用对象组合而不是继承。</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><html><br><table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"></td><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><br></table><br></html>\n\n<p>可以使用一张图来展示设计模式之间的关系：</p>\n<p><img src=\"/Java设计模式：创建型模式/设计模式之间的关系.jpg\" alt=\"设计模式之间的关系\"></p>\n<h3 id=\"六个原则：\"><a href=\"#六个原则：\" class=\"headerlink\" title=\"六个原则：\"></a>六个原则：</h3><ul>\n<li>开闭原则（Open Close Principle）<blockquote>\n<p>对扩展开放，对修改关闭。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>里氏代换原则（Liskov Substitution Principle）</p>\n<blockquote>\n<p>基类可以出现的任何地方，子类一定可以出现。</p>\n</blockquote>\n</li>\n<li><p>依赖倒转原则（Dependence Inversion Principle）</p>\n<blockquote>\n<p>针对接口编程，依赖于抽象而不依赖于具体。</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则（Interface Segregation Principle）</p>\n<blockquote>\n<p>降低类之间的耦合度。</p>\n</blockquote>\n</li>\n<li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p>\n<blockquote>\n<p>实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。</p>\n</blockquote>\n</li>\n<li><p>合成复用原则（Composite Reuse Principle）</p>\n<blockquote>\n<p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n</blockquote>\n</li>\n</ul>\n<p>三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。</p>\n<h2 id=\"创建者模式\"><a href=\"#创建者模式\" class=\"headerlink\" title=\"创建者模式\"></a>创建者模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。</p>\n<p>工厂模式可分为简单工厂、工厂方法、抽象工厂。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。</p>\n<p><img src=\"/Java设计模式：创建型模式/简单工厂.jpg\" alt=\"简单工厂\"></p>\n<p>简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。</p>\n<p><img src=\"/Java设计模式：创建型模式/工厂方法.jpg\" alt=\"工厂方法\"></p>\n<p>从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。</p>\n<p><img src=\"/Java设计模式：创建型模式/抽象工厂.jpg\" alt=\"抽象工厂\"></p>\n<p>以上介绍的三种工厂方法各有优缺点</p>\n<blockquote>\n<p>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  </p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。</p>\n<p>单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要支持多线程，可以给<code>getInstance</code>方法加锁<code>synchronized</code>，但是效率会变得很低。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双检式\"><a href=\"#双检式\" class=\"headerlink\" title=\"双检式\"></a>双检式</h4><p>双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。<code>getInstance</code> 的性能对应用程序很关键。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法使用了关键字<code>volatile</code>，关于该关键字的分析：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：volatile关键字解析\n</a></p>\n<blockquote>\n<p>在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。<br>volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。</p>\n</blockquote>\n<h4 id=\"静态内部类式\"><a href=\"#静态内部类式\" class=\"headerlink\" title=\"静态内部类式\"></a>静态内部类式</h4><p>能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<p>与双检式方式一样利用<code>ClassLoder</code>机制来保证初始化<code>instance</code>时只有一个线程。<br>关于 ClassLoader：<a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener\">一看你就懂，超详细java中的ClassLoader详解</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用<code>getInstance</code>之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 必要参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height = <span class=\"number\">170</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> weight = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">weight</span><span class=\"params\">(<span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Human <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Human(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Human</span><span class=\"params\">(Builder builder)</span> </span>&#123;</span><br><span class=\"line\">        name = builder.name;</span><br><span class=\"line\">        height = builder.height;</span><br><span class=\"line\">        weight = builder.weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human human = <span class=\"keyword\">new</span> Human.Builder(<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">                    .height(<span class=\"number\">175</span>)</span><br><span class=\"line\">                    .weight(<span class=\"number\">60</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。</p>\n<p>Java的<code>clone</code>方法便是使用了这种方法，关于该方法：<a href=\"https://www.cnblogs.com/xuanxufeng/p/6558330.html\" target=\"_blank\" rel=\"noopener\">java对象克隆以及深拷贝和浅拷贝</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> inteface Prototype &#123;</span><br><span class=\"line\">    <span class=\"function\">Prototype <span class=\"title\">clone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"title\">implement</span> <span class=\"title\">Prototype</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override Prototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Prototype p1 = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        Prototype p2 = p1.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"设计模式及其分类\"><a href=\"#设计模式及其分类\" class=\"headerlink\" title=\"设计模式及其分类\"></a>设计模式及其分类</h2><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p>设计模式（Design pattern）是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n<p>1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本《Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素）》 的书，该书首次提到了软件开发中设计模式的概念。</p>","more":"<p></p>\n<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>\n<ul>\n<li>对接口编程而不是对实现编程。</li>\n<li>优先使用对象组合而不是继承。</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><html><br><table class=\"tg\"><tr><th class=\"tg-0pky\">模式</th><th class=\"tg-0pky\">描述</th><th class=\"tg-0pky\">包含</th></tr><tr><td class=\"tg-0pky\">创建型模式</td><td class=\"tg-0pky\"></td><td class=\"tg-0pky\">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td class=\"tg-0pky\">结构型模式</td><td class=\"tg-0pky\">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td class=\"tg-0pky\">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td class=\"tg-0lax\">行为型模式</td><td class=\"tg-0lax\">这些设计模式特别关注对象之间的通信。</td><td class=\"tg-0lax\">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><br></table><br></html>\n\n<p>可以使用一张图来展示设计模式之间的关系：</p>\n<p><img src=\"/Java设计模式：创建型模式/设计模式之间的关系.jpg\" alt=\"设计模式之间的关系\"></p>\n<h3 id=\"六个原则：\"><a href=\"#六个原则：\" class=\"headerlink\" title=\"六个原则：\"></a>六个原则：</h3><ul>\n<li>开闭原则（Open Close Principle）<blockquote>\n<p>对扩展开放，对修改关闭。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>里氏代换原则（Liskov Substitution Principle）</p>\n<blockquote>\n<p>基类可以出现的任何地方，子类一定可以出现。</p>\n</blockquote>\n</li>\n<li><p>依赖倒转原则（Dependence Inversion Principle）</p>\n<blockquote>\n<p>针对接口编程，依赖于抽象而不依赖于具体。</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则（Interface Segregation Principle）</p>\n<blockquote>\n<p>降低类之间的耦合度。</p>\n</blockquote>\n</li>\n<li><p>迪米特法则，又称最少知道原则（Demeter Principle）</p>\n<blockquote>\n<p>实体应当尽量少地与其他实体发生相互作用，系统功能模块应相对独立。</p>\n</blockquote>\n</li>\n<li><p>合成复用原则（Composite Reuse Principle）</p>\n<blockquote>\n<p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n</blockquote>\n</li>\n</ul>\n<p>三大设计模式和六个原则构成了软件设计模式的基本内容，下面将介绍创建者模式。</p>\n<h2 id=\"创建者模式\"><a href=\"#创建者模式\" class=\"headerlink\" title=\"创建者模式\"></a>创建者模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>创建对象时不暴露创建逻辑，通过使用共同的接口来指向新创建的对象。</p>\n<p>工厂模式可分为简单工厂、工厂方法、抽象工厂。</p>\n<h4 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h4><p>工厂类（SimpleFactory）拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。</p>\n<p><img src=\"/Java设计模式：创建型模式/简单工厂.jpg\" alt=\"简单工厂\"></p>\n<p>简单工厂简单粗暴，但是其缺点也很明显，一是当产品种类繁多时代码量提高，二是增加新产品时，需要修改工厂实现，违背开闭原则（对拓展开放，对修改关闭）。工厂方法正好可以解决简单工厂的这两个缺点。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例，创建不同的产品实例。</p>\n<p><img src=\"/Java设计模式：创建型模式/工厂方法.jpg\" alt=\"工厂方法\"></p>\n<p>从图中可以看到，在工厂方法中，增加产品种类并不需要修改工厂类，只需要添加相应的工厂即可，符合开放-封闭原则。其缺点在于，对于某些可以形成产品族的情况，处理起来比较复杂，这一问题使用抽象工厂解决。</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p>工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广，其面对产品族。</p>\n<p><img src=\"/Java设计模式：创建型模式/抽象工厂.jpg\" alt=\"抽象工厂\"></p>\n<p>以上介绍的三种工厂方法各有优缺点</p>\n<blockquote>\n<p>简单工厂： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） <br>工厂方法：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>  抽象工厂：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br>  </p>\n</blockquote>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。其关键在于构造方法是私有的，面向所有对象提供全局单例。单例模式的缺陷在于没有抽象层，无法进行拓展，同时其类结构复杂，违背了单一职责原则。</p>\n<p>单例模式可分为线程安全懒汉式、线程不安全懒汉式、饿汉式、双重检查锁式以及静态内部类等多种实现方式。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><p>支持延迟初始化，代码如下，由于其不支持多线程，严格意义上来说并不算单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要支持多线程，可以给<code>getInstance</code>方法加锁<code>synchronized</code>，但是效率会变得很低。</p>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><p>不会延迟初始化，多线程安全，由于没有加锁，所以效率更高。缺点是类加载时就初始化，占用内存，同时也很容易产生垃圾对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双检式\"><a href=\"#双检式\" class=\"headerlink\" title=\"双检式\"></a>双检式</h4><p>双检即Double Checked Locking，安全、支持延迟初始化且在多线程情况下能保持高性能。<code>getInstance</code> 的性能对应用程序很关键。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法使用了关键字<code>volatile</code>，关于该关键字的分析：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：volatile关键字解析\n</a></p>\n<blockquote>\n<p>在不使用 volatile 时，假设两个线程A、B第一次调用单例方法，如果线程A先执行 instance = new Instance()，由于构造方法是一个非原子操作，编译后会生成多条字节码指令，因为 Java 的指令重排序，可能会先执行 instance 的赋值操作——在内存中开辟一片存储对象的区域，然后直接返回内存的引用。此时虽然 instance 不为空，但实际的初始化操作却还未执行，如果线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的 instance 对象。<br>volatile 关键字保证不同线程对变量进行操作时的可见性，禁止指令重排序优化，从而安全的实现单例。</p>\n</blockquote>\n<h4 id=\"静态内部类式\"><a href=\"#静态内部类式\" class=\"headerlink\" title=\"静态内部类式\"></a>静态内部类式</h4><p>能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<p>与双检式方式一样利用<code>ClassLoder</code>机制来保证初始化<code>instance</code>时只有一个线程。<br>关于 ClassLoader：<a href=\"https://blog.csdn.net/briblue/article/details/54973413\" target=\"_blank\" rel=\"noopener\">一看你就懂，超详细java中的ClassLoader详解</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相较于双重检查锁，由于静态内部类的特性——需要使用才会装载到内存中，所以实际上在第一次调用<code>getInstance</code>之前，SingletonHolder 是没有被装载进来的，只有在第一次调用了 getInstance() 之后，内部静态类的实例才会真正装载。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>实现单例模式的最佳方法。简洁、支持序列化、绝对防止多次实例化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>使用多个简单的对象逐步构建一个复杂的对象。下面的例子比较简单直观，实际上在复杂的系统中可以包含单独的 Director 、Builder 甚至抽象层等元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 必要参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height = <span class=\"number\">170</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> weight = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">weight</span><span class=\"params\">(<span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Human <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Human(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Human</span><span class=\"params\">(Builder builder)</span> </span>&#123;</span><br><span class=\"line\">        name = builder.name;</span><br><span class=\"line\">        height = builder.height;</span><br><span class=\"line\">        weight = builder.weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human human = <span class=\"keyword\">new</span> Human.Builder(<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">                    .height(<span class=\"number\">175</span>)</span><br><span class=\"line\">                    .weight(<span class=\"number\">60</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>当直接创建对象的代价比较大时（例如数据库对象操作），可以采用这种模式克隆出多个一模一样的对象。</p>\n<p>Java的<code>clone</code>方法便是使用了这种方法，关于该方法：<a href=\"https://www.cnblogs.com/xuanxufeng/p/6558330.html\" target=\"_blank\" rel=\"noopener\">java对象克隆以及深拷贝和浅拷贝</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> inteface Prototype &#123;</span><br><span class=\"line\">    <span class=\"function\">Prototype <span class=\"title\">clone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"title\">implement</span> <span class=\"title\">Prototype</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override Prototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Prototype p1 = <span class=\"keyword\">new</span> ConcretePrototype();</span><br><span class=\"line\">        Prototype p2 = p1.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java设计模式：结构型模式","date":"2019-01-20T16:56:04.000Z","_content":"\n## 适配器模式\n在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<!--more-->\n\n用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此`Volt5V`称为`Target`，而不兼容的220V电压称之为`Adaptee`，我们的目的是适配设计一个`Adpater`，方法有两种。\n\n### 类适配器模式\n\n```Java\ninterface Volt5V {\n    int get5V();\n}\n\nclass Volt220V {\n    public int get220V() {\n        return 220;\n    }\n}\n\nclass Adapter extends Volt220V implements Volt5V {\n    @Override\n    public int get5V() {\n        return 5;\n    }\n}\n\npublic static void main(String[] args) {\n    Adapter adapter = new Adapter();\n    System.out.println(\"获取需要的5V电源：\" + adapter.get5V());\n}\n\n```\n\n### 对象适配器模式\n与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 \n　　 \n```Java\nclass ObjectAdapter implements Volt5V {\n\n    private Volt220V volt220V;\n\n    public ObjectAdapter(Volt220V adaptee) {\n        volt220V = adaptee;\n    }\n\n    @Override\n    public int get5V() {\n        return 5;\n    }\n        \n    public int get220V() {\n        return volt220V.get220V();\n    }  \n}\n```\n关于 Android 中 ListView 中的 Adapter，可以参考：[Android源码之ListView的适配器模式](https://blog.csdn.net/bboyfeiyu/article/details/43950185)\n\n## 组合模式\n将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。\n\n- 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。\n- 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。\n- 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。\n\n对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。\n\n```Java\n//抽象构件，声明一个接口用于访问和管理Component的子部件\nabstract class Component {\n\n    public Component() { }\n\n    public abstract void add(Component component);\n\n    public abstract void remove(Component component);\n\n    //显示层级结构\n    public abstract void Display(int level);\n}\n\n//叶子节点\nclass Leaf extends Component {\n\n    public Leaf() {\n        super();\n    }\n\n    //无意义的实现\n    @Override\n    public void add(Component component) { }\n\n    //无意义的实现\n    @Override\n    public void remove(Component component) { }\n\n    @Override\n    public void Display(int level) {\n        System.out.println(\"-\" + level);\n    }\n}\n\n//枝节点\nclass Composite extends Component {\n\n    public Composite() {\n        super();\n    }\n\n    private List<Component> children = new ArrayList<>();\n\n    @Override\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    @Override\n    public void Display(int level) {\n        children.forEach(\n                component -> component.Display(level + 2)\n        );\n    }\n}\n\n```\n对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。\n\n## 装饰器模式\n向一个现有的对象添加新的功能，同时又不改变其结构。<br>\n创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。\n\n```Java\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Draw a circle\");\n    }\n}\n\n//实现了 Shape 接口的抽象装饰类。\nabstract class ShapeDecorator implements Shape {\n\n    Shape decoratedShape;\n\n    public ShapeDecorator(Shape decoratedShape) {\n        this.decoratedShape = decoratedShape;\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n    }\n}\n\n//具体的装饰类\nclass RedShapeDecorator extends ShapeDecorator {\n\n    public RedShapeDecorator(Shape decoratedShape) {\n        super(decoratedShape);\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n        setRedBorder(decoratedShape);\n    }\n\n    private void setRedBorder(Shape decoratedShape) {\n        System.out.println(\"Border color: Red\");\n    }\n}\n```\n\n## 代理模式\n下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\n```Java\ninterface Image {\n    void display();\n}\n\nclass RealImage implements Image {\n\n    private String fileName;\n\n    public RealImage(String fileName){\n        this.fileName = fileName;\n        loadFromDisk(fileName);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Displaying \" + fileName);\n    }\n\n    private void loadFromDisk(String fileName){\n        System.out.println(\"Loading \" + fileName);\n    }\n}\n\nclass ProxyImage implements Image {\n\n    private RealImage realImage;\n    private String fileName;\n\n    public ProxyImage(String fileName){\n        this.fileName = fileName;\n    }\n\n    @Override\n    public void display() {\n        if(realImage == null){\n            realImage = new RealImage(fileName);\n        }\n        realImage.display();\n    }\n}\n```\n\n静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br>\nJava中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。\n\n```Java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DisplayHandler implements InvocationHandler {\n\n    //要代理的真实对象\n    private Object obj;\n\n    public DisplayHandler(Object obj) {\n        this.obj = obj;\n    }\n\n    /**\n     *\n     * @param proxy 代理类代理的真实代理对象\n     * @param method 所要调用某个对象真实的方法的Method对象\n     * @param args 指代代理对象方法传递的参数\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //真实的对象执行之前\n        System.out.println(\"Before invoke...\");\n\n        Object invoke = method.invoke(obj, args);\n\n        //真实的对象执行之后\n        System.out.println(\"After invoke...\");\n        return invoke;\n    }\n}\n\npublic static void main(String[] args) {\n    Image image = new RealImage(\"hello.jpg\");\n    InvocationHandler handler = new DisplayHandler(image);\n\n    /*\n     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象\n     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法\n     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上\n     */\n    Image proxy = (Image) Proxy.newProxyInstance(\n            handler.getClass().getClassLoader(),\n            image.getClass().getInterfaces(),\n            handler);\n    proxy.display();\n}\n```\n控制台输出结果为 \n```\nLoading hello.jpg\nBefore invoke...\nDisplaying hello.jpg\nAfter invoke...\n```\n\n代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。\n\n## 其他\n\n### 过滤器模式\n简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。\n\n### 桥接模式\n桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。\n\n举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。\n\n### 外观模式\n外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。\n\n简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。\n\n\n### 享元模式\n所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点\n\n```Java\npublic class FlyweightFactory{\n\n    static Map<String, Shape> shapes = new HashMap<String, Shape>();\n    \n    public static Shape getShape(String key){\n        Shape shape = shapes.get(key);\n        if(shape == null){\n            shape = new Circle(key);\n            shapes.put(key, shape);\n        }\n        return shape;\n    }\n    \n    public static int getSum(){\n        return shapes.size();\n    }\n}\n```\n\n### 补充\n从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是\"转换行为\"，外观模式是一种\"简化行为\"。","source":"_posts/Java设计模式：结构型模式.md","raw":"---\ntitle: Java设计模式：结构型模式\ndate: 2019-01-21 00:56:04\ntags:\n- 设计模式\n- Java\ncategories:\n- Java\n---\n\n## 适配器模式\n在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<!--more-->\n\n用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此`Volt5V`称为`Target`，而不兼容的220V电压称之为`Adaptee`，我们的目的是适配设计一个`Adpater`，方法有两种。\n\n### 类适配器模式\n\n```Java\ninterface Volt5V {\n    int get5V();\n}\n\nclass Volt220V {\n    public int get220V() {\n        return 220;\n    }\n}\n\nclass Adapter extends Volt220V implements Volt5V {\n    @Override\n    public int get5V() {\n        return 5;\n    }\n}\n\npublic static void main(String[] args) {\n    Adapter adapter = new Adapter();\n    System.out.println(\"获取需要的5V电源：\" + adapter.get5V());\n}\n\n```\n\n### 对象适配器模式\n与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。 \n　　 \n```Java\nclass ObjectAdapter implements Volt5V {\n\n    private Volt220V volt220V;\n\n    public ObjectAdapter(Volt220V adaptee) {\n        volt220V = adaptee;\n    }\n\n    @Override\n    public int get5V() {\n        return 5;\n    }\n        \n    public int get220V() {\n        return volt220V.get220V();\n    }  \n}\n```\n关于 Android 中 ListView 中的 Adapter，可以参考：[Android源码之ListView的适配器模式](https://blog.csdn.net/bboyfeiyu/article/details/43950185)\n\n## 组合模式\n将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。\n\n- 组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。\n- 叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。\n- 合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。\n\n对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。\n\n```Java\n//抽象构件，声明一个接口用于访问和管理Component的子部件\nabstract class Component {\n\n    public Component() { }\n\n    public abstract void add(Component component);\n\n    public abstract void remove(Component component);\n\n    //显示层级结构\n    public abstract void Display(int level);\n}\n\n//叶子节点\nclass Leaf extends Component {\n\n    public Leaf() {\n        super();\n    }\n\n    //无意义的实现\n    @Override\n    public void add(Component component) { }\n\n    //无意义的实现\n    @Override\n    public void remove(Component component) { }\n\n    @Override\n    public void Display(int level) {\n        System.out.println(\"-\" + level);\n    }\n}\n\n//枝节点\nclass Composite extends Component {\n\n    public Composite() {\n        super();\n    }\n\n    private List<Component> children = new ArrayList<>();\n\n    @Override\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    @Override\n    public void Display(int level) {\n        children.forEach(\n                component -> component.Display(level + 2)\n        );\n    }\n}\n\n```\n对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。\n\n## 装饰器模式\n向一个现有的对象添加新的功能，同时又不改变其结构。<br>\n创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。\n\n```Java\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Draw a circle\");\n    }\n}\n\n//实现了 Shape 接口的抽象装饰类。\nabstract class ShapeDecorator implements Shape {\n\n    Shape decoratedShape;\n\n    public ShapeDecorator(Shape decoratedShape) {\n        this.decoratedShape = decoratedShape;\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n    }\n}\n\n//具体的装饰类\nclass RedShapeDecorator extends ShapeDecorator {\n\n    public RedShapeDecorator(Shape decoratedShape) {\n        super(decoratedShape);\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n        setRedBorder(decoratedShape);\n    }\n\n    private void setRedBorder(Shape decoratedShape) {\n        System.out.println(\"Border color: Red\");\n    }\n}\n```\n\n## 代理模式\n下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\n```Java\ninterface Image {\n    void display();\n}\n\nclass RealImage implements Image {\n\n    private String fileName;\n\n    public RealImage(String fileName){\n        this.fileName = fileName;\n        loadFromDisk(fileName);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Displaying \" + fileName);\n    }\n\n    private void loadFromDisk(String fileName){\n        System.out.println(\"Loading \" + fileName);\n    }\n}\n\nclass ProxyImage implements Image {\n\n    private RealImage realImage;\n    private String fileName;\n\n    public ProxyImage(String fileName){\n        this.fileName = fileName;\n    }\n\n    @Override\n    public void display() {\n        if(realImage == null){\n            realImage = new RealImage(fileName);\n        }\n        realImage.display();\n    }\n}\n```\n\n静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br>\nJava中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。\n\n```Java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DisplayHandler implements InvocationHandler {\n\n    //要代理的真实对象\n    private Object obj;\n\n    public DisplayHandler(Object obj) {\n        this.obj = obj;\n    }\n\n    /**\n     *\n     * @param proxy 代理类代理的真实代理对象\n     * @param method 所要调用某个对象真实的方法的Method对象\n     * @param args 指代代理对象方法传递的参数\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //真实的对象执行之前\n        System.out.println(\"Before invoke...\");\n\n        Object invoke = method.invoke(obj, args);\n\n        //真实的对象执行之后\n        System.out.println(\"After invoke...\");\n        return invoke;\n    }\n}\n\npublic static void main(String[] args) {\n    Image image = new RealImage(\"hello.jpg\");\n    InvocationHandler handler = new DisplayHandler(image);\n\n    /*\n     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象\n     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法\n     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上\n     */\n    Image proxy = (Image) Proxy.newProxyInstance(\n            handler.getClass().getClassLoader(),\n            image.getClass().getInterfaces(),\n            handler);\n    proxy.display();\n}\n```\n控制台输出结果为 \n```\nLoading hello.jpg\nBefore invoke...\nDisplaying hello.jpg\nAfter invoke...\n```\n\n代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。\n\n## 其他\n\n### 过滤器模式\n简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。\n\n### 桥接模式\n桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。\n\n举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。\n\n### 外观模式\n外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。\n\n简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。\n\n\n### 享元模式\n所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点\n\n```Java\npublic class FlyweightFactory{\n\n    static Map<String, Shape> shapes = new HashMap<String, Shape>();\n    \n    public static Shape getShape(String key){\n        Shape shape = shapes.get(key);\n        if(shape == null){\n            shape = new Circle(key);\n            shapes.put(key, shape);\n        }\n        return shape;\n    }\n    \n    public static int getSum(){\n        return shapes.size();\n    }\n}\n```\n\n### 补充\n从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是\"转换行为\"，外观模式是一种\"简化行为\"。","slug":"Java设计模式：结构型模式","published":1,"updated":"2019-03-15T15:27:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavc8001ri0upupip2w8x","content":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<a id=\"more\"></a></p>\n<p>用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此<code>Volt5V</code>称为<code>Target</code>，而不兼容的220V电压称之为<code>Adaptee</code>，我们的目的是适配设计一个<code>Adpater</code>，方法有两种。</p>\n<h3 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volt220V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Volt220V</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Adapter adapter = <span class=\"keyword\">new</span> Adapter();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"获取需要的5V电源：\"</span> + adapter.get5V());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h3><p>与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。<br>　　<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Volt220V volt220V;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObjectAdapter</span><span class=\"params\">(Volt220V adaptee)</span> </span>&#123;</span><br><span class=\"line\">        volt220V = adaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> volt220V.get220V();</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 Android 中 ListView 中的 Adapter，可以参考：<a href=\"https://blog.csdn.net/bboyfeiyu/article/details/43950185\" target=\"_blank\" rel=\"noopener\">Android源码之ListView的适配器模式</a></p>\n<h2 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h2><p>将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。</p>\n<ul>\n<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>\n<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>\n<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。</li>\n</ul>\n<p>对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象构件，声明一个接口用于访问和管理Component的子部件</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示层级结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//叶子节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-\"</span> + level);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枝节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Component&gt; children = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.add(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.remove(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        children.forEach(</span><br><span class=\"line\">                component -&gt; component.Display(level + <span class=\"number\">2</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。</p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>向一个现有的对象添加新的功能，同时又不改变其结构。<br><br>创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Draw a circle\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现了 Shape 接口的抽象装饰类。</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeDecorator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Shape decoratedShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.decoratedShape = decoratedShape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//具体的装饰类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedShapeDecorator</span> <span class=\"keyword\">extends</span> <span class=\"title\">ShapeDecorator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">        setRedBorder(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedBorder</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Border color: Red\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RealImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">        loadFromDisk(fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Displaying \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromDisk</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Loading \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealImage realImage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(realImage == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            realImage = <span class=\"keyword\">new</span> RealImage(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        realImage.display();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br><br>Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisplayHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//要代理的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DisplayHandler</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类代理的真实代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 所要调用某个对象真实的方法的Method对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 指代代理对象方法传递的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Before invoke...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object invoke = method.invoke(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After invoke...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Image image = <span class=\"keyword\">new</span> RealImage(<span class=\"string\">\"hello.jpg\"</span>);</span><br><span class=\"line\">    InvocationHandler handler = <span class=\"keyword\">new</span> DisplayHandler(image);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Image proxy = (Image) Proxy.newProxyInstance(</span><br><span class=\"line\">            handler.getClass().getClassLoader(),</span><br><span class=\"line\">            image.getClass().getInterfaces(),</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    proxy.display();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Loading hello.jpg</span><br><span class=\"line\">Before invoke...</span><br><span class=\"line\">Displaying hello.jpg</span><br><span class=\"line\">After invoke...</span><br></pre></td></tr></table></figure></p>\n<p>代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"过滤器模式\"><a href=\"#过滤器模式\" class=\"headerlink\" title=\"过滤器模式\"></a>过滤器模式</h3><p>简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。</p>\n<h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。</p>\n<p>举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。</p>\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>\n<p>简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。</p>\n<h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><p>所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlyweightFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;String, Shape&gt; shapes = <span class=\"keyword\">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">getShape</span><span class=\"params\">(String key)</span></span>&#123;</span><br><span class=\"line\">        Shape shape = shapes.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shape == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            shape = <span class=\"keyword\">new</span> Circle(key);</span><br><span class=\"line\">            shapes.put(key, shape);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shapes.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><p>在 Android 开发中，经常能见到各种各样的 Adapter 类，其采用的正是适配器模式。该设计模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口，从而使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>","more":"<p></p>\n<p>用电源接口举例，笔记本电脑的电源需要接入5V的电压，无法直接使用220v的交流电压，两者并不匹配，在软件开发中，该现象称之为接口不兼容，此时就需要适配器来进行接口转换。这个转换的中间层便是 Adapter 层。在这个例子中，我们需要5v的电压，因此<code>Volt5V</code>称为<code>Target</code>，而不兼容的220V电压称之为<code>Adaptee</code>，我们的目的是适配设计一个<code>Adpater</code>，方法有两种。</p>\n<h3 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volt220V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">220</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Volt220V</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Adapter adapter = <span class=\"keyword\">new</span> Adapter();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"获取需要的5V电源：\"</span> + adapter.get5V());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h3><p>与类适配器模式一样，对象适配器模式把被适配的类的API转换成为目标类的API，不同的是，对象适配器模式的连接方式不是继承，其使用代理关系连接到Adaptee类。<br>　　<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Volt5V</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Volt220V volt220V;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObjectAdapter</span><span class=\"params\">(Volt220V adaptee)</span> </span>&#123;</span><br><span class=\"line\">        volt220V = adaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get5V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get220V</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> volt220V.get220V();</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于 Android 中 ListView 中的 Adapter，可以参考：<a href=\"https://blog.csdn.net/bboyfeiyu/article/details/43950185\" target=\"_blank\" rel=\"noopener\">Android源码之ListView的适配器模式</a></p>\n<h2 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h2><p>将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。<br>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。</p>\n<ul>\n<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>\n<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>\n<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。</li>\n</ul>\n<p>对于透明组合模式来说，Component 中声明所有管理子对象的方法，其中包括Add，Remove等。这样做的好处是叶节点和枝节点具备完全一致的接口，对于外界没有区别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象构件，声明一个接口用于访问和管理Component的子部件</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示层级结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//叶子节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无意义的实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-\"</span> + level);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枝节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Component&gt; children = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.add(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">        children.remove(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        children.forEach(</span><br><span class=\"line\">                component -&gt; component.Display(level + <span class=\"number\">2</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这种方式来说，叶子节点并不具备 add、remove 等方法，对他们的实现是没有意义的，可以采用安全式组合模式，将叶子节点不具备的功能下放到枝节点中实现。该做法的弊端是对于客户端来说，必须对叶节点和枝节点进行判定，使用不便。</p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><p>向一个现有的对象添加新的功能，同时又不改变其结构。<br><br>创建一个 Shape 接口和实现了 Shape 接口的实体类。然后创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类，用来装饰 Shape 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Draw a circle\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现了 Shape 接口的抽象装饰类。</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShapeDecorator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Shape decoratedShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.decoratedShape = decoratedShape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//具体的装饰类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedShapeDecorator</span> <span class=\"keyword\">extends</span> <span class=\"title\">ShapeDecorator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedShapeDecorator</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        decoratedShape.draw();</span><br><span class=\"line\">        setRedBorder(decoratedShape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedBorder</span><span class=\"params\">(Shape decoratedShape)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Border color: Red\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>下面的例子展示了静态代理的过程，创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RealImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">        loadFromDisk(fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Displaying \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromDisk</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Loading \"</span> + fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyImage</span> <span class=\"keyword\">implements</span> <span class=\"title\">Image</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealImage realImage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fileName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyImage</span><span class=\"params\">(String fileName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName = fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(realImage == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            realImage = <span class=\"keyword\">new</span> RealImage(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        realImage.display();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态代理的缺点是显而易见的，由于代理类和委托类实现相同的接口，导致代码冗杂。接口的变化将引起所有实现类和代理类的变化，同时当代理类需要为多对象服务时也会显得力不从心，为此引入动态代理的方式。<br><br>Java中的动态代理类必须实现 reflect 包中的 InvocationHandler 接口，同时使用 Proxy 类。当通过动态代理对象调用一个方法时候，该方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法。还是以静态代理中 Image 举例，这次不再创建一个 ProxyImage， 而是通过一个 DisplayHandler 实现动态代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisplayHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//要代理的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DisplayHandler</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类代理的真实代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 所要调用某个对象真实的方法的Method对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 指代代理对象方法传递的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Before invoke...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object invoke = method.invoke(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真实的对象执行之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After invoke...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Image image = <span class=\"keyword\">new</span> RealImage(<span class=\"string\">\"hello.jpg\"</span>);</span><br><span class=\"line\">    InvocationHandler handler = <span class=\"keyword\">new</span> DisplayHandler(image);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数一：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数二：image.getClass().getInterfaces()，提供真实对象实现的接口，使代理对象能调用接口中的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数三：handler，将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Image proxy = (Image) Proxy.newProxyInstance(</span><br><span class=\"line\">            handler.getClass().getClassLoader(),</span><br><span class=\"line\">            image.getClass().getInterfaces(),</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    proxy.display();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Loading hello.jpg</span><br><span class=\"line\">Before invoke...</span><br><span class=\"line\">Displaying hello.jpg</span><br><span class=\"line\">After invoke...</span><br></pre></td></tr></table></figure></p>\n<p>代理模式和装饰模式非常类似，二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"过滤器模式\"><a href=\"#过滤器模式\" class=\"headerlink\" title=\"过滤器模式\"></a>过滤器模式</h3><p>简单的说，筛选器提供一个输入参数为特定类型集合的筛选方法，返回筛选之后的集合，同时筛选器之间可以组合。</p>\n<h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。</p>\n<p>举个例子，在画画这一行为中，画笔需要选择不同的颜色、绘画形状等，为了方便拓展，使用桥接模式，抽象出形状和颜色两个父类，然后根据需要对颜色和形状进行组合。实际上这是“面向接口编程”设计思想最直观的体现。</p>\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>\n<p>简单的来说就是对外提供一个简单接口，隐藏实现的逻辑。比如计算机的电源键，用户只需按电源键，就可以启动或者关闭计算机，无需知道它是怎么启动的(启动CPU、启动内存、启动硬盘)，怎么关闭的(关闭硬盘、关闭内存、关闭CPU)。</p>\n<h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><p>所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。通过其中的享元工厂来展示该模式的特点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlyweightFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;String, Shape&gt; shapes = <span class=\"keyword\">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">getShape</span><span class=\"params\">(String key)</span></span>&#123;</span><br><span class=\"line\">        Shape shape = shapes.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(shape == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            shape = <span class=\"keyword\">new</span> Circle(key);</span><br><span class=\"line\">            shapes.put(key, shape);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shapes.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>从代码上看，结构型模式中的很多模式具有相当大的相似性，具体区分的话，装饰器模式是“新增行为”，代理模式是“控制访问行为”，适配器模式是”转换行为”，外观模式是一种”简化行为”。</p>"},{"title":"LeakCanary源码解析","date":"2019-02-13T05:28:31.000Z","_content":"\n## 引言\n内存泄漏是 Android 开发中无法避免的问题，[LeakCanary](https://github.com/square/leakcanary) 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<!--more-->\n\n## ActivityLifecycleCallbacks\nLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。\n\n### 接口方法\n可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。\n\n```Java\n    public interface ActivityLifecycleCallbacks {\n        void onActivityCreated(Activity activity, Bundle savedInstanceState);\n        void onActivityStarted(Activity activity);\n        void onActivityResumed(Activity activity);\n        void onActivityPaused(Activity activity);\n        void onActivityStopped(Activity activity);\n        void onActivitySaveInstanceState(Activity activity, Bundle outState);\n        void onActivityDestroyed(Activity activity);\n    }\n```\n\n### 简单用法\n开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。\n```Java\npublic class MyApplication extends Application {\n\n    public static List<Activity> activityList;\n    public static final int ACTIVITY_MAX_NUM = 10;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        activityList = new LinkedList<>();\n        registerActivityLifecycleCallbacks(new MyActivityCallbacks());\n    }\n\n    class MyActivityCallbacks implements ActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            if (activityList.size() >= ACTIVITY_MAX_NUM) {\n                activityList.remove(activityList.size()-1).finish();\n            }\n            activityList.add(activity);\n        }\n\n        @Override\n        public void onActivityStarted(Activity activity) { }\n\n        @Override\n        public void onActivityResumed(Activity activity) { }\n\n        @Override\n        public void onActivityPaused(Activity activity) { }\n\n        @Override\n        public void onActivityStopped(Activity activity) { }\n\n        @Override\n        public void onActivitySaveInstanceState(Activity activity, Bundle outState) { }\n\n        @Override\n        public void onActivityDestroyed(Activity activity) {\n            activityList.remove(activity);\n        }\n    }\n    \n    public static Activity getCurrentActivity() {\n        return activityList.get(0);\n    }\n}\n```\n\n## 引用类型\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。\n\n### 强引用\n强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的`A a = new A()`中的引用a。\n\n### 软引用\n软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。\n```Java\nSoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));\nSystem.out.println(sr.get());\n```\n\n### 弱引用\n弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n```Java\nWeakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n         \nSystem.out.println(sr.get());\nSystem.gc();                //通知JVM的gc进行垃圾回收\nSystem.out.println(sr.get());\n```\n打印的结果为\n> hello\n<br>null\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n```Java\nReferenceQueue queue = new ReferenceQueue();\nWeakReference pr = new WeakReference(object, queue);\n```\n\n### 虚引用\nPhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其`get()`永远返回`null`\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n```Java\npublic class PhantomReference<T> extends Reference<T> {\n\n    public T get() {\n        return null;\n    }\n\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n## LeakCanary源码\n实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。\n\n### 执行流程\n跟踪调用的入口方法`install`\n```Java\npublic static @NonNull RefWatcher install(@NonNull Application application) {\n    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n}\n```\n\n`listenerServiceClass`方法位于 AndroidRefWatcherBuilder\n\n```Java\npublic @NonNull AndroidRefWatcherBuilder listenerServiceClass(\n      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {\n      \n    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);\n    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));\n}\n```\n该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和`excludedRefs`方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：\n\n```Java\npublic @NonNull RefWatcher buildAndInstall() {\n    if (LeakCanaryInternals.installedRefWatcher != null) {\n        throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\");\n    }\n    RefWatcher refWatcher = build();\n    if (refWatcher != DISABLED) {\n        if (enableDisplayLeakActivity) {\n            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);\n        }\n        if (watchActivities) {\n            ActivityRefWatcher.install(context, refWatcher);\n        }\n        if (watchFragments) {\n            FragmentRefWatcher.Helper.install(context, refWatcher);\n        }\n    }\n    LeakCanaryInternals.installedRefWatcher = refWatcher;\n    return refWatcher;\n}\n```\n该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪`install`方法\n\n```Java\npublic static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {\n    Application application = (Application) context.getApplicationContext();\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n\n    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);\n}\n\n//成员变量 lifecycleCallbacks\nprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n    new ActivityLifecycleCallbacksAdapter  {\n        @Override public void onActivityDestroyed(Activity activity) {\n            refWatcher.watch(activity);\n        }\n    };\n```\n\n由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。\n\n`watch`方法由 RefWatcher 默认实现：\n\n```Java\npublic void watch(Object watchedReference, String referenceName) {\n    ......  \n    retainedKeys.add(key);\n    final KeyedWeakReference reference =\n            new KeyedWeakReference(watchedReference, key, referenceName, queue);\n\n    ensureGoneAsync(watchStartNanoTime, reference);\n}\n```\n\n其中 retainedKeys 是一个 Set<String> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。 \nKeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。\n\n```Java\nprivate void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {\n    watchExecutor.execute(new Retryable() {\n        @Override public Retryable.Result run() {\n            return ensureGone(reference, watchStartNanoTime);\n        }\n    });\n}\n```\n\nwatchExecutor 为 AndroidWatchExecutor 对象\n```\npublic AndroidWatchExecutor(long initialDelayMillis) {\n    mainHandler = new Handler(Looper.getMainLooper());\n    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);\n    handlerThread.start();\n    backgroundHandler = new Handler(handlerThread.getLooper());\n    this.initialDelayMillis = initialDelayMillis;\n    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;\n}\n\n@Override public void execute(@NonNull Retryable retryable) {\n    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\n        waitForIdle(retryable, 0);\n    } else {\n        postWaitForIdle(retryable, 0);\n    }\n}\n```\n在`execute`中，不管是`waitForIdle`还是`postWaitForIdle`都会切换到主线程执行，最终会调用以下代码：\n```Java\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        postToBackgroundWithDelay(retryable, failedAttempts);\n        return false;\n      }\n    });\n```\n那么 IdleHandler 到底是什么呢？\n\n我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。\n\n`ensureGoneAsync`方法最终会调用`ensureGone`\n\n```Java\nRetryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {\n    ......\n    removeWeaklyReachableReferences();\n    ......\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n        ......\n        File heapDumpFile = heapDumper.dumpHeap();\n        ......\n        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)\n            .referenceName(reference.name)\n            .watchDurationMs(watchDurationMs)\n            .gcDurationMs(gcDurationMs)\n            .heapDumpDurationMs(heapDumpDurationMs)\n            .build();\n\n        heapdumpListener.analyze(heapDump);\n    }\n    return DONE;\n}\n```\n\n- `removeWeaklyReachableReferences`遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。\n- 调用`gcTrigger.runGc`去进行内存回收，这里没有使用`System.gc`，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。\n- 主动进行 GC 之后会再次调用`removeWeaklyReachableReferences`清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。\n- 生成性能统计文件.hprof，进行内存泄漏的分析。\n\n那么 hprof 文件是被解析成信息的呢\n\n```Java\nAnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);\n```\n\n```Java\npublic AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {\n    ......\n    MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile);\n    HprofParser parser = new HprofParser(e);\n    Snapshot snapshot = parser.parse();\n    this.deduplicateGcRoots(snapshot);\n    Instance leakingRef = this.findLeakingReference(referenceKey, snapshot);\n    return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ：\n        this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);\n}\n```\n\n`checkForLeak`方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的`parse`方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。\n\n得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。\n\n### 总结\nLeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。\n","source":"_posts/LeakCanary源码解析.md","raw":"---\ntitle: LeakCanary源码解析\ndate: 2019-02-13 13:28:31\ntags:\n- 内存泄漏\n- Android\n- 源码\ncategories:\n- Android\n---\n\n## 引言\n内存泄漏是 Android 开发中无法避免的问题，[LeakCanary](https://github.com/square/leakcanary) 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<!--more-->\n\n## ActivityLifecycleCallbacks\nLeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。\n\n### 接口方法\n可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。\n\n```Java\n    public interface ActivityLifecycleCallbacks {\n        void onActivityCreated(Activity activity, Bundle savedInstanceState);\n        void onActivityStarted(Activity activity);\n        void onActivityResumed(Activity activity);\n        void onActivityPaused(Activity activity);\n        void onActivityStopped(Activity activity);\n        void onActivitySaveInstanceState(Activity activity, Bundle outState);\n        void onActivityDestroyed(Activity activity);\n    }\n```\n\n### 简单用法\n开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。\n```Java\npublic class MyApplication extends Application {\n\n    public static List<Activity> activityList;\n    public static final int ACTIVITY_MAX_NUM = 10;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        activityList = new LinkedList<>();\n        registerActivityLifecycleCallbacks(new MyActivityCallbacks());\n    }\n\n    class MyActivityCallbacks implements ActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            if (activityList.size() >= ACTIVITY_MAX_NUM) {\n                activityList.remove(activityList.size()-1).finish();\n            }\n            activityList.add(activity);\n        }\n\n        @Override\n        public void onActivityStarted(Activity activity) { }\n\n        @Override\n        public void onActivityResumed(Activity activity) { }\n\n        @Override\n        public void onActivityPaused(Activity activity) { }\n\n        @Override\n        public void onActivityStopped(Activity activity) { }\n\n        @Override\n        public void onActivitySaveInstanceState(Activity activity, Bundle outState) { }\n\n        @Override\n        public void onActivityDestroyed(Activity activity) {\n            activityList.remove(activity);\n        }\n    }\n    \n    public static Activity getCurrentActivity() {\n        return activityList.get(0);\n    }\n}\n```\n\n## 引用类型\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。\n\n### 强引用\n强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的`A a = new A()`中的引用a。\n\n### 软引用\n软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。\n```Java\nSoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));\nSystem.out.println(sr.get());\n```\n\n### 弱引用\n弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n```Java\nWeakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n         \nSystem.out.println(sr.get());\nSystem.gc();                //通知JVM的gc进行垃圾回收\nSystem.out.println(sr.get());\n```\n打印的结果为\n> hello\n<br>null\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n```Java\nReferenceQueue queue = new ReferenceQueue();\nWeakReference pr = new WeakReference(object, queue);\n```\n\n### 虚引用\nPhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其`get()`永远返回`null`\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n```Java\npublic class PhantomReference<T> extends Reference<T> {\n\n    public T get() {\n        return null;\n    }\n\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n## LeakCanary源码\n实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。\n\n### 执行流程\n跟踪调用的入口方法`install`\n```Java\npublic static @NonNull RefWatcher install(@NonNull Application application) {\n    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n}\n```\n\n`listenerServiceClass`方法位于 AndroidRefWatcherBuilder\n\n```Java\npublic @NonNull AndroidRefWatcherBuilder listenerServiceClass(\n      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {\n      \n    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);\n    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));\n}\n```\n该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和`excludedRefs`方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：\n\n```Java\npublic @NonNull RefWatcher buildAndInstall() {\n    if (LeakCanaryInternals.installedRefWatcher != null) {\n        throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\");\n    }\n    RefWatcher refWatcher = build();\n    if (refWatcher != DISABLED) {\n        if (enableDisplayLeakActivity) {\n            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);\n        }\n        if (watchActivities) {\n            ActivityRefWatcher.install(context, refWatcher);\n        }\n        if (watchFragments) {\n            FragmentRefWatcher.Helper.install(context, refWatcher);\n        }\n    }\n    LeakCanaryInternals.installedRefWatcher = refWatcher;\n    return refWatcher;\n}\n```\n该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪`install`方法\n\n```Java\npublic static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {\n    Application application = (Application) context.getApplicationContext();\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n\n    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);\n}\n\n//成员变量 lifecycleCallbacks\nprivate final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n    new ActivityLifecycleCallbacksAdapter  {\n        @Override public void onActivityDestroyed(Activity activity) {\n            refWatcher.watch(activity);\n        }\n    };\n```\n\n由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。\n\n`watch`方法由 RefWatcher 默认实现：\n\n```Java\npublic void watch(Object watchedReference, String referenceName) {\n    ......  \n    retainedKeys.add(key);\n    final KeyedWeakReference reference =\n            new KeyedWeakReference(watchedReference, key, referenceName, queue);\n\n    ensureGoneAsync(watchStartNanoTime, reference);\n}\n```\n\n其中 retainedKeys 是一个 Set<String> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。 \nKeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。\n\n```Java\nprivate void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {\n    watchExecutor.execute(new Retryable() {\n        @Override public Retryable.Result run() {\n            return ensureGone(reference, watchStartNanoTime);\n        }\n    });\n}\n```\n\nwatchExecutor 为 AndroidWatchExecutor 对象\n```\npublic AndroidWatchExecutor(long initialDelayMillis) {\n    mainHandler = new Handler(Looper.getMainLooper());\n    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);\n    handlerThread.start();\n    backgroundHandler = new Handler(handlerThread.getLooper());\n    this.initialDelayMillis = initialDelayMillis;\n    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;\n}\n\n@Override public void execute(@NonNull Retryable retryable) {\n    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\n        waitForIdle(retryable, 0);\n    } else {\n        postWaitForIdle(retryable, 0);\n    }\n}\n```\n在`execute`中，不管是`waitForIdle`还是`postWaitForIdle`都会切换到主线程执行，最终会调用以下代码：\n```Java\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        postToBackgroundWithDelay(retryable, failedAttempts);\n        return false;\n      }\n    });\n```\n那么 IdleHandler 到底是什么呢？\n\n我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。\n\n`ensureGoneAsync`方法最终会调用`ensureGone`\n\n```Java\nRetryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {\n    ......\n    removeWeaklyReachableReferences();\n    ......\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n        ......\n        File heapDumpFile = heapDumper.dumpHeap();\n        ......\n        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)\n            .referenceName(reference.name)\n            .watchDurationMs(watchDurationMs)\n            .gcDurationMs(gcDurationMs)\n            .heapDumpDurationMs(heapDumpDurationMs)\n            .build();\n\n        heapdumpListener.analyze(heapDump);\n    }\n    return DONE;\n}\n```\n\n- `removeWeaklyReachableReferences`遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。\n- 调用`gcTrigger.runGc`去进行内存回收，这里没有使用`System.gc`，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。\n- 主动进行 GC 之后会再次调用`removeWeaklyReachableReferences`清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。\n- 生成性能统计文件.hprof，进行内存泄漏的分析。\n\n那么 hprof 文件是被解析成信息的呢\n\n```Java\nAnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);\n```\n\n```Java\npublic AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {\n    ......\n    MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile);\n    HprofParser parser = new HprofParser(e);\n    Snapshot snapshot = parser.parse();\n    this.deduplicateGcRoots(snapshot);\n    Instance leakingRef = this.findLeakingReference(referenceKey, snapshot);\n    return leakingRef == null ? AnalysisResult.noLeak(this.since(analysisStartNanoTime)) ：\n        this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);\n}\n```\n\n`checkForLeak`方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的`parse`方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。\n\n得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。\n\n### 总结\nLeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。\n","slug":"LeakCanary源码解析","published":1,"updated":"2019-03-15T15:27:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavca001vi0up3alsoe2j","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>内存泄漏是 Android 开发中无法避免的问题，<a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"noopener\">LeakCanary</a> 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。<a id=\"more\"></a></p>\n<h2 id=\"ActivityLifecycleCallbacks\"><a href=\"#ActivityLifecycleCallbacks\" class=\"headerlink\" title=\"ActivityLifecycleCallbacks\"></a>ActivityLifecycleCallbacks</h2><p>LeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。</p>\n<h3 id=\"接口方法\"><a href=\"#接口方法\" class=\"headerlink\" title=\"接口方法\"></a>接口方法</h3><p>可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h3><p>开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Activity&gt; activityList;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_MAX_NUM = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        activityList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> MyActivityCallbacks());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivityCallbacks</span> <span class=\"keyword\">implements</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activityList.size() &gt;= ACTIVITY_MAX_NUM) &#123;</span><br><span class=\"line\">                activityList.remove(activityList.size()-<span class=\"number\">1</span>).finish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            activityList.remove(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity <span class=\"title\">getCurrentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activityList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的<code>A a = new A()</code>中的引用a。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;String&gt; sr = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">         </span><br><span class=\"line\">System.out.println(sr.get());</span><br><span class=\"line\">System.gc();                <span class=\"comment\">//通知JVM的gc进行垃圾回收</span></span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<p>打印的结果为</p>\n<blockquote>\n<p>hello<br><br>null</p>\n</blockquote>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">WeakReference pr = <span class=\"keyword\">new</span> WeakReference(object, queue);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其<code>get()</code>永远返回<code>null</code></p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LeakCanary源码\"><a href=\"#LeakCanary源码\" class=\"headerlink\" title=\"LeakCanary源码\"></a>LeakCanary源码</h2><p>实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>跟踪调用的入口方法<code>install</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">install</span><span class=\"params\">(@NonNull Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class=\"line\">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class=\"line\">        .buildAndInstall();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>listenerServiceClass</code>方法位于 AndroidRefWatcherBuilder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">AndroidRefWatcherBuilder <span class=\"title\">listenerServiceClass</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heapDumpListener(<span class=\"keyword\">new</span> ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和<code>excludedRefs</code>方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">buildAndInstall</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LeakCanaryInternals.installedRefWatcher != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"buildAndInstall() should only be called once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RefWatcher refWatcher = build();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refWatcher != DISABLED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class=\"line\">            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchActivities) &#123;</span><br><span class=\"line\">            ActivityRefWatcher.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchFragments) &#123;</span><br><span class=\"line\">            FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪<code>install</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class=\"line\">    Application application = (Application) context.getApplicationContext();</span><br><span class=\"line\">    ActivityRefWatcher activityRefWatcher = <span class=\"keyword\">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//成员变量 lifecycleCallbacks</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ActivityLifecycleCallbacksAdapter  &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            refWatcher.watch(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。</p>\n<p><code>watch</code>方法由 RefWatcher 默认实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">watch</span><span class=\"params\">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">    retainedKeys.add(key);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> KeyedWeakReference reference =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 retainedKeys 是一个 Set<string> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。<br>KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。</string></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureGoneAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime, <span class=\"keyword\">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class=\"line\">    watchExecutor.execute(<span class=\"keyword\">new</span> Retryable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> Retryable.<span class=\"function\">Result <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>watchExecutor 为 AndroidWatchExecutor 对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AndroidWatchExecutor(long initialDelayMillis) &#123;</span><br><span class=\"line\">    mainHandler = new Handler(Looper.getMainLooper());</span><br><span class=\"line\">    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    backgroundHandler = new Handler(handlerThread.getLooper());</span><br><span class=\"line\">    this.initialDelayMillis = initialDelayMillis;</span><br><span class=\"line\">    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override public void execute(@NonNull Retryable retryable) &#123;</span><br><span class=\"line\">    if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class=\"line\">        waitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        postWaitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>execute</code>中，不管是<code>waitForIdle</code>还是<code>postWaitForIdle</code>都会切换到主线程执行，最终会调用以下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>那么 IdleHandler 到底是什么呢？</p>\n<p>我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。</p>\n<p><code>ensureGoneAsync</code>方法最终会调用<code>ensureGone</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retryable.<span class=\"function\">Result <span class=\"title\">ensureGone</span><span class=\"params\">(<span class=\"keyword\">final</span> KeyedWeakReference reference, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    gcTrigger.runGc();</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gone(reference)) &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        File heapDumpFile = heapDumper.dumpHeap();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class=\"line\">            .referenceName(reference.name)</span><br><span class=\"line\">            .watchDurationMs(watchDurationMs)</span><br><span class=\"line\">            .gcDurationMs(gcDurationMs)</span><br><span class=\"line\">            .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        heapdumpListener.analyze(heapDump);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DONE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>removeWeaklyReachableReferences</code>遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。</li>\n<li>调用<code>gcTrigger.runGc</code>去进行内存回收，这里没有使用<code>System.gc</code>，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。</li>\n<li>主动进行 GC 之后会再次调用<code>removeWeaklyReachableReferences</code>清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。</li>\n<li>生成性能统计文件.hprof，进行内存泄漏的分析。</li>\n</ul>\n<p>那么 hprof 文件是被解析成信息的呢</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AnalysisResult <span class=\"title\">checkForLeak</span><span class=\"params\">(File heapDumpFile, String referenceKey)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    MemoryMappedFileBuffer e = <span class=\"keyword\">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class=\"line\">    HprofParser parser = <span class=\"keyword\">new</span> HprofParser(e);</span><br><span class=\"line\">    Snapshot snapshot = parser.parse();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deduplicateGcRoots(snapshot);</span><br><span class=\"line\">    Instance leakingRef = <span class=\"keyword\">this</span>.findLeakingReference(referenceKey, snapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leakingRef == <span class=\"keyword\">null</span> ? AnalysisResult.noLeak(<span class=\"keyword\">this</span>.since(analysisStartNanoTime)) ：</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>checkForLeak</code>方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的<code>parse</code>方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。</p>\n<p>得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>内存泄漏是 Android 开发中无法避免的问题，<a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"noopener\">LeakCanary</a> 框架是 Square 公司开源的内存泄漏分析工具，其集成方便，使用便捷。</p>","more":"<p></p>\n<h2 id=\"ActivityLifecycleCallbacks\"><a href=\"#ActivityLifecycleCallbacks\" class=\"headerlink\" title=\"ActivityLifecycleCallbacks\"></a>ActivityLifecycleCallbacks</h2><p>LeakCanary 的实现基础之一，是 Android 官方在4.0（API 14）之后引入的 ActivityLifecycleCallbacks，它是 Application 类的内部接口，提供应用生命周期回调的注册方法，以集中管理应用的生命周期。</p>\n<h3 id=\"接口方法\"><a href=\"#接口方法\" class=\"headerlink\" title=\"接口方法\"></a>接口方法</h3><p>可以看到该接口定义了如下的 Activity 的生命周期回调方法，其与 Activity 的完整声明周期几乎是一一对应的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h3><p>开发中如果我们想要统一管理项目中所有的 Activity，可以通过自定义 ActivityManager 实现，然后在 BaseActivity 中对每一个 Activity 做 put/get 操作，该做法的缺陷是无法控制一些第三方框架的 Activity。<br>此时我们可以使用 ActivityLifecycleCallbacks ，在自定义的 Application 中维护一个 Activity链表， 由于所有的 Activity 的生命周期都会回调该接口，就能够实现对所有 Activity 的统一控制和管理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Activity&gt; activityList;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_MAX_NUM = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        activityList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> MyActivityCallbacks());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivityCallbacks</span> <span class=\"keyword\">implements</span> <span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activityList.size() &gt;= ACTIVITY_MAX_NUM) &#123;</span><br><span class=\"line\">                activityList.remove(activityList.size()-<span class=\"number\">1</span>).finish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(Activity activity, Bundle outState)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            activityList.remove(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity <span class=\"title\">getCurrentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activityList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用（StrongReference）是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如经常使用的<code>A a = new A()</code>中的引用a。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用（SoftReference）用来描述一些有用但并不是必需的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;String&gt; sr = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用（WeakReference）与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(<span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\">         </span><br><span class=\"line\">System.out.println(sr.get());</span><br><span class=\"line\">System.gc();                <span class=\"comment\">//通知JVM的gc进行垃圾回收</span></span><br><span class=\"line\">System.out.println(sr.get());</span><br></pre></td></tr></table></figure></p>\n<p>打印的结果为</p>\n<blockquote>\n<p>hello<br><br>null</p>\n</blockquote>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，当弱引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">WeakReference pr = <span class=\"keyword\">new</span> WeakReference(object, queue);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>PhantomReference，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，查看源码可以发现，其<code>get()</code>永远返回<code>null</code></p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LeakCanary源码\"><a href=\"#LeakCanary源码\" class=\"headerlink\" title=\"LeakCanary源码\"></a>LeakCanary源码</h2><p>实际上 LeakCanary 正是利用 Activity 的生命周期回调，配合弱引用检测实现内存泄漏的分析。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>跟踪调用的入口方法<code>install</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">install</span><span class=\"params\">(@NonNull Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class=\"line\">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class=\"line\">        .buildAndInstall();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>listenerServiceClass</code>方法位于 AndroidRefWatcherBuilder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">AndroidRefWatcherBuilder <span class=\"title\">listenerServiceClass</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heapDumpListener(<span class=\"keyword\">new</span> ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类的父类（RefWatcherBuilder）已经默认实现 heapDumpListener 和<code>excludedRefs</code>方法（定义一些开发者可以忽略的路径，即使发生了内存泄漏，LeakCanary 也不会弹出通知。大多是系统 Bug 导致）。下面来看最终调用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">RefWatcher <span class=\"title\">buildAndInstall</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LeakCanaryInternals.installedRefWatcher != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"buildAndInstall() should only be called once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RefWatcher refWatcher = build();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refWatcher != DISABLED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class=\"line\">            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchActivities) &#123;</span><br><span class=\"line\">            ActivityRefWatcher.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (watchFragments) &#123;</span><br><span class=\"line\">            FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> refWatcher;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法主要做了三件事：Build RefWatcher；启用 DisplayLeakActivity， 用于显示性能统计结果；install ActivityRefWatcher。继续跟踪<code>install</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">install</span><span class=\"params\">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class=\"line\">    Application application = (Application) context.getApplicationContext();</span><br><span class=\"line\">    ActivityRefWatcher activityRefWatcher = <span class=\"keyword\">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//成员变量 lifecycleCallbacks</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ActivityLifecycleCallbacksAdapter  &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            refWatcher.watch(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可知 LeakCanary 内部实现了对 Activity 生命周期的监听，ActivityLifecycleCallbacksAdapter 其实是对  Application.ActivityLifecycleCallbacks 中所有方法都做了空实现的抽象类。</p>\n<p><code>watch</code>方法由 RefWatcher 默认实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">watch</span><span class=\"params\">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class=\"line\">    ......  </span><br><span class=\"line\">    retainedKeys.add(key);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> KeyedWeakReference reference =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 retainedKeys 是一个 Set<string> 集合，每个检测的对象都对应一个唯一的 key，存储在 retainedKeys 中。<br>KeyedWeakReference 是 WeakReference 的子类，在其基础上添加了 key 和 name 两个属性用以跟踪记录。其中传入了一个 queue 参数，明显是引用队列。</string></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureGoneAsync</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime, <span class=\"keyword\">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class=\"line\">    watchExecutor.execute(<span class=\"keyword\">new</span> Retryable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> Retryable.<span class=\"function\">Result <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>watchExecutor 为 AndroidWatchExecutor 对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AndroidWatchExecutor(long initialDelayMillis) &#123;</span><br><span class=\"line\">    mainHandler = new Handler(Looper.getMainLooper());</span><br><span class=\"line\">    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);</span><br><span class=\"line\">    handlerThread.start();</span><br><span class=\"line\">    backgroundHandler = new Handler(handlerThread.getLooper());</span><br><span class=\"line\">    this.initialDelayMillis = initialDelayMillis;</span><br><span class=\"line\">    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override public void execute(@NonNull Retryable retryable) &#123;</span><br><span class=\"line\">    if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class=\"line\">        waitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        postWaitForIdle(retryable, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>execute</code>中，不管是<code>waitForIdle</code>还是<code>postWaitForIdle</code>都会切换到主线程执行，最终会调用以下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>那么 IdleHandler 到底是什么呢？</p>\n<p>我们都知道 Handler 是循环处理 MessageQueue 中的消息的，当消息队列中没有更多消息需要处理，且声明了 IdleHandler 接口的时候，就会去处理这里的操作。即指定一些操作，当线程空闲的时候来处理，此处执行的便是内存泄漏检测工作。</p>\n<p><code>ensureGoneAsync</code>方法最终会调用<code>ensureGone</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retryable.<span class=\"function\">Result <span class=\"title\">ensureGone</span><span class=\"params\">(<span class=\"keyword\">final</span> KeyedWeakReference reference, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    gcTrigger.runGc();</span><br><span class=\"line\">    removeWeaklyReachableReferences();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!gone(reference)) &#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        File heapDumpFile = heapDumper.dumpHeap();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class=\"line\">            .referenceName(reference.name)</span><br><span class=\"line\">            .watchDurationMs(watchDurationMs)</span><br><span class=\"line\">            .gcDurationMs(gcDurationMs)</span><br><span class=\"line\">            .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        heapdumpListener.analyze(heapDump);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DONE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>removeWeaklyReachableReferences</code>遍历引用队列 queue，判断队列中是否存在当前 Activity 的弱引用，存在则删除 retainedKeys 中对应引用的 key值。</li>\n<li>调用<code>gcTrigger.runGc</code>去进行内存回收，这里没有使用<code>System.gc</code>，是因为它仅仅是通知系统在合适的时间进行一次垃圾回收操作，并不能保证一定执行。</li>\n<li>主动进行 GC 之后会再次调用<code>removeWeaklyReachableReferences</code>清除 retainedKeys 中弱引用的 key 值，再判断是否移除。如果仍然没有移除，判定为内存泄漏。</li>\n<li>生成性能统计文件.hprof，进行内存泄漏的分析。</li>\n</ul>\n<p>那么 hprof 文件是被解析成信息的呢</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AnalysisResult <span class=\"title\">checkForLeak</span><span class=\"params\">(File heapDumpFile, String referenceKey)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    MemoryMappedFileBuffer e = <span class=\"keyword\">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class=\"line\">    HprofParser parser = <span class=\"keyword\">new</span> HprofParser(e);</span><br><span class=\"line\">    Snapshot snapshot = parser.parse();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deduplicateGcRoots(snapshot);</span><br><span class=\"line\">    Instance leakingRef = <span class=\"keyword\">this</span>.findLeakingReference(referenceKey, snapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leakingRef == <span class=\"keyword\">null</span> ? AnalysisResult.noLeak(<span class=\"keyword\">this</span>.since(analysisStartNanoTime)) ：</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>checkForLeak</code>方法使用了 Square 公司的另一个库 haha 来分析 Android heap dump，可以看到，执行转化的方法为 HprofParser 的<code>parse</code>方法，然后再将转化的信息封装成 AnalysisResult 对象，其中 HprofParser 是自定义的类，里面有一定的篇幅解析 .hprof 文件。</p>\n<p>得到结果后回调给 DisplayLeakService，该 Service 会根据传入进来的数据发送通知，存入数据。点击对应的通知进入 DisplayLeakActivity 界面，就能查看泄漏日志。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>LeakCanary 检测内存泄漏的设计思路十分巧妙、清晰。整个框架对于 ActivityLifecycleCallbacks、WeakReference、ReferenceQueue 和 IdleHandler 的使用，四大组件的开启和关闭等等，都很有意思，值得深和借鉴。</p>"},{"title":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","date":"2019-01-13T15:09:12.000Z","_content":"\n## 引言\n 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<!--more-->\n\n “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。\n\n 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。\n\n 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：[巴赫《六首无伴奏大提琴组曲》斯塔克](https://music.163.com/#/playlist?id=596314970)\n\n\n ## 正文\n 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。\n\n如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。\n那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。\n\n回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。\n\n探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。\n\n如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。\n\n应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。\n\n12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。\n\n马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。\n\n在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。\n\n在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。\n\n最感人的还是大师们晚年的演奏，情感饱足，回归天真。\n\n罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。\n\n罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。\n\n俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。\n\n法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。\n\n只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜","source":"_posts/巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》.md","raw":"---\ntitle: 巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》\ndate: 2019-01-13 23:09:12\ntags:\n- 音乐\n- 巴洛克\n- 巴赫\ncategories:\n- 艺术\n---\n\n## 引言\n 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<!--more-->\n\n “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。\n\n 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。\n\n 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：[巴赫《六首无伴奏大提琴组曲》斯塔克](https://music.163.com/#/playlist?id=596314970)\n\n\n ## 正文\n 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。\n\n如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。\n那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。\n\n回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。\n\n探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。\n\n如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。\n\n应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。\n\n12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。\n\n马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。\n\n在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。\n\n在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。\n\n最感人的还是大师们晚年的演奏，情感饱足，回归天真。\n\n罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。\n\n罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。\n\n俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。\n\n法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。\n\n只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜","slug":"巴洛克的珍珠：巴赫《六首无伴奏大提琴组曲》","published":1,"updated":"2019-03-15T15:26:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavcb001yi0upvezyp71t","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p> 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。<a id=\"more\"></a></p>\n<p> “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。</p>\n<p> 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。</p>\n<p> 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：<a href=\"https://music.163.com/#/playlist?id=596314970\" target=\"_blank\" rel=\"noopener\">巴赫《六首无伴奏大提琴组曲》斯塔克</a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p> 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。</p>\n<p>如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。<br>那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。</p>\n<p>回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。</p>\n<p>探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。</p>\n<p>如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。</p>\n<p>应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。</p>\n<p>12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。</p>\n<p>马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。</p>\n<p>在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。</p>\n<p>在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。</p>\n<p>最感人的还是大师们晚年的演奏，情感饱足，回归天真。</p>\n<p>罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。</p>\n<p>罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。</p>\n<p>俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。</p>\n<p>法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。</p>\n<p>只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p> 第一次接触“巴洛克”一词，是在CCTV音乐厅的“漫步经典”系列，也许是初中的一个午后，电视机里传来维瓦尔第《四季》组曲悠扬欢快的乐声，旋律飘过时光，铭刻在心中。</p>","more":"<p></p>\n<p> “漫步经典”系列关于巴洛克音乐的介绍共分六期节目，虽说特别在意，实际上也没有完整地看完。不知道何时起，就有了系统地了解西方古典音乐的想法，还专门去知乎浏览诸如“古典音乐”怎么入门之类的问答，可惜每次都是迈出第一步，便再无下文。不过倒也不在意，毕竟要“系统地”听完古典音乐史，对一个门外汉来说，也着实富有挑战性。</p>\n<p> 生活中专门欣赏古典音乐的机会不算多。心情烦躁、百无聊赖之际，会随性地打开关于古典音乐的歌单，戴上耳机，感受巴赫们银珠倾斜般饱满的情感。近来发现一本书：《穿T恤听古典音乐》，作者用音乐家的故事串联起西方古典音乐史，为欣赏古典音乐提供了不一样的方式。</p>\n<p> 本文摘录了书中关于巴赫《六首无伴奏大提琴组曲》的章节，记录关于这一伟大乐章背后的故事。组曲的网易云链接为：<a href=\"https://music.163.com/#/playlist?id=596314970\" target=\"_blank\" rel=\"noopener\">巴赫《六首无伴奏大提琴组曲》斯塔克</a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p> 1889年，13岁的卡萨尔斯（Pablo Casals）刚开始学大提琴不久，有一天，他和父亲在街头闲逛，走到一间昏暗的古董店里，浏览店里稀奇古怪的收藏。卡萨尔斯在角落里发现了一本破破的乐谱，大开本，纸质厚实，翻开来像一本巨大的祈祷书。父亲走过来，他看到上面有巴赫与大提琴的字样，没错，这就是遗失已久的巴赫作品《六首无伴奏大提琴组曲》。</p>\n<p>如今，巴赫的《六首无伴奏大提琴组曲》是大提琴家的旧约圣经，而在卡萨尔斯发现它之前，几乎无人演奏过，人们只听过零星片段，居然还有人煞有介事给它配上蹩脚的钢琴伴奏。<br>那天，卡萨尔斯像受到神启一般，紧紧抱着乐谱飞奔回家，迫不及待地开始练习。他说：“这次发现是对我生命的奇妙启示。”对于一位初学大提琴的少年，发现这样一个巨大的宝藏，已经意味着一种命运，他要把此生奉献给大提琴。</p>\n<p>回顾20世纪，没有哪位大提琴家赢得了像卡萨尔斯那样的成就与影响力：他旅行演出的足迹遍布世界各地；他完善了大提琴演奏技巧，提升了大提琴作为独奏乐器的地位；他反对西班牙内战而流亡巴黎，因此获诺贝尔和平奖提名。在他的祖国西班牙，还有一条名叫卡萨尔斯的公路……他是一位传奇的大提琴家，他说他不仅是大提琴家，他首先是一位音乐家。20岁的时候，卡萨尔斯去巴黎的大师那里学琴，拉完一曲，大师起身拥抱他说，你注定是不同凡响的音乐家。</p>\n<p>探寻这部《六首无伴奏大提琴组曲》的故事，就是回顾20世纪大提琴演奏艺术史。卡萨尔斯把一生用来演奏和推广这部乐曲，如今他的名字已经与这部曲集永远相连，是他的毕生努力让它成为大提琴的核心曲目。如今所有大提琴家都在练习它，挑战它。它是圣经，亦是归宿。童年时代的马友友把这套大提琴组曲当作练习曲，父亲要求他每天学习两小节，五岁的他竟能够从头至尾拉奏，并且以它开了独奏会。他与卡萨尔斯一样，艺术人生从巴赫开始。</p>\n<p>如今已经无人知道巴赫创作《六首无伴奏大提琴组曲》的确切年份，学者们从风格、体裁等因素考量，认为它作于巴赫在科滕担任宫廷乐长的时期。巴赫的大部分室内乐都是在那时完成的，一半是因为科滕的领主喜欢玩室内乐。这部组曲一共有6套36首曲目，包含6种舞曲：序奏、阿列曼德舞曲、库朗特舞曲、萨拉班德舞曲、吉格舞曲、小步舞曲。结构与当时写的《法国组曲》和《英国组曲》类似，按照巴洛克组曲方式排列。前三套组曲大约写于1702年，也就是《无伴奏小提琴奏鸣曲》时期，后三套技巧艰深表达晦涩，应该写于更晚一些年份。科滕领主是一位资深乐迷，也称得上是一位业余音乐家，他挑选的乐手都是一流的，巴赫在那里工作得非常愉快。据说六首大提琴组曲是为宫廷里的两位古大提琴家李尼希克（Christian Linike）和阿贝尔（Christian Ferdinand Abel）而作，他们居然在300年前就能胜任其中的复杂技巧。</p>\n<p>应该如何演奏这部乐曲？乐谱上除了音符，没有任何提示，没有速度，没有强弱记号，没有分句，也没有表情记号。巴赫给了自由，也给了挑战。青少年时代的卡萨尔斯花12年磨炼这部乐曲，他在练什么呢？首先，他练习拉琴的技巧，对他来说技巧已经跨越了其本身，成为一种无痕的表达。其次是分句，将延绵无尽的巴洛克曲线条分缕析，层层推进，钻研声音的透视法。巴赫是巴洛克时代最后的对位法大师，即使独奏声部也被他嵌入两三条隐形旋律，在乐句中若隐若现。音乐一句句展开，一层层深入，一座结构精巧的巴洛克建筑跃然眼前，呈现缜密立体的三维结构，每个细节都流畅而丰盈。</p>\n<p>12年之后，25岁的卡萨尔斯将它们录制成了唱片。如今听来，那一版录音也是经典演绎，令人赞叹，声部感错落有致，线条流畅悠然。音乐是无形的，技术也应该是无形的，复杂的技巧在他手中已经和音乐一样无形无痕，流动不息。这样的演奏里面有一种东方意境，后来马友友和林怀民继续在这部乐曲中探索东方韵味与中西方的精神联接。</p>\n<p>马友友与坂东玉三郎曾经合作了一部纪录片，叫作《巴赫灵感》之“巴赫无伴奏大提琴组曲之五，追寻希望”。坂东玉三郎是日本国宝级歌舞伎演员，在片中，马友友和他一起排练交流，一位说英语，一位说日语，一位拉奏，一位起舞。他们在大提琴曲中交谈，背后是排练场的巨大玻璃窗，把窗外大片日本的绿景收揽进画面。坂东听着马友友的琴声，独语、低首、回旋、沉思，窗外是淅淅沥沥的雨声，他以舞蹈演绎节奏、旋律的起伏、音乐的走句。他们把巴赫的第五组曲诠释为“仪式”、“哀叹”、“否定”、“祈”、“梦”和“调和”，如此提炼巴赫音乐中的戏剧力量。马友友在白纸上用毛笔写下“仪式”。是的，仪式，巴赫与日本艺术，两者相通之处就是其中的仪式感。日本与巴赫时代都讲究仪式感，仪式是为了尊重，也是一种美学。他们的这些诠释突破了东西方文化的界限，是消除民族性暗示的碎片，也是衔接这场东西合作的桥梁。这场表演最终让我们发现，巴赫的音乐无关东西方语境，它是每一个饱满心灵的歌咏，音乐正是在突破这种东西方局限之后才有可能靠近永恒。</p>\n<p>在林怀民的现代舞作品《水月》里面，中国的太极式舞姿中传来了巴赫的大提琴组曲第一首，音乐充满律动，舞蹈中却埋藏着深深的寂静与孤独。舞台的地面是一大片反光的镜子，舞者与之形影相对。他们能够无痕地融合，本质上是因为“独”，沉郁的独奏，一大片白影飘零，琴声如独舞，彼此在孤独中舒展、沉醉、忘怀。</p>\n<p>在音乐史上，20世纪是演绎的时代，唱片发行和全球巡演促成了演奏天才辈出。后来也有超越卡萨尔斯的演绎，比如匈牙利裔大提琴家斯塔克。他的演奏技术严谨精确，六曲拉到尾毫不松懈，所有细节都棱角分明，层次饱满。斯塔克的音乐风格与他的形象都是严谨冷冽的，不太流露情感，但他对这套乐曲似乎是感情最深的，前后录了五遍，他自己坦陈：前三遍主要顾及结构和技巧，后两遍才有感情流露。如此坦诚的演奏家不多。像斯塔克这样的技巧大师都要顾及技巧，可见该神曲的技巧有多难。斯塔克抑制情感的演奏让人们更关注乐音的运动，让人想起音乐美学家汉斯立克曾说：“音乐的内容就是乐音的运动形式。”但在理性背后，琴音中的沉郁深入肺腑，特别是第四弦在音列中低鸣不息，让悲哀若隐若现，更暗示了巴赫对位法的博大精深。反复听他的演奏，觉得他的严谨分明中似乎有一种无从解释的神秘感，这样的演奏或许才是深入德国精髓的，更贴近不倦探寻人类终极秘密的日耳曼心灵。</p>\n<p>最感人的还是大师们晚年的演奏，情感饱足，回归天真。</p>\n<p>罗斯托罗波维奇（Mstislav Leopoldovich Rostropovich），当代俄罗斯最著名的大提琴家。1989年，柏林墙被推倒的时候，罗斯托罗波维奇放下一切工作，背起大提琴赶赴柏林，从机场直接打车到柏林墙拆除的现场，借了把椅子，坐下就开始拉奏巴赫的《六首无伴奏大提琴组曲》。他说：“我无法忘怀所有想要翻越这堵墙而丧生的人们，当我拉起萨拉班德，人群里有位年轻人哭了。”这部乐曲罗斯托罗波维奇拉过无数遍，技巧无懈可击，他的强势与意志让巴赫深具阳刚之美。唯独那一次演奏让他毕生难忘。面对当时的场景人们能够说什么？只有巴赫的音乐能够抚慰人心，悲欣交集，欢喜与悲伤，欢庆与追念。这也是人们理解巴赫的时刻，他似乎懂得禅意，无所诉说又无所不说。每一个音符都是瞬间，都是永恒；都是悲剧，都是救赎；都是音乐，都是真理。</p>\n<p>罗斯托罗波维奇花了半生研读这部乐曲，到了晚年，他在法国南部的小镇上选了一座拥有900年历史的教堂，在那里完整录制了这部乐曲。年轻时已对每一个音符了然于心，如今在老教堂里，在破旧拱廊和湮没的线条中感知巴洛克韵律，每一个音符多么熟悉，又像是第一次听见，拉奏着深沉的低音，却又是一身轻松。他的强势与层次感，他对结构全局的把握，他的紧凑有力，让每个音符绽放金色的光芒，也让乐曲真正震撼人心。</p>\n<p>俄罗斯大提琴家沙夫兰（Danil Shafran）的版本最动人也最有想象力。他的音符无比连贯通透，延绵如土地，不息如河流。对于巴赫这样崎岖的多声部织体，不知道他是如何做到如履平地，歌唱得如此酣畅热情。这一版本也是我听过的最富有歌唱性的演奏，要知道，这部乐曲本身是不太能歌唱的。当然沙夫兰的演奏也最不像巴洛克风格，他发挥了其中的浪漫气质。</p>\n<p>法国大提琴学派也对这部乐曲作出贡献。詹德龙（Maurice Gendron）、富尼埃（Pierre Fournier）、托特里耶（Paul Tortelier）和纳瓦拉（Andre Navarra）被称为法国大提琴四骑士。他们的演奏没有德奥音乐家那种强硬，而是温暖流畅、关注细节的，带着妙曼的巴黎沙龙气息。富尼埃的版本最有古典气质，他真是一位天生的贵族，乐句无比优雅，音色如光滑的丝绸，却十分自然，如温暖善感的独白；詹德龙冷静轻盈一些，一派典雅的古典风范；托特里耶有激情，甚至灼痛感，可以听见音乐中催人奋起的力量。每个人个性迥异，他们的个人魅力丰满了巴赫的作品，与之互相成就。</p>\n<p>只是杜普雷的版本略有逊色。这也是意料之中，巴赫不是她的菜</p>"},{"title":"基本数据结构的简单Java实现","date":"2019-03-16T14:08:55.000Z","_content":"\n## 引言\nJDK 中提供了很多数据结构，如下所示\n> Collection\n> ├ List\n> │   ├ LinkedList\n> │   ├ ArrayList\n> │   └ Vector\n> │　    └Stack\n> └ Set\n>\n> Map\n> ├ Hashtable\n> ├ HashMap\n> └ WeakHashMap\n\n本文将进行部分数据结构的简单实现。\n\n<!--more-->\n\n## Stack\n```Java\npublic class MyStack<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int nowSize = 0;\n\n    public MyStack() {\n        this(10);\n    }\n\n    public MyStack(int initialCapacity) {\n        maxSize = initialCapacity;\n        dataArray = new Object[maxSize];\n    }\n\n    public void push(T data) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        dataArray[nowSize++] = data;\n    }\n\n    public T pop() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[--nowSize];\n    }\n\n    public T peek() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[nowSize-1];\n    }\n\n    public int search(T target) {\n        int p = nowSize;\n        while (p >= 0) {\n            if (dataArray[p] == target) {\n                return p;\n            }\n            p--;\n        }\n        return -1;\n    }\n\n    private void resize() {\n        maxSize = maxSize << 1;\n        Object[] newArray = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            newArray[i] = dataArray[i];\n        }\n        this.dataArray = newArray;\n    }\n\n    public int size() {\n        return nowSize;\n    }\n\n    public boolean empty() {\n        return nowSize == 0 ? true : false;\n    }\n}\n```\n## Queue\n```Java\npublic class MyQueue<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int front;\n    private int rear;\n\n    public MyQueue() {\n        this(10);\n    }\n\n    public MyQueue(int initialSize) {\n        maxSize = initialSize;\n        dataArray = new Object[maxSize];\n        front = rear = 0;\n    }\n\n    public void enqueue(T newData) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        //非循环队列\n        dataArray[rear++] = newData;\n        \n        //循环队列\n        //dataArray[rear] = newData;\n        //rear = (rear+1) % maxSize;\n    }\n\n    public T dequeue() {\n        if (empty()) {\n            return null;\n        }\n        T value = (T)dataArray[front];\n        //非循环队列\n        dataArray[front++] = null;\n        \n        //循环队列\n        //dataArray[front] = null;\n        //front = (front+1) % maxSize;\n        \n        return value;\n    }\n\n    public void resize() {\n        maxSize = maxSize << 1;\n        Object[] temp = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            temp[i] = dataArray[i];\n        }\n        dataArray = temp;\n    }\n\n    public int size() {\n        return Math.abs(front - rear);\n    }\n\n    public boolean empty() {\n        return front == rear ? true : false;\n    }\n}\n```\n\n## BinaryTree\n\n![二叉搜索树](基本数据结构的简单Java实现/二叉搜索树.png)\n\n```Java\npublic class MyBinaryTree<T> {\n\n    private Node root;\n\n    class Node {\n        private int key;\n        private T value;\n        private Node leftChild;\n        private Node rightChild;\n\n        public Node(int key, T value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    public Node find(int key) {\n        Node currentNode = root;\n        while (currentNode != null && currentNode.key != key) {\n            if (key < currentNode.leftChild.key) {\n                currentNode = currentNode.leftChild;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        return currentNode;\n    }\n\n    public void insert(int key, T value) {\n        if (root == null) {\n            root = new Node(key, value);\n            return;\n        }\n        Node currentNode = root;\n        Node parentNode = root;\n        Boolean isLeftChild = true;\n\n        while (currentNode != null) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        Node newNode = new Node(key, value);\n        if (isLeftChild) {\n            parentNode.leftChild = newNode;\n        } else {\n            parentNode.rightChild = newNode;\n        }\n    }\n\n    public boolean delete(int key) {\n        Node currentNode = root;    //待删除节点\n        Node parentNode = root;     //待删除节点的父节点\n        Boolean isLeftChild = true;\n        while (currentNode != null && currentNode.key != key) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n                isLeftChild = false;\n            }\n        }\n        if (currentNode == null) {\n            return false;\n        }\n        //删除节点为叶子节点\n        if (currentNode.leftChild == null && currentNode.rightChild == null) {\n            if (currentNode == root) {\n                root = null;\n            } else if (isLeftChild) {\n                parentNode.leftChild = null;\n            } else {\n                parentNode.rightChild = null;\n            }\n        } else if (currentNode.rightChild == null) {    //待删除节点只有左子节点\n            if (currentNode == root) {\n                root = currentNode.leftChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.leftChild;\n            } else {\n                parentNode.rightChild = currentNode.leftChild;\n            }\n        } else if (currentNode.leftChild == null) {    //待删除节点只有右子节点\n            if (currentNode == root) {\n                root = currentNode.rightChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.rightChild;\n            } else {\n                parentNode.rightChild = currentNode.rightChild;\n            }\n        } else {    //待删除节点既有左子节点又有右子节点\n            Node directPostNode = getDirectPostNode(currentNode);\n            currentNode.key = directPostNode.key;\n            currentNode.value = directPostNode.value;\n        }\n        return true;\n    }\n\n    /**\n     * 获得待删除节点的直接后继节点\n     *\n     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点\n     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点\n     * 并删除 key 值为 10 的节点的中序后继节点，\n     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，\n     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子\n     *\n     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），\n     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值\n     *\n     * @param delNode 待删除节点\n     * @return 返回直接后继节点\n     */\n    private Node getDirectPostNode(Node delNode) {\n        Node parentNode = delNode;  //保存待删除节点的直接后继节点的父节点\n        Node direcrPostNode = delNode;  //保存待删除节点的直接后继节点\n        Node currentNode = delNode.rightChild;\n\n        while (currentNode != null) {\n            parentNode = direcrPostNode;\n            direcrPostNode = currentNode;\n            currentNode = currentNode.leftChild;\n        }\n        if (direcrPostNode != delNode.rightChild) { //从树中删除此直接后继节点\n            parentNode.leftChild = direcrPostNode.rightChild;\n            direcrPostNode.rightChild = null;\n        }\n        return direcrPostNode;\n\n    }\n\n    public void preOrder(Node rootNode) {\n        if (rootNode != null) {\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void inOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void postOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n        }\n    }\n}\n\n```\n## HashMap\n\n![HashMap](基本数据结构的简单Java实现/HashMap.png)","source":"_posts/基本数据结构的简单Java实现.md","raw":"---\ntitle: 基本数据结构的简单Java实现\ndate: 2019-03-16 22:08:55\ntags:\n- Java\n- 数据结构\ncategories:\n- Java\n---\n\n## 引言\nJDK 中提供了很多数据结构，如下所示\n> Collection\n> ├ List\n> │   ├ LinkedList\n> │   ├ ArrayList\n> │   └ Vector\n> │　    └Stack\n> └ Set\n>\n> Map\n> ├ Hashtable\n> ├ HashMap\n> └ WeakHashMap\n\n本文将进行部分数据结构的简单实现。\n\n<!--more-->\n\n## Stack\n```Java\npublic class MyStack<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int nowSize = 0;\n\n    public MyStack() {\n        this(10);\n    }\n\n    public MyStack(int initialCapacity) {\n        maxSize = initialCapacity;\n        dataArray = new Object[maxSize];\n    }\n\n    public void push(T data) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        dataArray[nowSize++] = data;\n    }\n\n    public T pop() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[--nowSize];\n    }\n\n    public T peek() {\n        if (empty()) {\n            return null;\n        }\n        return (T)dataArray[nowSize-1];\n    }\n\n    public int search(T target) {\n        int p = nowSize;\n        while (p >= 0) {\n            if (dataArray[p] == target) {\n                return p;\n            }\n            p--;\n        }\n        return -1;\n    }\n\n    private void resize() {\n        maxSize = maxSize << 1;\n        Object[] newArray = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            newArray[i] = dataArray[i];\n        }\n        this.dataArray = newArray;\n    }\n\n    public int size() {\n        return nowSize;\n    }\n\n    public boolean empty() {\n        return nowSize == 0 ? true : false;\n    }\n}\n```\n## Queue\n```Java\npublic class MyQueue<T> {\n\n    private Object[] dataArray;\n    private int maxSize;\n    private int front;\n    private int rear;\n\n    public MyQueue() {\n        this(10);\n    }\n\n    public MyQueue(int initialSize) {\n        maxSize = initialSize;\n        dataArray = new Object[maxSize];\n        front = rear = 0;\n    }\n\n    public void enqueue(T newData) {\n        if (size() >= maxSize) {\n            resize();\n        }\n        //非循环队列\n        dataArray[rear++] = newData;\n        \n        //循环队列\n        //dataArray[rear] = newData;\n        //rear = (rear+1) % maxSize;\n    }\n\n    public T dequeue() {\n        if (empty()) {\n            return null;\n        }\n        T value = (T)dataArray[front];\n        //非循环队列\n        dataArray[front++] = null;\n        \n        //循环队列\n        //dataArray[front] = null;\n        //front = (front+1) % maxSize;\n        \n        return value;\n    }\n\n    public void resize() {\n        maxSize = maxSize << 1;\n        Object[] temp = new Object[maxSize];\n        for (int i = 0; i < dataArray.length; i++) {\n            temp[i] = dataArray[i];\n        }\n        dataArray = temp;\n    }\n\n    public int size() {\n        return Math.abs(front - rear);\n    }\n\n    public boolean empty() {\n        return front == rear ? true : false;\n    }\n}\n```\n\n## BinaryTree\n\n![二叉搜索树](基本数据结构的简单Java实现/二叉搜索树.png)\n\n```Java\npublic class MyBinaryTree<T> {\n\n    private Node root;\n\n    class Node {\n        private int key;\n        private T value;\n        private Node leftChild;\n        private Node rightChild;\n\n        public Node(int key, T value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    public Node find(int key) {\n        Node currentNode = root;\n        while (currentNode != null && currentNode.key != key) {\n            if (key < currentNode.leftChild.key) {\n                currentNode = currentNode.leftChild;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        return currentNode;\n    }\n\n    public void insert(int key, T value) {\n        if (root == null) {\n            root = new Node(key, value);\n            return;\n        }\n        Node currentNode = root;\n        Node parentNode = root;\n        Boolean isLeftChild = true;\n\n        while (currentNode != null) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n            }\n        }\n        Node newNode = new Node(key, value);\n        if (isLeftChild) {\n            parentNode.leftChild = newNode;\n        } else {\n            parentNode.rightChild = newNode;\n        }\n    }\n\n    public boolean delete(int key) {\n        Node currentNode = root;    //待删除节点\n        Node parentNode = root;     //待删除节点的父节点\n        Boolean isLeftChild = true;\n        while (currentNode != null && currentNode.key != key) {\n            parentNode = currentNode;\n            if (key < currentNode.key) {\n                currentNode = currentNode.leftChild;\n                isLeftChild = true;\n            } else {\n                currentNode = currentNode.rightChild;\n                isLeftChild = false;\n            }\n        }\n        if (currentNode == null) {\n            return false;\n        }\n        //删除节点为叶子节点\n        if (currentNode.leftChild == null && currentNode.rightChild == null) {\n            if (currentNode == root) {\n                root = null;\n            } else if (isLeftChild) {\n                parentNode.leftChild = null;\n            } else {\n                parentNode.rightChild = null;\n            }\n        } else if (currentNode.rightChild == null) {    //待删除节点只有左子节点\n            if (currentNode == root) {\n                root = currentNode.leftChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.leftChild;\n            } else {\n                parentNode.rightChild = currentNode.leftChild;\n            }\n        } else if (currentNode.leftChild == null) {    //待删除节点只有右子节点\n            if (currentNode == root) {\n                root = currentNode.rightChild;\n            } else if (isLeftChild) {\n                parentNode.leftChild = currentNode.rightChild;\n            } else {\n                parentNode.rightChild = currentNode.rightChild;\n            }\n        } else {    //待删除节点既有左子节点又有右子节点\n            Node directPostNode = getDirectPostNode(currentNode);\n            currentNode.key = directPostNode.key;\n            currentNode.value = directPostNode.value;\n        }\n        return true;\n    }\n\n    /**\n     * 获得待删除节点的直接后继节点\n     *\n     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点\n     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点\n     * 并删除 key 值为 10 的节点的中序后继节点，\n     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，\n     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子\n     *\n     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），\n     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值\n     *\n     * @param delNode 待删除节点\n     * @return 返回直接后继节点\n     */\n    private Node getDirectPostNode(Node delNode) {\n        Node parentNode = delNode;  //保存待删除节点的直接后继节点的父节点\n        Node direcrPostNode = delNode;  //保存待删除节点的直接后继节点\n        Node currentNode = delNode.rightChild;\n\n        while (currentNode != null) {\n            parentNode = direcrPostNode;\n            direcrPostNode = currentNode;\n            currentNode = currentNode.leftChild;\n        }\n        if (direcrPostNode != delNode.rightChild) { //从树中删除此直接后继节点\n            parentNode.leftChild = direcrPostNode.rightChild;\n            direcrPostNode.rightChild = null;\n        }\n        return direcrPostNode;\n\n    }\n\n    public void preOrder(Node rootNode) {\n        if (rootNode != null) {\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void inOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n            preOrder(rootNode.rightChild);\n        }\n    }\n\n    public void postOrder(Node rootNode) {\n        if (rootNode != null) {\n            preOrder(rootNode.leftChild);\n            preOrder(rootNode.rightChild);\n            System.out.println(rootNode.key + \": \" + rootNode.value);\n        }\n    }\n}\n\n```\n## HashMap\n\n![HashMap](基本数据结构的简单Java实现/HashMap.png)","slug":"基本数据结构的简单Java实现","published":1,"updated":"2019-03-16T14:40:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavcd0022i0upu48f4bpx","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>JDK 中提供了很多数据结构，如下所示</p>\n<blockquote>\n<p>Collection<br>├ List<br>│   ├ LinkedList<br>│   ├ ArrayList<br>│   └ Vector<br>│　    └Stack<br>└ Set</p>\n<p>Map<br>├ Hashtable<br>├ HashMap<br>└ WeakHashMap</p>\n</blockquote>\n<p>本文将进行部分数据结构的简单实现。</p>\n<a id=\"more\"></a>\n<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nowSize = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        maxSize = initialCapacity;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(T data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() &gt;= maxSize) &#123;</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dataArray[nowSize++] = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[--nowSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[nowSize-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(T target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = nowSize;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dataArray[p] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        maxSize = maxSize &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] newArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dataArray.length; i++) &#123;</span><br><span class=\"line\">            newArray[i] = dataArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataArray = newArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize == <span class=\"number\">0</span> ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> front;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rear;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialSize)</span> </span>&#123;</span><br><span class=\"line\">        maxSize = initialSize;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        front = rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(T newData)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() &gt;= maxSize) &#123;</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[rear++] = newData;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[rear] = newData;</span></span><br><span class=\"line\">        <span class=\"comment\">//rear = (rear+1) % maxSize;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        T value = (T)dataArray[front];</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[front++] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[front] = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//front = (front+1) % maxSize;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        maxSize = maxSize &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] temp = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dataArray.length; i++) &#123;</span><br><span class=\"line\">            temp[i] = dataArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dataArray = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.abs(front - rear);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> front == rear ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BinaryTree\"><a href=\"#BinaryTree\" class=\"headerlink\" title=\"BinaryTree\"></a>BinaryTree</h2><p><img src=\"/基本数据结构的简单Java实现/二叉搜索树.png\" alt=\"二叉搜索树\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBinaryTree</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> T value;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> &amp;&amp; currentNode.key != key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.leftChild.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        Node parentNode = root;</span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node newNode = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">            parentNode.leftChild = newNode;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            parentNode.rightChild = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        Node currentNode = root;    <span class=\"comment\">//待删除节点</span></span><br><span class=\"line\">        Node parentNode = root;     <span class=\"comment\">//待删除节点的父节点</span></span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> &amp;&amp; currentNode.key != key) &#123;</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//删除节点为叶子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span> &amp;&amp; currentNode.rightChild == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.rightChild == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">//待删除节点只有左子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = currentNode.leftChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">//待删除节点只有右子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = currentNode.rightChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = currentNode.rightChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">//待删除节点既有左子节点又有右子节点</span></span><br><span class=\"line\">            Node directPostNode = getDirectPostNode(currentNode);</span><br><span class=\"line\">            currentNode.key = directPostNode.key;</span><br><span class=\"line\">            currentNode.value = directPostNode.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得待删除节点的直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除 key 值为 10 的节点的中序后继节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delNode 待删除节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">getDirectPostNode</span><span class=\"params\">(Node delNode)</span> </span>&#123;</span><br><span class=\"line\">        Node parentNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点的父节点</span></span><br><span class=\"line\">        Node direcrPostNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点</span></span><br><span class=\"line\">        Node currentNode = delNode.rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentNode = direcrPostNode;</span><br><span class=\"line\">            direcrPostNode = currentNode;</span><br><span class=\"line\">            currentNode = currentNode.leftChild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (direcrPostNode != delNode.rightChild) &#123; <span class=\"comment\">//从树中删除此直接后继节点</span></span><br><span class=\"line\">            parentNode.leftChild = direcrPostNode.rightChild;</span><br><span class=\"line\">            direcrPostNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> direcrPostNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><img src=\"/基本数据结构的简单Java实现/HashMap.png\" alt=\"HashMap\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>JDK 中提供了很多数据结构，如下所示</p>\n<blockquote>\n<p>Collection<br>├ List<br>│   ├ LinkedList<br>│   ├ ArrayList<br>│   └ Vector<br>│　    └Stack<br>└ Set</p>\n<p>Map<br>├ Hashtable<br>├ HashMap<br>└ WeakHashMap</p>\n</blockquote>\n<p>本文将进行部分数据结构的简单实现。</p>","more":"<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nowSize = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        maxSize = initialCapacity;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(T data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() &gt;= maxSize) &#123;</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dataArray[nowSize++] = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[--nowSize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)dataArray[nowSize-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(T target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = nowSize;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dataArray[p] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        maxSize = maxSize &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] newArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dataArray.length; i++) &#123;</span><br><span class=\"line\">            newArray[i] = dataArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataArray = newArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nowSize == <span class=\"number\">0</span> ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] dataArray;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> front;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rear;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialSize)</span> </span>&#123;</span><br><span class=\"line\">        maxSize = initialSize;</span><br><span class=\"line\">        dataArray = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        front = rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(T newData)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size() &gt;= maxSize) &#123;</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[rear++] = newData;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[rear] = newData;</span></span><br><span class=\"line\">        <span class=\"comment\">//rear = (rear+1) % maxSize;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        T value = (T)dataArray[front];</span><br><span class=\"line\">        <span class=\"comment\">//非循环队列</span></span><br><span class=\"line\">        dataArray[front++] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//循环队列</span></span><br><span class=\"line\">        <span class=\"comment\">//dataArray[front] = null;</span></span><br><span class=\"line\">        <span class=\"comment\">//front = (front+1) % maxSize;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        maxSize = maxSize &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object[] temp = <span class=\"keyword\">new</span> Object[maxSize];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dataArray.length; i++) &#123;</span><br><span class=\"line\">            temp[i] = dataArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dataArray = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.abs(front - rear);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> front == rear ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BinaryTree\"><a href=\"#BinaryTree\" class=\"headerlink\" title=\"BinaryTree\"></a>BinaryTree</h2><p><img src=\"/基本数据结构的简单Java实现/二叉搜索树.png\" alt=\"二叉搜索树\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBinaryTree</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> T value;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node leftChild;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Node rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> &amp;&amp; currentNode.key != key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.leftChild.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> key, T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node currentNode = root;</span><br><span class=\"line\">        Node parentNode = root;</span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node newNode = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">            parentNode.leftChild = newNode;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            parentNode.rightChild = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        Node currentNode = root;    <span class=\"comment\">//待删除节点</span></span><br><span class=\"line\">        Node parentNode = root;     <span class=\"comment\">//待删除节点的父节点</span></span><br><span class=\"line\">        Boolean isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span> &amp;&amp; currentNode.key != key) &#123;</span><br><span class=\"line\">            parentNode = currentNode;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; currentNode.key) &#123;</span><br><span class=\"line\">                currentNode = currentNode.leftChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                currentNode = currentNode.rightChild;</span><br><span class=\"line\">                isLeftChild = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//删除节点为叶子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span> &amp;&amp; currentNode.rightChild == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.rightChild == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">//待删除节点只有左子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = currentNode.leftChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = currentNode.leftChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currentNode.leftChild == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">//待删除节点只有右子节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode == root) &#123;</span><br><span class=\"line\">                root = currentNode.rightChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLeftChild) &#123;</span><br><span class=\"line\">                parentNode.leftChild = currentNode.rightChild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                parentNode.rightChild = currentNode.rightChild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">//待删除节点既有左子节点又有右子节点</span></span><br><span class=\"line\">            Node directPostNode = getDirectPostNode(currentNode);</span><br><span class=\"line\">            currentNode.key = directPostNode.key;</span><br><span class=\"line\">            currentNode.value = directPostNode.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得待删除节点的直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 当待删除节点既有左孩子，又有右孩子时，例如删除图一中 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 这时就需要用 key 值为 10 的节点的中序后继节点（节点 11）来代替 key 值为 10 的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除 key 值为 10 的节点的中序后继节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 由中序遍历相关规则可知， key 值为 10 的节点的直接中序后继节点一定是其右子树中 key 值最小的节点，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以此中序后继节点一定不含子节点或者只含有一个右孩子</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 首先找到 key 值为 10 的节点的直接中序后继节点（即其右子树中值最小的节点 11），</span></span><br><span class=\"line\"><span class=\"comment\">     * 并删除此直接中序后继节点，然后将此后继节点的 key、value 值赋给待删除节点的 key，value值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delNode 待删除节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回直接后继节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">getDirectPostNode</span><span class=\"params\">(Node delNode)</span> </span>&#123;</span><br><span class=\"line\">        Node parentNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点的父节点</span></span><br><span class=\"line\">        Node direcrPostNode = delNode;  <span class=\"comment\">//保存待删除节点的直接后继节点</span></span><br><span class=\"line\">        Node currentNode = delNode.rightChild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentNode = direcrPostNode;</span><br><span class=\"line\">            direcrPostNode = currentNode;</span><br><span class=\"line\">            currentNode = currentNode.leftChild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (direcrPostNode != delNode.rightChild) &#123; <span class=\"comment\">//从树中删除此直接后继节点</span></span><br><span class=\"line\">            parentNode.leftChild = direcrPostNode.rightChild;</span><br><span class=\"line\">            direcrPostNode.rightChild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> direcrPostNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrder</span><span class=\"params\">(Node rootNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            preOrder(rootNode.leftChild);</span><br><span class=\"line\">            preOrder(rootNode.rightChild);</span><br><span class=\"line\">            System.out.println(rootNode.key + <span class=\"string\">\": \"</span> + rootNode.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><img src=\"/基本数据结构的简单Java实现/HashMap.png\" alt=\"HashMap\"></p>"},{"title":"翻越GFW记","date":"2019-01-12T15:31:31.000Z","_content":"\n## 前言\nGFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录`GFW`所为何物，以及`翻`的原理。<!--more-->\n## GFW\n\n### 所为何物\nGFW：Great Firewall (of the People's Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 \n\n\n形象的描述，在没有 GFW 的时代，访问互联网的方式如下\n\n![原始连接方式](翻越GFW记/原始连接方式.png)\n\nGFW 出现之后，则变成\n\n![GFW存在后的连接方式](翻越GFW记/GFW存在后的连接方式.png)\n\n其内部构造如下\n\n![翻越GFW记/GFW内部结构](翻越GFW记/GFW内部结构.jpg)\n\n它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。\n\nGFW的具体原理可以查看此文章：[全面学习GFW](https://cokebar.info/archives/253)\n\n### 如何工作\n#### 关键字过滤阻断\n关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。\n\n#### IP地址封锁\n路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br> \nGFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。\n\n#### DNS污染、劫持\nDNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br>\n\nDNS劫持和污染的方式有两种： \n\n- 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 \n- 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。\n\n值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：[中国防火长城-污染攻击大事记](https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记)。 \n\n**除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。**\n\n## 翻越记\n\n### 翻\n\n#### 修改Hosts文件\n足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。\n\nHosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。\n\n所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。\n\n#### SSH Tunnel\nSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br>\n\n![SSH连接方式](翻越GFW记/SSH连接方式.png)\n1. 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)\n2. 用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)\n3. 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)\n\n由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。\n\n#### VPN\n对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。\n\nVPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。\n\nVPN 的特点如下：\n- VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。\n- 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。\n- VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。\n\n#### Shadowsocks\nVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。\n\n技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下\n\n![SS连接方式](翻越GFW记/SS连接方式.png)\n\n- 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题\n- 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密\n- 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。\n\n相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。\n\n##### Shadowsocks-R\n虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。\n\n作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。\n\n##### V2Ray\nV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。\n\n### 记\n\n- 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。\n- 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。\n- 2004年，维基百科遭遇网络封锁，至今未解封。\n- 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。\n- 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。\n- 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。\n- 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。\n- 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。\n\n## 结语\n从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。\n\n翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。\n\n本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。","source":"_posts/翻越GFW记.md","raw":"---\ntitle: 翻越GFW记\ndate: 2019-01-12 23:31:31\ntags:\n- 翻墙\n- 互联网\ncategories:\n- 互联网\n---\n\n## 前言\nGFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录`GFW`所为何物，以及`翻`的原理。<!--more-->\n## GFW\n\n### 所为何物\nGFW：Great Firewall (of the People's Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 \n\n\n形象的描述，在没有 GFW 的时代，访问互联网的方式如下\n\n![原始连接方式](翻越GFW记/原始连接方式.png)\n\nGFW 出现之后，则变成\n\n![GFW存在后的连接方式](翻越GFW记/GFW存在后的连接方式.png)\n\n其内部构造如下\n\n![翻越GFW记/GFW内部结构](翻越GFW记/GFW内部结构.jpg)\n\n它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。\n\nGFW的具体原理可以查看此文章：[全面学习GFW](https://cokebar.info/archives/253)\n\n### 如何工作\n#### 关键字过滤阻断\n关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送 RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。\n\n#### IP地址封锁\n路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br> \nGFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。\n\n#### DNS污染、劫持\nDNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br>\n\nDNS劫持和污染的方式有两种： \n\n- 一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 \n- 另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。\n\n值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：[中国防火长城-污染攻击大事记](https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记)。 \n\n**除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。**\n\n## 翻越记\n\n### 翻\n\n#### 修改Hosts文件\n足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。\n\nHosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。\n\n所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。\n\n#### SSH Tunnel\nSSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br>\n\n![SSH连接方式](翻越GFW记/SSH连接方式.png)\n1. 首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)\n2. 用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)\n3. 服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)\n\n由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。\n\n#### VPN\n对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。\n\nVPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。\n\nVPN 的特点如下：\n- VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。\n- 商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。\n- VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。\n\n#### Shadowsocks\nVPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。\n\n技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下\n\n![SS连接方式](翻越GFW记/SS连接方式.png)\n\n- 1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题\n- 2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密\n- 3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。\n\n相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。\n\n##### Shadowsocks-R\n虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。\n\n作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。\n\n##### V2Ray\nV2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。\n\n### 记\n\n- 1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。\n- 2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。\n- 2004年，维基百科遭遇网络封锁，至今未解封。\n- 2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。\n- 2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。\n- 2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。\n- 2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。\n- 2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。\n\n## 结语\n从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。\n\n翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。\n\n本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。","slug":"翻越GFW记","published":1,"updated":"2019-03-15T15:25:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavcf0026i0uptkf9ruyy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录<code>GFW</code>所为何物，以及<code>翻</code>的原理。<a id=\"more\"></a></p>\n<h2 id=\"GFW\"><a href=\"#GFW\" class=\"headerlink\" title=\"GFW\"></a>GFW</h2><h3 id=\"所为何物\"><a href=\"#所为何物\" class=\"headerlink\" title=\"所为何物\"></a>所为何物</h3><p>GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 </p>\n<p>形象的描述，在没有 GFW 的时代，访问互联网的方式如下</p>\n<p><img src=\"/翻越GFW记/原始连接方式.png\" alt=\"原始连接方式\"></p>\n<p>GFW 出现之后，则变成</p>\n<p><img src=\"/翻越GFW记/GFW存在后的连接方式.png\" alt=\"GFW存在后的连接方式\"></p>\n<p>其内部构造如下</p>\n<p><img src=\"/翻越GFW记/GFW内部结构.jpg\" alt=\"翻越GFW记/GFW内部结构\"></p>\n<p>它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。</p>\n<p>GFW的具体原理可以查看此文章：<a href=\"https://cokebar.info/archives/253\" target=\"_blank\" rel=\"noopener\">全面学习GFW</a></p>\n<h3 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h3><h4 id=\"关键字过滤阻断\"><a href=\"#关键字过滤阻断\" class=\"headerlink\" title=\"关键字过滤阻断\"></a>关键字过滤阻断</h4><p>关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: <a href=\"http://www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送\" target=\"_blank\" rel=\"noopener\">www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送</a> RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。</p>\n<h4 id=\"IP地址封锁\"><a href=\"#IP地址封锁\" class=\"headerlink\" title=\"IP地址封锁\"></a>IP地址封锁</h4><p>路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br><br>GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。</p>\n<h4 id=\"DNS污染、劫持\"><a href=\"#DNS污染、劫持\" class=\"headerlink\" title=\"DNS污染、劫持\"></a>DNS污染、劫持</h4><p>DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br></p>\n<p>DNS劫持和污染的方式有两种： </p>\n<ul>\n<li>一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 </li>\n<li>另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。</li>\n</ul>\n<p>值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记\" target=\"_blank\" rel=\"noopener\">中国防火长城-污染攻击大事记</a>。 </p>\n<p><strong>除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。</strong></p>\n<h2 id=\"翻越记\"><a href=\"#翻越记\" class=\"headerlink\" title=\"翻越记\"></a>翻越记</h2><h3 id=\"翻\"><a href=\"#翻\" class=\"headerlink\" title=\"翻\"></a>翻</h3><h4 id=\"修改Hosts文件\"><a href=\"#修改Hosts文件\" class=\"headerlink\" title=\"修改Hosts文件\"></a>修改Hosts文件</h4><p>足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。</p>\n<p>Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。</p>\n<p>所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。</p>\n<h4 id=\"SSH-Tunnel\"><a href=\"#SSH-Tunnel\" class=\"headerlink\" title=\"SSH Tunnel\"></a>SSH Tunnel</h4><p>SSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br></p>\n<p><img src=\"/翻越GFW记/SSH连接方式.png\" alt=\"SSH连接方式\"></p>\n<ol>\n<li>首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)</li>\n<li>用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)</li>\n<li>服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)</li>\n</ol>\n<p>由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。</p>\n<h4 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h4><p>对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。</p>\n<p>VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。</p>\n<p>VPN 的特点如下：</p>\n<ul>\n<li>VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。</li>\n<li>商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。</li>\n<li>VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。</li>\n</ul>\n<h4 id=\"Shadowsocks\"><a href=\"#Shadowsocks\" class=\"headerlink\" title=\"Shadowsocks\"></a>Shadowsocks</h4><p>VPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。</p>\n<p>技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下</p>\n<p><img src=\"/翻越GFW记/SS连接方式.png\" alt=\"SS连接方式\"></p>\n<ul>\n<li>1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题</li>\n<li>2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密</li>\n<li>3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。</li>\n</ul>\n<p>相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。</p>\n<h5 id=\"Shadowsocks-R\"><a href=\"#Shadowsocks-R\" class=\"headerlink\" title=\"Shadowsocks-R\"></a>Shadowsocks-R</h5><p>虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。</p>\n<p>作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。</p>\n<h5 id=\"V2Ray\"><a href=\"#V2Ray\" class=\"headerlink\" title=\"V2Ray\"></a>V2Ray</h5><p>V2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。</p>\n<h3 id=\"记\"><a href=\"#记\" class=\"headerlink\" title=\"记\"></a>记</h3><ul>\n<li>1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。</li>\n<li>2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。</li>\n<li>2004年，维基百科遭遇网络封锁，至今未解封。</li>\n<li>2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。</li>\n<li>2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。</li>\n<li>2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。</li>\n<li>2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。</li>\n<li>2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。</p>\n<p>翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。</p>\n<p>本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>GFW是中国互联网上独特而不可忽视的存在，很多人在生活中都主动地搭建翻墙工具或者使用翻墙服务，以此访问“不存在的网站”。本文将记录<code>GFW</code>所为何物，以及<code>翻</code>的原理。</p>","more":"<p></p>\n<h2 id=\"GFW\"><a href=\"#GFW\" class=\"headerlink\" title=\"GFW\"></a>GFW</h2><h3 id=\"所为何物\"><a href=\"#所为何物\" class=\"headerlink\" title=\"所为何物\"></a>所为何物</h3><p>GFW：Great Firewall (of the People’s Republic of China)，中国国家防火墙，由于谐音the Great Wall，所以也称长城防火墙，是中国政府在其互联网边界的审查系统（包括相关行政审查系统），具体指监控和过滤互联网内容的软硬件系统，由服务器和路由器等设备、相关的应用程序构成。 </p>\n<p>形象的描述，在没有 GFW 的时代，访问互联网的方式如下</p>\n<p><img src=\"/翻越GFW记/原始连接方式.png\" alt=\"原始连接方式\"></p>\n<p>GFW 出现之后，则变成</p>\n<p><img src=\"/翻越GFW记/GFW存在后的连接方式.png\" alt=\"GFW存在后的连接方式\"></p>\n<p>其内部构造如下</p>\n<p><img src=\"/翻越GFW记/GFW内部结构.jpg\" alt=\"翻越GFW记/GFW内部结构\"></p>\n<p>它变成了本地浏览器和网站服务器之间的一道墙，阻拦了访问特定网站的请求，实际上，GFW 的拦截方式是多样的。</p>\n<p>GFW的具体原理可以查看此文章：<a href=\"https://cokebar.info/archives/253\" target=\"_blank\" rel=\"noopener\">全面学习GFW</a></p>\n<h3 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h3><h4 id=\"关键字过滤阻断\"><a href=\"#关键字过滤阻断\" class=\"headerlink\" title=\"关键字过滤阻断\"></a>关键字过滤阻断</h4><p>关键字过滤系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对 HTTP 的默认端口：80端口，因为 HTTP 传播的内容是明文的内容，没有经过加密，而 GFW 是一个 IDS(Intrusion detection system)。普通的关键词如果出现在 HTTP 请求报文的头部(如“Host: <a href=\"http://www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送\" target=\"_blank\" rel=\"noopener\">www.youtube.com”)时，则会马上伪装成对方向连接两端的计算机发送</a> RST 包(reset)干扰两者正常的 TCP 连接，进而使请求的内容无法继续查看。<br>如果GFW在数据流中发现了特殊的内文关键词时，其也会试图打断当前的连接，从而出现用户的网页开启一部分后，突然停止的情况。</p>\n<h4 id=\"IP地址封锁\"><a href=\"#IP地址封锁\" class=\"headerlink\" title=\"IP地址封锁\"></a>IP地址封锁</h4><p>路由器的正常工作方式是：遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。<br><br>GFW 通过路由器，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往被屏蔽网站的IP数据包无法到达。此外，GFW 对于某些网站会采取独立IP封锁技术，如果该网站使用了由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，就会造成所有该服务提供商的其它使用相同IP地址服务器的网站用户遭殃，就算这些网站的内容可能并无不当之处，也不能在中国大陆正常访问。</p>\n<h4 id=\"DNS污染、劫持\"><a href=\"#DNS污染、劫持\" class=\"headerlink\" title=\"DNS污染、劫持\"></a>DNS污染、劫持</h4><p>DNS 污染是指 GFW 刻意制造出特定的域名服务器分组，把域名指往不正确的IP地址。对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。2002年被封锁期间，Google的域名就被劫持到百度上。 <br></p>\n<p>DNS劫持和污染的方式有两种： </p>\n<ul>\n<li>一种是通过网络服务提供商(Internet Service Provider)提供的 DNS 服务器进 DNS 欺骗，当访问某个网站时，需要要把域名转换为一个IP地址，DNS 服务器负责将域名转换为IP地址，中国大陆的 ISP 接受通信管理局的屏蔽网站的指令后在 DNS 服务器里加入某些特定域名的虚假记录，当使用此 DNS 服务器的网络用户访问此特定网站时，DNS 服务便给出虚假的IP地址，导致访问网站失败，甚至返回 ISP 运营商提供的出错页面和广告页面。 </li>\n<li>另一种是 GFW 在 DNS 查询使用的 UDP 的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP 53端口进行查询的 DNS 请求，就返回一个虚假的IP地址。</li>\n</ul>\n<p>值得一提的是，IPv4时代，全球一共有13组根域名服务器，中国大陆早期有F、I两个根域 DNS 镜像，但因为多次 DNS 污染国外网络，被断开与国际互联网的连接，相关事件查看维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#污染攻击大事记\" target=\"_blank\" rel=\"noopener\">中国防火长城-污染攻击大事记</a>。 </p>\n<p><strong>除了以上几种封锁方法，GFW还会采用SSL连接阻断、特定端口封锁等工作方式。</strong></p>\n<h2 id=\"翻越记\"><a href=\"#翻越记\" class=\"headerlink\" title=\"翻越记\"></a>翻越记</h2><h3 id=\"翻\"><a href=\"#翻\" class=\"headerlink\" title=\"翻\"></a>翻</h3><h4 id=\"修改Hosts文件\"><a href=\"#修改Hosts文件\" class=\"headerlink\" title=\"修改Hosts文件\"></a>修改Hosts文件</h4><p>足够简单的方式，以解决 GFW 的 DNS 污染和劫持的问题。Hosts 文件是一个储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址，通常用于补充或取代网络中DNS的功能。和DNS不同的是，用户可以直接对 Hosts 文件进行控制。</p>\n<p>Hosts 文件的原本目的是提高解析的效率。在进行 DNS 请求以前，系统先检查自己的 Hosts 文件中是否有地址映射关系，如果有则调用该IP地址映射，如果没有再向已知的 DNS 服务器提出域名解析。由于 Hosts 的请求级别比DNS高，当 Hosts 文件里面有对应的IP时，客户端就会直接访问那个IP，而不必通过 DNS。各操作系统的 Hosts 文件各有不同，网络上有很多相关资料，在此不赘述。</p>\n<p>所以，将 Google、Twitter、Facebook 之类的IP放入 Hosts 文件，就可以不受 GFW 的 DNS  污染干扰。但由于 GFW 的IP封锁，大多数情况下，该方法很难有效。</p>\n<h4 id=\"SSH-Tunnel\"><a href=\"#SSH-Tunnel\" class=\"headerlink\" title=\"SSH Tunnel\"></a>SSH Tunnel</h4><p>SSH（Secure Shell）是一个提供数据通信安全、远程登录、远程指令执行等功能的安全网络协议。搭建一个 SSH 隧道翻墙，只需要有一台支持 SSH 的墙外服务器，且该服务器能 SSH 连接即可。<br></p>\n<p><img src=\"/翻越GFW记/SSH连接方式.png\" alt=\"SSH连接方式\"></p>\n<ol>\n<li>首先用户和境外服务器基于 SSH 建立起一条加密的通道 (1)</li>\n<li>用户通过建立起的隧道进行代理，通过 SSH  Server 向真实的服务发起请求 (2-3)</li>\n<li>服务通过 SSH Server，再通过创建好的隧道返回给用户 (4-5)</li>\n</ol>\n<p>由于 SSH 本身基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，SSH 本身的特征很明显，所以 GFW 一度通过分析连接的特征进行干扰，导致 SSH 存在被定向进行干扰的问题。</p>\n<h4 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h4><p>对于企业来说，为了共享资源、协同工作，需要连接各地的分支机构，传统的专线联网方式价格昂贵，一般中小企业难以负担。这时低成本的VPN技术孕育而生。VPN（Virtual Private Network）即虚拟专用网络，利用廉价接入的公共网络（主要使用Inter-net）来传输私有数据，具有成本优势，因此被很多企业和电信运营商采用。</p>\n<p>VPN 比Shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发——网络代理的实现思路大都如此。</p>\n<p>VPN 的特点如下：</p>\n<ul>\n<li>VPN 的设置是全局的，即所有联网程序都自动使用VPN；但SSH隧道需要程序设定，才会使用隧道联网。</li>\n<li>商用的VPN一般都是付费的，而自主搭建VPN 的难度要大于SSH隧道，因为SSH隧道只要一台可以SSH的服务器即可，不需要在服务器上配置任何东西。</li>\n<li>VPN 在IP层工作，而Shadowsocks在 TCP/UDP 层工作。</li>\n</ul>\n<h4 id=\"Shadowsocks\"><a href=\"#Shadowsocks\" class=\"headerlink\" title=\"Shadowsocks\"></a>Shadowsocks</h4><p>VPN之类的技术，有一个致命的缺陷：它们虽然通过了无法破解的RSA加密算法来对数据进行加密，但是在交换密钥、建立起隧道前仍在进行明文传输，GFW正是利用这一点，在交换秘钥的过程中暴力破解，这意味着接下来的加密没有任何意义。Shadowsocks所做的一点，就是提前规定好加密方式，解决 GFW 通过分析流量特征进行干扰的问题。</p>\n<p>技术原理上，Shadowsocks 是将原来 SSH 创建的 Socks5 协议拆开成 Server 端和 Client 端，其工作过程如下</p>\n<p><img src=\"/翻越GFW记/SS连接方式.png\" alt=\"SS连接方式\"></p>\n<ul>\n<li>1)、6) 客户端发出的请求基于 Socks5 协议跟 SS Local 端进行通讯，由于这个 SS Local 一般是本机或路由器或局域网的其他机器，不经过 GFW，解决了被 GFW 通过特征分析进行干扰的问题</li>\n<li>2)、5) SS Local 和 SS Server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密</li>\n<li>3)、4) SS Server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回。</li>\n</ul>\n<p>相比传统的 VPN (IKE, IPSec, PPTP…)，Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，可以拥有相对传统VPN更快的速度和更高的稳定性；而对比 V2Ray 这种科学上网的集合体，Shadowsocks在服务端更加轻量，单一协议完善程度更高；同时，Shadowsocks在移动端有更丰富的客户端选择，兼容性和灵活性更优。</p>\n<h5 id=\"Shadowsocks-R\"><a href=\"#Shadowsocks-R\" class=\"headerlink\" title=\"Shadowsocks-R\"></a>Shadowsocks-R</h5><p>虽说Shadowsocks“抹除了流量特征”，但从另一个角度看，其实它的特征也很明显：TCP/UDP上层的包全是密文，几乎和VPN没有区别。为解决这一问题，出现了Shadowsocks-R，它的其中一个特性，是在原 Shadowsocks 协议的数据流前面加上HTTP头，让GFW误认为是HTTP协议，从而对数据流应用针对HTTP的规则。</p>\n<p>作为SS的一个发展分支，由于SSR的作者一开始未将其开源（违反了 GPL 协议），所以实际上两者早期有不可调和的分歧。SSR拥有更多的功能，支持更多的加密方式，此外SSR还可以利用运营商的漏洞，开启免流服务，不过这是另一个问题了。</p>\n<h5 id=\"V2Ray\"><a href=\"#V2Ray\" class=\"headerlink\" title=\"V2Ray\"></a>V2Ray</h5><p>V2Ray 的实现原理跟Shadowsocks一脉相承，其特点在于引入新的通信协议，改正 Shadowsocks已有的缺点，使流量特征更难被 GFW 检测到；同时使用 UDP 作为下层协议，避免 TCP 带来的窗口和 RTO(Retry Timeout)等导致网速变慢的问题。</p>\n<h3 id=\"记\"><a href=\"#记\" class=\"headerlink\" title=\"记\"></a>记</h3><ul>\n<li>1998年，公安部开展”金盾工程”建设。次年，方滨兴调任国家计算机网络与信息安全管理中心副总工程师。</li>\n<li>2002年，Google经历多次封锁与解封，主要手段为DNS劫持、TCP会话阻断等。</li>\n<li>2004年，维基百科遭遇网络封锁，至今未解封。</li>\n<li>2008年，北京奥运会期间，中国政府短暂放宽GFW的封锁范围。</li>\n<li>2010年，Google因内容审查问题与中国政府交涉无效后，退出中国。</li>\n<li>2013年，GFW利用域名污染和关键词过滤等手段屏蔽GitHub，几天后被解封。</li>\n<li>2015年，Shadowsocks作者 @clowwindy遭遇公安机关调查，随后删除代码，不再参与开发。</li>\n<li>2017年，Shadowsocks-R作者 @BreakWa11被人肉和人身威胁，随后删除所有项目代码。</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>从二十年前“金盾工程”至今，中国的互联网管制未曾松动，在可预见的未来，应该也不会有所放缓。GFW经过十几年的发展，已经足够成熟，同时对于翻墙这一行为，执政党的治理侧重点也有从技术手段转向行政手段的趋势，每年，个人因为翻墙或者出售翻墙服务而被逮捕的时间屡屡见诸报端。</p>\n<p>翻墙技术和GFW每天都在上演道高一尺魔高一丈的戏码，两者的斗争更进一步，可能是人工智能在GFW上的深度部署，或者IPv6的全面普及。</p>\n<p>本文的绝大多数资料和图片均来自互联网，避免累赘，不再添加引用说明。</p>"},{"title":"Android IPC 机制详解","date":"2019-02-23T11:12:35.000Z","_content":"\n## 引言\nIPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。<!--more-->\n\n## 应用场景\n只有在多进程场景下才需要 IPC 机制。\n\n多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。\n\n使用多进程会造成如下的问题：\n- 静态成员和单例模式完全失效\n- 线程同步机制完全失效\n- SharedPreferences 可靠性下降\n- Application 会多次创建\n\n对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。\n\n## 基础概念\n\n### Serializable 接口\nJava 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个`seriaVersionUID`即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。\n\n```Java\npublic class User implements Serializable {\n    private static final long seriaVersionUID = 519067123721295773L\n    ...\n}\n\n//序列化过程\nUser user = new User(\"name\", 18);\nObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"file.txt\"));\nout.writeObject(user);\nout.close\n\n//反序列化过程\nObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"file.txt\"));\nUser user = (User) in.readObject();\nin.close\n```\n使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。\n\nJava 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。\n\n### Parcelable 接口\nAndroid 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。\n\n其与 Serializable 的区别在于\n- Parcelable 使用更复杂，后者如上面的代码，足够简洁。\n- 使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。\n- 使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。\n\n标准写法如下\n```Java\npublic class User implements Parcelable {\n\n    private String name;\n    private int id;\n\n    protected User(Parcel in) {\n        name = in.readString();\n        id = in.readInt();\n    }\n\n    /*\n        实例化静态变量CREATOR\n        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法\n     */\n    public static final Creator<User> CREATOR = new Creator<User>() {\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(name);\n        dest.writeInt(id);\n    }\n}\n```\n\n通过 Intent 传递和获取数据\n```Java\n//传递\nUser user = new User(\"Name\", 18);\nIntent intent = new Intent();\nintent.putExtra(\"data\", user);\n\n//使用\nUser user = getIntent().getParcelableExtra(\"data\");\n```\n\n### Binder\nBinder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。\n\n- 从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。\n- 从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。\n\n更多关于 Binder：[图解Android - Binder 和 Service](https://www.cnblogs.com/samchen2009/p/3316001.html)\n\n## 实现方式\n\n### Bundle\nBundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。\n\n### 文件共享\n利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。\n\n缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。\n\n### Socket\nSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。\n\n### AIDL\n\n#### 概念\nAndroid Interface Definition Language，Android 接口定义语言。\n\n- 数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下\n\n  > Java 中的八种基本数据类型、String、CharSequence。<br>\n  >\n  > List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br>\n  >\n  > Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br>\n\n- 定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。\n\n  > in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。\n\n关于更多：[你真的理解AIDL中的in，out，inout么?](https://blog.csdn.net/luoyanglizi/article/details/51958091)\n\n- 两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。 \n  注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。\n\n#### 实现\n第一类 AIDL 文件：\n```Java\n// Book.aidl\n// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用\n// 注意：Book.aidl 与 Book.java的包名应当是一样的\npackage com.febers.aidldemo;\n\n//注意parcelable是小写\nparcelable Book;\n```\n\n> 自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 `writeToParcel`方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现`readFromParcel`方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。\n\n第二类 AIDL 文件：\n```Java\n// BookManager.aidl\npackage com.lypeer.ipcclient;\n//导入所需要使用的非默认支持数据类型的包\nimport com.febers.aidldemo.Book;\n\ninterface BookManager {\n\n    //所有的返回值前都不需要加任何东西，不管是什么数据类型\n    List<Book> getBooks();\n    Book getBook();\n    int getBookCount();\n\n    //传参时，Java基本数据类型、String 以及 CharSequence 之外的类型\n    //都需要在前面加上定向tag，具体加什么量需而定\n    void setBookPrice(in Book book , int price)\n    void setBookName(in Book book , String name)\n    void addBookIn(in Book book);\n    void addBookOut(out Book book);\n    void addBookInout(inout Book book);\n}\n```\n完成上面的步骤之后，`build`项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。\n\n服务端\n```Java\n\npublic class AIDLService extends Service {\n\n    public final String TAG = this.getClass().getSimpleName();\n\n    //包含Book对象的list\n    private List<Book> mBooks = new ArrayList<>();\n\n    //由AIDL文件生成的BookManager\n    private final BookManager.Stub mBookManager = new BookManager.Stub() {\n        @Override\n        public List<Book> getBooks() throws RemoteException {\n            synchronized (this) {\n                Log.e(TAG, \"invoking getBooks() method , now the list is : \" + mBooks.toString());\n                if (mBooks != null) {\n                    return mBooks;\n                }\n                return new ArrayList<>();\n            }\n        }\n\n        @Override\n        public void addBook(Book book) throws RemoteException {\n            synchronized (this) {\n                if (mBooks == null) {\n                    mBooks = new ArrayList<>();\n                }\n                if (book == null) {\n                    Log.e(TAG, \"Book is null in In\");\n                    book = new Book();\n                }\n                //尝试修改book的参数，主要是为了观察其到客户端的反馈\n                book.setPrice(2333);\n                if (!mBooks.contains(book)) {\n                    mBooks.add(book);\n                }\n                //打印mBooks列表，观察客户端传过来的值\n                Log.e(TAG, \"invoking addBooks() method , now the list is : \" + mBooks.toString());\n            }\n        }\n    };\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Book book = new Book();\n        book.setName(\"Android开发艺术探索\");\n        book.setPrice(28);\n        mBooks.add(book);   \n    }\n\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.e(getClass().getSimpleName(), String.format(\"on bind,intent = %s\", intent.toString()));\n        return mBookManager;\n    }\n}\n```\n\n客户端\n```Java\npublic class AIDLActivity extends AppCompatActivity {\n\n    //由AIDL文件生成的 Java 类\n    private BookManager mBookManager = null;\n\n    //标志当前与服务端连接状况的布尔值，false为未连接，true为连接中\n    private boolean mBound = false;\n\n    //包含Book对象的list\n    private List<Book> mBooks;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_aidl);\n    }\n\n    /**\n     * 按钮的点击事件，点击之后调用服务端的addBookIn方法\n     *\n     * @param view\n     */\n    public void addBook(View view) {\n        //如果与服务端的连接处于未连接状态，则尝试连接\n        if (!mBound) {\n            attemptToBindService();\n            Toast.makeText(this, \"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\", Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (mBookManager == null) return;\n\n        Book book = new Book();\n        book.setName(\"APP研发录In\");\n        book.setPrice(30);\n        try {\n            mBookManager.addBook(book);\n            Log.e(getLocalClassName(), book.toString());\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 尝试与服务端建立连接\n     */\n    private void attemptToBindService() {\n        Intent intent = new Intent();\n        intent.setAction(\"com.febers.aidl\");\n        intent.setPackage(\"com.febers.aidldemo\");\n        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        if (!mBound) {\n            attemptToBindService();\n        }\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (mBound) {\n            unbindService(mServiceConnection);\n            mBound = false;\n        }\n    }\n\n    private ServiceConnection mServiceConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            Log.e(getLocalClassName(), \"service connected\");\n            mBookManager = BookManager.Stub.asInterface(service);\n            mBound = true;\n\n            if (mBookManager != null) {\n                try {\n                    mBooks = mBookManager.getBooks();\n                    Log.e(getLocalClassName(), mBooks.toString());\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            Log.e(getLocalClassName(), \"service disconnected\");\n            mBound = false;\n        }\n    };\n}\n```\n当然不要忘记在 Manifest 文件中注册 Service。\n控制台显示信息如下：\n> //服务端的 log 信息<br>\n> 1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br>\n> 2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br>\n> 3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]\n\n> //客户端的 log 信息<br>\n> 1，service connected<br>\n> 2，[name : Android开发艺术探索 , price : 28]<br>\n> 3，name : APP研发录In , price : 2333\n\n### Messager\nMessager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。\n\n#### 概念\nMessenger 有两个构造函数，分贝以 Handler 和 Binder 为参数\n```Java\nprivate final IMessenger mTarget;\npublic Messenger(Handler target) {\n    mTarget = target.getIMessenger();\n}\npublic Messenger(IBinder target) {\n    mTarget = IMessenger.Stub.asInterface(target);    //和前面的 AIDL 很相似吧\n}\n```\n\n`Handler.getIMessenger`源码：\n```Java\nfinal IMessenger getIMessenger() {\n    synchronized (mQueue) {\n        if (mMessenger != null) {\n            return mMessenger;\n        }\n        mMessenger = new MessengerImpl();\n        return mMessenger;\n    }\n}\n```\nIMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法`send(android.os.Message msg)`。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：\n```Java\nprivate final class MessengerImpl extends IMessenger.Stub {\n    public void send(Message msg) {\n        msg.sendingUid = Binder.getCallingUid();\n        Handler.this.sendMessage(msg);\n    }\n}\n```\n所以可以使用`Handler.handlerMessage`接收消息。Messenger 中对`send`的实现如下：\n```Java\npublic void send(Message message) throws RemoteException {\n    mTarget.send(message);\n}\n```\nMessenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部`send`方法实际上是调用 IMessenger 实现的`send`方法。\n\nMessenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。\n\n#### 实现\n服务端\n```Java\npublic class MessengerService extends Service {\n\n    private final String TAG = this.getClass().getSimpleName();\n\n    Messenger mMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9527) {\n                if (msg.getData() == null) {\n                    return;\n                }\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");  //接收客户端的消息\n                Log.e(TAG, \"Message from client: \" + content);\n\n                //回复消息给客户端\n                Message replyMsg = Message.obtain();\n                replyMsg.arg1 = 9528;\n                Bundle bundle = new Bundle();\n                bundle.putString(\"MSG_CONTENT\", \"已收到消息\");\n                replyMsg.setData(bundle);\n\n                try {\n                    msg.replyTo.send(replyMsg);     //回信\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n\n    @Nullable\n    @Override\n    public IBinder onBind(final Intent intent) {\n        return mMessenger.getBinder();\n    }\n}\n\n```\n\n客户端代码片段\n```Java\npublic class MessagerActivity extends AppCompatActivity {\n\n    Messenger mClientMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9528){\n                if (msg.getData() == null){\n                    return;\n                }\n\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");\n                Log.e(TAG, \"Message from server: \" + content);\n            }\n        }\n    });\n\n    //服务端的 Messenger\n    private Messenger mServerMessenger;\n\n    private ServiceConnection mMessengerConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(final ComponentName name, final IBinder service) {\n            mServerMessenger = new Messenger(service);\n        }\n\n        @Override\n        public void onServiceDisconnected(final ComponentName name) {\n            mServerMessenger = null;\n        }\n    };\n    \n    //发送消息\n    public void sendMsg() {\n        String msgContent = \"消息\"；\n\n        Message message = Message.obtain();\n        message.arg1 = 9527;\n        Bundle bundle = new Bundle();\n        bundle.putString(\"MSG_CONTENT\", msgContent);\n        message.setData(bundle);\n        message.replyTo = mClientMessenger;     //指定回信人是客户端定义的\n\n        try {\n            mServerMessenger.send(message);\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### ContentProvider\n主要用于不同的应用程序之间实现数据共享功能","source":"_posts/Android-IPC-机制详解.md","raw":"---\ntitle: Android IPC 机制详解\ndate: 2019-02-23 19:12:35\ntags:\n- Android\n- 多进程通信\ncategories:\n- Android\n---\n\n## 引言\nIPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。<!--more-->\n\n## 应用场景\n只有在多进程场景下才需要 IPC 机制。\n\n多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。\n\n使用多进程会造成如下的问题：\n- 静态成员和单例模式完全失效\n- 线程同步机制完全失效\n- SharedPreferences 可靠性下降\n- Application 会多次创建\n\n对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。\n\n## 基础概念\n\n### Serializable 接口\nJava 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个`seriaVersionUID`即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。\n\n```Java\npublic class User implements Serializable {\n    private static final long seriaVersionUID = 519067123721295773L\n    ...\n}\n\n//序列化过程\nUser user = new User(\"name\", 18);\nObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"file.txt\"));\nout.writeObject(user);\nout.close\n\n//反序列化过程\nObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"file.txt\"));\nUser user = (User) in.readObject();\nin.close\n```\n使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。\n\nJava 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。\n\n### Parcelable 接口\nAndroid 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。\n\n其与 Serializable 的区别在于\n- Parcelable 使用更复杂，后者如上面的代码，足够简洁。\n- 使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。\n- 使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。\n\n标准写法如下\n```Java\npublic class User implements Parcelable {\n\n    private String name;\n    private int id;\n\n    protected User(Parcel in) {\n        name = in.readString();\n        id = in.readInt();\n    }\n\n    /*\n        实例化静态变量CREATOR\n        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法\n     */\n    public static final Creator<User> CREATOR = new Creator<User>() {\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(name);\n        dest.writeInt(id);\n    }\n}\n```\n\n通过 Intent 传递和获取数据\n```Java\n//传递\nUser user = new User(\"Name\", 18);\nIntent intent = new Intent();\nintent.putExtra(\"data\", user);\n\n//使用\nUser user = getIntent().getParcelableExtra(\"data\");\n```\n\n### Binder\nBinder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。\n\n- 从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。\n- 从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。\n\n更多关于 Binder：[图解Android - Binder 和 Service](https://www.cnblogs.com/samchen2009/p/3316001.html)\n\n## 实现方式\n\n### Bundle\nBundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。\n\n### 文件共享\n利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。\n\n缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。\n\n### Socket\nSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。\n\n### AIDL\n\n#### 概念\nAndroid Interface Definition Language，Android 接口定义语言。\n\n- 数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下\n\n  > Java 中的八种基本数据类型、String、CharSequence。<br>\n  >\n  > List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br>\n  >\n  > Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br>\n\n- 定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。\n\n  > in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。\n\n关于更多：[你真的理解AIDL中的in，out，inout么?](https://blog.csdn.net/luoyanglizi/article/details/51958091)\n\n- 两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。 \n  注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。\n\n#### 实现\n第一类 AIDL 文件：\n```Java\n// Book.aidl\n// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用\n// 注意：Book.aidl 与 Book.java的包名应当是一样的\npackage com.febers.aidldemo;\n\n//注意parcelable是小写\nparcelable Book;\n```\n\n> 自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 `writeToParcel`方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现`readFromParcel`方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。\n\n第二类 AIDL 文件：\n```Java\n// BookManager.aidl\npackage com.lypeer.ipcclient;\n//导入所需要使用的非默认支持数据类型的包\nimport com.febers.aidldemo.Book;\n\ninterface BookManager {\n\n    //所有的返回值前都不需要加任何东西，不管是什么数据类型\n    List<Book> getBooks();\n    Book getBook();\n    int getBookCount();\n\n    //传参时，Java基本数据类型、String 以及 CharSequence 之外的类型\n    //都需要在前面加上定向tag，具体加什么量需而定\n    void setBookPrice(in Book book , int price)\n    void setBookName(in Book book , String name)\n    void addBookIn(in Book book);\n    void addBookOut(out Book book);\n    void addBookInout(inout Book book);\n}\n```\n完成上面的步骤之后，`build`项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。\n\n服务端\n```Java\n\npublic class AIDLService extends Service {\n\n    public final String TAG = this.getClass().getSimpleName();\n\n    //包含Book对象的list\n    private List<Book> mBooks = new ArrayList<>();\n\n    //由AIDL文件生成的BookManager\n    private final BookManager.Stub mBookManager = new BookManager.Stub() {\n        @Override\n        public List<Book> getBooks() throws RemoteException {\n            synchronized (this) {\n                Log.e(TAG, \"invoking getBooks() method , now the list is : \" + mBooks.toString());\n                if (mBooks != null) {\n                    return mBooks;\n                }\n                return new ArrayList<>();\n            }\n        }\n\n        @Override\n        public void addBook(Book book) throws RemoteException {\n            synchronized (this) {\n                if (mBooks == null) {\n                    mBooks = new ArrayList<>();\n                }\n                if (book == null) {\n                    Log.e(TAG, \"Book is null in In\");\n                    book = new Book();\n                }\n                //尝试修改book的参数，主要是为了观察其到客户端的反馈\n                book.setPrice(2333);\n                if (!mBooks.contains(book)) {\n                    mBooks.add(book);\n                }\n                //打印mBooks列表，观察客户端传过来的值\n                Log.e(TAG, \"invoking addBooks() method , now the list is : \" + mBooks.toString());\n            }\n        }\n    };\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Book book = new Book();\n        book.setName(\"Android开发艺术探索\");\n        book.setPrice(28);\n        mBooks.add(book);   \n    }\n\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.e(getClass().getSimpleName(), String.format(\"on bind,intent = %s\", intent.toString()));\n        return mBookManager;\n    }\n}\n```\n\n客户端\n```Java\npublic class AIDLActivity extends AppCompatActivity {\n\n    //由AIDL文件生成的 Java 类\n    private BookManager mBookManager = null;\n\n    //标志当前与服务端连接状况的布尔值，false为未连接，true为连接中\n    private boolean mBound = false;\n\n    //包含Book对象的list\n    private List<Book> mBooks;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_aidl);\n    }\n\n    /**\n     * 按钮的点击事件，点击之后调用服务端的addBookIn方法\n     *\n     * @param view\n     */\n    public void addBook(View view) {\n        //如果与服务端的连接处于未连接状态，则尝试连接\n        if (!mBound) {\n            attemptToBindService();\n            Toast.makeText(this, \"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\", Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (mBookManager == null) return;\n\n        Book book = new Book();\n        book.setName(\"APP研发录In\");\n        book.setPrice(30);\n        try {\n            mBookManager.addBook(book);\n            Log.e(getLocalClassName(), book.toString());\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 尝试与服务端建立连接\n     */\n    private void attemptToBindService() {\n        Intent intent = new Intent();\n        intent.setAction(\"com.febers.aidl\");\n        intent.setPackage(\"com.febers.aidldemo\");\n        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        if (!mBound) {\n            attemptToBindService();\n        }\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (mBound) {\n            unbindService(mServiceConnection);\n            mBound = false;\n        }\n    }\n\n    private ServiceConnection mServiceConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            Log.e(getLocalClassName(), \"service connected\");\n            mBookManager = BookManager.Stub.asInterface(service);\n            mBound = true;\n\n            if (mBookManager != null) {\n                try {\n                    mBooks = mBookManager.getBooks();\n                    Log.e(getLocalClassName(), mBooks.toString());\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            Log.e(getLocalClassName(), \"service disconnected\");\n            mBound = false;\n        }\n    };\n}\n```\n当然不要忘记在 Manifest 文件中注册 Service。\n控制台显示信息如下：\n> //服务端的 log 信息<br>\n> 1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br>\n> 2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br>\n> 3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]\n\n> //客户端的 log 信息<br>\n> 1，service connected<br>\n> 2，[name : Android开发艺术探索 , price : 28]<br>\n> 3，name : APP研发录In , price : 2333\n\n### Messager\nMessager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。\n\n#### 概念\nMessenger 有两个构造函数，分贝以 Handler 和 Binder 为参数\n```Java\nprivate final IMessenger mTarget;\npublic Messenger(Handler target) {\n    mTarget = target.getIMessenger();\n}\npublic Messenger(IBinder target) {\n    mTarget = IMessenger.Stub.asInterface(target);    //和前面的 AIDL 很相似吧\n}\n```\n\n`Handler.getIMessenger`源码：\n```Java\nfinal IMessenger getIMessenger() {\n    synchronized (mQueue) {\n        if (mMessenger != null) {\n            return mMessenger;\n        }\n        mMessenger = new MessengerImpl();\n        return mMessenger;\n    }\n}\n```\nIMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法`send(android.os.Message msg)`。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：\n```Java\nprivate final class MessengerImpl extends IMessenger.Stub {\n    public void send(Message msg) {\n        msg.sendingUid = Binder.getCallingUid();\n        Handler.this.sendMessage(msg);\n    }\n}\n```\n所以可以使用`Handler.handlerMessage`接收消息。Messenger 中对`send`的实现如下：\n```Java\npublic void send(Message message) throws RemoteException {\n    mTarget.send(message);\n}\n```\nMessenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部`send`方法实际上是调用 IMessenger 实现的`send`方法。\n\nMessenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。\n\n#### 实现\n服务端\n```Java\npublic class MessengerService extends Service {\n\n    private final String TAG = this.getClass().getSimpleName();\n\n    Messenger mMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9527) {\n                if (msg.getData() == null) {\n                    return;\n                }\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");  //接收客户端的消息\n                Log.e(TAG, \"Message from client: \" + content);\n\n                //回复消息给客户端\n                Message replyMsg = Message.obtain();\n                replyMsg.arg1 = 9528;\n                Bundle bundle = new Bundle();\n                bundle.putString(\"MSG_CONTENT\", \"已收到消息\");\n                replyMsg.setData(bundle);\n\n                try {\n                    msg.replyTo.send(replyMsg);     //回信\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n\n    @Nullable\n    @Override\n    public IBinder onBind(final Intent intent) {\n        return mMessenger.getBinder();\n    }\n}\n\n```\n\n客户端代码片段\n```Java\npublic class MessagerActivity extends AppCompatActivity {\n\n    Messenger mClientMessenger = new Messenger(new Handler() {\n        @Override\n        public void handleMessage(final Message msg) {\n            if (msg != null && msg.arg1 == 9528){\n                if (msg.getData() == null){\n                    return;\n                }\n\n                String content = (String) msg.getData().get(\"MSG_CONTENT\");\n                Log.e(TAG, \"Message from server: \" + content);\n            }\n        }\n    });\n\n    //服务端的 Messenger\n    private Messenger mServerMessenger;\n\n    private ServiceConnection mMessengerConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(final ComponentName name, final IBinder service) {\n            mServerMessenger = new Messenger(service);\n        }\n\n        @Override\n        public void onServiceDisconnected(final ComponentName name) {\n            mServerMessenger = null;\n        }\n    };\n    \n    //发送消息\n    public void sendMsg() {\n        String msgContent = \"消息\"；\n\n        Message message = Message.obtain();\n        message.arg1 = 9527;\n        Bundle bundle = new Bundle();\n        bundle.putString(\"MSG_CONTENT\", msgContent);\n        message.setData(bundle);\n        message.replyTo = mClientMessenger;     //指定回信人是客户端定义的\n\n        try {\n            mServerMessenger.send(message);\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### ContentProvider\n主要用于不同的应用程序之间实现数据共享功能","slug":"Android-IPC-机制详解","published":1,"updated":"2019-03-23T04:53:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavds002zi0upedbnelfe","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。<a id=\"more\"></a></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>只有在多进程场景下才需要 IPC 机制。</p>\n<p>多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。</p>\n<p>使用多进程会造成如下的问题：</p>\n<ul>\n<li>静态成员和单例模式完全失效</li>\n<li>线程同步机制完全失效</li>\n<li>SharedPreferences 可靠性下降</li>\n<li>Application 会多次创建</li>\n</ul>\n<p>对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"Serializable-接口\"><a href=\"#Serializable-接口\" class=\"headerlink\" title=\"Serializable 接口\"></a>Serializable 接口</h3><p>Java 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个<code>seriaVersionUID</code>即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> seriaVersionUID = <span class=\"number\">519067123721295773L</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//序列化过程</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">out.writeObject(user);</span><br><span class=\"line\">out.close</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//反序列化过程</span></span><br><span class=\"line\">ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">User user = (User) in.readObject();</span><br><span class=\"line\">in.close</span><br></pre></td></tr></table></figure>\n<p>使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。</p>\n<p>Java 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。</p>\n<h3 id=\"Parcelable-接口\"><a href=\"#Parcelable-接口\" class=\"headerlink\" title=\"Parcelable 接口\"></a>Parcelable 接口</h3><p>Android 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。</p>\n<p>其与 Serializable 的区别在于</p>\n<ul>\n<li>Parcelable 使用更复杂，后者如上面的代码，足够简洁。</li>\n<li>使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。</li>\n<li>使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。</li>\n</ul>\n<p>标准写法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">User</span><span class=\"params\">(Parcel in)</span> </span>&#123;</span><br><span class=\"line\">        name = in.readString();</span><br><span class=\"line\">        id = in.readInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        实例化静态变量CREATOR</span></span><br><span class=\"line\"><span class=\"comment\">        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Creator&lt;User&gt; CREATOR = <span class=\"keyword\">new</span> Creator&lt;User&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">createFromParcel</span><span class=\"params\">(Parcel in)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(in);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> User[] newArray(<span class=\"keyword\">int</span> size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User[size];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">describeContents</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeToParcel</span><span class=\"params\">(Parcel dest, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">        dest.writeString(name);</span><br><span class=\"line\">        dest.writeInt(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过 Intent 传递和获取数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传递</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">User user = getIntent().getParcelableExtra(<span class=\"string\">\"data\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h3><p>Binder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。</p>\n<ul>\n<li>从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。</li>\n<li>从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。</li>\n</ul>\n<p>更多关于 Binder：<a href=\"https://www.cnblogs.com/samchen2009/p/3316001.html\" target=\"_blank\" rel=\"noopener\">图解Android - Binder 和 Service</a></p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><h3 id=\"Bundle\"><a href=\"#Bundle\" class=\"headerlink\" title=\"Bundle\"></a>Bundle</h3><p>Bundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。</p>\n<h3 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h3><p>利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。</p>\n<p>缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。</p>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。</p>\n<h3 id=\"AIDL\"><a href=\"#AIDL\" class=\"headerlink\" title=\"AIDL\"></a>AIDL</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Android Interface Definition Language，Android 接口定义语言。</p>\n<ul>\n<li><p>数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下</p>\n<blockquote>\n<p>Java 中的八种基本数据类型、String、CharSequence。<br></p>\n<p>List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br></p>\n<p>Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br></p>\n</blockquote>\n</li>\n<li><p>定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。</p>\n<blockquote>\n<p>in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于更多：<a href=\"https://blog.csdn.net/luoyanglizi/article/details/51958091\" target=\"_blank\" rel=\"noopener\">你真的理解AIDL中的in，out，inout么?</a></p>\n<ul>\n<li>两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。<br>注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。</li>\n</ul>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>第一类 AIDL 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Book.aidl</span></span><br><span class=\"line\"><span class=\"comment\">// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：Book.aidl 与 Book.java的包名应当是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.febers.aidldemo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意parcelable是小写</span></span><br><span class=\"line\">parcelable Book;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 <code>writeToParcel</code>方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现<code>readFromParcel</code>方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。</p>\n</blockquote>\n<p>第二类 AIDL 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BookManager.aidl</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</span><br><span class=\"line\"><span class=\"comment\">//导入所需要使用的非默认支持数据类型的包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.febers.aidldemo.Book;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BookManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所有的返回值前都不需要加任何东西，不管是什么数据类型</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Book <span class=\"title\">getBook</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBookCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传参时，Java基本数据类型、String 以及 CharSequence 之外的类型</span></span><br><span class=\"line\">    <span class=\"comment\">//都需要在前面加上定向tag，具体加什么量需而定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBookPrice</span><span class=\"params\">(in Book book , <span class=\"keyword\">int</span> price)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">setBookName</span><span class=\"params\">(in Book book , String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">addBookIn</span><span class=\"params\">(in Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookOut</span><span class=\"params\">(out Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookInout</span><span class=\"params\">(inout Book book)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完成上面的步骤之后，<code>build</code>项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。</p>\n<p>服务端<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Book&gt; mBooks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的BookManager</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BookManager.Stub mBookManager = <span class=\"keyword\">new</span> BookManager.Stub() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking getBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> mBooks;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(Book book)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mBooks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (book == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    Log.e(TAG, <span class=\"string\">\"Book is null in In\"</span>);</span><br><span class=\"line\">                    book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class=\"line\">                book.setPrice(<span class=\"number\">2333</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mBooks.contains(book)) &#123;</span><br><span class=\"line\">                    mBooks.add(book);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//打印mBooks列表，观察客户端传过来的值</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking addBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"Android开发艺术探索\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">28</span>);</span><br><span class=\"line\">        mBooks.add(book);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(getClass().getSimpleName(), String.format(<span class=\"string\">\"on bind,intent = %s\"</span>, intent.toString()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mBookManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的 Java 类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BookManager mBookManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//标志当前与服务端连接状况的布尔值，false为未连接，true为连接中</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Book&gt; mBooks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_aidl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮的点击事件，点击之后调用服务端的addBookIn方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> view</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果与服务端的连接处于未连接状态，则尝试连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) &#123;</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBookManager == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"APP研发录In\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">30</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mBookManager.addBook(book);</span><br><span class=\"line\">            Log.e(getLocalClassName(), book.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试与服务端建立连接</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attemptToBindService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">        intent.setAction(<span class=\"string\">\"com.febers.aidl\"</span>);</span><br><span class=\"line\">        intent.setPackage(<span class=\"string\">\"com.febers.aidldemo\"</span>);</span><br><span class=\"line\">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) &#123;</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBound) &#123;</span><br><span class=\"line\">            unbindService(mServiceConnection);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mServiceConnection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service connected\"</span>);</span><br><span class=\"line\">            mBookManager = BookManager.Stub.asInterface(service);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mBookManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    mBooks = mBookManager.getBooks();</span><br><span class=\"line\">                    Log.e(getLocalClassName(), mBooks.toString());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service disconnected\"</span>);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然不要忘记在 Manifest 文件中注册 Service。<br>控制台显示信息如下：</p>\n<blockquote>\n<p>//服务端的 log 信息<br><br>1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br><br>2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br><br>3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]</p>\n</blockquote>\n<blockquote>\n<p>//客户端的 log 信息<br><br>1，service connected<br><br>2，[name : Android开发艺术探索 , price : 28]<br><br>3，name : APP研发录In , price : 2333</p>\n</blockquote>\n<h3 id=\"Messager\"><a href=\"#Messager\" class=\"headerlink\" title=\"Messager\"></a>Messager</h3><p>Messager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。</p>\n<h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Messenger 有两个构造函数，分贝以 Handler 和 Binder 为参数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IMessenger mTarget;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(Handler target)</span> </span>&#123;</span><br><span class=\"line\">    mTarget = target.getIMessenger();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(IBinder target)</span> </span>&#123;</span><br><span class=\"line\">    mTarget = IMessenger.Stub.asInterface(target);    <span class=\"comment\">//和前面的 AIDL 很相似吧</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Handler.getIMessenger</code>源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> IMessenger <span class=\"title\">getIMessenger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mQueue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mMessenger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mMessenger = <span class=\"keyword\">new</span> MessengerImpl();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>IMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法<code>send(android.os.Message msg)</code>。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        msg.sendingUid = Binder.getCallingUid();</span><br><span class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以可以使用<code>Handler.handlerMessage</code>接收消息。Messenger 中对<code>send</code>的实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    mTarget.send(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Messenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部<code>send</code>方法实际上是调用 IMessenger 实现的<code>send</code>方法。</p>\n<p>Messenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。</p>\n<h4 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>服务端<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.arg1 == <span class=\"number\">9527</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);  <span class=\"comment\">//接收客户端的消息</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from client: \"</span> + content);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//回复消息给客户端</span></span><br><span class=\"line\">                Message replyMsg = Message.obtain();</span><br><span class=\"line\">                replyMsg.arg1 = <span class=\"number\">9528</span>;</span><br><span class=\"line\">                Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">                bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, <span class=\"string\">\"已收到消息\"</span>);</span><br><span class=\"line\">                replyMsg.setData(bundle);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    msg.replyTo.send(replyMsg);     <span class=\"comment\">//回信</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(<span class=\"keyword\">final</span> Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger.getBinder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端代码片段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessagerActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mClientMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.arg1 == <span class=\"number\">9528</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from server: \"</span> + content);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//服务端的 Messenger</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger mServerMessenger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mMessengerConnection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name, <span class=\"keyword\">final</span> IBinder service)</span> </span>&#123;</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">new</span> Messenger(service);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name)</span> </span>&#123;</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//发送消息</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String msgContent = <span class=\"string\">\"消息\"</span>；</span><br><span class=\"line\"></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        message.arg1 = <span class=\"number\">9527</span>;</span><br><span class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">        bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, msgContent);</span><br><span class=\"line\">        message.setData(bundle);</span><br><span class=\"line\">        message.replyTo = mClientMessenger;     <span class=\"comment\">//指定回信人是客户端定义的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mServerMessenger.send(message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ContentProvider\"><a href=\"#ContentProvider\" class=\"headerlink\" title=\"ContentProvider\"></a>ContentProvider</h3><p>主要用于不同的应用程序之间实现数据共享功能</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>IPC（Inter-Process Communication），进程间通信或者跨进程通信，指不同的进程之间进行数据交换的过程。按照操作系统的描述，进程是指一个执行单元，在 PC 或移动设备上指一个程序/应用。容易混淆的另一个概念是线程，线程是 CPU 调度的最小单元，属于有限的系统资源。一个进程可以包含多个线程。</p>","more":"<p></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>只有在多进程场景下才需要 IPC 机制。</p>\n<p>多进程的情况分为两种。第一种情况是应用因为某些原因需要采用多进程模式来实现，比如一些模块由于特殊原因需要运行在单独的进程中、为了加大可使用的内存需要多进程来获取多份内存空间（Android 对单个应用可使用的内存做了限制，早期为16MB）；第二种情况则是当前应用需要向其他应用获取数据，比如使用 ContentProvider 去查询数据。</p>\n<p>使用多进程会造成如下的问题：</p>\n<ul>\n<li>静态成员和单例模式完全失效</li>\n<li>线程同步机制完全失效</li>\n<li>SharedPreferences 可靠性下降</li>\n<li>Application 会多次创建</li>\n</ul>\n<p>对于第四点，当一个组件跑在一个新的进程中，由于系统要在创建新的线程同时分配虚拟机，这一过程相当于启动一个应用，所以会创建一个新的 Application。</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"Serializable-接口\"><a href=\"#Serializable-接口\" class=\"headerlink\" title=\"Serializable 接口\"></a>Serializable 接口</h3><p>Java 提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 实现序列化很简单，只需要实现接口，提供一个<code>seriaVersionUID</code>即可（不提供会对反序列化过程产生影响），系统便会自动完成默认的序列化过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> seriaVersionUID = <span class=\"number\">519067123721295773L</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//序列化过程</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">out.writeObject(user);</span><br><span class=\"line\">out.close</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//反序列化过程</span></span><br><span class=\"line\">ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"file.txt\"</span>));</span><br><span class=\"line\">User user = (User) in.readObject();</span><br><span class=\"line\">in.close</span><br></pre></td></tr></table></figure>\n<p>使用 Serializable 实现序列化需要注意，static 和 transient 关键字修饰的变量不会被序列化。使用 static 修饰的变量的值存储在 JVM 中。</p>\n<p>Java 还提供了另一种序列化的方式：Externalizable接口，该接口继承自 Serializable 而且优先级更高，使用之后序列化的细节需要开发人员自己实现，同时 transient 关键字将失去作用。</p>\n<h3 id=\"Parcelable-接口\"><a href=\"#Parcelable-接口\" class=\"headerlink\" title=\"Parcelable 接口\"></a>Parcelable 接口</h3><p>Android 官方提供的序列化接口，实现接口之后，类的对象即可进行一个“从对象存储为 Parcel ， 从 Parcel 读取为对象”的读写过程。Parcel 包装了可序列化的数据，可以在Binder中自由传输。</p>\n<p>其与 Serializable 的区别在于</p>\n<ul>\n<li>Parcelable 使用更复杂，后者如上面的代码，足够简洁。</li>\n<li>使用内存时，Parcelable 比 Serializable 性能高，因为 Serializable 序列化的时候会产生大量临时变量，引起频繁的GC。</li>\n<li>使用本地存储的时候，Serializable 更有保障性，因为 Parcelable 在外界有变化的情况下不能很好的保证数据的持续性。</li>\n</ul>\n<p>标准写法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">User</span><span class=\"params\">(Parcel in)</span> </span>&#123;</span><br><span class=\"line\">        name = in.readString();</span><br><span class=\"line\">        id = in.readInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        实例化静态变量CREATOR</span></span><br><span class=\"line\"><span class=\"comment\">        从Parcel中构造一个实现了Parcelable的类的实例,Parcel来自writeToParcel方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Creator&lt;User&gt; CREATOR = <span class=\"keyword\">new</span> Creator&lt;User&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">createFromParcel</span><span class=\"params\">(Parcel in)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(in);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> User[] newArray(<span class=\"keyword\">int</span> size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User[size];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">describeContents</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeToParcel</span><span class=\"params\">(Parcel dest, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">        dest.writeString(name);</span><br><span class=\"line\">        dest.writeInt(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过 Intent 传递和获取数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传递</span></span><br><span class=\"line\">User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Name\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">User user = getIntent().getParcelableExtra(<span class=\"string\">\"data\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h3><p>Binder 是一个实现了 IBinder 接口的类。从 IPC 角度，Binder 是 Android 中的一种跨进程通信方式，Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在 Linux 中没有。</p>\n<ul>\n<li>从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager(ActivityManager、WindowManager 等等)和相应 ManagerService 的桥梁。</li>\n<li>从 Android 应用层角度，Binder 是客户端和服务端进行通信的媒介，当我们 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，客户端通过它获取服务端提供的服务（普通服务和基于 AIDL 的服务）或者数据。</li>\n</ul>\n<p>更多关于 Binder：<a href=\"https://www.cnblogs.com/samchen2009/p/3316001.html\" target=\"_blank\" rel=\"noopener\">图解Android - Binder 和 Service</a></p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><h3 id=\"Bundle\"><a href=\"#Bundle\" class=\"headerlink\" title=\"Bundle\"></a>Bundle</h3><p>Bundle 可以在四大组件之间通过 Intent 传递数据，它本身实现了 Parcelable 接口，能够存储基本数据类型、String、实现了 Parcelable 的对象以及以上类型的数组。</p>\n<h3 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h3><p>利用多进程同时读写同个外部文件达到是数据交互的目的。存储形式没有限制，可以是 XML、文本、对象序列化等等。</p>\n<p>缺点在于，Linux 系统对文件并发读写没有限制，会导致数据不同步的问题，所以该方式只适合于对数据同步要求不高的进程间通信。</p>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的TCP和UDP协议。</p>\n<h3 id=\"AIDL\"><a href=\"#AIDL\" class=\"headerlink\" title=\"AIDL\"></a>AIDL</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Android Interface Definition Language，Android 接口定义语言。</p>\n<ul>\n<li><p>数据类型：作为一门“语言”，它有一些与 Java 不同的地方。除了基本数据类型、String 和 CharSequence 之外，使用其他的数据类型都需要显式导入，无论 aidl 接口是否与目标类在同一个包中。其支持的数据类型如下</p>\n<blockquote>\n<p>Java 中的八种基本数据类型、String、CharSequence。<br></p>\n<p>List类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的 Parcelable 类型。List可以使用泛型。<br></p>\n<p>Map类型：其中的元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map不支持泛型。<br></p>\n</blockquote>\n</li>\n<li><p>定向tag：AIDL 中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。</p>\n<blockquote>\n<p>in 为定向 tag 时，表现为服务端将会接收到一个对象的完整数据，但是客户端的对象不会因为服务端对传参的修改而发生变动；<br>out 为定向 tag 时，表现为服务端将会接收到对象的的空对象，但是在服务端对接收到的空对象有任何修改之后，客户端将会同步变动；<br>inout 为定向 tag 时，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于更多：<a href=\"https://blog.csdn.net/luoyanglizi/article/details/51958091\" target=\"_blank\" rel=\"noopener\">你真的理解AIDL中的in，out，inout么?</a></p>\n<ul>\n<li>两种类型：所有的 AIDL 文件可分为两类。一类定义 Parcelable 对象，以供其他 AIDL 文件使用非默认支持的数据类型。一类定义方法接口，以供系统完成跨进程通信。<br>可以看到，两类文件都是在“定义”，而不涉及具体的实现，这就是为什么它叫做“Android 接口定义语言”。<br>注：所有的非默认支持数据类型必须通过第一类 AIDL 文件定义才能被使用。</li>\n</ul>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>第一类 AIDL 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Book.aidl</span></span><br><span class=\"line\"><span class=\"comment\">// 这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：Book.aidl 与 Book.java的包名应当是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.febers.aidldemo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意parcelable是小写</span></span><br><span class=\"line\">parcelable Book;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>自定义 Parcelable 对象只支持为 in 的定向 tag 。原因在于生成的类中只有 <code>writeToParcel</code>方法，而如果要支持为 out 或者 inout 的定向 tag，还需要实现<code>readFromParcel</code>方法，而该方法并没有在 Parcelable 接口中定义，需要我们从头写。</p>\n</blockquote>\n<p>第二类 AIDL 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BookManager.aidl</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</span><br><span class=\"line\"><span class=\"comment\">//导入所需要使用的非默认支持数据类型的包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.febers.aidldemo.Book;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BookManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所有的返回值前都不需要加任何东西，不管是什么数据类型</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Book <span class=\"title\">getBook</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBookCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传参时，Java基本数据类型、String 以及 CharSequence 之外的类型</span></span><br><span class=\"line\">    <span class=\"comment\">//都需要在前面加上定向tag，具体加什么量需而定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBookPrice</span><span class=\"params\">(in Book book , <span class=\"keyword\">int</span> price)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">setBookName</span><span class=\"params\">(in Book book , String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">addBookIn</span><span class=\"params\">(in Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookOut</span><span class=\"params\">(out Book book)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookInout</span><span class=\"params\">(inout Book book)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完成上面的步骤之后，<code>build</code>项目，编译器就会为我们生成相应的 BookManager 类。此时就可以开始服务端、客户端的代码编写。</p>\n<p>服务端<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Book&gt; mBooks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的BookManager</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BookManager.Stub mBookManager = <span class=\"keyword\">new</span> BookManager.Stub() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking getBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> mBooks;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(Book book)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mBooks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mBooks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (book == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    Log.e(TAG, <span class=\"string\">\"Book is null in In\"</span>);</span><br><span class=\"line\">                    book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class=\"line\">                book.setPrice(<span class=\"number\">2333</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mBooks.contains(book)) &#123;</span><br><span class=\"line\">                    mBooks.add(book);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//打印mBooks列表，观察客户端传过来的值</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"invoking addBooks() method , now the list is : \"</span> + mBooks.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"Android开发艺术探索\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">28</span>);</span><br><span class=\"line\">        mBooks.add(book);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(getClass().getSimpleName(), String.format(<span class=\"string\">\"on bind,intent = %s\"</span>, intent.toString()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mBookManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AIDLActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由AIDL文件生成的 Java 类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BookManager mBookManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//标志当前与服务端连接状况的布尔值，false为未连接，true为连接中</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//包含Book对象的list</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Book&gt; mBooks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_aidl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按钮的点击事件，点击之后调用服务端的addBookIn方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> view</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果与服务端的连接处于未连接状态，则尝试连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) &#123;</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"当前与服务端处于未连接状态，正在尝试重连，请稍后再试\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBookManager == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">        book.setName(<span class=\"string\">\"APP研发录In\"</span>);</span><br><span class=\"line\">        book.setPrice(<span class=\"number\">30</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mBookManager.addBook(book);</span><br><span class=\"line\">            Log.e(getLocalClassName(), book.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试与服务端建立连接</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attemptToBindService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">        intent.setAction(<span class=\"string\">\"com.febers.aidl\"</span>);</span><br><span class=\"line\">        intent.setPackage(<span class=\"string\">\"com.febers.aidldemo\"</span>);</span><br><span class=\"line\">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mBound) &#123;</span><br><span class=\"line\">            attemptToBindService();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBound) &#123;</span><br><span class=\"line\">            unbindService(mServiceConnection);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mServiceConnection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service connected\"</span>);</span><br><span class=\"line\">            mBookManager = BookManager.Stub.asInterface(service);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mBookManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    mBooks = mBookManager.getBooks();</span><br><span class=\"line\">                    Log.e(getLocalClassName(), mBooks.toString());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</span><br><span class=\"line\">            Log.e(getLocalClassName(), <span class=\"string\">\"service disconnected\"</span>);</span><br><span class=\"line\">            mBound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然不要忘记在 Manifest 文件中注册 Service。<br>控制台显示信息如下：</p>\n<blockquote>\n<p>//服务端的 log 信息<br><br>1，on bind,intent = Intent { act=com.lypeer.aidl pkg=com.lypeer.ipcserver }<br><br>2，invoking getBooks() method , now the list is : [name : Android开发艺术探索 , price : 28]<br><br>3，invoking addBooks() method , now the list is : [name : Android开发艺术探索 , price : 28, name : APP研发录In , price : 2333]</p>\n</blockquote>\n<blockquote>\n<p>//客户端的 log 信息<br><br>1，service connected<br><br>2，[name : Android开发艺术探索 , price : 28]<br><br>3，name : APP研发录In , price : 2333</p>\n</blockquote>\n<h3 id=\"Messager\"><a href=\"#Messager\" class=\"headerlink\" title=\"Messager\"></a>Messager</h3><p>Messager 底层使用了 AIDL 方式。和 AIDL 不同的是，Messager 利用 Handler 形式处理消息的接收发送，因此是线程安全的，这也表示它不支持并发处理；而 AIDL 方式是非线程安全的，支持并发处理，因此使用 AIDL 方式时需要保证代码的线程安全。</p>\n<h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Messenger 有两个构造函数，分贝以 Handler 和 Binder 为参数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IMessenger mTarget;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(Handler target)</span> </span>&#123;</span><br><span class=\"line\">    mTarget = target.getIMessenger();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(IBinder target)</span> </span>&#123;</span><br><span class=\"line\">    mTarget = IMessenger.Stub.asInterface(target);    <span class=\"comment\">//和前面的 AIDL 很相似吧</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Handler.getIMessenger</code>源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> IMessenger <span class=\"title\">getIMessenger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mQueue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mMessenger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mMessenger = <span class=\"keyword\">new</span> MessengerImpl();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>IMessenger 是 AIDL 生成的跨进程接口，里面定义了一个发送消息的方法<code>send(android.os.Message msg)</code>。Handler 中 MessengerImpl 实现了该方法，使用 Handler 将消息发出去：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        msg.sendingUid = Binder.getCallingUid();</span><br><span class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以可以使用<code>Handler.handlerMessage</code>接收消息。Messenger 中对<code>send</code>的实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    mTarget.send(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Messenger 中持有一个 IMessenger 的引用，在构造函数中可以通过 Handler 或者 Binder 的形式获得最终的实现，内部<code>send</code>方法实际上是调用 IMessenger 实现的<code>send</code>方法。</p>\n<p>Messenger 是 AIDL 的简化版，把接口都封装好，开发者只需在一个进程创建一个 Handler 传递给 Messenger，Messenger 皆可以把消息跨进程传递到另一个进程，在另一个进程的 Handler 在处理消息就可以。</p>\n<h4 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>服务端<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"keyword\">this</span>.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.arg1 == <span class=\"number\">9527</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);  <span class=\"comment\">//接收客户端的消息</span></span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from client: \"</span> + content);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//回复消息给客户端</span></span><br><span class=\"line\">                Message replyMsg = Message.obtain();</span><br><span class=\"line\">                replyMsg.arg1 = <span class=\"number\">9528</span>;</span><br><span class=\"line\">                Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">                bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, <span class=\"string\">\"已收到消息\"</span>);</span><br><span class=\"line\">                replyMsg.setData(bundle);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    msg.replyTo.send(replyMsg);     <span class=\"comment\">//回信</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(<span class=\"keyword\">final</span> Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger.getBinder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>客户端代码片段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessagerActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Messenger mClientMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.arg1 == <span class=\"number\">9528</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (msg.getData() == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                String content = (String) msg.getData().get(<span class=\"string\">\"MSG_CONTENT\"</span>);</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Message from server: \"</span> + content);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//服务端的 Messenger</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger mServerMessenger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mMessengerConnection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name, <span class=\"keyword\">final</span> IBinder service)</span> </span>&#123;</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">new</span> Messenger(service);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(<span class=\"keyword\">final</span> ComponentName name)</span> </span>&#123;</span><br><span class=\"line\">            mServerMessenger = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//发送消息</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String msgContent = <span class=\"string\">\"消息\"</span>；</span><br><span class=\"line\"></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        message.arg1 = <span class=\"number\">9527</span>;</span><br><span class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">        bundle.putString(<span class=\"string\">\"MSG_CONTENT\"</span>, msgContent);</span><br><span class=\"line\">        message.setData(bundle);</span><br><span class=\"line\">        message.replyTo = mClientMessenger;     <span class=\"comment\">//指定回信人是客户端定义的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mServerMessenger.send(message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ContentProvider\"><a href=\"#ContentProvider\" class=\"headerlink\" title=\"ContentProvider\"></a>ContentProvider</h3><p>主要用于不同的应用程序之间实现数据共享功能</p>"},{"title":"Android 动画详解","date":"2019-02-18T11:12:22.000Z","_content":"\n## 引言\nAndroid 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。<!--more-->\n\n## View Animation \n视图动画的作用对象是 View，可分为补间动画和帧动画。\n\n### 补间动画\n动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。\n\n#### XML 方式\n创建一个 set.xml 文件，通过动画集合标签`<set>`将四种效果结合起来\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<--动画集合\ninterpolator 表示所采用的的差值器，其影响动画的速度，可以不指定\nshareInterpolator 表示集合中的动画是否和集合共享同一个差值器-->\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fillAfter=\"true\"\n    android:shareInterpolator=\"true\"\n    android:repeatMode=\"reverse\">\n    \n    <!-- 缩放动画\n    fromXScale 表示水平方向缩放的起始值\n    toXScale 表示水平方向的结束值\n    fillAfter 表示动画显示结束保持最后一帧-->\n    <scale  \n        android:duration=\"1000\"\n        android:fillAfter=\"true\"\n        android:fromXScale=\"0.5\"\n        android:fromYScale=\"0.5\"\n        android:toXScale=\"1\"\n        android:toYScale=\"1\"\n        android:repeatCount=\"infinite\"/><!--次数 ,infinite 为无线循环播放-->\n        \n    <!-- 透明度动画\n        fromAlpha 表示起始透明度\n        toAlpha 表示结束透明度-->\n    <alpha\n        android:duration=\"2000\"\n        android:fillAfter=\"true\"\n        android:fromAlpha=\"0.7\"\n        android:toAlpha=\"1\"/>\n        \n    <!--旋转动画\n    fromDegrees 表示起始角度\n    toDegrees 表示结束角度-->\n    <rotate\n        android:fromDegrees=\"0\"\n        android:toDegrees=\"90\"\n        android:fillAfter=\"true\"\n        android:duration=\"1000\"/>\n    \n    <!--平移动画-->\n    <translate\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:toXDelta=\"100%\"\n        android:toYDelta=\"-100%\"\n        android:fillAfter=\"true\"\n        android:duration=\"2000\"\n        />\n</set>\n```\n使用以上动画的方式如下\n```Java\nAnimation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);\nview.startAnimation(anim);\n```\n\n#### Java 代码方式\n使用 Java 代码实现动画的方式如下\n```Java\npublic void startAnimationSet() {\n    //创建动画，参数表示他的子动画是否共用一个插值器\n    AnimationSet animationSet = new AnimationSet(true);\n    //添加动画\n    animationSet.addAnimation(new AlphaAnimation(1.0f, 0.0f));\n    //设置插值器\n    animationSet.setInterpolator(new LinearInterpolator());\n    //设置动画持续时长\n    animationSet.setDuration(3000);\n    //设置动画结束之后是否保持动画的目标状态\n    animationSet.setFillAfter(true);\n    //设置动画结束之后是否保持动画开始时的状态\n    animationSet.setFillBefore(false);\n    //设置重复模式\n    animationSet.setRepeatMode(AnimationSet.REVERSE);\n    //设置重复次数\n    animationSet.setRepeatCount(AnimationSet.INFINITE);\n    //设置动画延时时间\n    animationSet.setStartOffset(2000);\n    //取消动画\n    animationSet.cancel();\n    //释放资源\n    animationSet.reset();\n    //开始动画\n    view.startAnimation(animationSet);\n}\n```\n\n#### 自定义\n除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的`initialize`和`applyTransformation`方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 \n\n#### 特殊使用\nView 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。\n\n### 帧动画\n帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。\n\n首先需要定义一个 XML 文件`frame_animation.xml`\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"false\">\n    <item\n        android:drawable=\"@mipmap/image1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/image2\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/iamge2\"\n        android:duration=\"100\" />\n</animation-list>\n```\n然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可\n```Java\nview.setBackgroundResource(R.drawable.frame_animation)；\nAnimationDrawable drawable = (AnimationDrawable) view.getBackground();\ndrawable.start();\n```\n\n## Property Animation\n属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：\n- 补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。\n- 补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。\n\n与补间动画类似，属性动画也需要定义几个方面的属性：\n- 动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。\n- 动画插值方式。通过 android:interploator 指定。\n- 动画重复次数。通过 android:repeatCount 指定。\n- 重复行为。通过 android:repeatMode 指定。\n- 动画集。在属性资源文件中通过 `<set>` 来组合。\n- 帧刷新率。指定多长时间播放一帧。默认为 10 ms。\n\n### API\n- ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。\n- ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。\n- AnimatorSet：Animator 的子类，用于组合多个 Animator。\n\n属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。\n- IntEvaluator：计算 int 类型属性值的计算器。\n- FloatEvaluator：用于计算 float 类型属性值的计算器。\n- ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。\n- TypeEvaluator：可以自定义计算器。\n\n### ValueAniamtor\nValueAnimator 类中有3个重要方法：\n> ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)\n\n#### ofInt\n将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator\n\n下面的代码将实现按钮的宽度从 150px 放大到 500px\n```Java\n    Button mButton = (Button) findViewById(R.id.Button);\n    // 设置属性数值的初始值 & 结束值\n    // ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500\n    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, 500);\n  \n    // 设置动画的播放各种属性\n    valueAnimator.setDuration(2000);\n\n    // 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度\n    // 设置更新监听器，数值每次变化更新都会调用该方法\n    valueAnimator.addUpdateListener(new AnimatorUpdateListener() {\n    \n        @Override\n        public void onAnimationUpdate(ValueAnimator animator) {\n            // 获得每次变化后的属性值\n            int currentValue = (Integer) animator.getAnimatedValue();\n            // 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化\n            mButton.getLayoutParams().width = currentValue;\n            \n            // 刷新视图，即重新绘制\n            mButton.requestLayout();\n        }\n    });\n    valueAnimator.start();  // 启动动画\n}\n```\n\n#### ofFloat\n其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）\n```Java\npublic class FloatEvaluator implements TypeEvaluator {  \n\n    /**\n     * 重写evaluate()\n     *\n     * @param fraction 动画完成度（根据它来计算当前动画的值）\n     * @param startValue 动画的初始值\n     * @param endValue 动画的结束值\n     * @return \n     */\n    public Object evaluate(float fraction, Object startValue, Object endValue) {  \n\n        float startFloat = ((Number) startValue).floatValue();  \n        \n        // 初始值过渡到结束值的算法\n        // 1. 用结束值减去初始值，算出它们之间的差值\n        // 2. 用上述差值乘以 fraction 系数\n        // 3. 加上初始值，得到当前动画的值\n        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  \n    }  \n}  \n```\n\n#### ofObject\n对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。\n\n但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。\n\n自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。\n\n```Java\npublic class PointEvaluator implements TypeEvaluator {\n\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        // 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n\n        // 根据fraction来计算当前动画的x和y的值\n        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());\n        \n        // 将计算后的坐标封装到一个新的Point对象中并返回\n        Point point = new Point(x, y);\n        return point;\n    }\n}\n```\n将属性动画作用到自定义View当中\n```Java\npublic class MyView extends View {\n\n    public static final float RADIUS = 70f;// 圆的半径\n    private Point currentPoint;// 当前点坐标\n    private Paint mPaint;// 绘图画笔\n    \n    // 构造方法，初始化画笔\n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    // 实现绘制逻辑\n    // 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果\n    @Override\n    protected void onDraw(Canvas canvas) {\n        // 如果当前点坐标为空(即第一次)\n        if (currentPoint == null) {\n            currentPoint = new Point(RADIUS, RADIUS);  // 创建一个点对象(坐标是(70,70))\n\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n\n            // 将属性动画作用到View中\n            Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70)\n            Point endPoint = new Point(700, 1000);// 结束点为(700,1000)\n\n            ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);\n            anim.setDuration(5000);\n    \n            anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override\n                public void onAnimationUpdate(ValueAnimator animation) {\n                    currentPoint = (Point) animation.getAnimatedValue();\n                    // 每次赋值后就重新绘制，从而实现动画效果\n                    // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次\n                    invalidate();  \n                }\n            });\n            anim.start();\n        } else {\n            // 如果坐标值不为0,则画圆\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n        }\n    }\n}\n```\n\n### ObjectAnimator\n继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。\nObjectAnimator 与 ValueAnimator类的区别在于\n- ValueAnimator 类是先改变值，然后**手动赋值**给对象的属性从而实现动画，属于**间接**对对象属性进行操作\n- ObjectAnimator 类是先改变值，然后**自动赋值**给对象的属性从而实现动画，属于**直接**对对象属性进行操作\n\n#### 具体使用\n对于\n> ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ....values); \n\n其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值\n\n对 Button 进行变换\n```Java\n\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  // 效果:常规->全透明->常规\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);\n......\nanimator.setDuration(5000);\nanimator.start();\n```\n\n#### 自定义\n在上面的例子中，我们给`ObjectAnimator.ofFloat`的第二个参数`String property`传入`alpha`、`rotation`、`translationX` 和`scaleY`等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的`get/set`方法进行的。\n\n所以自定义属性就可以通过为对象设置需要操作属性的`set/get`方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。\n\n还是对一个球做变换\n```Java\npublic class MyView2 extends View {\n    public static final float RADIUS = 100f;\n    private Paint mPaint;\n\n    private String color;  // 设置背景颜色属性\n\n    // 设置背景颜色的get() & set()方法\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n        mPaint.setColor(Color.parseColor(color));  // 将画笔的颜色设置成方法参数传入的颜色\n        invalidate();\n    }\n\n    public MyView2(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        canvas.drawCircle(500, 500, RADIUS, mPaint);\n    }\n}\n```\n实现自定义估值器，完成颜色过渡的逻辑\n```Java\npublic class ColorEvaluator implements TypeEvaluator {\n\n    private int mCurrentRed;\n\n    private int mCurrentGreen ;\n\n    private int mCurrentBlue ;\n\n    // 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        String startColor = (String) startValue;\n        String endColor = (String) endValue;\n\n        // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字\n        // 那么每个颜色的取值范围是0-255\n        int startRed = Integer.parseInt(startColor.substring(1, 3), 16);\n        int startGreen = Integer.parseInt(startColor.substring(3, 5), 16);\n        int startBlue = Integer.parseInt(startColor.substring(5, 7), 16);\n\n        int endRed = Integer.parseInt(endColor.substring(1, 3), 16);\n        int endGreen = Integer.parseInt(endColor.substring(3, 5), 16);\n        int endBlue = Integer.parseInt(endColor.substring(5, 7), 16);\n\n        // 将初始化颜色的值定义为当前需要操作的颜色值\n        mCurrentRed = startRed;\n        mCurrentGreen = startGreen;\n        mCurrentBlue = startBlue;\n\n\n        // 计算初始颜色和结束颜色之间的差值\n        // 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢\n        int redDiff = Math.abs(startRed - endRed);\n        int greenDiff = Math.abs(startGreen - endGreen);\n        int blueDiff = Math.abs(startBlue - endBlue);\n        int colorDiff = redDiff + greenDiff + blueDiff;\n        \n        if (mCurrentRed != endRed) {\n            // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1\n            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0, fraction);\n        \n        } else if (mCurrentGreen != endGreen) {\n            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);\n            \n        } else if (mCurrentBlue != endBlue) {\n            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);\n        }\n        // 将计算出的当前颜色的值组装返回\n        String currentColor = \"#\" + getHexString(mCurrentRed)\n                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);\n        return currentColor;\n    }\n\n\n\n    // 根据fraction值来计算当前的颜色。\n    private int getCurrentColor(int startColor, int endColor, int colorDiff,\n                                int offset, float fraction) {\n        int currentColor;\n        if (startColor > endColor) {\n            currentColor = (int) (startColor - (fraction * colorDiff - offset));\n            if (currentColor < endColor) {\n                currentColor = endColor;\n            }\n        } else {\n            currentColor = (int) (startColor + (fraction * colorDiff - offset));\n            if (currentColor > endColor) {\n                currentColor = endColor;\n            }\n        }\n        return currentColor;\n    }\n\n    // 将10进制颜色值转换成16进制。\n    private String getHexString(int value) {\n        String hexString = Integer.toHexString(value);\n        if (hexString.length() == 1) {\n            hexString = \"0\" + hexString;\n        }\n        return hexString;\n    }\n}\n```\n具体调用\n```Java\nObjectAnimator anim = ObjectAnimator.ofObject(myView2, \"color\", new ColorEvaluator(), \"#0000FF\", \"#FF0000\");\nanim.setDuration(2000);\nanim.start();\n```\n\n此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中`setWidth`并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过`get/set`无法改变控件的宽度，也就无法实现动画效果。\n\n解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的`get/set`方法。\n```Java\nButtonWrapper wrapper = new ViewWrapper(button);\nObjectAnimator.ofInt(wrapper, \"width\", 500)\n        .setDuration(3000)\n        .start();\n\nprivate static class ViewWrapper {\n    private View mTarget;\n\n    public ViewWrapper(View target) {\n        mTarget = target;\n    }\n    \n    // 为宽度设置get/set\n    public int getWidth() {\n            return mTarget.getLayoutParams().width;\n    }\n    \n    public void setWidth(int width) {\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n```\n\n### AnimatorSet\n最后介绍组合动画类，仅展示用法\n```Java\n\nObjectAnimator translation = ObjectAnimator.ofFloat(mButton, \"translationX\", curTranslationX, 300,curTranslationX);  \nObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);  \nObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  \n\nAnimatorSet animSet = new AnimatorSet();  \n\nanimSet.play(translation).with(rotate).before(alpha);  \nanimSet.setDuration(5000);  \nanimSet.start();  \n```\n## Spring Animation\nSpringAnimation，弹簧动画，位于`android.support.animation`包中，属性动画位于`android.animation.Animator`包中，其实通过 [BounceInterpolator](https://developer.android.com/reference/android/view/animation/BounceInterpolator.html) 或者 [OvershootInterpolator](https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html) 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。\n\n使用之前需要导入`com.android.support:support-dynamic-animation`包\n\n### API\n```Java\npublic SpringAnimation(View v, ViewProperty property)\npublic SpringAnimation(View v, ViewProperty property, float finalPosition)\n```\n参数分别是操作对应的View，对应的变化属性及最终的位置。\n\nViewProperty 包括(Z轴支持需要API >= 21)：\n>TRANSLATION_X\n>TRANSLATION_Y\n>TRANSLATION_Z\n>SCALE_X\n>SCALE_Y\n>ROTATION\n>ROTATION_X\n>ROTATION_Y\n>X\n>Y\n>Z\n>ALPHA\n>SCROLL_X\n>SCROLL_Y\n\n在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量\n- Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快\n- DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ > 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 < ζ <1)。\n\n### 简单使用\n```Java\nSpringAnimation btnAnim = new SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, 0);\n\nbtnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);\nbtnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);\n\nbtnAnim.setStartVelocity(10000);  //开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反\nbtnAnim.start();\n```","source":"_posts/Android-动画详解.md","raw":"---\ntitle: Android 动画详解\ndate: 2019-02-18 19:12:22\ntags:\n- Android\n- 动画开发\ncategories:\n- Android\n---\n\n## 引言\nAndroid 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。<!--more-->\n\n## View Animation \n视图动画的作用对象是 View，可分为补间动画和帧动画。\n\n### 补间动画\n动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。\n\n#### XML 方式\n创建一个 set.xml 文件，通过动画集合标签`<set>`将四种效果结合起来\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<--动画集合\ninterpolator 表示所采用的的差值器，其影响动画的速度，可以不指定\nshareInterpolator 表示集合中的动画是否和集合共享同一个差值器-->\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fillAfter=\"true\"\n    android:shareInterpolator=\"true\"\n    android:repeatMode=\"reverse\">\n    \n    <!-- 缩放动画\n    fromXScale 表示水平方向缩放的起始值\n    toXScale 表示水平方向的结束值\n    fillAfter 表示动画显示结束保持最后一帧-->\n    <scale  \n        android:duration=\"1000\"\n        android:fillAfter=\"true\"\n        android:fromXScale=\"0.5\"\n        android:fromYScale=\"0.5\"\n        android:toXScale=\"1\"\n        android:toYScale=\"1\"\n        android:repeatCount=\"infinite\"/><!--次数 ,infinite 为无线循环播放-->\n        \n    <!-- 透明度动画\n        fromAlpha 表示起始透明度\n        toAlpha 表示结束透明度-->\n    <alpha\n        android:duration=\"2000\"\n        android:fillAfter=\"true\"\n        android:fromAlpha=\"0.7\"\n        android:toAlpha=\"1\"/>\n        \n    <!--旋转动画\n    fromDegrees 表示起始角度\n    toDegrees 表示结束角度-->\n    <rotate\n        android:fromDegrees=\"0\"\n        android:toDegrees=\"90\"\n        android:fillAfter=\"true\"\n        android:duration=\"1000\"/>\n    \n    <!--平移动画-->\n    <translate\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:toXDelta=\"100%\"\n        android:toYDelta=\"-100%\"\n        android:fillAfter=\"true\"\n        android:duration=\"2000\"\n        />\n</set>\n```\n使用以上动画的方式如下\n```Java\nAnimation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);\nview.startAnimation(anim);\n```\n\n#### Java 代码方式\n使用 Java 代码实现动画的方式如下\n```Java\npublic void startAnimationSet() {\n    //创建动画，参数表示他的子动画是否共用一个插值器\n    AnimationSet animationSet = new AnimationSet(true);\n    //添加动画\n    animationSet.addAnimation(new AlphaAnimation(1.0f, 0.0f));\n    //设置插值器\n    animationSet.setInterpolator(new LinearInterpolator());\n    //设置动画持续时长\n    animationSet.setDuration(3000);\n    //设置动画结束之后是否保持动画的目标状态\n    animationSet.setFillAfter(true);\n    //设置动画结束之后是否保持动画开始时的状态\n    animationSet.setFillBefore(false);\n    //设置重复模式\n    animationSet.setRepeatMode(AnimationSet.REVERSE);\n    //设置重复次数\n    animationSet.setRepeatCount(AnimationSet.INFINITE);\n    //设置动画延时时间\n    animationSet.setStartOffset(2000);\n    //取消动画\n    animationSet.cancel();\n    //释放资源\n    animationSet.reset();\n    //开始动画\n    view.startAnimation(animationSet);\n}\n```\n\n#### 自定义\n除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的`initialize`和`applyTransformation`方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 \n\n#### 特殊使用\nView 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。\n\n### 帧动画\n帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。\n\n首先需要定义一个 XML 文件`frame_animation.xml`\n```XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"false\">\n    <item\n        android:drawable=\"@mipmap/image1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/image2\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@mipmap/iamge2\"\n        android:duration=\"100\" />\n</animation-list>\n```\n然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可\n```Java\nview.setBackgroundResource(R.drawable.frame_animation)；\nAnimationDrawable drawable = (AnimationDrawable) view.getBackground();\ndrawable.start();\n```\n\n## Property Animation\n属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：\n- 补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。\n- 补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。\n\n与补间动画类似，属性动画也需要定义几个方面的属性：\n- 动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。\n- 动画插值方式。通过 android:interploator 指定。\n- 动画重复次数。通过 android:repeatCount 指定。\n- 重复行为。通过 android:repeatMode 指定。\n- 动画集。在属性资源文件中通过 `<set>` 来组合。\n- 帧刷新率。指定多长时间播放一帧。默认为 10 ms。\n\n### API\n- ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。\n- ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。\n- AnimatorSet：Animator 的子类，用于组合多个 Animator。\n\n属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。\n- IntEvaluator：计算 int 类型属性值的计算器。\n- FloatEvaluator：用于计算 float 类型属性值的计算器。\n- ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。\n- TypeEvaluator：可以自定义计算器。\n\n### ValueAniamtor\nValueAnimator 类中有3个重要方法：\n> ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)\n\n#### ofInt\n将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator\n\n下面的代码将实现按钮的宽度从 150px 放大到 500px\n```Java\n    Button mButton = (Button) findViewById(R.id.Button);\n    // 设置属性数值的初始值 & 结束值\n    // ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500\n    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, 500);\n  \n    // 设置动画的播放各种属性\n    valueAnimator.setDuration(2000);\n\n    // 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度\n    // 设置更新监听器，数值每次变化更新都会调用该方法\n    valueAnimator.addUpdateListener(new AnimatorUpdateListener() {\n    \n        @Override\n        public void onAnimationUpdate(ValueAnimator animator) {\n            // 获得每次变化后的属性值\n            int currentValue = (Integer) animator.getAnimatedValue();\n            // 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化\n            mButton.getLayoutParams().width = currentValue;\n            \n            // 刷新视图，即重新绘制\n            mButton.requestLayout();\n        }\n    });\n    valueAnimator.start();  // 启动动画\n}\n```\n\n#### ofFloat\n其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）\n```Java\npublic class FloatEvaluator implements TypeEvaluator {  \n\n    /**\n     * 重写evaluate()\n     *\n     * @param fraction 动画完成度（根据它来计算当前动画的值）\n     * @param startValue 动画的初始值\n     * @param endValue 动画的结束值\n     * @return \n     */\n    public Object evaluate(float fraction, Object startValue, Object endValue) {  \n\n        float startFloat = ((Number) startValue).floatValue();  \n        \n        // 初始值过渡到结束值的算法\n        // 1. 用结束值减去初始值，算出它们之间的差值\n        // 2. 用上述差值乘以 fraction 系数\n        // 3. 加上初始值，得到当前动画的值\n        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  \n    }  \n}  \n```\n\n#### ofObject\n对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。\n\n但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。\n\n自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。\n\n```Java\npublic class PointEvaluator implements TypeEvaluator {\n\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        // 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n\n        // 根据fraction来计算当前动画的x和y的值\n        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());\n        \n        // 将计算后的坐标封装到一个新的Point对象中并返回\n        Point point = new Point(x, y);\n        return point;\n    }\n}\n```\n将属性动画作用到自定义View当中\n```Java\npublic class MyView extends View {\n\n    public static final float RADIUS = 70f;// 圆的半径\n    private Point currentPoint;// 当前点坐标\n    private Paint mPaint;// 绘图画笔\n    \n    // 构造方法，初始化画笔\n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    // 实现绘制逻辑\n    // 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果\n    @Override\n    protected void onDraw(Canvas canvas) {\n        // 如果当前点坐标为空(即第一次)\n        if (currentPoint == null) {\n            currentPoint = new Point(RADIUS, RADIUS);  // 创建一个点对象(坐标是(70,70))\n\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n\n            // 将属性动画作用到View中\n            Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70)\n            Point endPoint = new Point(700, 1000);// 结束点为(700,1000)\n\n            ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);\n            anim.setDuration(5000);\n    \n            anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override\n                public void onAnimationUpdate(ValueAnimator animation) {\n                    currentPoint = (Point) animation.getAnimatedValue();\n                    // 每次赋值后就重新绘制，从而实现动画效果\n                    // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次\n                    invalidate();  \n                }\n            });\n            anim.start();\n        } else {\n            // 如果坐标值不为0,则画圆\n            float x = currentPoint.getX();\n            float y = currentPoint.getY();\n            canvas.drawCircle(x, y, RADIUS, mPaint);\n        }\n    }\n}\n```\n\n### ObjectAnimator\n继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。\nObjectAnimator 与 ValueAnimator类的区别在于\n- ValueAnimator 类是先改变值，然后**手动赋值**给对象的属性从而实现动画，属于**间接**对对象属性进行操作\n- ObjectAnimator 类是先改变值，然后**自动赋值**给对象的属性从而实现动画，属于**直接**对对象属性进行操作\n\n#### 具体使用\n对于\n> ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ....values); \n\n其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值\n\n对 Button 进行变换\n```Java\n\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  // 效果:常规->全透明->常规\nObjectAnimator animator = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);\n......\nanimator.setDuration(5000);\nanimator.start();\n```\n\n#### 自定义\n在上面的例子中，我们给`ObjectAnimator.ofFloat`的第二个参数`String property`传入`alpha`、`rotation`、`translationX` 和`scaleY`等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的`get/set`方法进行的。\n\n所以自定义属性就可以通过为对象设置需要操作属性的`set/get`方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。\n\n还是对一个球做变换\n```Java\npublic class MyView2 extends View {\n    public static final float RADIUS = 100f;\n    private Paint mPaint;\n\n    private String color;  // 设置背景颜色属性\n\n    // 设置背景颜色的get() & set()方法\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n        mPaint.setColor(Color.parseColor(color));  // 将画笔的颜色设置成方法参数传入的颜色\n        invalidate();\n    }\n\n    public MyView2(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        canvas.drawCircle(500, 500, RADIUS, mPaint);\n    }\n}\n```\n实现自定义估值器，完成颜色过渡的逻辑\n```Java\npublic class ColorEvaluator implements TypeEvaluator {\n\n    private int mCurrentRed;\n\n    private int mCurrentGreen ;\n\n    private int mCurrentBlue ;\n\n    // 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n\n        String startColor = (String) startValue;\n        String endColor = (String) endValue;\n\n        // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字\n        // 那么每个颜色的取值范围是0-255\n        int startRed = Integer.parseInt(startColor.substring(1, 3), 16);\n        int startGreen = Integer.parseInt(startColor.substring(3, 5), 16);\n        int startBlue = Integer.parseInt(startColor.substring(5, 7), 16);\n\n        int endRed = Integer.parseInt(endColor.substring(1, 3), 16);\n        int endGreen = Integer.parseInt(endColor.substring(3, 5), 16);\n        int endBlue = Integer.parseInt(endColor.substring(5, 7), 16);\n\n        // 将初始化颜色的值定义为当前需要操作的颜色值\n        mCurrentRed = startRed;\n        mCurrentGreen = startGreen;\n        mCurrentBlue = startBlue;\n\n\n        // 计算初始颜色和结束颜色之间的差值\n        // 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢\n        int redDiff = Math.abs(startRed - endRed);\n        int greenDiff = Math.abs(startGreen - endGreen);\n        int blueDiff = Math.abs(startBlue - endBlue);\n        int colorDiff = redDiff + greenDiff + blueDiff;\n        \n        if (mCurrentRed != endRed) {\n            // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 ->>关注1\n            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0, fraction);\n        \n        } else if (mCurrentGreen != endGreen) {\n            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);\n            \n        } else if (mCurrentBlue != endBlue) {\n            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);\n        }\n        // 将计算出的当前颜色的值组装返回\n        String currentColor = \"#\" + getHexString(mCurrentRed)\n                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);\n        return currentColor;\n    }\n\n\n\n    // 根据fraction值来计算当前的颜色。\n    private int getCurrentColor(int startColor, int endColor, int colorDiff,\n                                int offset, float fraction) {\n        int currentColor;\n        if (startColor > endColor) {\n            currentColor = (int) (startColor - (fraction * colorDiff - offset));\n            if (currentColor < endColor) {\n                currentColor = endColor;\n            }\n        } else {\n            currentColor = (int) (startColor + (fraction * colorDiff - offset));\n            if (currentColor > endColor) {\n                currentColor = endColor;\n            }\n        }\n        return currentColor;\n    }\n\n    // 将10进制颜色值转换成16进制。\n    private String getHexString(int value) {\n        String hexString = Integer.toHexString(value);\n        if (hexString.length() == 1) {\n            hexString = \"0\" + hexString;\n        }\n        return hexString;\n    }\n}\n```\n具体调用\n```Java\nObjectAnimator anim = ObjectAnimator.ofObject(myView2, \"color\", new ColorEvaluator(), \"#0000FF\", \"#FF0000\");\nanim.setDuration(2000);\nanim.start();\n```\n\n此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中`setWidth`并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过`get/set`无法改变控件的宽度，也就无法实现动画效果。\n\n解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的`get/set`方法。\n```Java\nButtonWrapper wrapper = new ViewWrapper(button);\nObjectAnimator.ofInt(wrapper, \"width\", 500)\n        .setDuration(3000)\n        .start();\n\nprivate static class ViewWrapper {\n    private View mTarget;\n\n    public ViewWrapper(View target) {\n        mTarget = target;\n    }\n    \n    // 为宽度设置get/set\n    public int getWidth() {\n            return mTarget.getLayoutParams().width;\n    }\n    \n    public void setWidth(int width) {\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n```\n\n### AnimatorSet\n最后介绍组合动画类，仅展示用法\n```Java\n\nObjectAnimator translation = ObjectAnimator.ofFloat(mButton, \"translationX\", curTranslationX, 300,curTranslationX);  \nObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, \"rotation\", 0f, 360f);  \nObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, \"alpha\", 1f, 0f, 1f);  \n\nAnimatorSet animSet = new AnimatorSet();  \n\nanimSet.play(translation).with(rotate).before(alpha);  \nanimSet.setDuration(5000);  \nanimSet.start();  \n```\n## Spring Animation\nSpringAnimation，弹簧动画，位于`android.support.animation`包中，属性动画位于`android.animation.Animator`包中，其实通过 [BounceInterpolator](https://developer.android.com/reference/android/view/animation/BounceInterpolator.html) 或者 [OvershootInterpolator](https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html) 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。\n\n使用之前需要导入`com.android.support:support-dynamic-animation`包\n\n### API\n```Java\npublic SpringAnimation(View v, ViewProperty property)\npublic SpringAnimation(View v, ViewProperty property, float finalPosition)\n```\n参数分别是操作对应的View，对应的变化属性及最终的位置。\n\nViewProperty 包括(Z轴支持需要API >= 21)：\n>TRANSLATION_X\n>TRANSLATION_Y\n>TRANSLATION_Z\n>SCALE_X\n>SCALE_Y\n>ROTATION\n>ROTATION_X\n>ROTATION_Y\n>X\n>Y\n>Z\n>ALPHA\n>SCROLL_X\n>SCROLL_Y\n\n在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量\n- Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快\n- DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ > 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 < ζ <1)。\n\n### 简单使用\n```Java\nSpringAnimation btnAnim = new SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, 0);\n\nbtnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);\nbtnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);\n\nbtnAnim.setStartVelocity(10000);  //开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反\nbtnAnim.start();\n```","slug":"Android-动画详解","published":1,"updated":"2019-03-15T15:28:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavdt0030i0upn559qva5","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。<a id=\"more\"></a></p>\n<h2 id=\"View-Animation\"><a href=\"#View-Animation\" class=\"headerlink\" title=\"View Animation\"></a>View Animation</h2><p>视图动画的作用对象是 View，可分为补间动画和帧动画。</p>\n<h3 id=\"补间动画\"><a href=\"#补间动画\" class=\"headerlink\" title=\"补间动画\"></a>补间动画</h3><p>动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。</p>\n<h4 id=\"XML-方式\"><a href=\"#XML-方式\" class=\"headerlink\" title=\"XML 方式\"></a>XML 方式</h4><p>创建一个 set.xml 文件，通过动画集合标签<code>&lt;set&gt;</code>将四种效果结合起来<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">--动画集合</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">interpolator</span> 表示所采用的的差值器，其影响动画的速度，可以不指定</span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">shareInterpolator</span> 表示集合中的动画是否和集合共享同一个差值器<span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">set</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shareInterpolator</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:repeatMode</span>=<span class=\"string\">\"reverse\"</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 缩放动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromXScale 表示水平方向缩放的起始值</span></span><br><span class=\"line\"><span class=\"comment\">    toXScale 表示水平方向的结束值</span></span><br><span class=\"line\"><span class=\"comment\">    fillAfter 表示动画显示结束保持最后一帧--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scale</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:repeatCount</span>=<span class=\"string\">\"infinite\"</span>/&gt;</span><span class=\"comment\">&lt;!--次数 ,infinite 为无线循环播放--&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 透明度动画</span></span><br><span class=\"line\"><span class=\"comment\">        fromAlpha 表示起始透明度</span></span><br><span class=\"line\"><span class=\"comment\">        toAlpha 表示结束透明度--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">alpha</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromAlpha</span>=<span class=\"string\">\"0.7\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toAlpha</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--旋转动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromDegrees 表示起始角度</span></span><br><span class=\"line\"><span class=\"comment\">    toDegrees 表示结束角度--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rotate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromDegrees</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toDegrees</span>=<span class=\"string\">\"90\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span>/&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--平移动画--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">translate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXDelta</span>=<span class=\"string\">\"100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYDelta</span>=<span class=\"string\">\"-100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用以上动画的方式如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);</span><br><span class=\"line\">view.startAnimation(anim);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Java-代码方式\"><a href=\"#Java-代码方式\" class=\"headerlink\" title=\"Java 代码方式\"></a>Java 代码方式</h4><p>使用 Java 代码实现动画的方式如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startAnimationSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建动画，参数表示他的子动画是否共用一个插值器</span></span><br><span class=\"line\">    AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//添加动画</span></span><br><span class=\"line\">    animationSet.addAnimation(<span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>));</span><br><span class=\"line\">    <span class=\"comment\">//设置插值器</span></span><br><span class=\"line\">    animationSet.setInterpolator(<span class=\"keyword\">new</span> LinearInterpolator());</span><br><span class=\"line\">    <span class=\"comment\">//设置动画持续时长</span></span><br><span class=\"line\">    animationSet.setDuration(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画的目标状态</span></span><br><span class=\"line\">    animationSet.setFillAfter(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画开始时的状态</span></span><br><span class=\"line\">    animationSet.setFillBefore(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复模式</span></span><br><span class=\"line\">    animationSet.setRepeatMode(AnimationSet.REVERSE);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复次数</span></span><br><span class=\"line\">    animationSet.setRepeatCount(AnimationSet.INFINITE);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画延时时间</span></span><br><span class=\"line\">    animationSet.setStartOffset(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//取消动画</span></span><br><span class=\"line\">    animationSet.cancel();</span><br><span class=\"line\">    <span class=\"comment\">//释放资源</span></span><br><span class=\"line\">    animationSet.reset();</span><br><span class=\"line\">    <span class=\"comment\">//开始动画</span></span><br><span class=\"line\">    view.startAnimation(animationSet);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的<code>initialize</code>和<code>applyTransformation</code>方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 </p>\n<h4 id=\"特殊使用\"><a href=\"#特殊使用\" class=\"headerlink\" title=\"特殊使用\"></a>特殊使用</h4><p>View 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。</p>\n<h3 id=\"帧动画\"><a href=\"#帧动画\" class=\"headerlink\" title=\"帧动画\"></a>帧动画</h3><p>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。</p>\n<p>首先需要定义一个 XML 文件<code>frame_animation.xml</code><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">animation-list</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:oneshot</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/iamge2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.setBackgroundResource(R.drawable.frame_animation)；</span><br><span class=\"line\">AnimationDrawable drawable = (AnimationDrawable) view.getBackground();</span><br><span class=\"line\">drawable.start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Property-Animation\"><a href=\"#Property-Animation\" class=\"headerlink\" title=\"Property Animation\"></a>Property Animation</h2><p>属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：</p>\n<ul>\n<li>补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。</li>\n<li>补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。</li>\n</ul>\n<p>与补间动画类似，属性动画也需要定义几个方面的属性：</p>\n<ul>\n<li>动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。</li>\n<li>动画插值方式。通过 android:interploator 指定。</li>\n<li>动画重复次数。通过 android:repeatCount 指定。</li>\n<li>重复行为。通过 android:repeatMode 指定。</li>\n<li>动画集。在属性资源文件中通过 <code>&lt;set&gt;</code> 来组合。</li>\n<li>帧刷新率。指定多长时间播放一帧。默认为 10 ms。</li>\n</ul>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。</li>\n<li>ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。</li>\n<li>AnimatorSet：Animator 的子类，用于组合多个 Animator。</li>\n</ul>\n<p>属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。</p>\n<ul>\n<li>IntEvaluator：计算 int 类型属性值的计算器。</li>\n<li>FloatEvaluator：用于计算 float 类型属性值的计算器。</li>\n<li>ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。</li>\n<li>TypeEvaluator：可以自定义计算器。</li>\n</ul>\n<h3 id=\"ValueAniamtor\"><a href=\"#ValueAniamtor\" class=\"headerlink\" title=\"ValueAniamtor\"></a>ValueAniamtor</h3><p>ValueAnimator 类中有3个重要方法：</p>\n<blockquote>\n<p>ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)</p>\n</blockquote>\n<h4 id=\"ofInt\"><a href=\"#ofInt\" class=\"headerlink\" title=\"ofInt\"></a>ofInt</h4><p>将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator</p>\n<p>下面的代码将实现按钮的宽度从 150px 放大到 500px<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Button mButton = (Button) findViewById(R.id.Button);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性数值的初始值 &amp; 结束值</span></span><br><span class=\"line\">    <span class=\"comment\">// ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500</span></span><br><span class=\"line\">    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, <span class=\"number\">500</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置动画的播放各种属性</span></span><br><span class=\"line\">    valueAnimator.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置更新监听器，数值每次变化更新都会调用该方法</span></span><br><span class=\"line\">    valueAnimator.addUpdateListener(<span class=\"keyword\">new</span> AnimatorUpdateListener() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animator)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得每次变化后的属性值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> currentValue = (Integer) animator.getAnimatedValue();</span><br><span class=\"line\">            <span class=\"comment\">// 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化</span></span><br><span class=\"line\">            mButton.getLayoutParams().width = currentValue;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 刷新视图，即重新绘制</span></span><br><span class=\"line\">            mButton.requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    valueAnimator.start();  <span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ofFloat\"><a href=\"#ofFloat\" class=\"headerlink\" title=\"ofFloat\"></a>ofFloat</h4><p>其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FloatEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 重写evaluate()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fraction 动画完成度（根据它来计算当前动画的值）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> startValue 动画的初始值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> endValue 动画的结束值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> startFloat = ((Number) startValue).floatValue();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始值过渡到结束值的算法</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 用结束值减去初始值，算出它们之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 用上述差值乘以 fraction 系数</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 加上初始值，得到当前动画的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ofObject\"><a href=\"#ofObject\" class=\"headerlink\" title=\"ofObject\"></a>ofObject</h4><p>对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。</p>\n<p>但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。</p>\n<p>自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PointEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象</span></span><br><span class=\"line\">        Point startPoint = (Point) startValue;</span><br><span class=\"line\">        Point endPoint = (Point) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据fraction来计算当前动画的x和y的值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());</span><br><span class=\"line\">        <span class=\"keyword\">float</span> y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将计算后的坐标封装到一个新的Point对象中并返回</span></span><br><span class=\"line\">        Point point = <span class=\"keyword\">new</span> Point(x, y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将属性动画作用到自定义View当中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">70f</span>;<span class=\"comment\">// 圆的半径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point currentPoint;<span class=\"comment\">// 当前点坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;<span class=\"comment\">// 绘图画笔</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造方法，初始化画笔</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现绘制逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前点坐标为空(即第一次)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentPoint == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            currentPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);  <span class=\"comment\">// 创建一个点对象(坐标是(70,70))</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将属性动画作用到View中</span></span><br><span class=\"line\">            Point startPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);<span class=\"comment\">// 初始点为圆心(70,70)</span></span><br><span class=\"line\">            Point endPoint = <span class=\"keyword\">new</span> Point(<span class=\"number\">700</span>, <span class=\"number\">1000</span>);<span class=\"comment\">// 结束点为(700,1000)</span></span><br><span class=\"line\"></span><br><span class=\"line\">            ValueAnimator anim = ValueAnimator.ofObject(<span class=\"keyword\">new</span> PointEvaluator(), startPoint, endPoint);</span><br><span class=\"line\">            anim.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">            anim.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">                    currentPoint = (Point) animation.getAnimatedValue();</span><br><span class=\"line\">                    <span class=\"comment\">// 每次赋值后就重新绘制，从而实现动画效果</span></span><br><span class=\"line\">                    <span class=\"comment\">// 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次</span></span><br><span class=\"line\">                    invalidate();  </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            anim.start();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果坐标值不为0,则画圆</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h3><p>继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。<br>ObjectAnimator 与 ValueAnimator类的区别在于</p>\n<ul>\n<li>ValueAnimator 类是先改变值，然后<strong>手动赋值</strong>给对象的属性从而实现动画，属于<strong>间接</strong>对对象属性进行操作</li>\n<li>ObjectAnimator 类是先改变值，然后<strong>自动赋值</strong>给对象的属性从而实现动画，属于<strong>直接</strong>对对象属性进行操作</li>\n</ul>\n<h4 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h4><p>对于</p>\n<blockquote>\n<p>ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ….values); </p>\n</blockquote>\n<p>其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值</p>\n<p>对 Button 进行变换<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  <span class=\"comment\">// 效果:常规-&gt;全透明-&gt;常规</span></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);</span><br><span class=\"line\">......</span><br><span class=\"line\">animator.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自定义-1\"><a href=\"#自定义-1\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>在上面的例子中，我们给<code>ObjectAnimator.ofFloat</code>的第二个参数<code>String property</code>传入<code>alpha</code>、<code>rotation</code>、<code>translationX</code> 和<code>scaleY</code>等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的<code>get/set</code>方法进行的。</p>\n<p>所以自定义属性就可以通过为对象设置需要操作属性的<code>set/get</code>方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。</p>\n<p>还是对一个球做变换<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView2</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">100f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String color;  <span class=\"comment\">// 设置背景颜色属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置背景颜色的get() &amp; set()方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getColor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">        mPaint.setColor(Color.parseColor(color));  <span class=\"comment\">// 将画笔的颜色设置成方法参数传入的颜色</span></span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView2</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        canvas.drawCircle(<span class=\"number\">500</span>, <span class=\"number\">500</span>, RADIUS, mPaint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现自定义估值器，完成颜色过渡的逻辑<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentRed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentGreen ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentBlue ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String startColor = (String) startValue;</span><br><span class=\"line\">        String endColor = (String) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么每个颜色的取值范围是0-255</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> startRed = Integer.parseInt(startColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startGreen = Integer.parseInt(startColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startBlue = Integer.parseInt(startColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> endRed = Integer.parseInt(endColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endGreen = Integer.parseInt(endColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endBlue = Integer.parseInt(endColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将初始化颜色的值定义为当前需要操作的颜色值</span></span><br><span class=\"line\">        mCurrentRed = startRed;</span><br><span class=\"line\">        mCurrentGreen = startGreen;</span><br><span class=\"line\">        mCurrentBlue = startBlue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算初始颜色和结束颜色之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> redDiff = Math.abs(startRed - endRed);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> greenDiff = Math.abs(startGreen - endGreen);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> blueDiff = Math.abs(startBlue - endBlue);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> colorDiff = redDiff + greenDiff + blueDiff;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCurrentRed != endRed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// getCurrentColor()决定如何根据差值来决定颜色变化的快慢 -&gt;&gt;关注1</span></span><br><span class=\"line\">            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, <span class=\"number\">0</span>, fraction);</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentGreen != endGreen) &#123;</span><br><span class=\"line\">            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentBlue != endBlue) &#123;</span><br><span class=\"line\">            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将计算出的当前颜色的值组装返回</span></span><br><span class=\"line\">        String currentColor = <span class=\"string\">\"#\"</span> + getHexString(mCurrentRed)</span><br><span class=\"line\">                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据fraction值来计算当前的颜色。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getCurrentColor</span><span class=\"params\">(<span class=\"keyword\">int</span> startColor, <span class=\"keyword\">int</span> endColor, <span class=\"keyword\">int</span> colorDiff,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> offset, <span class=\"keyword\">float</span> fraction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentColor;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startColor &gt; endColor) &#123;</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor - (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor &lt; endColor) &#123;</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor + (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor &gt; endColor) &#123;</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将10进制颜色值转换成16进制。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getHexString</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        String hexString = Integer.toHexString(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hexString.length() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            hexString = <span class=\"string\">\"0\"</span> + hexString;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hexString;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator anim = ObjectAnimator.ofObject(myView2, <span class=\"string\">\"color\"</span>, <span class=\"keyword\">new</span> ColorEvaluator(), <span class=\"string\">\"#0000FF\"</span>, <span class=\"string\">\"#FF0000\"</span>);</span><br><span class=\"line\">anim.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\">anim.start();</span><br></pre></td></tr></table></figure></p>\n<p>此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中<code>setWidth</code>并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过<code>get/set</code>无法改变控件的宽度，也就无法实现动画效果。</p>\n<p>解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的<code>get/set</code>方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ButtonWrapper wrapper = <span class=\"keyword\">new</span> ViewWrapper(button);</span><br><span class=\"line\">ObjectAnimator.ofInt(wrapper, <span class=\"string\">\"width\"</span>, <span class=\"number\">500</span>)</span><br><span class=\"line\">        .setDuration(<span class=\"number\">3000</span>)</span><br><span class=\"line\">        .start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewWrapper</span><span class=\"params\">(View target)</span> </span>&#123;</span><br><span class=\"line\">        mTarget = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 为宽度设置get/set</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWidth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mTarget.getLayoutParams().width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> width)</span> </span>&#123;</span><br><span class=\"line\">        mTarget.getLayoutParams().width = width;</span><br><span class=\"line\">        mTarget.requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AnimatorSet\"><a href=\"#AnimatorSet\" class=\"headerlink\" title=\"AnimatorSet\"></a>AnimatorSet</h3><p>最后介绍组合动画类，仅展示用法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"translationX\"</span>, curTranslationX, <span class=\"number\">300</span>,curTranslationX);  </span><br><span class=\"line\">ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);  </span><br><span class=\"line\">ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">AnimatorSet animSet = <span class=\"keyword\">new</span> AnimatorSet();  </span><br><span class=\"line\"></span><br><span class=\"line\">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class=\"line\">animSet.setDuration(<span class=\"number\">5000</span>);  </span><br><span class=\"line\">animSet.start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Spring-Animation\"><a href=\"#Spring-Animation\" class=\"headerlink\" title=\"Spring Animation\"></a>Spring Animation</h2><p>SpringAnimation，弹簧动画，位于<code>android.support.animation</code>包中，属性动画位于<code>android.animation.Animator</code>包中，其实通过 <a href=\"https://developer.android.com/reference/android/view/animation/BounceInterpolator.html\" target=\"_blank\" rel=\"noopener\">BounceInterpolator</a> 或者 <a href=\"https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html\" target=\"_blank\" rel=\"noopener\">OvershootInterpolator</a> 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。</p>\n<p>使用之前需要导入<code>com.android.support:support-dynamic-animation</code>包</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property, <span class=\"keyword\">float</span> finalPosition)</span></span></span><br></pre></td></tr></table></figure>\n<p>参数分别是操作对应的View，对应的变化属性及最终的位置。</p>\n<p>ViewProperty 包括(Z轴支持需要API &gt;= 21)：</p>\n<blockquote>\n<p>TRANSLATION_X<br>TRANSLATION_Y<br>TRANSLATION_Z<br>SCALE_X<br>SCALE_Y<br>ROTATION<br>ROTATION_X<br>ROTATION_Y<br>X<br>Y<br>Z<br>ALPHA<br>SCROLL_X<br>SCROLL_Y</p>\n</blockquote>\n<p>在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量</p>\n<ul>\n<li>Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快</li>\n<li>DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ &gt; 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 &lt; ζ &lt;1)。</li>\n</ul>\n<h3 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpringAnimation btnAnim = <span class=\"keyword\">new</span> SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);</span><br><span class=\"line\">btnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.setStartVelocity(<span class=\"number\">10000</span>);  <span class=\"comment\">//开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反</span></span><br><span class=\"line\">btnAnim.start();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Android 提供了很多丰富的 API 去实现动画效果，加上 SDK 25.3 时推出的 SpringAnimation，总共有三大类 Animation 供开发者使用。</p>","more":"<p></p>\n<h2 id=\"View-Animation\"><a href=\"#View-Animation\" class=\"headerlink\" title=\"View Animation\"></a>View Animation</h2><p>视图动画的作用对象是 View，可分为补间动画和帧动画。</p>\n<h3 id=\"补间动画\"><a href=\"#补间动画\" class=\"headerlink\" title=\"补间动画\"></a>补间动画</h3><p>动画开始和结尾的中间过程都是假象，是渲染出来的表象，只是显示的位置变动，View的实际位置未改变，表现为View移动到其他地方，点击事件仍在原处才能响应。利用补间动画，同一个图形在界面上可以进行透明度（AlphaAnimation）、缩放（ScaleAnimation）、旋转（RotateAnimation）、平移（TranslateAnimation）的变化。</p>\n<h4 id=\"XML-方式\"><a href=\"#XML-方式\" class=\"headerlink\" title=\"XML 方式\"></a>XML 方式</h4><p>创建一个 set.xml 文件，通过动画集合标签<code>&lt;set&gt;</code>将四种效果结合起来<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">--动画集合</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">interpolator</span> 表示所采用的的差值器，其影响动画的速度，可以不指定</span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">shareInterpolator</span> 表示集合中的动画是否和集合共享同一个差值器<span class=\"attr\">--</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">set</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shareInterpolator</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:repeatMode</span>=<span class=\"string\">\"reverse\"</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 缩放动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromXScale 表示水平方向缩放的起始值</span></span><br><span class=\"line\"><span class=\"comment\">    toXScale 表示水平方向的结束值</span></span><br><span class=\"line\"><span class=\"comment\">    fillAfter 表示动画显示结束保持最后一帧--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scale</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYScale</span>=<span class=\"string\">\"0.5\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYScale</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:repeatCount</span>=<span class=\"string\">\"infinite\"</span>/&gt;</span><span class=\"comment\">&lt;!--次数 ,infinite 为无线循环播放--&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 透明度动画</span></span><br><span class=\"line\"><span class=\"comment\">        fromAlpha 表示起始透明度</span></span><br><span class=\"line\"><span class=\"comment\">        toAlpha 表示结束透明度--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">alpha</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromAlpha</span>=<span class=\"string\">\"0.7\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toAlpha</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--旋转动画</span></span><br><span class=\"line\"><span class=\"comment\">    fromDegrees 表示起始角度</span></span><br><span class=\"line\"><span class=\"comment\">    toDegrees 表示结束角度--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rotate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromDegrees</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toDegrees</span>=<span class=\"string\">\"90\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"1000\"</span>/&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--平移动画--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">translate</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromXDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fromYDelta</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toXDelta</span>=<span class=\"string\">\"100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:toYDelta</span>=<span class=\"string\">\"-100%\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:fillAfter</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用以上动画的方式如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation anim = AnimationUtils.loadAnimation(context, R.anim.my_animation);</span><br><span class=\"line\">view.startAnimation(anim);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Java-代码方式\"><a href=\"#Java-代码方式\" class=\"headerlink\" title=\"Java 代码方式\"></a>Java 代码方式</h4><p>使用 Java 代码实现动画的方式如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startAnimationSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建动画，参数表示他的子动画是否共用一个插值器</span></span><br><span class=\"line\">    AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//添加动画</span></span><br><span class=\"line\">    animationSet.addAnimation(<span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>));</span><br><span class=\"line\">    <span class=\"comment\">//设置插值器</span></span><br><span class=\"line\">    animationSet.setInterpolator(<span class=\"keyword\">new</span> LinearInterpolator());</span><br><span class=\"line\">    <span class=\"comment\">//设置动画持续时长</span></span><br><span class=\"line\">    animationSet.setDuration(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画的目标状态</span></span><br><span class=\"line\">    animationSet.setFillAfter(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画结束之后是否保持动画开始时的状态</span></span><br><span class=\"line\">    animationSet.setFillBefore(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复模式</span></span><br><span class=\"line\">    animationSet.setRepeatMode(AnimationSet.REVERSE);</span><br><span class=\"line\">    <span class=\"comment\">//设置重复次数</span></span><br><span class=\"line\">    animationSet.setRepeatCount(AnimationSet.INFINITE);</span><br><span class=\"line\">    <span class=\"comment\">//设置动画延时时间</span></span><br><span class=\"line\">    animationSet.setStartOffset(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    <span class=\"comment\">//取消动画</span></span><br><span class=\"line\">    animationSet.cancel();</span><br><span class=\"line\">    <span class=\"comment\">//释放资源</span></span><br><span class=\"line\">    animationSet.reset();</span><br><span class=\"line\">    <span class=\"comment\">//开始动画</span></span><br><span class=\"line\">    view.startAnimation(animationSet);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>除了系统自带的四种补间动画，我们还可以自定义 View 动画。派生一种动画只需要继承抽象类 Animation，然后重写它的<code>initialize</code>和<code>applyTransformation</code>方法即可，在前一个方法中做初始化工作，后一个方法中进行相应的矩阵变换，本文不再详细介绍。 </p>\n<h4 id=\"特殊使用\"><a href=\"#特殊使用\" class=\"headerlink\" title=\"特殊使用\"></a>特殊使用</h4><p>View 动画还可以用在控制 ViewGroup 中子元素的出场效果、实现不同 Activity 的切换效果等场景中。</p>\n<h3 id=\"帧动画\"><a href=\"#帧动画\" class=\"headerlink\" title=\"帧动画\"></a>帧动画</h3><p>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于补间动画，系统提供了另外一个类 AnimationDrawable 来使用帧动画。</p>\n<p>首先需要定义一个 XML 文件<code>frame_animation.xml</code><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">animation-list</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:oneshot</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/image2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@mipmap/iamge2\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:duration</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后将上述的 Drawable 作为 View 的背景并通过 Drawable 来播放动画即可<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.setBackgroundResource(R.drawable.frame_animation)；</span><br><span class=\"line\">AnimationDrawable drawable = (AnimationDrawable) view.getBackground();</span><br><span class=\"line\">drawable.start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Property-Animation\"><a href=\"#Property-Animation\" class=\"headerlink\" title=\"Property Animation\"></a>Property Animation</h2><p>属性动画在 API 11 引入，可以看作是增强版的补间动画，与补间动画的不同之处体现在：</p>\n<ul>\n<li>补间动画只能定义两个关键帧在透明、旋转、位移和倾斜这四个属性的变换，但是属性动画可以定义任何属性的变化。</li>\n<li>补间动画只能对 UI 组件执行动画，但属性动画可以对任何对象执行动画。</li>\n</ul>\n<p>与补间动画类似，属性动画也需要定义几个方面的属性：</p>\n<ul>\n<li>动画持续时间。默认为 300ms，可以通过 android:duration 属性指定。</li>\n<li>动画插值方式。通过 android:interploator 指定。</li>\n<li>动画重复次数。通过 android:repeatCount 指定。</li>\n<li>重复行为。通过 android:repeatMode 指定。</li>\n<li>动画集。在属性资源文件中通过 <code>&lt;set&gt;</code> 来组合。</li>\n<li>帧刷新率。指定多长时间播放一帧。默认为 10 ms。</li>\n</ul>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>ValueAnimator：属性动画用到的主要的时间引擎，负责计算各个帧的属性值。</li>\n<li>ObjectAnimator： ValueAnimator 的子类，对指定对象的属性执行动画。</li>\n<li>AnimatorSet：Animator 的子类，用于组合多个 Animator。</li>\n</ul>\n<p>属性动画还提供了一个 Evaluator ，用来控制如何计算属性值。</p>\n<ul>\n<li>IntEvaluator：计算 int 类型属性值的计算器。</li>\n<li>FloatEvaluator：用于计算 float 类型属性值的计算器。</li>\n<li>ArgbEvaluator：用于计算十六进制形式表示的颜色值的计算器。</li>\n<li>TypeEvaluator：可以自定义计算器。</li>\n</ul>\n<h3 id=\"ValueAniamtor\"><a href=\"#ValueAniamtor\" class=\"headerlink\" title=\"ValueAniamtor\"></a>ValueAniamtor</h3><p>ValueAnimator 类中有3个重要方法：</p>\n<blockquote>\n<p>ValueAnimator.ofInt(int values)<br>ValueAnimator.ofFloat(float values)<br>ValueAnimator.ofObject(int values)</p>\n</blockquote>\n<h4 id=\"ofInt\"><a href=\"#ofInt\" class=\"headerlink\" title=\"ofInt\"></a>ofInt</h4><p>将初始值以整型数值的形式过渡到结束值,即估值器是整型估值器 —— IntEvaluator</p>\n<p>下面的代码将实现按钮的宽度从 150px 放大到 500px<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Button mButton = (Button) findViewById(R.id.Button);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性数值的初始值 &amp; 结束值</span></span><br><span class=\"line\">    <span class=\"comment\">// ValueAnimator.ofInt()内置了整型估值器，默认设置了如何从初始值150 过渡到 结束值500</span></span><br><span class=\"line\">    ValueAnimator valueAnimator = ValueAnimator.ofInt(mButton.getLayoutParams().width, <span class=\"number\">500</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 设置动画的播放各种属性</span></span><br><span class=\"line\">    valueAnimator.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将属性数值手动赋值给对象的属性，此处是将值赋给按钮的宽度</span></span><br><span class=\"line\">    <span class=\"comment\">// 设置更新监听器，数值每次变化更新都会调用该方法</span></span><br><span class=\"line\">    valueAnimator.addUpdateListener(<span class=\"keyword\">new</span> AnimatorUpdateListener() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animator)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得每次变化后的属性值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> currentValue = (Integer) animator.getAnimatedValue();</span><br><span class=\"line\">            <span class=\"comment\">// 将值手动赋值给对象的属性，实现按钮宽度属性的动态变化</span></span><br><span class=\"line\">            mButton.getLayoutParams().width = currentValue;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 刷新视图，即重新绘制</span></span><br><span class=\"line\">            mButton.requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    valueAnimator.start();  <span class=\"comment\">// 启动动画</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ofFloat\"><a href=\"#ofFloat\" class=\"headerlink\" title=\"ofFloat\"></a>ofFloat</h4><p>其与 ofInt 的区别仅在于采用了浮点估值器（FloatEvaluator）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FloatEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 重写evaluate()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fraction 动画完成度（根据它来计算当前动画的值）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> startValue 动画的初始值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> endValue 动画的结束值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> startFloat = ((Number) startValue).floatValue();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始值过渡到结束值的算法</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 用结束值减去初始值，算出它们之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 用上述差值乘以 fraction 系数</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 加上初始值，得到当前动画的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ofObject\"><a href=\"#ofObject\" class=\"headerlink\" title=\"ofObject\"></a>ofObject</h4><p>对于 ValueAnimator.ofInt 和 ValueAnimator.ofFloat 来说，由于使用了系统内置的估值器 —— FloatEvaluator 和 IntEvaluator，所以已经默认实现了从初始值到结束值的逻辑。</p>\n<p>但对于 ValueAnimator.ofObject，并没有系统默认实现，因为对象的动画操作复杂多样，系统无法知道如何从初始对象过度到结束对象，因此需要自定义估值器（TypeEvaluator）来告知系统具体的逻辑。</p>\n<p>自定义一个估值器 PointEvaluator，实现一个圆从一个点移动到另外一个点。默认已经有了一个点坐标类：Point，其具有 x 和 y 两个浮点属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PointEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将动画初始值startValue 和 动画结束值endValue 类型转换成Point对象</span></span><br><span class=\"line\">        Point startPoint = (Point) startValue;</span><br><span class=\"line\">        Point endPoint = (Point) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据fraction来计算当前动画的x和y的值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());</span><br><span class=\"line\">        <span class=\"keyword\">float</span> y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将计算后的坐标封装到一个新的Point对象中并返回</span></span><br><span class=\"line\">        Point point = <span class=\"keyword\">new</span> Point(x, y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将属性动画作用到自定义View当中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">70f</span>;<span class=\"comment\">// 圆的半径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point currentPoint;<span class=\"comment\">// 当前点坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;<span class=\"comment\">// 绘图画笔</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造方法，初始化画笔</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现绘制逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// 先在初始点画圆，监听当前坐标值的变化，每次变化都调用onDraw()重新绘制圆，实现圆的平移动画效果</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前点坐标为空(即第一次)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentPoint == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            currentPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);  <span class=\"comment\">// 创建一个点对象(坐标是(70,70))</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将属性动画作用到View中</span></span><br><span class=\"line\">            Point startPoint = <span class=\"keyword\">new</span> Point(RADIUS, RADIUS);<span class=\"comment\">// 初始点为圆心(70,70)</span></span><br><span class=\"line\">            Point endPoint = <span class=\"keyword\">new</span> Point(<span class=\"number\">700</span>, <span class=\"number\">1000</span>);<span class=\"comment\">// 结束点为(700,1000)</span></span><br><span class=\"line\"></span><br><span class=\"line\">            ValueAnimator anim = ValueAnimator.ofObject(<span class=\"keyword\">new</span> PointEvaluator(), startPoint, endPoint);</span><br><span class=\"line\">            anim.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">            anim.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">                    currentPoint = (Point) animation.getAnimatedValue();</span><br><span class=\"line\">                    <span class=\"comment\">// 每次赋值后就重新绘制，从而实现动画效果</span></span><br><span class=\"line\">                    <span class=\"comment\">// 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次</span></span><br><span class=\"line\">                    invalidate();  </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            anim.start();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果坐标值不为0,则画圆</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> x = currentPoint.getX();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> y = currentPoint.getY();</span><br><span class=\"line\">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h3><p>继承自 ValueAnimator 类，即底层的动画实现机制基于 ValueAnimator。<br>ObjectAnimator 与 ValueAnimator类的区别在于</p>\n<ul>\n<li>ValueAnimator 类是先改变值，然后<strong>手动赋值</strong>给对象的属性从而实现动画，属于<strong>间接</strong>对对象属性进行操作</li>\n<li>ObjectAnimator 类是先改变值，然后<strong>自动赋值</strong>给对象的属性从而实现动画，属于<strong>直接</strong>对对象属性进行操作</li>\n</ul>\n<h4 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h4><p>对于</p>\n<blockquote>\n<p>ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ….values); </p>\n</blockquote>\n<p>其中 values 参数不定，表示动画初始值和结束值，如果是两个参数a,b，则动画效果是从属性的a值到b值；如果是三个参数a,b,c，则动画效果是从属性的a值到b值再到c值</p>\n<p>对 Button 进行变换<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  <span class=\"comment\">// 效果:常规-&gt;全透明-&gt;常规</span></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);</span><br><span class=\"line\">......</span><br><span class=\"line\">animator.setDuration(<span class=\"number\">5000</span>);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自定义-1\"><a href=\"#自定义-1\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><p>在上面的例子中，我们给<code>ObjectAnimator.ofFloat</code>的第二个参数<code>String property</code>传入<code>alpha</code>、<code>rotation</code>、<code>translationX</code> 和<code>scaleY</code>等值，实际上，我们可以传任意属性值，因为 ObjectAnimator 类实现动画效果的本质是：不断控制值的变化，再不断自动赋给对象的属性，赋值的过程是通过调用对象的<code>get/set</code>方法进行的。</p>\n<p>所以自定义属性就可以通过为对象设置需要操作属性的<code>set/get</code>方法，再实现 TypeEvaluator 定义属性变化的逻辑完成。</p>\n<p>还是对一个球做变换<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView2</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> RADIUS = <span class=\"number\">100f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String color;  <span class=\"comment\">// 设置背景颜色属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置背景颜色的get() &amp; set()方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getColor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(String color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">        mPaint.setColor(Color.parseColor(color));  <span class=\"comment\">// 将画笔的颜色设置成方法参数传入的颜色</span></span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView2</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        canvas.drawCircle(<span class=\"number\">500</span>, <span class=\"number\">500</span>, RADIUS, mPaint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现自定义估值器，完成颜色过渡的逻辑<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorEvaluator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeEvaluator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentRed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentGreen ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentBlue ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重写evaluate，写入对象动画过渡的逻辑，此处为颜色过渡</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"keyword\">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String startColor = (String) startValue;</span><br><span class=\"line\">        String endColor = (String) endValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么每个颜色的取值范围是0-255</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> startRed = Integer.parseInt(startColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startGreen = Integer.parseInt(startColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> startBlue = Integer.parseInt(startColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> endRed = Integer.parseInt(endColor.substring(<span class=\"number\">1</span>, <span class=\"number\">3</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endGreen = Integer.parseInt(endColor.substring(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> endBlue = Integer.parseInt(endColor.substring(<span class=\"number\">5</span>, <span class=\"number\">7</span>), <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将初始化颜色的值定义为当前需要操作的颜色值</span></span><br><span class=\"line\">        mCurrentRed = startRed;</span><br><span class=\"line\">        mCurrentGreen = startGreen;</span><br><span class=\"line\">        mCurrentBlue = startBlue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算初始颜色和结束颜色之间的差值</span></span><br><span class=\"line\">        <span class=\"comment\">// 该差值决定着颜色变化的快慢，如果初始颜色值和结束颜色值相近，变化会比较缓慢</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> redDiff = Math.abs(startRed - endRed);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> greenDiff = Math.abs(startGreen - endGreen);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> blueDiff = Math.abs(startBlue - endBlue);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> colorDiff = redDiff + greenDiff + blueDiff;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCurrentRed != endRed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// getCurrentColor()决定如何根据差值来决定颜色变化的快慢 -&gt;&gt;关注1</span></span><br><span class=\"line\">            mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, <span class=\"number\">0</span>, fraction);</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentGreen != endGreen) &#123;</span><br><span class=\"line\">            mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mCurrentBlue != endBlue) &#123;</span><br><span class=\"line\">            mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将计算出的当前颜色的值组装返回</span></span><br><span class=\"line\">        String currentColor = <span class=\"string\">\"#\"</span> + getHexString(mCurrentRed)</span><br><span class=\"line\">                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据fraction值来计算当前的颜色。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getCurrentColor</span><span class=\"params\">(<span class=\"keyword\">int</span> startColor, <span class=\"keyword\">int</span> endColor, <span class=\"keyword\">int</span> colorDiff,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> offset, <span class=\"keyword\">float</span> fraction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentColor;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startColor &gt; endColor) &#123;</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor - (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor &lt; endColor) &#123;</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            currentColor = (<span class=\"keyword\">int</span>) (startColor + (fraction * colorDiff - offset));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentColor &gt; endColor) &#123;</span><br><span class=\"line\">                currentColor = endColor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将10进制颜色值转换成16进制。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getHexString</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        String hexString = Integer.toHexString(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hexString.length() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            hexString = <span class=\"string\">\"0\"</span> + hexString;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hexString;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator anim = ObjectAnimator.ofObject(myView2, <span class=\"string\">\"color\"</span>, <span class=\"keyword\">new</span> ColorEvaluator(), <span class=\"string\">\"#0000FF\"</span>, <span class=\"string\">\"#FF0000\"</span>);</span><br><span class=\"line\">anim.setDuration(<span class=\"number\">2000</span>);</span><br><span class=\"line\">anim.start();</span><br></pre></td></tr></table></figure></p>\n<p>此时还有一个问题需要我们解决：如果需要对 view 控件（比如 button）的宽高做变换，但是由于因为 View 中<code>setWidth</code>并不是设置 View 的宽度，而是设置控件的最大和最小宽度，所以通过<code>get/set</code>无法改变控件的宽度，也就无法实现动画效果。</p>\n<p>解决方案是使用装饰器模式，包装原始动画对象，间接给对象加上该属性的<code>get/set</code>方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ButtonWrapper wrapper = <span class=\"keyword\">new</span> ViewWrapper(button);</span><br><span class=\"line\">ObjectAnimator.ofInt(wrapper, <span class=\"string\">\"width\"</span>, <span class=\"number\">500</span>)</span><br><span class=\"line\">        .setDuration(<span class=\"number\">3000</span>)</span><br><span class=\"line\">        .start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewWrapper</span><span class=\"params\">(View target)</span> </span>&#123;</span><br><span class=\"line\">        mTarget = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 为宽度设置get/set</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWidth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mTarget.getLayoutParams().width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> width)</span> </span>&#123;</span><br><span class=\"line\">        mTarget.getLayoutParams().width = width;</span><br><span class=\"line\">        mTarget.requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AnimatorSet\"><a href=\"#AnimatorSet\" class=\"headerlink\" title=\"AnimatorSet\"></a>AnimatorSet</h3><p>最后介绍组合动画类，仅展示用法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"translationX\"</span>, curTranslationX, <span class=\"number\">300</span>,curTranslationX);  </span><br><span class=\"line\">ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"rotation\"</span>, <span class=\"number\">0f</span>, <span class=\"number\">360f</span>);  </span><br><span class=\"line\">ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, <span class=\"string\">\"alpha\"</span>, <span class=\"number\">1f</span>, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">AnimatorSet animSet = <span class=\"keyword\">new</span> AnimatorSet();  </span><br><span class=\"line\"></span><br><span class=\"line\">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class=\"line\">animSet.setDuration(<span class=\"number\">5000</span>);  </span><br><span class=\"line\">animSet.start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Spring-Animation\"><a href=\"#Spring-Animation\" class=\"headerlink\" title=\"Spring Animation\"></a>Spring Animation</h2><p>SpringAnimation，弹簧动画，位于<code>android.support.animation</code>包中，属性动画位于<code>android.animation.Animator</code>包中，其实通过 <a href=\"https://developer.android.com/reference/android/view/animation/BounceInterpolator.html\" target=\"_blank\" rel=\"noopener\">BounceInterpolator</a> 或者 <a href=\"https://developer.android.com/reference/android/view/animation/OvershootInterpolator.html\" target=\"_blank\" rel=\"noopener\">OvershootInterpolator</a> 作为插值器，同样可以实现弹性动画效果，引入 SpringAnimation 是因为它使用更简单，而且上两个差值器实现的轨迹并不符合物理学上的弹跳效果。</p>\n<p>使用之前需要导入<code>com.android.support:support-dynamic-animation</code>包</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringAnimation</span><span class=\"params\">(View v, ViewProperty property, <span class=\"keyword\">float</span> finalPosition)</span></span></span><br></pre></td></tr></table></figure>\n<p>参数分别是操作对应的View，对应的变化属性及最终的位置。</p>\n<p>ViewProperty 包括(Z轴支持需要API &gt;= 21)：</p>\n<blockquote>\n<p>TRANSLATION_X<br>TRANSLATION_Y<br>TRANSLATION_Z<br>SCALE_X<br>SCALE_Y<br>ROTATION<br>ROTATION_X<br>ROTATION_Y<br>X<br>Y<br>Z<br>ALPHA<br>SCROLL_X<br>SCROLL_Y</p>\n</blockquote>\n<p>在 SpringAnimation 中有一个 SpringForce 对象，负责对应的变量设置及位置计算。其中包括两个个关键变量</p>\n<ul>\n<li>Stiffness 刚度(劲度/弹性)，刚度越大，形变产生的里也就越大，体现在效果上就是运动越快</li>\n<li>DampingRatio 阻尼系数，系数越大，动画停止的越快。从理论上讲分为三种情况 Overdamped过阻尼（ζ &gt; 1）、Critically damped临界阻尼(ζ = 1)、Underdamped欠阻尼状态(0 &lt; ζ &lt;1)。</li>\n</ul>\n<h3 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpringAnimation btnAnim = <span class=\"keyword\">new</span> SpringAnimation(mButton, SpringAnimation.TRANSLATION_Y, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.getSpring().setStiffness(SpringForce.STIFFNESS_VERY_LOW);</span><br><span class=\"line\">btnAnim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);</span><br><span class=\"line\"></span><br><span class=\"line\">btnAnim.setStartVelocity(<span class=\"number\">10000</span>);  <span class=\"comment\">//开始速度，单位是px/second. 正数是弹簧收缩的方向，负数相反</span></span><br><span class=\"line\">btnAnim.start();</span><br></pre></td></tr></table></figure>"},{"title":"《剑指offer》题目 Java 实现","date":"2019-03-18T02:42:29.000Z","_content":"\n### Problem1：单例模式实现\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n<!--more-->\n### Problem2：二维数组中的查找\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n```java\n    /**\n     * 从二维数组的右上角开始选取与 key 比较的整数\n     * column 的变化:arr[0].length - 1 ---> 0\n     * row 的变化 0 ---> arr.length\n     *\n     * @param arr \n     * @param key \n     */\npublic static boolean find(int[][] arr, int key) {\n    int col = arr[0].length - 1;\n    int row = 0;\n    while (col >= 0 && row < arr.length) {\n        if (arr[row][col] == key) {\n            return true;\n        } else if (arr[row][col] > key) {   //大于查找值，则往前推一列\n            col--;\n        } else {    //小于查找值，则往下推一行\n            row++;\n        }\n    }\n    return false;\n}\n```\n\n\n\n### Problem3：替换空格\n\n请实现一个函数，将字符串的每个空格替换为\"%20\"。例如输入`We are happy`，则输出`We%20are%20happy`。\n\n```java\n    /**\n     * 使用 StringBuilder\n     * \n     * @param str\n     * @return\n     */\n    public static String replace(String str) {\n        if (str.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == ' ') {\n                builder.append(\"%20\");\n            } else {\n                builder.append(str.charAt(i));\n            }\n        }\n        return builder.toString();\n    }\n```\n\n\n\n### Problem4：从尾到头打印链表\n\n输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值\n\n```java\nstatic class ListNode<T> {\n    T value;\n    ListNode next;\n\n    public ListNode(T value) {\n        this.value = value;\n    }\n}\n\n/**\n * 使用栈实现\n *\n * @param headNode\n */\npublic static void printListReverse(ListNode headNode) {\n    Stack<ListNode> stack = new Stack<>();\n    while (headNode != null) {\n        stack.push(headNode);\n        headNode = headNode.next;\n    }\n    while (!stack.empty()) {\n        System.out.println(stack.pop().value + \" \");\n    }\n}\n\npublic static void main(String[] args) {\n    ListNode<Integer> node = new ListNode<>(1);\n    node.next = new ListNode<>(2);\n    node.next.next = new ListNode<>(3);\n    printListReverse(node);\n}\n```\n\n\n\n### Problem5：重建二叉树\n\n输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。\n\n假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。\n\n例如输入前序遍历序列： `{1, 2, 4, 7, 3, 5, 6, 8}`\n\n中序遍历序列：`{4, 7, 2, 1, 5, 3, 8, 6}`\n\n重建出所示二叉树并且输出它的头结点。\n\n```java\n                     1\n                   /   \\\n                  2     3\n                 /     / \\\n                4     5   6\n                 \\        /\n                 7        8\n```\n\n#### 知识点补充\n\n> 前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）\n>\n> 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）\n>\n> 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）\n\n> 二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。\n>\n> 二叉树的特例是**堆**和**红黑树**。\n>\n> 堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。\n>\n> 红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。\n\n### Problem6：用两个栈实现队列\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数\n`appendTail`和`deleteHead`,分别完成在队列尾部插入结点和在队列头部删除结点的功能\n```Java\npublic class ConstructQueue {\n    /*\n     s1 用来实现放入新的元素，直接放到栈顶\n     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2\n     然后删除底部元素，再将 s2 元素移回 s1\n     */\n    Stack<String> stack1 = new Stack<>();\n    Stack<String> stack2 = new Stack<>();\n\n    // 实现appendTail函数\n    public void appendTail(String s) {\n        stack1.push(s);\n    }\n\n    // 实现deleteHead函数\n    public String deleteHead() {\n        while (!stack1.empty()) {\n            stack2.push(stack1.pop());\n        }\n        String head = stack2.pop();\n        while (!stack2.empty()) {\n            stack1.push(stack2.pop());\n        }\n        return head;\n    }\n\n    public static void main(String[] args) {\n        ConstructQueue queue = new ConstructQueue();\n        queue.appendTail(\"a\");\n        queue.appendTail(\"b\");\n        queue.appendTail(\"c\");\n        queue.appendTail(\"d\");\n        System.out.println(queue.deleteHead());\n        System.out.println(queue.deleteHead());\n    }\n}\n```\n输出如下\n```\na\nb\n```\n### Problem7：旋转数组的最小数字\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。\n例如数组 `{3, 4, 5, 1, 2}`为`{1, 2, 3, 4, 5}`的一个旋转，该数组的最小值为 1;\n\n```Java\npublic static void main(String[] args) {\n    int[] a = {3, 4, 5, 1, 2};\n    System.out.println(minNumInRotateArray(a));\n}\n\n/**\n     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。\n     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。\n     *\n     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。\n     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，\n     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。\n     * 同理第二个指针的范围也将逐渐缩小\n     *\n     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。\n     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，\n     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。\n     * \n     * @param array\n     */\npublic static int minNumInRotateArray(int[] array) {\n    if (array == null) {\n        return 0;\n    }\n    int left = 0;\n    int right = array.length - 1;\n    int mid = 0;\n    while (array[left] >= array[right]) {\n        if (right - left == 1) {\n            mid = right;\n            break;\n        }\n        mid = (left + right) / 2;\n\n        // 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组\n        if (array[left] == array[right] && array[right] == array[mid]) {\n            return findInOrder(array, left, right);\n        }\n        \n        if (array[left] <= array[mid]) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    return array[mid];\n}\n\nstatic int findInOrder(int[] array, int left, int right) {\n    int k = array[left];\n    for (int i = 0; i < right; i++) {\n        if (array[i] < k) {\n            k = array[i];\n        }\n    }\n    return k;\n}\n```\n\n### Problem8：斐波那契数列\n写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： \n> n=0, f(n)=0;\n> n=1, f(n)=1; \n> n>1, f(n) = f(n-1) + f(n-2).\n\n```Java\npublic static void main(String[] args) {\n    for (int i = 0; i < 11; i++) {\n        System.out.print(fibonacci(i) + \" \");\n    }\n}\n\npublic static int fibonacci(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n```\n输出结果\n```\n0 1 1 2 3 5 8 13 21 34 55 \n```\n### Problem9：二进制中1的个数\n请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。\n\n例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。\n\n```\npublic static int oneCountsOfBinary(int i) {\n    char[] chars = Integer.toBinaryString(i).toCharArray();\n    int count = 0;\n    for (char c : chars) {\n        if (c == '1') {\n            count++;\n        }\n    }\n    return count;\n}\n\npublic static int _oneCountsOfBinary(int i) {\n    int count = 0;\n    int flag = 1;\n    while (flag != 0) {\n        if ((i & flag) != 0) {\n            count++;\n        }\n        flag = flag << 1;\n    }\n    return count;\n}\n```\n\n### Problem10：数值的整数次方\n 实现函数`double power(double base, int exponent)`，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。 \n```Java\npublic static double power(double base, int exponent) {\n    if (base <= 0) {\n        throw new RuntimeException(\"运算无意义\");\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if (exponent < 0) {\n        return 1 / powerUnsigned(base, -exponent);\n    } else {\n        return powerUnsigned(base, exponent);\n    }\n}\n\nstatic double powerUnsigned(double base, int exponent) {\n    double result = base;\n    for (int i = 1; i < exponent; i++) {\n        result = result * base;\n    }\n    return result;\n}\n```\n\n### Problem11：O（1）时间删除链表结点\n给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。\n```Java\nstatic class Node {\n    int value;\n    Node next;\n\n    public Node(int value) {\n        this.value = value;\n    }\n}\n\n/**\n * 只有一个节点时，直接置空\n * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null\n * 否则 p->next 的值赋值给p，把p->next删除掉\n *\n * @param head\n * @param delNode\n */\npublic static void deleteNode(Node head, Node delNode) {\n    if (head == null || delNode == null) {\n        return;\n    }\n    if (head == delNode) {\n        head = null;\n        return;\n    }\n    if (delNode.next == null) {\n        Node temp = head;\n        while (temp.next != delNode) {\n            temp = temp.next;\n        }\n        temp.next = null;\n        return;\n    }\n    delNode.value = delNode.next.value;\n    delNode.next = delNode.next.next;\n}\n```\n### Problem12：调整数组中奇数和偶数的先后顺序\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;\n```Java\npublic static void orderArray(int[] array) {\n    int left = 0;\n    int right = array.length - 1;\n    while (left < right) {\n        while (left < right && !isEven(array[left])) {\n            left ++;\n        }\n        while (left < right && isEven(array[right])) {\n            right --;\n        }\n        if (left < right) {\n            int temp = array[left];\n            array[left] = array[right];\n            array[right] = temp;\n        }\n    }\n}\n\nstatic boolean isEven(int i) {\n    return ((i & 1) == 0);\n}\n```\n\n### Problem13：链表中倒数第K个结点\n输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。\n\n例如一个链表有6个结点，从头结点开始它们的值依次是`1、2、3、4、5、6`。这个链表的倒数第三个结点是值为4的结点。\n\n```Java\n    /**\n     * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动\n     * 从第k步开始，第二个指针也开始从链表的头指针开始遍历\n     * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上\n     * \n     * @param head 头结点\n     * @param k 倒数第k个节点\n     */\n    public static int find(ListNode head, int k){\n        if (head == null) {\n            return 0;\n        }\n        ListNode first = head;\n        ListNode second = head;\n        for (int i = 1; i < k; i++) {\n            if (first.next != null) {\n                first = first.next;\n            } else {\n                return 0;\n            }\n        }\n        System.out.println(first.val);\n        while (first.next != null) {\n            first = first.next;\n            second = second.next;\n        }\n        System.out.println(first.val);\n        return second.val;\n    }\n\n    static class ListNode {\n        int val;\n        ListNode next;\n\n        public ListNode(int val) {\n            this.val = val;\n        }\n    }\n```\n### Problem14：翻转链表\n定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点\n\n\n\n![](《剑指offer》题目-Java-实现/翻转链表.png)\n\n```Java\n    /**\n     * 翻转单链表\n     * \n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode getReversedListHead(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        //current节点是head的下一个节点\n        ListNode current = head.next;\n        //当前的head变为链表的尾，所以next为空\n        head.next = null;\n        \n        while (current != null) {\n            //currentNext节点是current的下一个节点。\n            ListNode currentNext = current.next;\n            //current.next反方向指向以前的节点\n            current.next = head;\n            \n            //移动head和current指针，到后面head重新成为头节点\n            head = current;\n            current = currentNext;\n        }\n        return head;\n    }\n\n    /**\n     * 翻转单链表的递归实现\n     *\n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode reverseListByRecursion(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newList = reverseListByRecursion(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newList;\n    }\n```\n\n### Problem15：合并两个排序的链表\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。\n\n```java\n    public static ListNode merge(ListNode n1, ListNode n2) {\n        if (n1 == null) {\n            return n2;\n        }\n        if (n2 == null) {\n            return n1;\n        }\n        ListNode mergeNode = null;\n        if (n1.val < n2.val) {\n            mergeNode = n1;\n            mergeNode.next = merge(n1.next, n2);\n        } else {\n            mergeNode = n2;\n            mergeNode.next = merge(n1, n2.next);\n        }\n        return mergeNode;\n    }\n```\n\n\n\n### Problem16：树的子结构判断\n\n\n\n### Problem17：二叉树的镜像\n\n### Problem18：顺时针打印矩阵\n\n### Problem19：包含min函数的栈\n\n### Problem20：栈的压入、弹出序列\n\n### Problem21：从上往下打印二叉树\n\n### Problem22：二叉搜索树的后序遍历\n\n### Problem23：二叉树中和为某一值的路径\n\n### Problem24：字符串的排列\n\n### Problem25：数组中出现次数超过一半的数字\n\n### Problem26：连续子数组的最大和\n\n### Problem27：整数中1出现的次数\n\n### Problem28：把数组排成最小的数\n\n### Problem29：丑数\n\n### Problem30：第一个只出现一次的字符\n\n### Problem31：数组中的逆序对\n\n### Problem32：两个链表的第一个公共节点\n\n### Problem33：二叉树的深度&&平衡二叉树判断\n\n### Problem34：数字在排序数组中出现的次数\n\n### Problem35：数组中只出现一次的数字\n\n### Problem36：和为S的两个数字 \n\n### Problem37：和为S的连续正数序列\n\n### Problem38：翻转单词的顺序\n\n### Problem39：扑克牌的顺子\n\n### Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\n\n### Problem41：计算1+2+3+ ··· + n\n\n### Problem42：不用加减乘除做加法\n\n### Problem43：把字符串转换为整数\n\n### Problem44：数组中重复的数字\n\n### Problem45：构建乘积数组\n\n### Problem46：正则表达式匹配\n\n### Problem47：表示数值的字符串\n\n### Problem48：字符流中第一个不重复的字符\n\n### Problem49：链表中环的入口结点\n\n### Problem50：删除链表中欧冠重复的节点\n\n### Problem51：二叉树的下一个节点\n\n### Problem52：把二叉树打印成多行\n\n### Problem53：按之字形顺序打印二叉树\n\n### Problem54：序列化二叉树\n\n### Problem55：二叉搜索树的第K个节点\n\n### Problem56：滑动窗口的最大值大值","source":"_posts/《剑指offer》题目-Java-实现.md","raw":"---\ntitle: 《剑指offer》题目 Java 实现\ndate: 2019-03-18 10:42:29\ntags:\n- 算法\n- Java\ncategories:\n- 算法\n---\n\n### Problem1：单例模式实现\n```Java\npublic class Singleton {  \n\n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n} \n```\n<!--more-->\n### Problem2：二维数组中的查找\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n```java\n    /**\n     * 从二维数组的右上角开始选取与 key 比较的整数\n     * column 的变化:arr[0].length - 1 ---> 0\n     * row 的变化 0 ---> arr.length\n     *\n     * @param arr \n     * @param key \n     */\npublic static boolean find(int[][] arr, int key) {\n    int col = arr[0].length - 1;\n    int row = 0;\n    while (col >= 0 && row < arr.length) {\n        if (arr[row][col] == key) {\n            return true;\n        } else if (arr[row][col] > key) {   //大于查找值，则往前推一列\n            col--;\n        } else {    //小于查找值，则往下推一行\n            row++;\n        }\n    }\n    return false;\n}\n```\n\n\n\n### Problem3：替换空格\n\n请实现一个函数，将字符串的每个空格替换为\"%20\"。例如输入`We are happy`，则输出`We%20are%20happy`。\n\n```java\n    /**\n     * 使用 StringBuilder\n     * \n     * @param str\n     * @return\n     */\n    public static String replace(String str) {\n        if (str.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == ' ') {\n                builder.append(\"%20\");\n            } else {\n                builder.append(str.charAt(i));\n            }\n        }\n        return builder.toString();\n    }\n```\n\n\n\n### Problem4：从尾到头打印链表\n\n输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值\n\n```java\nstatic class ListNode<T> {\n    T value;\n    ListNode next;\n\n    public ListNode(T value) {\n        this.value = value;\n    }\n}\n\n/**\n * 使用栈实现\n *\n * @param headNode\n */\npublic static void printListReverse(ListNode headNode) {\n    Stack<ListNode> stack = new Stack<>();\n    while (headNode != null) {\n        stack.push(headNode);\n        headNode = headNode.next;\n    }\n    while (!stack.empty()) {\n        System.out.println(stack.pop().value + \" \");\n    }\n}\n\npublic static void main(String[] args) {\n    ListNode<Integer> node = new ListNode<>(1);\n    node.next = new ListNode<>(2);\n    node.next.next = new ListNode<>(3);\n    printListReverse(node);\n}\n```\n\n\n\n### Problem5：重建二叉树\n\n输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。\n\n假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。\n\n例如输入前序遍历序列： `{1, 2, 4, 7, 3, 5, 6, 8}`\n\n中序遍历序列：`{4, 7, 2, 1, 5, 3, 8, 6}`\n\n重建出所示二叉树并且输出它的头结点。\n\n```java\n                     1\n                   /   \\\n                  2     3\n                 /     / \\\n                4     5   6\n                 \\        /\n                 7        8\n```\n\n#### 知识点补充\n\n> 前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）\n>\n> 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）\n>\n> 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）\n\n> 二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。\n>\n> 二叉树的特例是**堆**和**红黑树**。\n>\n> 堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。\n>\n> 红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。\n\n### Problem6：用两个栈实现队列\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数\n`appendTail`和`deleteHead`,分别完成在队列尾部插入结点和在队列头部删除结点的功能\n```Java\npublic class ConstructQueue {\n    /*\n     s1 用来实现放入新的元素，直接放到栈顶\n     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2\n     然后删除底部元素，再将 s2 元素移回 s1\n     */\n    Stack<String> stack1 = new Stack<>();\n    Stack<String> stack2 = new Stack<>();\n\n    // 实现appendTail函数\n    public void appendTail(String s) {\n        stack1.push(s);\n    }\n\n    // 实现deleteHead函数\n    public String deleteHead() {\n        while (!stack1.empty()) {\n            stack2.push(stack1.pop());\n        }\n        String head = stack2.pop();\n        while (!stack2.empty()) {\n            stack1.push(stack2.pop());\n        }\n        return head;\n    }\n\n    public static void main(String[] args) {\n        ConstructQueue queue = new ConstructQueue();\n        queue.appendTail(\"a\");\n        queue.appendTail(\"b\");\n        queue.appendTail(\"c\");\n        queue.appendTail(\"d\");\n        System.out.println(queue.deleteHead());\n        System.out.println(queue.deleteHead());\n    }\n}\n```\n输出如下\n```\na\nb\n```\n### Problem7：旋转数组的最小数字\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。\n例如数组 `{3, 4, 5, 1, 2}`为`{1, 2, 3, 4, 5}`的一个旋转，该数组的最小值为 1;\n\n```Java\npublic static void main(String[] args) {\n    int[] a = {3, 4, 5, 1, 2};\n    System.out.println(minNumInRotateArray(a));\n}\n\n/**\n     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。\n     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。\n     *\n     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。\n     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，\n     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。\n     * 同理第二个指针的范围也将逐渐缩小\n     *\n     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。\n     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，\n     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。\n     * \n     * @param array\n     */\npublic static int minNumInRotateArray(int[] array) {\n    if (array == null) {\n        return 0;\n    }\n    int left = 0;\n    int right = array.length - 1;\n    int mid = 0;\n    while (array[left] >= array[right]) {\n        if (right - left == 1) {\n            mid = right;\n            break;\n        }\n        mid = (left + right) / 2;\n\n        // 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组\n        if (array[left] == array[right] && array[right] == array[mid]) {\n            return findInOrder(array, left, right);\n        }\n        \n        if (array[left] <= array[mid]) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    return array[mid];\n}\n\nstatic int findInOrder(int[] array, int left, int right) {\n    int k = array[left];\n    for (int i = 0; i < right; i++) {\n        if (array[i] < k) {\n            k = array[i];\n        }\n    }\n    return k;\n}\n```\n\n### Problem8：斐波那契数列\n写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： \n> n=0, f(n)=0;\n> n=1, f(n)=1; \n> n>1, f(n) = f(n-1) + f(n-2).\n\n```Java\npublic static void main(String[] args) {\n    for (int i = 0; i < 11; i++) {\n        System.out.print(fibonacci(i) + \" \");\n    }\n}\n\npublic static int fibonacci(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n```\n输出结果\n```\n0 1 1 2 3 5 8 13 21 34 55 \n```\n### Problem9：二进制中1的个数\n请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。\n\n例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。\n\n```\npublic static int oneCountsOfBinary(int i) {\n    char[] chars = Integer.toBinaryString(i).toCharArray();\n    int count = 0;\n    for (char c : chars) {\n        if (c == '1') {\n            count++;\n        }\n    }\n    return count;\n}\n\npublic static int _oneCountsOfBinary(int i) {\n    int count = 0;\n    int flag = 1;\n    while (flag != 0) {\n        if ((i & flag) != 0) {\n            count++;\n        }\n        flag = flag << 1;\n    }\n    return count;\n}\n```\n\n### Problem10：数值的整数次方\n 实现函数`double power(double base, int exponent)`，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。 \n```Java\npublic static double power(double base, int exponent) {\n    if (base <= 0) {\n        throw new RuntimeException(\"运算无意义\");\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if (exponent < 0) {\n        return 1 / powerUnsigned(base, -exponent);\n    } else {\n        return powerUnsigned(base, exponent);\n    }\n}\n\nstatic double powerUnsigned(double base, int exponent) {\n    double result = base;\n    for (int i = 1; i < exponent; i++) {\n        result = result * base;\n    }\n    return result;\n}\n```\n\n### Problem11：O（1）时间删除链表结点\n给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。\n```Java\nstatic class Node {\n    int value;\n    Node next;\n\n    public Node(int value) {\n        this.value = value;\n    }\n}\n\n/**\n * 只有一个节点时，直接置空\n * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null\n * 否则 p->next 的值赋值给p，把p->next删除掉\n *\n * @param head\n * @param delNode\n */\npublic static void deleteNode(Node head, Node delNode) {\n    if (head == null || delNode == null) {\n        return;\n    }\n    if (head == delNode) {\n        head = null;\n        return;\n    }\n    if (delNode.next == null) {\n        Node temp = head;\n        while (temp.next != delNode) {\n            temp = temp.next;\n        }\n        temp.next = null;\n        return;\n    }\n    delNode.value = delNode.next.value;\n    delNode.next = delNode.next.next;\n}\n```\n### Problem12：调整数组中奇数和偶数的先后顺序\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;\n```Java\npublic static void orderArray(int[] array) {\n    int left = 0;\n    int right = array.length - 1;\n    while (left < right) {\n        while (left < right && !isEven(array[left])) {\n            left ++;\n        }\n        while (left < right && isEven(array[right])) {\n            right --;\n        }\n        if (left < right) {\n            int temp = array[left];\n            array[left] = array[right];\n            array[right] = temp;\n        }\n    }\n}\n\nstatic boolean isEven(int i) {\n    return ((i & 1) == 0);\n}\n```\n\n### Problem13：链表中倒数第K个结点\n输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。\n\n例如一个链表有6个结点，从头结点开始它们的值依次是`1、2、3、4、5、6`。这个链表的倒数第三个结点是值为4的结点。\n\n```Java\n    /**\n     * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动\n     * 从第k步开始，第二个指针也开始从链表的头指针开始遍历\n     * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上\n     * \n     * @param head 头结点\n     * @param k 倒数第k个节点\n     */\n    public static int find(ListNode head, int k){\n        if (head == null) {\n            return 0;\n        }\n        ListNode first = head;\n        ListNode second = head;\n        for (int i = 1; i < k; i++) {\n            if (first.next != null) {\n                first = first.next;\n            } else {\n                return 0;\n            }\n        }\n        System.out.println(first.val);\n        while (first.next != null) {\n            first = first.next;\n            second = second.next;\n        }\n        System.out.println(first.val);\n        return second.val;\n    }\n\n    static class ListNode {\n        int val;\n        ListNode next;\n\n        public ListNode(int val) {\n            this.val = val;\n        }\n    }\n```\n### Problem14：翻转链表\n定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点\n\n\n\n![](《剑指offer》题目-Java-实现/翻转链表.png)\n\n```Java\n    /**\n     * 翻转单链表\n     * \n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode getReversedListHead(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        //current节点是head的下一个节点\n        ListNode current = head.next;\n        //当前的head变为链表的尾，所以next为空\n        head.next = null;\n        \n        while (current != null) {\n            //currentNext节点是current的下一个节点。\n            ListNode currentNext = current.next;\n            //current.next反方向指向以前的节点\n            current.next = head;\n            \n            //移动head和current指针，到后面head重新成为头节点\n            head = current;\n            current = currentNext;\n        }\n        return head;\n    }\n\n    /**\n     * 翻转单链表的递归实现\n     *\n     * @param head 原链表的头节点\n     * @return 翻转之后的头节点\n     */\n    public static ListNode reverseListByRecursion(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newList = reverseListByRecursion(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newList;\n    }\n```\n\n### Problem15：合并两个排序的链表\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。\n\n```java\n    public static ListNode merge(ListNode n1, ListNode n2) {\n        if (n1 == null) {\n            return n2;\n        }\n        if (n2 == null) {\n            return n1;\n        }\n        ListNode mergeNode = null;\n        if (n1.val < n2.val) {\n            mergeNode = n1;\n            mergeNode.next = merge(n1.next, n2);\n        } else {\n            mergeNode = n2;\n            mergeNode.next = merge(n1, n2.next);\n        }\n        return mergeNode;\n    }\n```\n\n\n\n### Problem16：树的子结构判断\n\n\n\n### Problem17：二叉树的镜像\n\n### Problem18：顺时针打印矩阵\n\n### Problem19：包含min函数的栈\n\n### Problem20：栈的压入、弹出序列\n\n### Problem21：从上往下打印二叉树\n\n### Problem22：二叉搜索树的后序遍历\n\n### Problem23：二叉树中和为某一值的路径\n\n### Problem24：字符串的排列\n\n### Problem25：数组中出现次数超过一半的数字\n\n### Problem26：连续子数组的最大和\n\n### Problem27：整数中1出现的次数\n\n### Problem28：把数组排成最小的数\n\n### Problem29：丑数\n\n### Problem30：第一个只出现一次的字符\n\n### Problem31：数组中的逆序对\n\n### Problem32：两个链表的第一个公共节点\n\n### Problem33：二叉树的深度&&平衡二叉树判断\n\n### Problem34：数字在排序数组中出现的次数\n\n### Problem35：数组中只出现一次的数字\n\n### Problem36：和为S的两个数字 \n\n### Problem37：和为S的连续正数序列\n\n### Problem38：翻转单词的顺序\n\n### Problem39：扑克牌的顺子\n\n### Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\n\n### Problem41：计算1+2+3+ ··· + n\n\n### Problem42：不用加减乘除做加法\n\n### Problem43：把字符串转换为整数\n\n### Problem44：数组中重复的数字\n\n### Problem45：构建乘积数组\n\n### Problem46：正则表达式匹配\n\n### Problem47：表示数值的字符串\n\n### Problem48：字符流中第一个不重复的字符\n\n### Problem49：链表中环的入口结点\n\n### Problem50：删除链表中欧冠重复的节点\n\n### Problem51：二叉树的下一个节点\n\n### Problem52：把二叉树打印成多行\n\n### Problem53：按之字形顺序打印二叉树\n\n### Problem54：序列化二叉树\n\n### Problem55：二叉搜索树的第K个节点\n\n### Problem56：滑动窗口的最大值大值","slug":"《剑指offer》题目-Java-实现","published":1,"updated":"2019-03-25T09:17:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavdu0032i0up9wwvbhpr","content":"<h3 id=\"Problem1：单例模式实现\"><a href=\"#Problem1：单例模式实现\" class=\"headerlink\" title=\"Problem1：单例模式实现\"></a>Problem1：单例模式实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"Problem2：二维数组中的查找\"><a href=\"#Problem2：二维数组中的查找\" class=\"headerlink\" title=\"Problem2：二维数组中的查找\"></a>Problem2：二维数组中的查找</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从二维数组的右上角开始选取与 key 比较的整数</span></span><br><span class=\"line\"><span class=\"comment\">     * column 的变化:arr[0].length - 1 ---&gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">     * row 的变化 0 ---&gt; arr.length</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] arr, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> col = arr[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (col &gt;= <span class=\"number\">0</span> &amp;&amp; row &lt; arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[row][col] == key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[row][col] &gt; key) &#123;   <span class=\"comment\">//大于查找值，则往前推一列</span></span><br><span class=\"line\">            col--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">//小于查找值，则往下推一行</span></span><br><span class=\"line\">            row++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem3：替换空格\"><a href=\"#Problem3：替换空格\" class=\"headerlink\" title=\"Problem3：替换空格\"></a>Problem3：替换空格</h3><p>请实现一个函数，将字符串的每个空格替换为”%20”。例如输入<code>We are happy</code>，则输出<code>We%20are%20happy</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 StringBuilder</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">replace</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(i) == <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">            builder.append(<span class=\"string\">\"%20\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            builder.append(str.charAt(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem4：从尾到头打印链表\"><a href=\"#Problem4：从尾到头打印链表\" class=\"headerlink\" title=\"Problem4：从尾到头打印链表\"></a>Problem4：从尾到头打印链表</h3><p>输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T value;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用栈实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> headNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printListReverse</span><span class=\"params\">(ListNode headNode)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;ListNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (headNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        stack.push(headNode);</span><br><span class=\"line\">        headNode = headNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.empty()) &#123;</span><br><span class=\"line\">        System.out.println(stack.pop().value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ListNode&lt;Integer&gt; node = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">    node.next = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    node.next.next = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">    printListReverse(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem5：重建二叉树\"><a href=\"#Problem5：重建二叉树\" class=\"headerlink\" title=\"Problem5：重建二叉树\"></a>Problem5：重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。</p>\n<p>假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。</p>\n<p>例如输入前序遍历序列： <code>{1, 2, 4, 7, 3, 5, 6, 8}</code></p>\n<p>中序遍历序列：<code>{4, 7, 2, 1, 5, 3, 8, 6}</code></p>\n<p>重建出所示二叉树并且输出它的头结点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">1</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\"> /     / \\</span><br><span class=\"line\"><span class=\"number\">4</span>     <span class=\"number\">5</span>   <span class=\"number\">6</span></span><br><span class=\"line\"> \\        /</span><br><span class=\"line\"> <span class=\"number\">7</span>        <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"知识点补充\"><a href=\"#知识点补充\" class=\"headerlink\" title=\"知识点补充\"></a>知识点补充</h4><blockquote>\n<p>前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）</p>\n<p>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）</p>\n<p>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）</p>\n</blockquote>\n<blockquote>\n<p>二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。</p>\n<p>二叉树的特例是<strong>堆</strong>和<strong>红黑树</strong>。</p>\n<p>堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。</p>\n<p>红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。</p>\n</blockquote>\n<h3 id=\"Problem6：用两个栈实现队列\"><a href=\"#Problem6：用两个栈实现队列\" class=\"headerlink\" title=\"Problem6：用两个栈实现队列\"></a>Problem6：用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<br><code>appendTail</code>和<code>deleteHead</code>,分别完成在队列尾部插入结点和在队列头部删除结点的功能<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConstructQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     s1 用来实现放入新的元素，直接放到栈顶</span></span><br><span class=\"line\"><span class=\"comment\">     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2</span></span><br><span class=\"line\"><span class=\"comment\">     然后删除底部元素，再将 s2 元素移回 s1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Stack&lt;String&gt; stack1 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;String&gt; stack2 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现appendTail函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现deleteHead函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String head = stack2.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConstructQueue queue = <span class=\"keyword\">new</span> ConstructQueue();</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem7：旋转数组的最小数字\"><a href=\"#Problem7：旋转数组的最小数字\" class=\"headerlink\" title=\"Problem7：旋转数组的最小数字\"></a>Problem7：旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。<br>例如数组 <code>{3, 4, 5, 1, 2}</code>为<code>{1, 2, 3, 4, 5}</code>的一个旋转，该数组的最小值为 1;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    System.out.println(minNumInRotateArray(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。</span></span><br><span class=\"line\"><span class=\"comment\">     * 同理第二个指针的范围也将逐渐缩小</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">minNumInRotateArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (array[left] &gt;= array[right]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            mid = right;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] == array[right] &amp;&amp; array[right] == array[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> findInOrder(array, left, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] &lt;= array[mid]) &#123;</span><br><span class=\"line\">            left = mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array[mid];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">findInOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = array[left];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; right; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] &lt; k) &#123;</span><br><span class=\"line\">            k = array[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem8：斐波那契数列\"><a href=\"#Problem8：斐波那契数列\" class=\"headerlink\" title=\"Problem8：斐波那契数列\"></a>Problem8：斐波那契数列</h3><p>写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： </p>\n<blockquote>\n<p>n=0, f(n)=0;<br>n=1, f(n)=1;<br>n&gt;1, f(n) = f(n-1) + f(n-2).</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">        System.out.print(fibonacci(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">fibonacci</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem9：二进制中1的个数\"><a href=\"#Problem9：二进制中1的个数\" class=\"headerlink\" title=\"Problem9：二进制中1的个数\"></a>Problem9：二进制中1的个数</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。</p>\n<p>例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int oneCountsOfBinary(int i) &#123;</span><br><span class=\"line\">    char[] chars = Integer.toBinaryString(i).toCharArray();</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    for (char c : chars) &#123;</span><br><span class=\"line\">        if (c == &apos;1&apos;) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static int _oneCountsOfBinary(int i) &#123;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    int flag = 1;</span><br><span class=\"line\">    while (flag != 0) &#123;</span><br><span class=\"line\">        if ((i &amp; flag) != 0) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        flag = flag &lt;&lt; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem10：数值的整数次方\"><a href=\"#Problem10：数值的整数次方\" class=\"headerlink\" title=\"Problem10：数值的整数次方\"></a>Problem10：数值的整数次方</h3><p> 实现函数<code>double power(double base, int exponent)</code>，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">power</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"运算无意义\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> / powerUnsigned(base, -exponent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> powerUnsigned(base, exponent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">powerUnsigned</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = base;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; exponent; i++) &#123;</span><br><span class=\"line\">        result = result * base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem11：O（1）时间删除链表结点\"><a href=\"#Problem11：O（1）时间删除链表结点\" class=\"headerlink\" title=\"Problem11：O（1）时间删除链表结点\"></a>Problem11：O（1）时间删除链表结点</h3><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 只有一个节点时，直接置空</span></span><br><span class=\"line\"><span class=\"comment\"> * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则 p-&gt;next 的值赋值给p，把p-&gt;next删除掉</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> delNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(Node head, Node delNode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || delNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == delNode) &#123;</span><br><span class=\"line\">        head = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delNode.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Node temp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp.next != delNode) &#123;</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delNode.value = delNode.next.value;</span><br><span class=\"line\">    delNode.next = delNode.next.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem12：调整数组中奇数和偶数的先后顺序\"><a href=\"#Problem12：调整数组中奇数和偶数的先后顺序\" class=\"headerlink\" title=\"Problem12：调整数组中奇数和偶数的先后顺序\"></a>Problem12：调整数组中奇数和偶数的先后顺序</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">orderArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; !isEven(array[left])) &#123;</span><br><span class=\"line\">            left ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; isEven(array[right])) &#123;</span><br><span class=\"line\">            right --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = array[left];</span><br><span class=\"line\">            array[left] = array[right];</span><br><span class=\"line\">            array[right] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEven</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem13：链表中倒数第K个结点\"><a href=\"#Problem13：链表中倒数第K个结点\" class=\"headerlink\" title=\"Problem13：链表中倒数第K个结点\"></a>Problem13：链表中倒数第K个结点</h3><p>输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。</p>\n<p>例如一个链表有6个结点，从头结点开始它们的值依次是<code>1、2、3、4、5、6</code>。这个链表的倒数第三个结点是值为4的结点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第k步开始，第二个指针也开始从链表的头指针开始遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 头结点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> k 倒数第k个节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode first = head;</span><br><span class=\"line\">    ListNode second = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (first.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        first = first.next;</span><br><span class=\"line\">        second = second.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> second.val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem14：翻转链表\"><a href=\"#Problem14：翻转链表\" class=\"headerlink\" title=\"Problem14：翻转链表\"></a>Problem14：翻转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>\n<p><img src=\"/《剑指offer》题目-Java-实现/翻转链表.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">getReversedListHead</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//current节点是head的下一个节点</span></span><br><span class=\"line\">    ListNode current = head.next;</span><br><span class=\"line\">    <span class=\"comment\">//当前的head变为链表的尾，所以next为空</span></span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//currentNext节点是current的下一个节点。</span></span><br><span class=\"line\">        ListNode currentNext = current.next;</span><br><span class=\"line\">        <span class=\"comment\">//current.next反方向指向以前的节点</span></span><br><span class=\"line\">        current.next = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//移动head和current指针，到后面head重新成为头节点</span></span><br><span class=\"line\">        head = current;</span><br><span class=\"line\">        current = currentNext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表的递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">reverseListByRecursion</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode newList = reverseListByRecursion(head.next);</span><br><span class=\"line\">    head.next.next = head;</span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem15：合并两个排序的链表\"><a href=\"#Problem15：合并两个排序的链表\" class=\"headerlink\" title=\"Problem15：合并两个排序的链表\"></a>Problem15：合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode mergeNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1.val &lt; n2.val) &#123;</span><br><span class=\"line\">        mergeNode = n1;</span><br><span class=\"line\">        mergeNode.next = merge(n1.next, n2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mergeNode = n2;</span><br><span class=\"line\">        mergeNode.next = merge(n1, n2.next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem16：树的子结构判断\"><a href=\"#Problem16：树的子结构判断\" class=\"headerlink\" title=\"Problem16：树的子结构判断\"></a>Problem16：树的子结构判断</h3><h3 id=\"Problem17：二叉树的镜像\"><a href=\"#Problem17：二叉树的镜像\" class=\"headerlink\" title=\"Problem17：二叉树的镜像\"></a>Problem17：二叉树的镜像</h3><h3 id=\"Problem18：顺时针打印矩阵\"><a href=\"#Problem18：顺时针打印矩阵\" class=\"headerlink\" title=\"Problem18：顺时针打印矩阵\"></a>Problem18：顺时针打印矩阵</h3><h3 id=\"Problem19：包含min函数的栈\"><a href=\"#Problem19：包含min函数的栈\" class=\"headerlink\" title=\"Problem19：包含min函数的栈\"></a>Problem19：包含min函数的栈</h3><h3 id=\"Problem20：栈的压入、弹出序列\"><a href=\"#Problem20：栈的压入、弹出序列\" class=\"headerlink\" title=\"Problem20：栈的压入、弹出序列\"></a>Problem20：栈的压入、弹出序列</h3><h3 id=\"Problem21：从上往下打印二叉树\"><a href=\"#Problem21：从上往下打印二叉树\" class=\"headerlink\" title=\"Problem21：从上往下打印二叉树\"></a>Problem21：从上往下打印二叉树</h3><h3 id=\"Problem22：二叉搜索树的后序遍历\"><a href=\"#Problem22：二叉搜索树的后序遍历\" class=\"headerlink\" title=\"Problem22：二叉搜索树的后序遍历\"></a>Problem22：二叉搜索树的后序遍历</h3><h3 id=\"Problem23：二叉树中和为某一值的路径\"><a href=\"#Problem23：二叉树中和为某一值的路径\" class=\"headerlink\" title=\"Problem23：二叉树中和为某一值的路径\"></a>Problem23：二叉树中和为某一值的路径</h3><h3 id=\"Problem24：字符串的排列\"><a href=\"#Problem24：字符串的排列\" class=\"headerlink\" title=\"Problem24：字符串的排列\"></a>Problem24：字符串的排列</h3><h3 id=\"Problem25：数组中出现次数超过一半的数字\"><a href=\"#Problem25：数组中出现次数超过一半的数字\" class=\"headerlink\" title=\"Problem25：数组中出现次数超过一半的数字\"></a>Problem25：数组中出现次数超过一半的数字</h3><h3 id=\"Problem26：连续子数组的最大和\"><a href=\"#Problem26：连续子数组的最大和\" class=\"headerlink\" title=\"Problem26：连续子数组的最大和\"></a>Problem26：连续子数组的最大和</h3><h3 id=\"Problem27：整数中1出现的次数\"><a href=\"#Problem27：整数中1出现的次数\" class=\"headerlink\" title=\"Problem27：整数中1出现的次数\"></a>Problem27：整数中1出现的次数</h3><h3 id=\"Problem28：把数组排成最小的数\"><a href=\"#Problem28：把数组排成最小的数\" class=\"headerlink\" title=\"Problem28：把数组排成最小的数\"></a>Problem28：把数组排成最小的数</h3><h3 id=\"Problem29：丑数\"><a href=\"#Problem29：丑数\" class=\"headerlink\" title=\"Problem29：丑数\"></a>Problem29：丑数</h3><h3 id=\"Problem30：第一个只出现一次的字符\"><a href=\"#Problem30：第一个只出现一次的字符\" class=\"headerlink\" title=\"Problem30：第一个只出现一次的字符\"></a>Problem30：第一个只出现一次的字符</h3><h3 id=\"Problem31：数组中的逆序对\"><a href=\"#Problem31：数组中的逆序对\" class=\"headerlink\" title=\"Problem31：数组中的逆序对\"></a>Problem31：数组中的逆序对</h3><h3 id=\"Problem32：两个链表的第一个公共节点\"><a href=\"#Problem32：两个链表的第一个公共节点\" class=\"headerlink\" title=\"Problem32：两个链表的第一个公共节点\"></a>Problem32：两个链表的第一个公共节点</h3><h3 id=\"Problem33：二叉树的深度-amp-amp-平衡二叉树判断\"><a href=\"#Problem33：二叉树的深度-amp-amp-平衡二叉树判断\" class=\"headerlink\" title=\"Problem33：二叉树的深度&amp;&amp;平衡二叉树判断\"></a>Problem33：二叉树的深度&amp;&amp;平衡二叉树判断</h3><h3 id=\"Problem34：数字在排序数组中出现的次数\"><a href=\"#Problem34：数字在排序数组中出现的次数\" class=\"headerlink\" title=\"Problem34：数字在排序数组中出现的次数\"></a>Problem34：数字在排序数组中出现的次数</h3><h3 id=\"Problem35：数组中只出现一次的数字\"><a href=\"#Problem35：数组中只出现一次的数字\" class=\"headerlink\" title=\"Problem35：数组中只出现一次的数字\"></a>Problem35：数组中只出现一次的数字</h3><h3 id=\"Problem36：和为S的两个数字\"><a href=\"#Problem36：和为S的两个数字\" class=\"headerlink\" title=\"Problem36：和为S的两个数字\"></a>Problem36：和为S的两个数字</h3><h3 id=\"Problem37：和为S的连续正数序列\"><a href=\"#Problem37：和为S的连续正数序列\" class=\"headerlink\" title=\"Problem37：和为S的连续正数序列\"></a>Problem37：和为S的连续正数序列</h3><h3 id=\"Problem38：翻转单词的顺序\"><a href=\"#Problem38：翻转单词的顺序\" class=\"headerlink\" title=\"Problem38：翻转单词的顺序\"></a>Problem38：翻转单词的顺序</h3><h3 id=\"Problem39：扑克牌的顺子\"><a href=\"#Problem39：扑克牌的顺子\" class=\"headerlink\" title=\"Problem39：扑克牌的顺子\"></a>Problem39：扑克牌的顺子</h3><h3 id=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"><a href=\"#Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\" class=\"headerlink\" title=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"></a>Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）</h3><h3 id=\"Problem41：计算1-2-3-···-n\"><a href=\"#Problem41：计算1-2-3-···-n\" class=\"headerlink\" title=\"Problem41：计算1+2+3+ ··· + n\"></a>Problem41：计算1+2+3+ ··· + n</h3><h3 id=\"Problem42：不用加减乘除做加法\"><a href=\"#Problem42：不用加减乘除做加法\" class=\"headerlink\" title=\"Problem42：不用加减乘除做加法\"></a>Problem42：不用加减乘除做加法</h3><h3 id=\"Problem43：把字符串转换为整数\"><a href=\"#Problem43：把字符串转换为整数\" class=\"headerlink\" title=\"Problem43：把字符串转换为整数\"></a>Problem43：把字符串转换为整数</h3><h3 id=\"Problem44：数组中重复的数字\"><a href=\"#Problem44：数组中重复的数字\" class=\"headerlink\" title=\"Problem44：数组中重复的数字\"></a>Problem44：数组中重复的数字</h3><h3 id=\"Problem45：构建乘积数组\"><a href=\"#Problem45：构建乘积数组\" class=\"headerlink\" title=\"Problem45：构建乘积数组\"></a>Problem45：构建乘积数组</h3><h3 id=\"Problem46：正则表达式匹配\"><a href=\"#Problem46：正则表达式匹配\" class=\"headerlink\" title=\"Problem46：正则表达式匹配\"></a>Problem46：正则表达式匹配</h3><h3 id=\"Problem47：表示数值的字符串\"><a href=\"#Problem47：表示数值的字符串\" class=\"headerlink\" title=\"Problem47：表示数值的字符串\"></a>Problem47：表示数值的字符串</h3><h3 id=\"Problem48：字符流中第一个不重复的字符\"><a href=\"#Problem48：字符流中第一个不重复的字符\" class=\"headerlink\" title=\"Problem48：字符流中第一个不重复的字符\"></a>Problem48：字符流中第一个不重复的字符</h3><h3 id=\"Problem49：链表中环的入口结点\"><a href=\"#Problem49：链表中环的入口结点\" class=\"headerlink\" title=\"Problem49：链表中环的入口结点\"></a>Problem49：链表中环的入口结点</h3><h3 id=\"Problem50：删除链表中欧冠重复的节点\"><a href=\"#Problem50：删除链表中欧冠重复的节点\" class=\"headerlink\" title=\"Problem50：删除链表中欧冠重复的节点\"></a>Problem50：删除链表中欧冠重复的节点</h3><h3 id=\"Problem51：二叉树的下一个节点\"><a href=\"#Problem51：二叉树的下一个节点\" class=\"headerlink\" title=\"Problem51：二叉树的下一个节点\"></a>Problem51：二叉树的下一个节点</h3><h3 id=\"Problem52：把二叉树打印成多行\"><a href=\"#Problem52：把二叉树打印成多行\" class=\"headerlink\" title=\"Problem52：把二叉树打印成多行\"></a>Problem52：把二叉树打印成多行</h3><h3 id=\"Problem53：按之字形顺序打印二叉树\"><a href=\"#Problem53：按之字形顺序打印二叉树\" class=\"headerlink\" title=\"Problem53：按之字形顺序打印二叉树\"></a>Problem53：按之字形顺序打印二叉树</h3><h3 id=\"Problem54：序列化二叉树\"><a href=\"#Problem54：序列化二叉树\" class=\"headerlink\" title=\"Problem54：序列化二叉树\"></a>Problem54：序列化二叉树</h3><h3 id=\"Problem55：二叉搜索树的第K个节点\"><a href=\"#Problem55：二叉搜索树的第K个节点\" class=\"headerlink\" title=\"Problem55：二叉搜索树的第K个节点\"></a>Problem55：二叉搜索树的第K个节点</h3><h3 id=\"Problem56：滑动窗口的最大值大值\"><a href=\"#Problem56：滑动窗口的最大值大值\" class=\"headerlink\" title=\"Problem56：滑动窗口的最大值大值\"></a>Problem56：滑动窗口的最大值大值</h3>","site":{"data":{}},"excerpt":"<h3 id=\"Problem1：单例模式实现\"><a href=\"#Problem1：单例模式实现\" class=\"headerlink\" title=\"Problem1：单例模式实现\"></a>Problem1：单例模式实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"Problem2：二维数组中的查找\"><a href=\"#Problem2：二维数组中的查找\" class=\"headerlink\" title=\"Problem2：二维数组中的查找\"></a>Problem2：二维数组中的查找</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从二维数组的右上角开始选取与 key 比较的整数</span></span><br><span class=\"line\"><span class=\"comment\">     * column 的变化:arr[0].length - 1 ---&gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">     * row 的变化 0 ---&gt; arr.length</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] arr, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> col = arr[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (col &gt;= <span class=\"number\">0</span> &amp;&amp; row &lt; arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[row][col] == key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[row][col] &gt; key) &#123;   <span class=\"comment\">//大于查找值，则往前推一列</span></span><br><span class=\"line\">            col--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">//小于查找值，则往下推一行</span></span><br><span class=\"line\">            row++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem3：替换空格\"><a href=\"#Problem3：替换空格\" class=\"headerlink\" title=\"Problem3：替换空格\"></a>Problem3：替换空格</h3><p>请实现一个函数，将字符串的每个空格替换为”%20”。例如输入<code>We are happy</code>，则输出<code>We%20are%20happy</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 StringBuilder</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">replace</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(i) == <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">            builder.append(<span class=\"string\">\"%20\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            builder.append(str.charAt(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem4：从尾到头打印链表\"><a href=\"#Problem4：从尾到头打印链表\" class=\"headerlink\" title=\"Problem4：从尾到头打印链表\"></a>Problem4：从尾到头打印链表</h3><p>输入一个链表的头结点，按照从尾到头的顺序打印出每个节点的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T value;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用栈实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> headNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printListReverse</span><span class=\"params\">(ListNode headNode)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;ListNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (headNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        stack.push(headNode);</span><br><span class=\"line\">        headNode = headNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.empty()) &#123;</span><br><span class=\"line\">        System.out.println(stack.pop().value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ListNode&lt;Integer&gt; node = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">    node.next = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    node.next.next = <span class=\"keyword\">new</span> ListNode&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">    printListReverse(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem5：重建二叉树\"><a href=\"#Problem5：重建二叉树\" class=\"headerlink\" title=\"Problem5：重建二叉树\"></a>Problem5：重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。</p>\n<p>假设输入的前序遍历和中序遍历的结果中都不包含重复的数字。</p>\n<p>例如输入前序遍历序列： <code>{1, 2, 4, 7, 3, 5, 6, 8}</code></p>\n<p>中序遍历序列：<code>{4, 7, 2, 1, 5, 3, 8, 6}</code></p>\n<p>重建出所示二叉树并且输出它的头结点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">1</span></span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  <span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\"> /     / \\</span><br><span class=\"line\"><span class=\"number\">4</span>     <span class=\"number\">5</span>   <span class=\"number\">6</span></span><br><span class=\"line\"> \\        /</span><br><span class=\"line\"> <span class=\"number\">7</span>        <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"知识点补充\"><a href=\"#知识点补充\" class=\"headerlink\" title=\"知识点补充\"></a>知识点补充</h4><blockquote>\n<p>前序遍历：先访问根节点，再访问左子结点，最后访问右子结点；（根左右）</p>\n<p>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点；（左根右）</p>\n<p>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点；（左右根）</p>\n</blockquote>\n<blockquote>\n<p>二叉搜索树：左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。</p>\n<p>二叉树的特例是<strong>堆</strong>和<strong>红黑树</strong>。</p>\n<p>堆分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。</p>\n<p>红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。</p>\n</blockquote>\n<h3 id=\"Problem6：用两个栈实现队列\"><a href=\"#Problem6：用两个栈实现队列\" class=\"headerlink\" title=\"Problem6：用两个栈实现队列\"></a>Problem6：用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<br><code>appendTail</code>和<code>deleteHead</code>,分别完成在队列尾部插入结点和在队列头部删除结点的功能<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConstructQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     s1 用来实现放入新的元素，直接放到栈顶</span></span><br><span class=\"line\"><span class=\"comment\">     s2 用来辅助删除元素，删除队头时，先将 s1 中除底部元素之外全都移到 s2</span></span><br><span class=\"line\"><span class=\"comment\">     然后删除底部元素，再将 s2 元素移回 s1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Stack&lt;String&gt; stack1 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;String&gt; stack2 = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现appendTail函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现deleteHead函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String head = stack2.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConstructQueue queue = <span class=\"keyword\">new</span> ConstructQueue();</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">        queue.appendTail(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">        System.out.println(queue.deleteHead());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem7：旋转数组的最小数字\"><a href=\"#Problem7：旋转数组的最小数字\" class=\"headerlink\" title=\"Problem7：旋转数组的最小数字\"></a>Problem7：旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转 。输入一个递增排序的数组的旋转，输出旋转数组的最小元素。<br>例如数组 <code>{3, 4, 5, 1, 2}</code>为<code>{1, 2, 3, 4, 5}</code>的一个旋转，该数组的最小值为 1;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    System.out.println(minNumInRotateArray(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意到旋转之后的数组可以划分为两个排序子数组，前面的子数组元素都大于或等于后面子数组的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 还可以注意到最小的元素刚好是这两个子数组的分界点。在排序数组中我们可以用二分查找法实现O(logn)的查找。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 用两个指针分别指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该大于等于最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着可以找到数组中间的元素。如果中间元素位于前面的递增数组，则它应该大于等于第一个指针指向的元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 此时我们要找到的最小元素肯定应该位于该中间元素的后面。这样我们把第一个指针指向中间元素，从而缩小查找范围。</span></span><br><span class=\"line\"><span class=\"comment\">     * 同理第二个指针的范围也将逐渐缩小</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 第一个指针总是指向前面的递增数组元素，第二个指针总是指向后面的递增数组元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 最终第一个指针将指向前面的子数组的最后一个元素，第二个指针将指向后面的子数组的第一个元素，</span></span><br><span class=\"line\"><span class=\"comment\">     * 即二者最后指向相邻的元素，且第二个指针指向的刚好是最小的元素——循环结束条件。</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">minNumInRotateArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (array[left] &gt;= array[right]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            mid = right;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 此时应该用顺序查找，因为不确定array[mid]位于哪个有序子数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] == array[right] &amp;&amp; array[right] == array[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> findInOrder(array, left, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[left] &lt;= array[mid]) &#123;</span><br><span class=\"line\">            left = mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array[mid];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">findInOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = array[left];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; right; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[i] &lt; k) &#123;</span><br><span class=\"line\">            k = array[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem8：斐波那契数列\"><a href=\"#Problem8：斐波那契数列\" class=\"headerlink\" title=\"Problem8：斐波那契数列\"></a>Problem8：斐波那契数列</h3><p>写一个函数，输入n，求斐波那契数列的第n项，斐波那契数列的定义如下： </p>\n<blockquote>\n<p>n=0, f(n)=0;<br>n=1, f(n)=1;<br>n&gt;1, f(n) = f(n-1) + f(n-2).</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">        System.out.print(fibonacci(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">fibonacci</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem9：二进制中1的个数\"><a href=\"#Problem9：二进制中1的个数\" class=\"headerlink\" title=\"Problem9：二进制中1的个数\"></a>Problem9：二进制中1的个数</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。</p>\n<p>例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int oneCountsOfBinary(int i) &#123;</span><br><span class=\"line\">    char[] chars = Integer.toBinaryString(i).toCharArray();</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    for (char c : chars) &#123;</span><br><span class=\"line\">        if (c == &apos;1&apos;) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static int _oneCountsOfBinary(int i) &#123;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    int flag = 1;</span><br><span class=\"line\">    while (flag != 0) &#123;</span><br><span class=\"line\">        if ((i &amp; flag) != 0) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        flag = flag &lt;&lt; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem10：数值的整数次方\"><a href=\"#Problem10：数值的整数次方\" class=\"headerlink\" title=\"Problem10：数值的整数次方\"></a>Problem10：数值的整数次方</h3><p> 实现函数<code>double power(double base, int exponent)</code>，求 base 的 exponent 次方。不能使用库函数，同时不需要考虑大数问题。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">power</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"运算无意义\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exponent &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> / powerUnsigned(base, -exponent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> powerUnsigned(base, exponent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">powerUnsigned</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = base;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; exponent; i++) &#123;</span><br><span class=\"line\">        result = result * base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem11：O（1）时间删除链表结点\"><a href=\"#Problem11：O（1）时间删除链表结点\" class=\"headerlink\" title=\"Problem11：O（1）时间删除链表结点\"></a>Problem11：O（1）时间删除链表结点</h3><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 只有一个节点时，直接置空</span></span><br><span class=\"line\"><span class=\"comment\"> * 当待删除节点为尾节点时，需要遍历得到上一个节点，然后让得到的节点的next 为 null</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则 p-&gt;next 的值赋值给p，把p-&gt;next删除掉</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> delNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(Node head, Node delNode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || delNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == delNode) &#123;</span><br><span class=\"line\">        head = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delNode.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Node temp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp.next != delNode) &#123;</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delNode.value = delNode.next.value;</span><br><span class=\"line\">    delNode.next = delNode.next.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem12：调整数组中奇数和偶数的先后顺序\"><a href=\"#Problem12：调整数组中奇数和偶数的先后顺序\" class=\"headerlink\" title=\"Problem12：调整数组中奇数和偶数的先后顺序\"></a>Problem12：调整数组中奇数和偶数的先后顺序</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有 奇数位于数组的前半部分，所有偶数位于数组的后半部分;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">orderArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = array.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; !isEven(array[left])) &#123;</span><br><span class=\"line\">            left ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; isEven(array[right])) &#123;</span><br><span class=\"line\">            right --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = array[left];</span><br><span class=\"line\">            array[left] = array[right];</span><br><span class=\"line\">            array[right] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEven</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Problem13：链表中倒数第K个结点\"><a href=\"#Problem13：链表中倒数第K个结点\" class=\"headerlink\" title=\"Problem13：链表中倒数第K个结点\"></a>Problem13：链表中倒数第K个结点</h3><p>输入一个链表，输出该链表中倒数第K个结点。为了符合大多数人的习 惯，从1开始计数，即链表的尾结点是倒数第一个结点。</p>\n<p>例如一个链表有6个结点，从头结点开始它们的值依次是<code>1、2、3、4、5、6</code>。这个链表的倒数第三个结点是值为4的结点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用两个指针解决，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动</span></span><br><span class=\"line\"><span class=\"comment\"> * 从第k步开始，第二个指针也开始从链表的头指针开始遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针刚好在倒数第k个结点上</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 头结点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> k 倒数第k个节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode first = head;</span><br><span class=\"line\">    ListNode second = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (first.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        first = first.next;</span><br><span class=\"line\">        second = second.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(first.val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> second.val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem14：翻转链表\"><a href=\"#Problem14：翻转链表\" class=\"headerlink\" title=\"Problem14：翻转链表\"></a>Problem14：翻转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>\n<p><img src=\"/《剑指offer》题目-Java-实现/翻转链表.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">getReversedListHead</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//current节点是head的下一个节点</span></span><br><span class=\"line\">    ListNode current = head.next;</span><br><span class=\"line\">    <span class=\"comment\">//当前的head变为链表的尾，所以next为空</span></span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//currentNext节点是current的下一个节点。</span></span><br><span class=\"line\">        ListNode currentNext = current.next;</span><br><span class=\"line\">        <span class=\"comment\">//current.next反方向指向以前的节点</span></span><br><span class=\"line\">        current.next = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//移动head和current指针，到后面head重新成为头节点</span></span><br><span class=\"line\">        head = current;</span><br><span class=\"line\">        current = currentNext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 翻转单链表的递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> head 原链表的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 翻转之后的头节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">reverseListByRecursion</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode newList = reverseListByRecursion(head.next);</span><br><span class=\"line\">    head.next.next = head;</span><br><span class=\"line\">    head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem15：合并两个排序的链表\"><a href=\"#Problem15：合并两个排序的链表\" class=\"headerlink\" title=\"Problem15：合并两个排序的链表\"></a>Problem15：合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode mergeNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n1.val &lt; n2.val) &#123;</span><br><span class=\"line\">        mergeNode = n1;</span><br><span class=\"line\">        mergeNode.next = merge(n1.next, n2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mergeNode = n2;</span><br><span class=\"line\">        mergeNode.next = merge(n1, n2.next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Problem16：树的子结构判断\"><a href=\"#Problem16：树的子结构判断\" class=\"headerlink\" title=\"Problem16：树的子结构判断\"></a>Problem16：树的子结构判断</h3><h3 id=\"Problem17：二叉树的镜像\"><a href=\"#Problem17：二叉树的镜像\" class=\"headerlink\" title=\"Problem17：二叉树的镜像\"></a>Problem17：二叉树的镜像</h3><h3 id=\"Problem18：顺时针打印矩阵\"><a href=\"#Problem18：顺时针打印矩阵\" class=\"headerlink\" title=\"Problem18：顺时针打印矩阵\"></a>Problem18：顺时针打印矩阵</h3><h3 id=\"Problem19：包含min函数的栈\"><a href=\"#Problem19：包含min函数的栈\" class=\"headerlink\" title=\"Problem19：包含min函数的栈\"></a>Problem19：包含min函数的栈</h3><h3 id=\"Problem20：栈的压入、弹出序列\"><a href=\"#Problem20：栈的压入、弹出序列\" class=\"headerlink\" title=\"Problem20：栈的压入、弹出序列\"></a>Problem20：栈的压入、弹出序列</h3><h3 id=\"Problem21：从上往下打印二叉树\"><a href=\"#Problem21：从上往下打印二叉树\" class=\"headerlink\" title=\"Problem21：从上往下打印二叉树\"></a>Problem21：从上往下打印二叉树</h3><h3 id=\"Problem22：二叉搜索树的后序遍历\"><a href=\"#Problem22：二叉搜索树的后序遍历\" class=\"headerlink\" title=\"Problem22：二叉搜索树的后序遍历\"></a>Problem22：二叉搜索树的后序遍历</h3><h3 id=\"Problem23：二叉树中和为某一值的路径\"><a href=\"#Problem23：二叉树中和为某一值的路径\" class=\"headerlink\" title=\"Problem23：二叉树中和为某一值的路径\"></a>Problem23：二叉树中和为某一值的路径</h3><h3 id=\"Problem24：字符串的排列\"><a href=\"#Problem24：字符串的排列\" class=\"headerlink\" title=\"Problem24：字符串的排列\"></a>Problem24：字符串的排列</h3><h3 id=\"Problem25：数组中出现次数超过一半的数字\"><a href=\"#Problem25：数组中出现次数超过一半的数字\" class=\"headerlink\" title=\"Problem25：数组中出现次数超过一半的数字\"></a>Problem25：数组中出现次数超过一半的数字</h3><h3 id=\"Problem26：连续子数组的最大和\"><a href=\"#Problem26：连续子数组的最大和\" class=\"headerlink\" title=\"Problem26：连续子数组的最大和\"></a>Problem26：连续子数组的最大和</h3><h3 id=\"Problem27：整数中1出现的次数\"><a href=\"#Problem27：整数中1出现的次数\" class=\"headerlink\" title=\"Problem27：整数中1出现的次数\"></a>Problem27：整数中1出现的次数</h3><h3 id=\"Problem28：把数组排成最小的数\"><a href=\"#Problem28：把数组排成最小的数\" class=\"headerlink\" title=\"Problem28：把数组排成最小的数\"></a>Problem28：把数组排成最小的数</h3><h3 id=\"Problem29：丑数\"><a href=\"#Problem29：丑数\" class=\"headerlink\" title=\"Problem29：丑数\"></a>Problem29：丑数</h3><h3 id=\"Problem30：第一个只出现一次的字符\"><a href=\"#Problem30：第一个只出现一次的字符\" class=\"headerlink\" title=\"Problem30：第一个只出现一次的字符\"></a>Problem30：第一个只出现一次的字符</h3><h3 id=\"Problem31：数组中的逆序对\"><a href=\"#Problem31：数组中的逆序对\" class=\"headerlink\" title=\"Problem31：数组中的逆序对\"></a>Problem31：数组中的逆序对</h3><h3 id=\"Problem32：两个链表的第一个公共节点\"><a href=\"#Problem32：两个链表的第一个公共节点\" class=\"headerlink\" title=\"Problem32：两个链表的第一个公共节点\"></a>Problem32：两个链表的第一个公共节点</h3><h3 id=\"Problem33：二叉树的深度-amp-amp-平衡二叉树判断\"><a href=\"#Problem33：二叉树的深度-amp-amp-平衡二叉树判断\" class=\"headerlink\" title=\"Problem33：二叉树的深度&amp;&amp;平衡二叉树判断\"></a>Problem33：二叉树的深度&amp;&amp;平衡二叉树判断</h3><h3 id=\"Problem34：数字在排序数组中出现的次数\"><a href=\"#Problem34：数字在排序数组中出现的次数\" class=\"headerlink\" title=\"Problem34：数字在排序数组中出现的次数\"></a>Problem34：数字在排序数组中出现的次数</h3><h3 id=\"Problem35：数组中只出现一次的数字\"><a href=\"#Problem35：数组中只出现一次的数字\" class=\"headerlink\" title=\"Problem35：数组中只出现一次的数字\"></a>Problem35：数组中只出现一次的数字</h3><h3 id=\"Problem36：和为S的两个数字\"><a href=\"#Problem36：和为S的两个数字\" class=\"headerlink\" title=\"Problem36：和为S的两个数字\"></a>Problem36：和为S的两个数字</h3><h3 id=\"Problem37：和为S的连续正数序列\"><a href=\"#Problem37：和为S的连续正数序列\" class=\"headerlink\" title=\"Problem37：和为S的连续正数序列\"></a>Problem37：和为S的连续正数序列</h3><h3 id=\"Problem38：翻转单词的顺序\"><a href=\"#Problem38：翻转单词的顺序\" class=\"headerlink\" title=\"Problem38：翻转单词的顺序\"></a>Problem38：翻转单词的顺序</h3><h3 id=\"Problem39：扑克牌的顺子\"><a href=\"#Problem39：扑克牌的顺子\" class=\"headerlink\" title=\"Problem39：扑克牌的顺子\"></a>Problem39：扑克牌的顺子</h3><h3 id=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"><a href=\"#Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\" class=\"headerlink\" title=\"Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）\"></a>Problem40：y圆圈中最后剩下的数字（约瑟夫环问题）</h3><h3 id=\"Problem41：计算1-2-3-···-n\"><a href=\"#Problem41：计算1-2-3-···-n\" class=\"headerlink\" title=\"Problem41：计算1+2+3+ ··· + n\"></a>Problem41：计算1+2+3+ ··· + n</h3><h3 id=\"Problem42：不用加减乘除做加法\"><a href=\"#Problem42：不用加减乘除做加法\" class=\"headerlink\" title=\"Problem42：不用加减乘除做加法\"></a>Problem42：不用加减乘除做加法</h3><h3 id=\"Problem43：把字符串转换为整数\"><a href=\"#Problem43：把字符串转换为整数\" class=\"headerlink\" title=\"Problem43：把字符串转换为整数\"></a>Problem43：把字符串转换为整数</h3><h3 id=\"Problem44：数组中重复的数字\"><a href=\"#Problem44：数组中重复的数字\" class=\"headerlink\" title=\"Problem44：数组中重复的数字\"></a>Problem44：数组中重复的数字</h3><h3 id=\"Problem45：构建乘积数组\"><a href=\"#Problem45：构建乘积数组\" class=\"headerlink\" title=\"Problem45：构建乘积数组\"></a>Problem45：构建乘积数组</h3><h3 id=\"Problem46：正则表达式匹配\"><a href=\"#Problem46：正则表达式匹配\" class=\"headerlink\" title=\"Problem46：正则表达式匹配\"></a>Problem46：正则表达式匹配</h3><h3 id=\"Problem47：表示数值的字符串\"><a href=\"#Problem47：表示数值的字符串\" class=\"headerlink\" title=\"Problem47：表示数值的字符串\"></a>Problem47：表示数值的字符串</h3><h3 id=\"Problem48：字符流中第一个不重复的字符\"><a href=\"#Problem48：字符流中第一个不重复的字符\" class=\"headerlink\" title=\"Problem48：字符流中第一个不重复的字符\"></a>Problem48：字符流中第一个不重复的字符</h3><h3 id=\"Problem49：链表中环的入口结点\"><a href=\"#Problem49：链表中环的入口结点\" class=\"headerlink\" title=\"Problem49：链表中环的入口结点\"></a>Problem49：链表中环的入口结点</h3><h3 id=\"Problem50：删除链表中欧冠重复的节点\"><a href=\"#Problem50：删除链表中欧冠重复的节点\" class=\"headerlink\" title=\"Problem50：删除链表中欧冠重复的节点\"></a>Problem50：删除链表中欧冠重复的节点</h3><h3 id=\"Problem51：二叉树的下一个节点\"><a href=\"#Problem51：二叉树的下一个节点\" class=\"headerlink\" title=\"Problem51：二叉树的下一个节点\"></a>Problem51：二叉树的下一个节点</h3><h3 id=\"Problem52：把二叉树打印成多行\"><a href=\"#Problem52：把二叉树打印成多行\" class=\"headerlink\" title=\"Problem52：把二叉树打印成多行\"></a>Problem52：把二叉树打印成多行</h3><h3 id=\"Problem53：按之字形顺序打印二叉树\"><a href=\"#Problem53：按之字形顺序打印二叉树\" class=\"headerlink\" title=\"Problem53：按之字形顺序打印二叉树\"></a>Problem53：按之字形顺序打印二叉树</h3><h3 id=\"Problem54：序列化二叉树\"><a href=\"#Problem54：序列化二叉树\" class=\"headerlink\" title=\"Problem54：序列化二叉树\"></a>Problem54：序列化二叉树</h3><h3 id=\"Problem55：二叉搜索树的第K个节点\"><a href=\"#Problem55：二叉搜索树的第K个节点\" class=\"headerlink\" title=\"Problem55：二叉搜索树的第K个节点\"></a>Problem55：二叉搜索树的第K个节点</h3><h3 id=\"Problem56：滑动窗口的最大值大值\"><a href=\"#Problem56：滑动窗口的最大值大值\" class=\"headerlink\" title=\"Problem56：滑动窗口的最大值大值\"></a>Problem56：滑动窗口的最大值大值</h3>"},{"title":"Java 线程和线程池详解","date":"2019-03-20T09:29:06.000Z","_content":"\n## 引言\n线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：\n> java.lang.Thread 类的一个实例；\n>\n> 线程的执行。\n\n<!--more-->\n\n## Java 线程\n\n### 线程和进程\n\n#### 概念\n\n进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。\n\n#### 区别\n进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。\n\n线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。\n\n> 一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。\n>\n> Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。\n>\n> 由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。\n\n实际开发中使用多线程的优势在于\n\n- 进程之间不能共享内存，而线程之间可以共享内存。\n- 系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。\n- Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。\n\n### 线程的状态\n图一\n\n\n\n![](Java-线程和线程池详解/线程状态1.png)\n\n图二\n\n![](Java-线程和线程池详解/线程状态2.png)\n\n### 分类\nJava 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。\n\n只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。\n```Java\npublic class Main {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread();\n        thread.setDaemon(true);\n        System.out.println(\"is daemon thread? \" + thread.isDaemon());\n    }\n}\n```\n输出为\n```\nis daemon thread? true\n```\n使用守护线程要注意的点\n- `thread.setDaemon(true)` 必须在 `thread.start()` 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。\n- 在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 \n- 不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 \n\n### Runnable 和 Thread\nRunnable 是一个线程接口，查看其构造\n```Java\npublic interface Runnable {\n    public abstract void run();\n}\n```\n其中只定义了一个`run`方法\n\nThread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的`init`\n```\nprivate void init(ThreadGroup g, Runnable target, String name,\n                      long stackSize, AccessControlContext acc,\n                      boolean inheritThreadLocals)\n```\n观察 Thread 中重写的`run`方法\n```Java\n@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n其中 target 为 Runnable 对象，即调用 Thread 的`run`实际上是调用我们传进去的 Runnable 的对应方法\n\n观察其`start`方法\n```Java\npublic synchronized void start() {\n    //不能重复调用 start 方法\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n        \n    //将线程加入线程组\n    group.add(this);\n    //线程开始标志\n    boolean started = false;\n    try {\n        //调用native方法开始多线程\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n其中`start0`是 native 方法，在其中新建线程，然后回调 target 的 run 方法。\n\n也就是说，如果我们直接调用`run`方法，相当于调用普通方法，不会有多线程效果。只有调用`start`才会在后台开启另一个线程，等待 CPU 调度。\n\n### 多线程 API\n#### Object\n实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法\n\n| 方法            | 描述                                                         |\n| --------------- | ------------------------------------------------------------ |\n| wait()          | 锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池 |\n| wait(long)      | 锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。 |\n| wait(long, int) | 和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000 |\n| notify()        | 随机唤醒一个处于等待中的线程（同一个等待阻塞池中）           |\n| notifyAll()     | 唤醒所有等待中的线程（同一个等待阻塞池中）                   |\n\n以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行`object.wait()`方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下\n```Java\npublic class ThreadTest {\n    public static void main(String[] args) {\n        Thread t = Thread.currentThread();\n        try {\n            t.wait(2000);   //由于没有获得锁，将抛出 IllegalMonitorStateException 异常\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in Main: \" + t.toString());\n        A a = new A();\n        a.printThreadInfo();\n    }\n}\n\nclass A {\n    public synchronized void printThreadInfo() {\n        Thread t = Thread.currentThread();\n        try {\n            wait(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in A: \" + t.toString());\n    }\n}\n```\n删除`main`中 try/catch 语句之后，控制台输出如下\n```\ncurrent Thread info in Main: Thread[main,5,main]\n//等待两秒\ncurrent Thread info in A: Thread[main,5,main]\n```\n**为什么需要在 synchronized 中？**\n> wait和notify用于线程间通信。\n> 以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性\n>\n> 一般对队列的操作如下:\n> while(queue.size() == MAX_SIZE){ wait() }\n>\n> 假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2\n>\n> - t1判断队列满，需要 wait 阻塞线程。\n>\n> - 但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。\n>\n> - 这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。\n>\n> - 假如此时消费者不消费了，那么生产者则会一直阻塞下去。\n>\n> - 所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。\n\n**为什么定义在 Object 中？**\n> Object 中的`wait()`, `notify()`等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。\n>\n> `wait()`会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！\n> 当线程释放它持有的“同步锁”之后变成等待线程，可以被`notify()`或`notifyAll()`唤醒。那么，`notify()`依据什么唤醒等待线程的？或者说，`wait()`等待线程和`notify()`之间通过什么关联起来？答案是：依据“对象的同步锁”。\n>\n> 负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用`notify()`或`notifyAll()`方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n> 总之，`notify()`, `wait()`依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！\n>\n> 这就是`notify()`, `wait()`等函数定义在 Object 类，而不是 Thread 类中的原因。\n>\n> 来自 [JAVA 线程状态及转化](https://www.cnblogs.com/happy-coder/p/6587092.html)\n\n#### Thread \n| 方法                      | 描述                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| Thread.currentThread()    | 返回对当前线程对象的引用                                     |\n| Thread.interrupted()      | 检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false） |\n| Thread.sleep(long millis) | 使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会） |\n| Thread.yield()            | 使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会） |\n| t.getId()...              | 返回该线程的 id 等等信息                                     |\n| t.interrupt()             | 将该线程中断（实际并不会中断，只是将中断标志设置为true）     |\n| t.isInterrupted()         | 检测该线程是否已经中断                                       |\n| t.join()                  | 在a线程中调用b.join()，则a线程阻塞，直到b线程执行完          |\n| t.join(long millis)       | 同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。 |\n\n---\n关于 interrupt，[JAVA interrupt、interrupted和isInterrupted的区别](https://blog.csdn.net/qpc908694753/article/details/61414495)\n> interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为\"中断\"状态。\n>\n> 注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。\n\n#### 废弃方法\n- stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止\n- suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。\n- resume：用来回复被挂起的线程，跟 suspend 对应。\n\n## 线程池\n\nJava 中关于线程池的继承关系如下\n\n![](Java-线程和线程池详解/继承图.png)\n\nExecutor 是一个顶层接口，其中只声明了一个方法`execute(Runnable)`，用来执行传进去的任务\n\nExecutorService 接口继承了 Executor 接口，并声明了一些方法：`submit`、`invokeAll`、`invokeAny`以及`shutDown` 等\n\n抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法\n\nThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下\n```Java\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n- corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用`prestartAllCoreThreads`或者`prestartCoreThread`方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中\n- maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程\n- keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了`allowCoreThreadTimeOut(boolean)`方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0\n- unit：参数keepAliveTime的时间单位，有7种取值\n```\nTimeUnit.DAYS;               //天\nTimeUnit.HOURS;             //小时\nTimeUnit.MINUTES;           //分钟\nTimeUnit.SECONDS;           //秒\nTimeUnit.MILLISECONDS;      //毫秒\nTimeUnit.MICROSECONDS;      //微妙\nTimeUnit.NANOSECONDS;       //纳秒\n```\n\n- workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：\n```\nArrayBlockingQueue;\nLinkedBlockingQueue;\nSynchronousQueue;\n```\n- threadFactory：线程工厂，主要用来创建线程\n- handler：表示当拒绝处理任务时的策略，有以下四种选择：\n```\nThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 \nThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 \nThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\nThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 \n```\n\n#### 为何使用\n- 降低资源消耗<br>\n  可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 \n- 提高响应速度<br> \n  当任务到达时，任务可以不需要等到线程创建就能立即执行。 \n- 提高线程的可管理性 <br>\n  线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控\n\n#### 如何使用\n实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法\n```Java\n    //创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的\n    //线程池满了就不再添加线程；\n    //如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列\n    //因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务\n    //若池中线程空闲时间超过指定大小，则该线程会被销毁。\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //创建只有一个线程的线程池，且线程的存活时间是无限的\n    //当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>(),\n                                    threadFactory));\n    }\n    \n    //创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行\n    //如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中\n    //这是一种按照超时时间排序的队列结构\n    public static ScheduledExecutorService newScheduledThreadPool(\n            int corePoolSize, ThreadFactory threadFactory) {\n        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\n    }\n```\nThreadPoolExecutor 中比较重要的方法\n\n| 方法          | 描述                                                      |\n| ------------- | --------------------------------------------------------- |\n| execute()     | 向线程池提交一个任务，交由线程池去执行                    |\n| submit()      | 向线程池提交任务的，能够返回任务执行的结果（利用 Future） |\n| shutdown()    | 关闭线程池                                                |\n| shutdownNow() | 关闭线程池                                                |\n\n还有其他的方法比如：`getQueue()`、`getPoolSize()` 、`getActiveCount()`、`getCompletedTaskCount()`等用来获取线程池的相关属性。\n\n简单使用\n```Java\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        System.out.println(Thread.currentThread());\n        executor.execute(()-> {\n            System.out.println(Thread.currentThread());\n        });\n    }\n```\n控制台输出\n```\nThread[main,5,main]\nThread[pool-1-thread-1,5,main]\n```\n#### 工作原理\n观察 ThreadPoolExecutor 中的`execute`方法\n```Java\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n  \n        /**\n         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务\n         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。\n         * 三、如果加入 workQueue 失败，则创建线程执行任务，\n         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n\n跟踪`addWorker`方法\n```Java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (int c = ctl.get();;) {\n        // Check if queue empty only if necessary.\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP)\n                || firstTask != null\n                || workQueue.isEmpty()))\n            return false;\n        for (;;) {\n            /*\n             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，\n             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况\n             */\n            if (workerCountOf(c)\n                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateAtLeast(c, SHUTDOWN))\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n        \n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        /*\n         * 创建Worker时会调用threadFactory来创建一个线程。\n         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。\n         */\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                int c = ctl.get();\n                \n                if (isRunning(c) ||\n                    (runStateLessThan(c, STOP) && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n新建 Work ，同时也会利用工厂类实例化一个线程\n```Java\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n如果 workerAdded，调用`t.start()`\n```Java\npublic void run() {\n    runWorker(this);\n}\n```\n跟踪`runWorker`\n```Java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                try {\n                    task.run();\n                    afterExecute(task, null);\n                } catch (Throwable ex) {\n                    afterExecute(task, ex);\n                    throw ex;\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n可以看到`getTask`方法不断从 workerQueue 中读取任务然后执行。只要`getTask`方法不返回 null，循环就不会退出。\n```Java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n    for (;;) {\n        int c = ctl.get();\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        int wc = workerCountOf(c);\n\n        //是判断当前线程数是否大于 corePoolSize\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        \n        /*\n         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务\n         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出\n         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前\n         */\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n最后用一张图总结上述过程\n\n![](Java-线程和线程池详解/线程池流程.png)","source":"_posts/Java-线程和线程池详解.md","raw":"---\ntitle: Java 线程和线程池详解\ndate: 2019-03-20 17:29:06\ntags:\n- Java\n- 多线程\n- 线程池\ncategories:\n- Java\n---\n\n## 引言\n线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：\n> java.lang.Thread 类的一个实例；\n>\n> 线程的执行。\n\n<!--more-->\n\n## Java 线程\n\n### 线程和进程\n\n#### 概念\n\n进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。\n\n#### 区别\n进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。\n\n线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。\n\n> 一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。\n>\n> Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。\n>\n> 由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。\n\n实际开发中使用多线程的优势在于\n\n- 进程之间不能共享内存，而线程之间可以共享内存。\n- 系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。\n- Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。\n\n### 线程的状态\n图一\n\n\n\n![](Java-线程和线程池详解/线程状态1.png)\n\n图二\n\n![](Java-线程和线程池详解/线程状态2.png)\n\n### 分类\nJava 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。\n\n只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。\n```Java\npublic class Main {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread();\n        thread.setDaemon(true);\n        System.out.println(\"is daemon thread? \" + thread.isDaemon());\n    }\n}\n```\n输出为\n```\nis daemon thread? true\n```\n使用守护线程要注意的点\n- `thread.setDaemon(true)` 必须在 `thread.start()` 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。\n- 在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 \n- 不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 \n\n### Runnable 和 Thread\nRunnable 是一个线程接口，查看其构造\n```Java\npublic interface Runnable {\n    public abstract void run();\n}\n```\n其中只定义了一个`run`方法\n\nThread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的`init`\n```\nprivate void init(ThreadGroup g, Runnable target, String name,\n                      long stackSize, AccessControlContext acc,\n                      boolean inheritThreadLocals)\n```\n观察 Thread 中重写的`run`方法\n```Java\n@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n其中 target 为 Runnable 对象，即调用 Thread 的`run`实际上是调用我们传进去的 Runnable 的对应方法\n\n观察其`start`方法\n```Java\npublic synchronized void start() {\n    //不能重复调用 start 方法\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n        \n    //将线程加入线程组\n    group.add(this);\n    //线程开始标志\n    boolean started = false;\n    try {\n        //调用native方法开始多线程\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n其中`start0`是 native 方法，在其中新建线程，然后回调 target 的 run 方法。\n\n也就是说，如果我们直接调用`run`方法，相当于调用普通方法，不会有多线程效果。只有调用`start`才会在后台开启另一个线程，等待 CPU 调度。\n\n### 多线程 API\n#### Object\n实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法\n\n| 方法            | 描述                                                         |\n| --------------- | ------------------------------------------------------------ |\n| wait()          | 锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池 |\n| wait(long)      | 锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。 |\n| wait(long, int) | 和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000 |\n| notify()        | 随机唤醒一个处于等待中的线程（同一个等待阻塞池中）           |\n| notifyAll()     | 唤醒所有等待中的线程（同一个等待阻塞池中）                   |\n\n以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行`object.wait()`方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下\n```Java\npublic class ThreadTest {\n    public static void main(String[] args) {\n        Thread t = Thread.currentThread();\n        try {\n            t.wait(2000);   //由于没有获得锁，将抛出 IllegalMonitorStateException 异常\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in Main: \" + t.toString());\n        A a = new A();\n        a.printThreadInfo();\n    }\n}\n\nclass A {\n    public synchronized void printThreadInfo() {\n        Thread t = Thread.currentThread();\n        try {\n            wait(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"current Thread info in A: \" + t.toString());\n    }\n}\n```\n删除`main`中 try/catch 语句之后，控制台输出如下\n```\ncurrent Thread info in Main: Thread[main,5,main]\n//等待两秒\ncurrent Thread info in A: Thread[main,5,main]\n```\n**为什么需要在 synchronized 中？**\n> wait和notify用于线程间通信。\n> 以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性\n>\n> 一般对队列的操作如下:\n> while(queue.size() == MAX_SIZE){ wait() }\n>\n> 假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2\n>\n> - t1判断队列满，需要 wait 阻塞线程。\n>\n> - 但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。\n>\n> - 这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。\n>\n> - 假如此时消费者不消费了，那么生产者则会一直阻塞下去。\n>\n> - 所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。\n\n**为什么定义在 Object 中？**\n> Object 中的`wait()`, `notify()`等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。\n>\n> `wait()`会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！\n> 当线程释放它持有的“同步锁”之后变成等待线程，可以被`notify()`或`notifyAll()`唤醒。那么，`notify()`依据什么唤醒等待线程的？或者说，`wait()`等待线程和`notify()`之间通过什么关联起来？答案是：依据“对象的同步锁”。\n>\n> 负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用`notify()`或`notifyAll()`方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n> 总之，`notify()`, `wait()`依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！\n>\n> 这就是`notify()`, `wait()`等函数定义在 Object 类，而不是 Thread 类中的原因。\n>\n> 来自 [JAVA 线程状态及转化](https://www.cnblogs.com/happy-coder/p/6587092.html)\n\n#### Thread \n| 方法                      | 描述                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| Thread.currentThread()    | 返回对当前线程对象的引用                                     |\n| Thread.interrupted()      | 检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false） |\n| Thread.sleep(long millis) | 使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会） |\n| Thread.yield()            | 使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会） |\n| t.getId()...              | 返回该线程的 id 等等信息                                     |\n| t.interrupt()             | 将该线程中断（实际并不会中断，只是将中断标志设置为true）     |\n| t.isInterrupted()         | 检测该线程是否已经中断                                       |\n| t.join()                  | 在a线程中调用b.join()，则a线程阻塞，直到b线程执行完          |\n| t.join(long millis)       | 同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。 |\n\n---\n关于 interrupt，[JAVA interrupt、interrupted和isInterrupted的区别](https://blog.csdn.net/qpc908694753/article/details/61414495)\n> interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为\"中断\"状态。\n>\n> 注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。\n\n#### 废弃方法\n- stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止\n- suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。\n- resume：用来回复被挂起的线程，跟 suspend 对应。\n\n## 线程池\n\nJava 中关于线程池的继承关系如下\n\n![](Java-线程和线程池详解/继承图.png)\n\nExecutor 是一个顶层接口，其中只声明了一个方法`execute(Runnable)`，用来执行传进去的任务\n\nExecutorService 接口继承了 Executor 接口，并声明了一些方法：`submit`、`invokeAll`、`invokeAny`以及`shutDown` 等\n\n抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法\n\nThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下\n```Java\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n- corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用`prestartAllCoreThreads`或者`prestartCoreThread`方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中\n- maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程\n- keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了`allowCoreThreadTimeOut(boolean)`方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0\n- unit：参数keepAliveTime的时间单位，有7种取值\n```\nTimeUnit.DAYS;               //天\nTimeUnit.HOURS;             //小时\nTimeUnit.MINUTES;           //分钟\nTimeUnit.SECONDS;           //秒\nTimeUnit.MILLISECONDS;      //毫秒\nTimeUnit.MICROSECONDS;      //微妙\nTimeUnit.NANOSECONDS;       //纳秒\n```\n\n- workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：\n```\nArrayBlockingQueue;\nLinkedBlockingQueue;\nSynchronousQueue;\n```\n- threadFactory：线程工厂，主要用来创建线程\n- handler：表示当拒绝处理任务时的策略，有以下四种选择：\n```\nThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 \nThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 \nThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\nThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 \n```\n\n#### 为何使用\n- 降低资源消耗<br>\n  可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 \n- 提高响应速度<br> \n  当任务到达时，任务可以不需要等到线程创建就能立即执行。 \n- 提高线程的可管理性 <br>\n  线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控\n\n#### 如何使用\n实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法\n```Java\n    //创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的\n    //线程池满了就不再添加线程；\n    //如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列\n    //因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务\n    //若池中线程空闲时间超过指定大小，则该线程会被销毁。\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>(),\n                                      threadFactory);\n    }\n    \n    //创建只有一个线程的线程池，且线程的存活时间是无限的\n    //当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>(),\n                                    threadFactory));\n    }\n    \n    //创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行\n    //如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中\n    //这是一种按照超时时间排序的队列结构\n    public static ScheduledExecutorService newScheduledThreadPool(\n            int corePoolSize, ThreadFactory threadFactory) {\n        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\n    }\n```\nThreadPoolExecutor 中比较重要的方法\n\n| 方法          | 描述                                                      |\n| ------------- | --------------------------------------------------------- |\n| execute()     | 向线程池提交一个任务，交由线程池去执行                    |\n| submit()      | 向线程池提交任务的，能够返回任务执行的结果（利用 Future） |\n| shutdown()    | 关闭线程池                                                |\n| shutdownNow() | 关闭线程池                                                |\n\n还有其他的方法比如：`getQueue()`、`getPoolSize()` 、`getActiveCount()`、`getCompletedTaskCount()`等用来获取线程池的相关属性。\n\n简单使用\n```Java\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        System.out.println(Thread.currentThread());\n        executor.execute(()-> {\n            System.out.println(Thread.currentThread());\n        });\n    }\n```\n控制台输出\n```\nThread[main,5,main]\nThread[pool-1-thread-1,5,main]\n```\n#### 工作原理\n观察 ThreadPoolExecutor 中的`execute`方法\n```Java\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n  \n        /**\n         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务\n         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。\n         * 三、如果加入 workQueue 失败，则创建线程执行任务，\n         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n\n跟踪`addWorker`方法\n```Java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (int c = ctl.get();;) {\n        // Check if queue empty only if necessary.\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP)\n                || firstTask != null\n                || workQueue.isEmpty()))\n            return false;\n        for (;;) {\n            /*\n             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，\n             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况\n             */\n            if (workerCountOf(c)\n                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateAtLeast(c, SHUTDOWN))\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n        \n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        /*\n         * 创建Worker时会调用threadFactory来创建一个线程。\n         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。\n         */\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                int c = ctl.get();\n                \n                if (isRunning(c) ||\n                    (runStateLessThan(c, STOP) && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n新建 Work ，同时也会利用工厂类实例化一个线程\n```Java\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n如果 workerAdded，调用`t.start()`\n```Java\npublic void run() {\n    runWorker(this);\n}\n```\n跟踪`runWorker`\n```Java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                try {\n                    task.run();\n                    afterExecute(task, null);\n                } catch (Throwable ex) {\n                    afterExecute(task, ex);\n                    throw ex;\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n可以看到`getTask`方法不断从 workerQueue 中读取任务然后执行。只要`getTask`方法不返回 null，循环就不会退出。\n```Java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n    for (;;) {\n        int c = ctl.get();\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        int wc = workerCountOf(c);\n\n        //是判断当前线程数是否大于 corePoolSize\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        \n        /*\n         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务\n         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出\n         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前\n         */\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n最后用一张图总结上述过程\n\n![](Java-线程和线程池详解/线程池流程.png)","slug":"Java-线程和线程池详解","published":1,"updated":"2019-03-21T10:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjurzavea003di0upt32ghpxm","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：</p>\n<blockquote>\n<p>java.lang.Thread 类的一个实例；</p>\n<p>线程的执行。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Java-线程\"><a href=\"#Java-线程\" class=\"headerlink\" title=\"Java 线程\"></a>Java 线程</h2><h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>\n<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</p>\n<p>线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。</p>\n<blockquote>\n<p>一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。</p>\n<p>Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。</p>\n<p>由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。</p>\n</blockquote>\n<p>实际开发中使用多线程的优势在于</p>\n<ul>\n<li>进程之间不能共享内存，而线程之间可以共享内存。</li>\n<li>系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。</li>\n<li>Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。</li>\n</ul>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><p>图一</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态1.png\" alt=\"\"></p>\n<p>图二</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态2.png\" alt=\"\"></p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>Java 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。</p>\n<p>只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"is daemon thread? \"</span> + thread.isDaemon());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is daemon thread? true</span><br></pre></td></tr></table></figure></p>\n<p>使用守护线程要注意的点</p>\n<ul>\n<li><code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。</li>\n<li>在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 </li>\n<li>不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 </li>\n</ul>\n<h3 id=\"Runnable-和-Thread\"><a href=\"#Runnable-和-Thread\" class=\"headerlink\" title=\"Runnable 和 Thread\"></a>Runnable 和 Thread</h3><p>Runnable 是一个线程接口，查看其构造<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中只定义了一个<code>run</code>方法</p>\n<p>Thread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的<code>init</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class=\"line\">                      long stackSize, AccessControlContext acc,</span><br><span class=\"line\">                      boolean inheritThreadLocals)</span><br></pre></td></tr></table></figure></p>\n<p>观察 Thread 中重写的<code>run</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 target 为 Runnable 对象，即调用 Thread 的<code>run</code>实际上是调用我们传进去的 Runnable 的对应方法</p>\n<p>观察其<code>start</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不能重复调用 start 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">//将线程加入线程组</span></span><br><span class=\"line\">    group.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程开始标志</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> started = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用native方法开始多线程</span></span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!started) &#123;</span><br><span class=\"line\">                group.threadStartFailed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* do nothing. If start0 threw a Throwable then</span></span><br><span class=\"line\"><span class=\"comment\">              it will be passed up the call stack */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>start0</code>是 native 方法，在其中新建线程，然后回调 target 的 run 方法。</p>\n<p>也就是说，如果我们直接调用<code>run</code>方法，相当于调用普通方法，不会有多线程效果。只有调用<code>start</code>才会在后台开启另一个线程，等待 CPU 调度。</p>\n<h3 id=\"多线程-API\"><a href=\"#多线程-API\" class=\"headerlink\" title=\"多线程 API\"></a>多线程 API</h3><h4 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h4><p>实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wait()</td>\n<td>锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池</td>\n</tr>\n<tr>\n<td>wait(long)</td>\n<td>锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。</td>\n</tr>\n<tr>\n<td>wait(long, int)</td>\n<td>和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000</td>\n</tr>\n<tr>\n<td>notify()</td>\n<td>随机唤醒一个处于等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n<tr>\n<td>notifyAll()</td>\n<td>唤醒所有等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n</tbody>\n</table>\n<p>以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行<code>object.wait()</code>方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            t.wait(<span class=\"number\">2000</span>);   <span class=\"comment\">//由于没有获得锁，将抛出 IllegalMonitorStateException 异常</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in Main: \"</span> + t.toString());</span><br><span class=\"line\">        A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">        a.printThreadInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">printThreadInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            wait(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in A: \"</span> + t.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>删除<code>main</code>中 try/catch 语句之后，控制台输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current Thread info in Main: Thread[main,5,main]</span><br><span class=\"line\">//等待两秒</span><br><span class=\"line\">current Thread info in A: Thread[main,5,main]</span><br></pre></td></tr></table></figure></p>\n<p><strong>为什么需要在 synchronized 中？</strong></p>\n<blockquote>\n<p>wait和notify用于线程间通信。<br>以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性</p>\n<p>一般对队列的操作如下:<br>while(queue.size() == MAX_SIZE){ wait() }</p>\n<p>假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2</p>\n<ul>\n<li><p>t1判断队列满，需要 wait 阻塞线程。</p>\n</li>\n<li><p>但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。</p>\n</li>\n<li><p>这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。</p>\n</li>\n<li><p>假如此时消费者不消费了，那么生产者则会一直阻塞下去。</p>\n</li>\n<li><p>所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>为什么定义在 Object 中？</strong></p>\n<blockquote>\n<p>Object 中的<code>wait()</code>, <code>notify()</code>等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。</p>\n<p><code>wait()</code>会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！<br>当线程释放它持有的“同步锁”之后变成等待线程，可以被<code>notify()</code>或<code>notifyAll()</code>唤醒。那么，<code>notify()</code>依据什么唤醒等待线程的？或者说，<code>wait()</code>等待线程和<code>notify()</code>之间通过什么关联起来？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用<code>notify()</code>或<code>notifyAll()</code>方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，<code>notify()</code>, <code>wait()</code>依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！</p>\n<p>这就是<code>notify()</code>, <code>wait()</code>等函数定义在 Object 类，而不是 Thread 类中的原因。</p>\n<p>来自 <a href=\"https://www.cnblogs.com/happy-coder/p/6587092.html\" target=\"_blank\" rel=\"noopener\">JAVA 线程状态及转化</a></p>\n</blockquote>\n<h4 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Thread.currentThread()</td>\n<td>返回对当前线程对象的引用</td>\n</tr>\n<tr>\n<td>Thread.interrupted()</td>\n<td>检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false）</td>\n</tr>\n<tr>\n<td>Thread.sleep(long millis)</td>\n<td>使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会）</td>\n</tr>\n<tr>\n<td>Thread.yield()</td>\n<td>使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会）</td>\n</tr>\n<tr>\n<td>t.getId()…</td>\n<td>返回该线程的 id 等等信息</td>\n</tr>\n<tr>\n<td>t.interrupt()</td>\n<td>将该线程中断（实际并不会中断，只是将中断标志设置为true）</td>\n</tr>\n<tr>\n<td>t.isInterrupted()</td>\n<td>检测该线程是否已经中断</td>\n</tr>\n<tr>\n<td>t.join()</td>\n<td>在a线程中调用b.join()，则a线程阻塞，直到b线程执行完</td>\n</tr>\n<tr>\n<td>t.join(long millis)</td>\n<td>同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>关于 interrupt，<a href=\"https://blog.csdn.net/qpc908694753/article/details/61414495\" target=\"_blank\" rel=\"noopener\">JAVA interrupt、interrupted和isInterrupted的区别</a></p>\n<blockquote>\n<p>interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。</p>\n<p>注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>\n</blockquote>\n<h4 id=\"废弃方法\"><a href=\"#废弃方法\" class=\"headerlink\" title=\"废弃方法\"></a>废弃方法</h4><ul>\n<li>stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止</li>\n<li>suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。</li>\n<li>resume：用来回复被挂起的线程，跟 suspend 对应。</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>Java 中关于线程池的继承关系如下</p>\n<p><img src=\"/Java-线程和线程池详解/继承图.png\" alt=\"\"></p>\n<p>Executor 是一个顶层接口，其中只声明了一个方法<code>execute(Runnable)</code>，用来执行传进去的任务</p>\n<p>ExecutorService 接口继承了 Executor 接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code> 等</p>\n<p>抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法</p>\n<p>ThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用<code>prestartAllCoreThreads</code>或者<code>prestartCoreThread</code>方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中</li>\n<li>maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程</li>\n<li>keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0</li>\n<li><p>unit：参数keepAliveTime的时间单位，有7种取值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TimeUnit.DAYS;               //天</span><br><span class=\"line\">TimeUnit.HOURS;             //小时</span><br><span class=\"line\">TimeUnit.MINUTES;           //分钟</span><br><span class=\"line\">TimeUnit.SECONDS;           //秒</span><br><span class=\"line\">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class=\"line\">TimeUnit.MICROSECONDS;      //微妙</span><br><span class=\"line\">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayBlockingQueue;</span><br><span class=\"line\">LinkedBlockingQueue;</span><br><span class=\"line\">SynchronousQueue;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>threadFactory：线程工厂，主要用来创建线程</p>\n</li>\n<li>handler：表示当拒绝处理任务时的策略，有以下四种选择：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"为何使用\"><a href=\"#为何使用\" class=\"headerlink\" title=\"为何使用\"></a>为何使用</h4><ul>\n<li>降低资源消耗<br><br>可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>\n<li>提高响应速度<br><br>当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>\n<li>提高线程的可管理性 <br><br>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>\n</ul>\n<h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//线程池满了就不再添加线程；</span></span><br><span class=\"line\"><span class=\"comment\">//如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列</span></span><br><span class=\"line\"><span class=\"comment\">//因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务</span></span><br><span class=\"line\"><span class=\"comment\">//若池中线程空闲时间超过指定大小，则该线程会被销毁。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建只有一个线程的线程池，且线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">        (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                threadFactory));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行</span></span><br><span class=\"line\"><span class=\"comment\">//如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中</span></span><br><span class=\"line\"><span class=\"comment\">//这是一种按照超时时间排序的队列结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ThreadPoolExecutor 中比较重要的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>execute()</td>\n<td>向线程池提交一个任务，交由线程池去执行</td>\n</tr>\n<tr>\n<td>submit()</td>\n<td>向线程池提交任务的，能够返回任务执行的结果（利用 Future）</td>\n</tr>\n<tr>\n<td>shutdown()</td>\n<td>关闭线程池</td>\n</tr>\n<tr>\n<td>shutdownNow()</td>\n<td>关闭线程池</td>\n</tr>\n</tbody>\n</table>\n<p>还有其他的方法比如：<code>getQueue()</code>、<code>getPoolSize()</code> 、<code>getActiveCount()</code>、<code>getCompletedTaskCount()</code>等用来获取线程池的相关属性。</p>\n<p>简单使用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    System.out.println(Thread.currentThread());</span><br><span class=\"line\">    executor.execute(()-&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[main,5,main]</span><br><span class=\"line\">Thread[pool-1-thread-1,5,main]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>观察 ThreadPoolExecutor 中的<code>execute</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。</span></span><br><span class=\"line\"><span class=\"comment\">         * 三、如果加入 workQueue 失败，则创建线程执行任务，</span></span><br><span class=\"line\"><span class=\"comment\">         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            c = ctl.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">                reject(command);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟踪<code>addWorker</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = ctl.get();;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class=\"line\">                || firstTask != <span class=\"keyword\">null</span></span><br><span class=\"line\">                || workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，</span></span><br><span class=\"line\"><span class=\"comment\">             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c)</span><br><span class=\"line\">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 创建Worker时会调用threadFactory来创建一个线程。</span></span><br><span class=\"line\"><span class=\"comment\">         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isRunning(c) ||</span><br><span class=\"line\">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>新建 Work ，同时也会利用工厂类实例化一个线程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果 workerAdded，调用<code>t.start()</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟踪<code>runWorker</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                    afterExecute(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    afterExecute(task, ex);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>getTask</code>方法不断从 workerQueue 中读取任务然后执行。只要<code>getTask</code>方法不返回 null，循环就不会退出。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//是判断当前线程数是否大于 corePoolSize</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后用一张图总结上述过程</p>\n<p><img src=\"/Java-线程和线程池详解/线程池流程.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>线程在 Java 开发中是一个很重要的概念。 在Java中，“线程”指两件不同的事情：</p>\n<blockquote>\n<p>java.lang.Thread 类的一个实例；</p>\n<p>线程的执行。</p>\n</blockquote>","more":"<h2 id=\"Java-线程\"><a href=\"#Java-线程\" class=\"headerlink\" title=\"Java 线程\"></a>Java 线程</h2><h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>\n<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。，线程是 CPU 执行的基本单位，是花费最小开销的实体。</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>进程有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</p>\n<p>线程中堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。</p>\n<blockquote>\n<p>一个进程中的多个线程是并发运行的，从微观角度看存在先后顺序，哪个线程被执行完全取决于 CPU 的调度，程序员无法干涉。这也就造成了多线程的随机性。</p>\n<p>Java 程序的进程里面至少包含两个线程，主线程也就是 main() 方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，对应一个进程。</p>\n<p>由于创建一个线程的开销比创建一个进程的开销小的多，在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。</p>\n</blockquote>\n<p>实际开发中使用多线程的优势在于</p>\n<ul>\n<li>进程之间不能共享内存，而线程之间可以共享内存。</li>\n<li>系统创建进程需要为该进程重新分配系统资源，创建线程的代价则小的多，因此多任务并发时，多线程效率高。</li>\n<li>Java 语言本身内置多线程功能的支持，而不是单纯作为底层系统的调度方式，从而简化了多线程编程。</li>\n</ul>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><p>图一</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态1.png\" alt=\"\"></p>\n<p>图二</p>\n<p><img src=\"/Java-线程和线程池详解/线程状态2.png\" alt=\"\"></p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>Java 中的线程可以分为用户线程（User Thread）和守护线程（Daemon Thread）。</p>\n<p>只要当前 JVM 实例中存在任何一个非守护线程没有结束，守护线程就全部工作；当最后一个非守护线程结束，即虚拟机中只存在守护线程时，JVM 就会停止运行。Daemon Thread 的作用是为其他线程提供各种服务，最典型的应用就是垃圾收集器。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"is daemon thread? \"</span> + thread.isDaemon());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is daemon thread? true</span><br></pre></td></tr></table></figure></p>\n<p>使用守护线程要注意的点</p>\n<ul>\n<li><code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则抛出一个 IllegalThreadStateException 异常。因为不能把正在运行的常规线程设置为守护线程。</li>\n<li>在 Daemon Thread 中产生的新线程也属于 Daemon Thread。 </li>\n<li>不要在 Daemon Thread 中分配读写操作或者计算逻辑任务。 </li>\n</ul>\n<h3 id=\"Runnable-和-Thread\"><a href=\"#Runnable-和-Thread\" class=\"headerlink\" title=\"Runnable 和 Thread\"></a>Runnable 和 Thread</h3><p>Runnable 是一个线程接口，查看其构造<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中只定义了一个<code>run</code>方法</p>\n<p>Thread 是实现了 Runnable 接口的类，所有新建 Thread 实例的方法最后都会调用到内部的<code>init</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class=\"line\">                      long stackSize, AccessControlContext acc,</span><br><span class=\"line\">                      boolean inheritThreadLocals)</span><br></pre></td></tr></table></figure></p>\n<p>观察 Thread 中重写的<code>run</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 target 为 Runnable 对象，即调用 Thread 的<code>run</code>实际上是调用我们传进去的 Runnable 的对应方法</p>\n<p>观察其<code>start</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不能重复调用 start 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">//将线程加入线程组</span></span><br><span class=\"line\">    group.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程开始标志</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> started = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用native方法开始多线程</span></span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!started) &#123;</span><br><span class=\"line\">                group.threadStartFailed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* do nothing. If start0 threw a Throwable then</span></span><br><span class=\"line\"><span class=\"comment\">              it will be passed up the call stack */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>start0</code>是 native 方法，在其中新建线程，然后回调 target 的 run 方法。</p>\n<p>也就是说，如果我们直接调用<code>run</code>方法，相当于调用普通方法，不会有多线程效果。只有调用<code>start</code>才会在后台开启另一个线程，等待 CPU 调度。</p>\n<h3 id=\"多线程-API\"><a href=\"#多线程-API\" class=\"headerlink\" title=\"多线程 API\"></a>多线程 API</h3><h4 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h4><p>实际上除了 Thread，Java 的基类 Object 中也定义了一些关于多线程操作的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wait()</td>\n<td>锁对象调用该方法使当前线程进入等待状态，并立刻释放锁对象，直到被其他线程唤醒进入等锁池</td>\n</tr>\n<tr>\n<td>wait(long)</td>\n<td>锁对象调用该方法使当前线程进入等待状态，同时释放锁对象。但是超过等待的时间后线程会自动唤醒，或者被其他线程唤醒，并进入等锁池中。</td>\n</tr>\n<tr>\n<td>wait(long, int)</td>\n<td>和o.wait(long)方法一样，如果int参数大于0则前面的long数字加1000</td>\n</tr>\n<tr>\n<td>notify()</td>\n<td>随机唤醒一个处于等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n<tr>\n<td>notifyAll()</td>\n<td>唤醒所有等待中的线程（同一个等待阻塞池中）</td>\n</tr>\n</tbody>\n</table>\n<p>以上的方法必须写在 synchronized 方法内部或者 synchronized 块内部，因为它们要求当前正在运行<code>object.wait()</code>方法的线程拥有 object 的对象锁，否则抛出异常，测试代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            t.wait(<span class=\"number\">2000</span>);   <span class=\"comment\">//由于没有获得锁，将抛出 IllegalMonitorStateException 异常</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in Main: \"</span> + t.toString());</span><br><span class=\"line\">        A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">        a.printThreadInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">printThreadInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            wait(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"current Thread info in A: \"</span> + t.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>删除<code>main</code>中 try/catch 语句之后，控制台输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">current Thread info in Main: Thread[main,5,main]</span><br><span class=\"line\">//等待两秒</span><br><span class=\"line\">current Thread info in A: Thread[main,5,main]</span><br></pre></td></tr></table></figure></p>\n<p><strong>为什么需要在 synchronized 中？</strong></p>\n<blockquote>\n<p>wait和notify用于线程间通信。<br>以生产者消费者模式举例，生产者和消费者通过队列进行通信，对于队列的操作要保证线程安全性</p>\n<p>一般对队列的操作如下:<br>while(queue.size() == MAX_SIZE){ wait() }</p>\n<p>假如不对这段代码加锁，就会出现问题。模拟一个生产者线程t1和一个消费者线程t2</p>\n<ul>\n<li><p>t1判断队列满，需要 wait 阻塞线程。</p>\n</li>\n<li><p>但是就在t1还没有调用 wait 的时候，消费者t2消费了一个产品，导致队列非满。</p>\n</li>\n<li><p>这时候生产者线程t1调用 wait 阻塞，造成的情况就是队列非满，但是生产者线程阻塞了。</p>\n</li>\n<li><p>假如此时消费者不消费了，那么生产者则会一直阻塞下去。</p>\n</li>\n<li><p>所以在调用 wait、notify 以及 notifyAll 等方法时一定要进行同步处理。</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>为什么定义在 Object 中？</strong></p>\n<blockquote>\n<p>Object 中的<code>wait()</code>, <code>notify()</code>等方法，和 synchronized 一样，会对“对象的同步锁”进行操作。</p>\n<p><code>wait()</code>会使“当前线程”等待。进入等待状态时，线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”将无法运行！<br>当线程释放它持有的“同步锁”之后变成等待线程，可以被<code>notify()</code>或<code>notifyAll()</code>唤醒。那么，<code>notify()</code>依据什么唤醒等待线程的？或者说，<code>wait()</code>等待线程和<code>notify()</code>之间通过什么关联起来？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(“唤醒线程”)，只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用<code>notify()</code>或<code>notifyAll()</code>方法之后，才能唤醒等待线程。此时因为唤醒线程还持有“该对象的同步锁”，所以必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，<code>notify()</code>, <code>wait()</code>依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！</p>\n<p>这就是<code>notify()</code>, <code>wait()</code>等函数定义在 Object 类，而不是 Thread 类中的原因。</p>\n<p>来自 <a href=\"https://www.cnblogs.com/happy-coder/p/6587092.html\" target=\"_blank\" rel=\"noopener\">JAVA 线程状态及转化</a></p>\n</blockquote>\n<h4 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Thread.currentThread()</td>\n<td>返回对当前线程对象的引用</td>\n</tr>\n<tr>\n<td>Thread.interrupted()</td>\n<td>检测当前线程是否已经中断（调用该方法后将该线程的中断标志位设为false，连续两次调用该方法第二次肯定为false）</td>\n</tr>\n<tr>\n<td>Thread.sleep(long millis)</td>\n<td>使当前线程睡眠（不会释放锁对象，可以让其他线程有执行的机会）</td>\n</tr>\n<tr>\n<td>Thread.yield()</td>\n<td>使当前线程放弃cpu的执行权（有可能立刻又被重新选中继续执行，只可能给优先级更高的线程机会）</td>\n</tr>\n<tr>\n<td>t.getId()…</td>\n<td>返回该线程的 id 等等信息</td>\n</tr>\n<tr>\n<td>t.interrupt()</td>\n<td>将该线程中断（实际并不会中断，只是将中断标志设置为true）</td>\n</tr>\n<tr>\n<td>t.isInterrupted()</td>\n<td>检测该线程是否已经中断</td>\n</tr>\n<tr>\n<td>t.join()</td>\n<td>在a线程中调用b.join()，则a线程阻塞，直到b线程执行完</td>\n</tr>\n<tr>\n<td>t.join(long millis)</td>\n<td>同上，不过a线程阻塞的时间根据long的大小有关，如果达到设定的阻塞时间，就算b线程没有执行完，a线程也会被唤醒。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>关于 interrupt，<a href=\"https://blog.csdn.net/qpc908694753/article/details/61414495\" target=\"_blank\" rel=\"noopener\">JAVA interrupt、interrupted和isInterrupted的区别</a></p>\n<blockquote>\n<p>interrupt 方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。</p>\n<p>注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>\n</blockquote>\n<h4 id=\"废弃方法\"><a href=\"#废弃方法\" class=\"headerlink\" title=\"废弃方法\"></a>废弃方法</h4><ul>\n<li>stop：会释放该线程所持有的所有锁，但这种释放是不可控制、非预期的。而且一个线程不应该由其他线程来强制中断或停止，而应该自行停止</li>\n<li>suspend：线程在暂停的时候仍然占有该资源，导致需要该资源的线程产生环路等待，从而造成死锁。</li>\n<li>resume：用来回复被挂起的线程，跟 suspend 对应。</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>Java 中关于线程池的继承关系如下</p>\n<p><img src=\"/Java-线程和线程池详解/继承图.png\" alt=\"\"></p>\n<p>Executor 是一个顶层接口，其中只声明了一个方法<code>execute(Runnable)</code>，用来执行传进去的任务</p>\n<p>ExecutorService 接口继承了 Executor 接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code> 等</p>\n<p>抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法</p>\n<p>ThreadPoolExecutor 继承了类 AbstractExecutorService，是线程池实现类，构造方法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>corePoolSize：核心池的大小，创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用<code>prestartAllCoreThreads</code>或者<code>prestartCoreThread</code>方法预创建线程，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。当线程池中的线程数目达到 corePoolSize 后，到达的任务会被放到缓存队列中</li>\n<li>maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程</li>\n<li>keepAliveTime：线程没有任务执行时最多保持多久时间会终止。默认情况下，当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，就会终止，直到线程池中的线程数不超过 corePoolSize。但如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，即使线程数不大于 corePoolSize，该参数也会起作用，直到线程池中的线程数为0</li>\n<li><p>unit：参数keepAliveTime的时间单位，有7种取值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TimeUnit.DAYS;               //天</span><br><span class=\"line\">TimeUnit.HOURS;             //小时</span><br><span class=\"line\">TimeUnit.MINUTES;           //分钟</span><br><span class=\"line\">TimeUnit.SECONDS;           //秒</span><br><span class=\"line\">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class=\"line\">TimeUnit.MICROSECONDS;      //微妙</span><br><span class=\"line\">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>workQueue：阻塞队列，用来存储等待执行的任务，会对线程池的运行过程产生重大影响。一般来说有以下几种选择：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayBlockingQueue;</span><br><span class=\"line\">LinkedBlockingQueue;</span><br><span class=\"line\">SynchronousQueue;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>threadFactory：线程工厂，主要用来创建线程</p>\n</li>\n<li>handler：表示当拒绝处理任务时的策略，有以下四种选择：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class=\"line\">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"为何使用\"><a href=\"#为何使用\" class=\"headerlink\" title=\"为何使用\"></a>为何使用</h4><ul>\n<li>降低资源消耗<br><br>可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>\n<li>提高响应速度<br><br>当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>\n<li>提高线程的可管理性 <br><br>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>\n</ul>\n<h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>实际上新建线程池都通过工厂类 Executors 类实现，其中定义一些新建 ThreadPoolExecutor 实例的工厂方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建可容纳固定数量线程的线程池，每个线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//线程池满了就不再添加线程；</span></span><br><span class=\"line\"><span class=\"comment\">//如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列</span></span><br><span class=\"line\"><span class=\"comment\">//因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务</span></span><br><span class=\"line\"><span class=\"comment\">//若池中线程空闲时间超过指定大小，则该线程会被销毁。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                  threadFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建只有一个线程的线程池，且线程的存活时间是无限的</span></span><br><span class=\"line\"><span class=\"comment\">//当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">        (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                threadFactory));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行</span></span><br><span class=\"line\"><span class=\"comment\">//如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中</span></span><br><span class=\"line\"><span class=\"comment\">//这是一种按照超时时间排序的队列结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ThreadPoolExecutor 中比较重要的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>execute()</td>\n<td>向线程池提交一个任务，交由线程池去执行</td>\n</tr>\n<tr>\n<td>submit()</td>\n<td>向线程池提交任务的，能够返回任务执行的结果（利用 Future）</td>\n</tr>\n<tr>\n<td>shutdown()</td>\n<td>关闭线程池</td>\n</tr>\n<tr>\n<td>shutdownNow()</td>\n<td>关闭线程池</td>\n</tr>\n</tbody>\n</table>\n<p>还有其他的方法比如：<code>getQueue()</code>、<code>getPoolSize()</code> 、<code>getActiveCount()</code>、<code>getCompletedTaskCount()</code>等用来获取线程池的相关属性。</p>\n<p>简单使用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    System.out.println(Thread.currentThread());</span><br><span class=\"line\">    executor.execute(()-&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>控制台输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[main,5,main]</span><br><span class=\"line\">Thread[pool-1-thread-1,5,main]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>观察 ThreadPoolExecutor 中的<code>execute</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 一、判断当前活跃线程数是否小于 corePoolSize，如果小于，调用 addWorker 创建线程执行任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 二、如果大于 corePoolSize，将任务添加到 workQueue 队列。</span></span><br><span class=\"line\"><span class=\"comment\">         * 三、如果加入 workQueue 失败，则创建线程执行任务，</span></span><br><span class=\"line\"><span class=\"comment\">         *     如果创建线程失败(当前线程数大于maximumPoolSize)，就会调用reject(内部用handler)处理拒绝任务。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            c = ctl.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">                reject(command);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟踪<code>addWorker</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = ctl.get();;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class=\"line\">                || firstTask != <span class=\"keyword\">null</span></span><br><span class=\"line\">                || workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             *在创建非核心线程，即core等于false时。判断当前线程数是否大于等于maximumPoolSize，</span></span><br><span class=\"line\"><span class=\"comment\">             *如果大于等于则返回false，即上边说的第三步中创建线程失败的情况</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c)</span><br><span class=\"line\">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 创建Worker时会调用threadFactory来创建一个线程。</span></span><br><span class=\"line\"><span class=\"comment\">         * 上边的第二步中中启动一个线程会触发Worker的run方法被线程调用。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isRunning(c) ||</span><br><span class=\"line\">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>新建 Work ，同时也会利用工厂类实例化一个线程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果 workerAdded，调用<code>t.start()</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟踪<code>runWorker</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                    afterExecute(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    afterExecute(task, ex);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>getTask</code>方法不断从 workerQueue 中读取任务然后执行。只要<code>getTask</code>方法不返回 null，循环就不会退出。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class=\"line\">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//是判断当前线程数是否大于 corePoolSize</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数大于 corePoolSize，调用 workQueue 的poll方法获取任务</span></span><br><span class=\"line\"><span class=\"comment\">         * 超时时间为 keepAliveTime。如果超时，poll返回了null，上边的while循序就会退出</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果当前线程数小于 corePoolSize，调用 workQueue 的take方法阻塞当前</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后用一张图总结上述过程</p>\n<p><img src=\"/Java-线程和线程池详解/线程池流程.png\" alt=\"\"></p>"},{"title":"Dart笔记（一）：基本语法和数据类型","date":"2019-04-22T06:27:18.000Z","_content":"\n## 引言\n\n终于开始 Flutter 的具体学习，一切从 Dart 语言开始。\n\n```\nvoid main() {\n    print('hello world');\n}\n```\n\n<!--more-->\n\n## 环境搭建\n\nDart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。\n\n![](Dart笔记(一)：基本语法和数据类型/idea_create.png)\n\n\n\n创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的`main`函数作为运行的入口。在`run`之前需要`edit configuration`，很简单，只要指定对应的文件即可。\n\n![](Dart笔记(一)：基本语法和数据类型/idea_category.png)\n\n\n\n## 上手\n\nDart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为`null`。可以使用具体的类型声明，也可以使用`var`、`dynamic`、`const`、`final`等关键字\n\n```\nvoid main() {\n  var i = 0;\n  var d = 2.0;\n  var s = 'hello';\n  var b = true;\n  var l = [1, 2, 3];\n  var m = {0: 'a', 1: 'b'};\n  \n  print(main is Function);  //true\n}\n```\n\n通过查看官方库的`core`包，可以大概看出其结构\n\n![dart_core](Dart笔记(一)：基本语法和数据类型/dart_core.png)\n\n## 数据类型\n\n### Numbers\n\n包括 int 和 double，分别代表整形和浮点型。\n\nint 的数值范围不超过2的64位，具体与平台有关。\n\ndouble 的","source":"_posts/Dart 笔记之基本语法和数据类型.md","raw":"---\ntitle: Dart笔记（一）：基本语法和数据类型\ndate: 2019-04-22 14:27:18\ncategories:\n- Dart\ntags: \n- Dart\n---\n\n## 引言\n\n终于开始 Flutter 的具体学习，一切从 Dart 语言开始。\n\n```\nvoid main() {\n    print('hello world');\n}\n```\n\n<!--more-->\n\n## 环境搭建\n\nDart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。\n\n![](Dart笔记(一)：基本语法和数据类型/idea_create.png)\n\n\n\n创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的`main`函数作为运行的入口。在`run`之前需要`edit configuration`，很简单，只要指定对应的文件即可。\n\n![](Dart笔记(一)：基本语法和数据类型/idea_category.png)\n\n\n\n## 上手\n\nDart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为`null`。可以使用具体的类型声明，也可以使用`var`、`dynamic`、`const`、`final`等关键字\n\n```\nvoid main() {\n  var i = 0;\n  var d = 2.0;\n  var s = 'hello';\n  var b = true;\n  var l = [1, 2, 3];\n  var m = {0: 'a', 1: 'b'};\n  \n  print(main is Function);  //true\n}\n```\n\n通过查看官方库的`core`包，可以大概看出其结构\n\n![dart_core](Dart笔记(一)：基本语法和数据类型/dart_core.png)\n\n## 数据类型\n\n### Numbers\n\n包括 int 和 double，分别代表整形和浮点型。\n\nint 的数值范围不超过2的64位，具体与平台有关。\n\ndouble 的","slug":"Dart 笔记之基本语法和数据类型","published":1,"updated":"2019-04-22T10:13:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjus7e4f80003cgupa2ho5tem","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>终于开始 Flutter 的具体学习，一切从 Dart 语言开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    print(&apos;hello world&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。</p>\n<p><img src=\"/Dart 笔记之基本语法和数据类型/Dart笔记(一\" alt=\"\">：基本语法和数据类型/idea_create.png)</p>\n<p>创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的<code>main</code>函数作为运行的入口。在<code>run</code>之前需要<code>edit configuration</code>，很简单，只要指定对应的文件即可。</p>\n<p><img src=\"/Dart 笔记之基本语法和数据类型/Dart笔记(一\" alt=\"\">：基本语法和数据类型/idea_category.png)</p>\n<h2 id=\"上手\"><a href=\"#上手\" class=\"headerlink\" title=\"上手\"></a>上手</h2><p>Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为<code>null</code>。可以使用具体的类型声明，也可以使用<code>var</code>、<code>dynamic</code>、<code>const</code>、<code>final</code>等关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  var d = 2.0;</span><br><span class=\"line\">  var s = &apos;hello&apos;;</span><br><span class=\"line\">  var b = true;</span><br><span class=\"line\">  var l = [1, 2, 3];</span><br><span class=\"line\">  var m = &#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  print(main is Function);  //true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查看官方库的<code>core</code>包，可以大概看出其结构</p>\n<p><img src=\"/Dart 笔记之基本语法和数据类型/Dart笔记(一\" alt=\"dart_core\">：基本语法和数据类型/dart_core.png)</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>包括 int 和 double，分别代表整形和浮点型。</p>\n<p>int 的数值范围不超过2的64位，具体与平台有关。</p>\n<p>double 的</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>终于开始 Flutter 的具体学习，一切从 Dart 语言开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    print(&apos;hello world&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。</p>\n<p><img src=\"/Dart 笔记之基本语法和数据类型/Dart笔记(一\" alt=\"\">：基本语法和数据类型/idea_create.png)</p>\n<p>创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的<code>main</code>函数作为运行的入口。在<code>run</code>之前需要<code>edit configuration</code>，很简单，只要指定对应的文件即可。</p>\n<p><img src=\"/Dart 笔记之基本语法和数据类型/Dart笔记(一\" alt=\"\">：基本语法和数据类型/idea_category.png)</p>\n<h2 id=\"上手\"><a href=\"#上手\" class=\"headerlink\" title=\"上手\"></a>上手</h2><p>Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为<code>null</code>。可以使用具体的类型声明，也可以使用<code>var</code>、<code>dynamic</code>、<code>const</code>、<code>final</code>等关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  var d = 2.0;</span><br><span class=\"line\">  var s = &apos;hello&apos;;</span><br><span class=\"line\">  var b = true;</span><br><span class=\"line\">  var l = [1, 2, 3];</span><br><span class=\"line\">  var m = &#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  print(main is Function);  //true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查看官方库的<code>core</code>包，可以大概看出其结构</p>\n<p><img src=\"/Dart 笔记之基本语法和数据类型/Dart笔记(一\" alt=\"dart_core\">：基本语法和数据类型/dart_core.png)</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>包括 int 和 double，分别代表整形和浮点型。</p>\n<p>int 的数值范围不超过2的64位，具体与平台有关。</p>\n<p>double 的</p>"},{"title":"Dart笔记（一）：基本语法和数据类型","date":"2019-04-22T06:27:18.000Z","_content":"\n## 引言\n\n终于开始 Flutter 的具体学习，一切从 Dart 语言开始。\n\n```\nvoid main() {\n    print('hello world');\n}\n```\n\n<!--more-->\n\n## 环境搭建\n\nDart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。\n\n![](Dart 笔记之基本语法和数据类型/idea_create.png)\n\n\n\n创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的`main`函数作为运行的入口。在`run`之前需要`edit configuration`，很简单，只要指定对应的文件即可。\n\n![](Dart 笔记之基本语法和数据类型/idea_category.png)\n\n\n\n## 声明变量\n\nDart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为`null`。可以使用具体的类型声明，也可以使用`var`、`dynamic`、`const`、`final`等关键字\n\n```\nvoid main() {\n  var i = 0;\n  var d = 2.0;\n  var s = 'hello';\n  var b = true;\n  var l = [1, 2, 3];\n  var m = {0: 'a', 1: 'b'};\n  \n  print(main is Function);  //true\n}\n```\n\n通过查看官方库的`core`包，可以大概看出其结构\n\n![dart_core](Dart 笔记之基本语法和数据类型/dart_core.png)\n\n## 数据类型\n\n### Numbers\n\n包括 int 和 double，分别代表整形和浮点型。\n\nint 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。\n\n### String\n\n在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码\n\n```dart\nvar s1 = \"hello\";\nvar s2 = 'world';\nvar s3 = 'hello' + 'world';\nvar s4 = 'hello' 'world';\nvar s5 = \"\"\"hello \n              world\"\"\";\n```\n\n如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。\n\n```dart\nvar clapping = '\\u{1f44f}';\nprint(clapping);\n\nRunes runes = new Runes('\\u{1f44d}');\nprint(new String.fromCharCode(runes.first));\n```\n\n\n\n上面的输出为\n\n```\n👏\n👍\n```\n\n### Boolean\n\n提供 bool 用来声明布尔型变量，默认为 false。\n\n### List 和 Map\n\n```dart\nList<int> l = [1,2,3];\nl.forEach((x) => print(x)); //forEach的参数为 Function\nfor(var x in l) { //使用for-in\n  print(x);\n}\n\nMap<int, String> map = {0: \"a\", 1: \"b\"};\nmap[0] = \"c\";\n```\n\n## Function\n\n### 普通Function\n\n函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。\n\n```dart\nvoid main() {\n  single1('Tom', 20);\n  single2('Tom', 20);\n  single3('Tom', 20, weight: 30); //由于没有位置约束，必须指定形参名称\n  single4('Tom', 20, 20, 30);\n}\n\nbool single1(String name, int age) {\n  return true;\n}\n\n//返回类型和参数类型可省略，支持返回表达式\nsingle2(name, age) => true;\n\n//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值\nbool single3(String name, int age, {int weight = 60, int height}) => true;\n\n//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight\nbool single4(String name, int age, [int weight, int height]) => true;\n```\n\n对于`main`方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：\n\n```dart\nvoid main() => runApp(MyApp());\n```\n\n### Lambda表达式\n\n在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量\n\n```dart\nvar f = (c) {\n  print(c);\n};\n\nf('hello');\n\nvar list = [1, 2, 3];\nprintElement(x) {\t//方法签名写成 void printElement(int x) 更直观\n  print(x);\n}\n\nlist.forEach(printElement);\n```\n\n`forEach`的函数定义如下\n\n```dart\nvoid forEach(void f(E element)) {\n  for (E element in this) f(element);\n}\n```\n\n下面的例子直观展示将函数作为变量传递的思想\n\n```dart\nFunction makeAdder(num n) {\n  return (num i) => n + i;\n}\n  \n//更明晰的写法\nFunction makeAdder_(num n) {\n  Function add = (num i) {\n    return i + n;\n  };\n  return add;\n}\n\nvar adder2 = makeAdder(2);\nprint(adder2(3));\n```\n\n控制台将输出 5\n\n## 运算符\n\n### 赋值操作符\n\n除了`=`，还有`??=`，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。\n\n### 相等\n\n`==`将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的`identical`方法\n\n```dart\nexternal bool identical(Object a, Object b);\n```\n\n### 除法\n\n| 操作符 | 含义               |\n| :----: | ------------------ |\n|   /    | 除，比如 5/2 = 2.5 |\n|   ~/   | 整除， 5/2 = 2     |\n\n### 类型判断\n\n| 操作符 | 含义                       |\n| :----: | -------------------------- |\n|   is   | 对象属于指定类型则返回true |\n|  is!   | 对象不属于指定类型返回true |\n|   as   | 类型转换                   |\n\n### 条件表达式\n\n分为两种\n\n```dart\ncondition ? expr1 : expr2\t//通用表达式\nexpr1 ?? expr2\t//如果 expr1 非空，返回其值，否则返回 expr2\n```\n\n### 级联调用与非空调用\n\n```dart\n//常规写法\nvar button = querySelector('#button');\nbutton.text = 'Confirm';\nbutton.classes.add('important');\nbutton.onClick.listen((e) => window.alert('Confirmed!'));\n\n//使用级联表达式\nquerySelector('#button') // Get an object.\n  ..text = 'Confirm'   // Use its members.\n  ..classes.add('important')\n  ..onClick.listen((e) => window.alert('Confirmed!'));\n\n//非空调用\nprint(button?.text);\n```\n\n## 其他\n\nDart 语言在比如 `if/else`、`[do、]while`、`for`、`switch/case`等语句上跟 Java 类似，不再赘述。\n\n异常处理的做法如下\n\n```dart\n//抛出异常\nthrow 'x should be less than 10';\t\nthrow new FormatException('Expected at least 1 section');\n\n//捕获异常\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlamas();\n}\n\ntry {\n //...\n} on Exception catch (e) {\n  print('Unknown exception: $e');\n} catch (e, s) {\t\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```","source":"_posts/Dart笔记（一）：基本语法和数据类型.md","raw":"---\ntitle: Dart笔记（一）：基本语法和数据类型\ndate: 2019-04-22 14:27:18\ncategories:\n- Dart\ntags: \n- Dart\n---\n\n## 引言\n\n终于开始 Flutter 的具体学习，一切从 Dart 语言开始。\n\n```\nvoid main() {\n    print('hello world');\n}\n```\n\n<!--more-->\n\n## 环境搭建\n\nDart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。\n\n![](Dart 笔记之基本语法和数据类型/idea_create.png)\n\n\n\n创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的`main`函数作为运行的入口。在`run`之前需要`edit configuration`，很简单，只要指定对应的文件即可。\n\n![](Dart 笔记之基本语法和数据类型/idea_category.png)\n\n\n\n## 声明变量\n\nDart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为`null`。可以使用具体的类型声明，也可以使用`var`、`dynamic`、`const`、`final`等关键字\n\n```\nvoid main() {\n  var i = 0;\n  var d = 2.0;\n  var s = 'hello';\n  var b = true;\n  var l = [1, 2, 3];\n  var m = {0: 'a', 1: 'b'};\n  \n  print(main is Function);  //true\n}\n```\n\n通过查看官方库的`core`包，可以大概看出其结构\n\n![dart_core](Dart 笔记之基本语法和数据类型/dart_core.png)\n\n## 数据类型\n\n### Numbers\n\n包括 int 和 double，分别代表整形和浮点型。\n\nint 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。\n\n### String\n\n在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码\n\n```dart\nvar s1 = \"hello\";\nvar s2 = 'world';\nvar s3 = 'hello' + 'world';\nvar s4 = 'hello' 'world';\nvar s5 = \"\"\"hello \n              world\"\"\";\n```\n\n如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。\n\n```dart\nvar clapping = '\\u{1f44f}';\nprint(clapping);\n\nRunes runes = new Runes('\\u{1f44d}');\nprint(new String.fromCharCode(runes.first));\n```\n\n\n\n上面的输出为\n\n```\n👏\n👍\n```\n\n### Boolean\n\n提供 bool 用来声明布尔型变量，默认为 false。\n\n### List 和 Map\n\n```dart\nList<int> l = [1,2,3];\nl.forEach((x) => print(x)); //forEach的参数为 Function\nfor(var x in l) { //使用for-in\n  print(x);\n}\n\nMap<int, String> map = {0: \"a\", 1: \"b\"};\nmap[0] = \"c\";\n```\n\n## Function\n\n### 普通Function\n\n函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。\n\n```dart\nvoid main() {\n  single1('Tom', 20);\n  single2('Tom', 20);\n  single3('Tom', 20, weight: 30); //由于没有位置约束，必须指定形参名称\n  single4('Tom', 20, 20, 30);\n}\n\nbool single1(String name, int age) {\n  return true;\n}\n\n//返回类型和参数类型可省略，支持返回表达式\nsingle2(name, age) => true;\n\n//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值\nbool single3(String name, int age, {int weight = 60, int height}) => true;\n\n//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight\nbool single4(String name, int age, [int weight, int height]) => true;\n```\n\n对于`main`方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：\n\n```dart\nvoid main() => runApp(MyApp());\n```\n\n### Lambda表达式\n\n在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量\n\n```dart\nvar f = (c) {\n  print(c);\n};\n\nf('hello');\n\nvar list = [1, 2, 3];\nprintElement(x) {\t//方法签名写成 void printElement(int x) 更直观\n  print(x);\n}\n\nlist.forEach(printElement);\n```\n\n`forEach`的函数定义如下\n\n```dart\nvoid forEach(void f(E element)) {\n  for (E element in this) f(element);\n}\n```\n\n下面的例子直观展示将函数作为变量传递的思想\n\n```dart\nFunction makeAdder(num n) {\n  return (num i) => n + i;\n}\n  \n//更明晰的写法\nFunction makeAdder_(num n) {\n  Function add = (num i) {\n    return i + n;\n  };\n  return add;\n}\n\nvar adder2 = makeAdder(2);\nprint(adder2(3));\n```\n\n控制台将输出 5\n\n## 运算符\n\n### 赋值操作符\n\n除了`=`，还有`??=`，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。\n\n### 相等\n\n`==`将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的`identical`方法\n\n```dart\nexternal bool identical(Object a, Object b);\n```\n\n### 除法\n\n| 操作符 | 含义               |\n| :----: | ------------------ |\n|   /    | 除，比如 5/2 = 2.5 |\n|   ~/   | 整除， 5/2 = 2     |\n\n### 类型判断\n\n| 操作符 | 含义                       |\n| :----: | -------------------------- |\n|   is   | 对象属于指定类型则返回true |\n|  is!   | 对象不属于指定类型返回true |\n|   as   | 类型转换                   |\n\n### 条件表达式\n\n分为两种\n\n```dart\ncondition ? expr1 : expr2\t//通用表达式\nexpr1 ?? expr2\t//如果 expr1 非空，返回其值，否则返回 expr2\n```\n\n### 级联调用与非空调用\n\n```dart\n//常规写法\nvar button = querySelector('#button');\nbutton.text = 'Confirm';\nbutton.classes.add('important');\nbutton.onClick.listen((e) => window.alert('Confirmed!'));\n\n//使用级联表达式\nquerySelector('#button') // Get an object.\n  ..text = 'Confirm'   // Use its members.\n  ..classes.add('important')\n  ..onClick.listen((e) => window.alert('Confirmed!'));\n\n//非空调用\nprint(button?.text);\n```\n\n## 其他\n\nDart 语言在比如 `if/else`、`[do、]while`、`for`、`switch/case`等语句上跟 Java 类似，不再赘述。\n\n异常处理的做法如下\n\n```dart\n//抛出异常\nthrow 'x should be less than 10';\t\nthrow new FormatException('Expected at least 1 section');\n\n//捕获异常\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlamas();\n}\n\ntry {\n //...\n} on Exception catch (e) {\n  print('Unknown exception: $e');\n} catch (e, s) {\t\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```","slug":"Dart笔记（一）：基本语法和数据类型","published":1,"updated":"2019-04-22T11:37:46.000Z","_id":"cjus7f5570006cgupzwias228","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>终于开始 Flutter 的具体学习，一切从 Dart 语言开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    print(&apos;hello world&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。</p>\n<p><img src=\"/Dart笔记（一）：基本语法和数据类型/Dart 笔记之基本语法和数据类型/idea_create.png\" alt=\"\"></p>\n<p>创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的<code>main</code>函数作为运行的入口。在<code>run</code>之前需要<code>edit configuration</code>，很简单，只要指定对应的文件即可。</p>\n<p><img src=\"/Dart笔记（一）：基本语法和数据类型/Dart 笔记之基本语法和数据类型/idea_category.png\" alt=\"\"></p>\n<h2 id=\"声明变量\"><a href=\"#声明变量\" class=\"headerlink\" title=\"声明变量\"></a>声明变量</h2><p>Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为<code>null</code>。可以使用具体的类型声明，也可以使用<code>var</code>、<code>dynamic</code>、<code>const</code>、<code>final</code>等关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  var d = 2.0;</span><br><span class=\"line\">  var s = &apos;hello&apos;;</span><br><span class=\"line\">  var b = true;</span><br><span class=\"line\">  var l = [1, 2, 3];</span><br><span class=\"line\">  var m = &#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  print(main is Function);  //true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查看官方库的<code>core</code>包，可以大概看出其结构</p>\n<p><img src=\"/Dart笔记（一）：基本语法和数据类型/Dart 笔记之基本语法和数据类型/dart_core.png\" alt=\"dart_core\"></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>包括 int 和 double，分别代表整形和浮点型。</p>\n<p>int 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"string\">'hello'</span> + <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"string\">'hello'</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s5 = <span class=\"string\">\"\"\"hello </span></span><br><span class=\"line\"><span class=\"string\">              world\"\"\"</span>;</span><br></pre></td></tr></table></figure>\n<p>如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u&#123;1f44f&#125;'</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\"></span><br><span class=\"line\">Runes runes = <span class=\"keyword\">new</span> Runes(<span class=\"string\">'\\u&#123;1f44d&#125;'</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCode(runes.first));</span><br></pre></td></tr></table></figure>\n<p>上面的输出为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">👏</span><br><span class=\"line\">👍</span><br></pre></td></tr></table></figure>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><p>提供 bool 用来声明布尔型变量，默认为 false。</p>\n<h3 id=\"List-和-Map\"><a href=\"#List-和-Map\" class=\"headerlink\" title=\"List 和 Map\"></a>List 和 Map</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">l.forEach((x) =&gt; <span class=\"built_in\">print</span>(x)); <span class=\"comment\">//forEach的参数为 Function</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x <span class=\"keyword\">in</span> l) &#123; <span class=\"comment\">//使用for-in</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">String</span>&gt; map = &#123;<span class=\"number\">0</span>: <span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"b\"</span>&#125;;</span><br><span class=\"line\">map[<span class=\"number\">0</span>] = <span class=\"string\">\"c\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><h3 id=\"普通Function\"><a href=\"#普通Function\" class=\"headerlink\" title=\"普通Function\"></a>普通Function</h3><p>函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  single1(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single2(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single3(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, weight: <span class=\"number\">30</span>); <span class=\"comment\">//由于没有位置约束，必须指定形参名称</span></span><br><span class=\"line\">  single4(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single1(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类型和参数类型可省略，支持返回表达式</span></span><br><span class=\"line\">single2(name, age) =&gt; <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single3(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, &#123;<span class=\"built_in\">int</span> weight = <span class=\"number\">60</span>, <span class=\"built_in\">int</span> height&#125;) =&gt; <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single4(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, [<span class=\"built_in\">int</span> weight, <span class=\"built_in\">int</span> height]) =&gt; <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>对于<code>main</code>方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h3><p>在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (c) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(c);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">printElement(x) &#123;\t<span class=\"comment\">//方法签名写成 void printElement(int x) 更直观</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">list.forEach(printElement);</span><br></pre></td></tr></table></figure>\n<p><code>forEach</code>的函数定义如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> forEach(<span class=\"keyword\">void</span> f(E element)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (E element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) f(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的例子直观展示将函数作为变量传递的思想</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder(<span class=\"built_in\">num</span> n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; n + i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//更明晰的写法</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder_(<span class=\"built_in\">num</span> n) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> add = (<span class=\"built_in\">num</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + n;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> adder2 = makeAdder(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adder2(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n<p>控制台将输出 5</p>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"赋值操作符\"><a href=\"#赋值操作符\" class=\"headerlink\" title=\"赋值操作符\"></a>赋值操作符</h3><p>除了<code>=</code>，还有<code>??=</code>，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。</p>\n<h3 id=\"相等\"><a href=\"#相等\" class=\"headerlink\" title=\"相等\"></a>相等</h3><p><code>==</code>将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的<code>identical</code>方法</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"built_in\">bool</span> identical(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br></pre></td></tr></table></figure>\n<h3 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/</td>\n<td>除，比如 5/2 = 2.5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">~/</td>\n<td>整除， 5/2 = 2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">is</td>\n<td>对象属于指定类型则返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">is!</td>\n<td>对象不属于指定类型返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">as</td>\n<td>类型转换</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><p>分为两种</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition ? expr1 : expr2\t<span class=\"comment\">//通用表达式</span></span><br><span class=\"line\">expr1 ?? expr2\t<span class=\"comment\">//如果 expr1 非空，返回其值，否则返回 expr2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"级联调用与非空调用\"><a href=\"#级联调用与非空调用\" class=\"headerlink\" title=\"级联调用与非空调用\"></a>级联调用与非空调用</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常规写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>);</span><br><span class=\"line\">button.text = <span class=\"string\">'Confirm'</span>;</span><br><span class=\"line\">button.classes.add(<span class=\"string\">'important'</span>);</span><br><span class=\"line\">button.onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用级联表达式</span></span><br><span class=\"line\"><span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>) <span class=\"comment\">// Get an object.</span></span><br><span class=\"line\">  ..text = <span class=\"string\">'Confirm'</span>   <span class=\"comment\">// Use its members.</span></span><br><span class=\"line\">  ..classes.add(<span class=\"string\">'important'</span>)</span><br><span class=\"line\">  ..onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非空调用</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(button?.text);</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>Dart 语言在比如 <code>if/else</code>、<code>[do、]while</code>、<code>for</code>、<code>switch/case</code>等语句上跟 Java 类似，不再赘述。</p>\n<p>异常处理的做法如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'x should be less than 10'</span>;\t</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获异常</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125; catch (e, s) &#123;\t</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Exception details:\\n <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Stack trace:\\n <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>终于开始 Flutter 的具体学习，一切从 Dart 语言开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">    print(&apos;hello world&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>Dart 的 SDK 下载可能需要梯子。作者使用的开发环境是 Intellij IDEA，首先下载 Dart 的 Plugin，重启 IDEA 之后创建一个 Dart Project，当然首先需要确认 SDK 的路径。</p>\n<p><img src=\"/Dart笔记（一）：基本语法和数据类型/Dart 笔记之基本语法和数据类型/idea_create.png\" alt=\"\"></p>\n<p>创建之后的文件窗口如下，右键 DartDemo 文件夹，新建一个 dart 文件，和 C/C++ 类似，Dart 语言以文件中的<code>main</code>函数作为运行的入口。在<code>run</code>之前需要<code>edit configuration</code>，很简单，只要指定对应的文件即可。</p>\n<p><img src=\"/Dart笔记（一）：基本语法和数据类型/Dart 笔记之基本语法和数据类型/idea_category.png\" alt=\"\"></p>\n<h2 id=\"声明变量\"><a href=\"#声明变量\" class=\"headerlink\" title=\"声明变量\"></a>声明变量</h2><p>Dart 是一门完全面向对象的语言，包括基本数据类型、函数都是对象，继承自 Object。声明一个对象可以初始化，否则其值为<code>null</code>。可以使用具体的类型声明，也可以使用<code>var</code>、<code>dynamic</code>、<code>const</code>、<code>final</code>等关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void main() &#123;</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  var d = 2.0;</span><br><span class=\"line\">  var s = &apos;hello&apos;;</span><br><span class=\"line\">  var b = true;</span><br><span class=\"line\">  var l = [1, 2, 3];</span><br><span class=\"line\">  var m = &#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  print(main is Function);  //true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查看官方库的<code>core</code>包，可以大概看出其结构</p>\n<p><img src=\"/Dart笔记（一）：基本语法和数据类型/Dart 笔记之基本语法和数据类型/dart_core.png\" alt=\"dart_core\"></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>包括 int 和 double，分别代表整形和浮点型。</p>\n<p>int 的数值范围不超过2的64位，具体与平台有关，一般为 -2^53 to 2^53。double 则属于64位的双精度浮点型数据。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>在 Dart 中，可以使用单引号或者双引号定义一个字符串变量，或者使用三引号定义格式字符串。Dart 的字符串使用 UTF-16 编码</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"string\">'hello'</span> + <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"string\">'hello'</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s5 = <span class=\"string\">\"\"\"hello </span></span><br><span class=\"line\"><span class=\"string\">              world\"\"\"</span>;</span><br></pre></td></tr></table></figure>\n<p>如果要使用 UTF-32 编码，则要通过 Runes（符号文字），它可以把文字转换成符号表情或者特定文字。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u&#123;1f44f&#125;'</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\"></span><br><span class=\"line\">Runes runes = <span class=\"keyword\">new</span> Runes(<span class=\"string\">'\\u&#123;1f44d&#125;'</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCode(runes.first));</span><br></pre></td></tr></table></figure>\n<p>上面的输出为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">👏</span><br><span class=\"line\">👍</span><br></pre></td></tr></table></figure>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><p>提供 bool 用来声明布尔型变量，默认为 false。</p>\n<h3 id=\"List-和-Map\"><a href=\"#List-和-Map\" class=\"headerlink\" title=\"List 和 Map\"></a>List 和 Map</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">l.forEach((x) =&gt; <span class=\"built_in\">print</span>(x)); <span class=\"comment\">//forEach的参数为 Function</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x <span class=\"keyword\">in</span> l) &#123; <span class=\"comment\">//使用for-in</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">String</span>&gt; map = &#123;<span class=\"number\">0</span>: <span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"b\"</span>&#125;;</span><br><span class=\"line\">map[<span class=\"number\">0</span>] = <span class=\"string\">\"c\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><h3 id=\"普通Function\"><a href=\"#普通Function\" class=\"headerlink\" title=\"普通Function\"></a>普通Function</h3><p>函数或者方法。和Java 不同，Dart 中方法是有类型的，属于 Function。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  single1(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single2(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">  single3(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, weight: <span class=\"number\">30</span>); <span class=\"comment\">//由于没有位置约束，必须指定形参名称</span></span><br><span class=\"line\">  single4(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single1(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类型和参数类型可省略，支持返回表达式</span></span><br><span class=\"line\">single2(name, age) =&gt; <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选命名参数，调用时没有顺序要求，同时可选参数可以指定默认值</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single3(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, &#123;<span class=\"built_in\">int</span> weight = <span class=\"number\">60</span>, <span class=\"built_in\">int</span> height&#125;) =&gt; <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可选位置参数，通过位置来确定参数值，要想指定 height 必须先指定 weight</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> single4(<span class=\"built_in\">String</span> name, <span class=\"built_in\">int</span> age, [<span class=\"built_in\">int</span> weight, <span class=\"built_in\">int</span> height]) =&gt; <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>对于<code>main</code>方法来说，可以定义其为一个有参的方法，同样可以作为入口方法。在 Flutter 项目中的入口方法为：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h3><p>在 Lambda 表达式中，函数可以“没有名字”，同样，也可以像 kotlin 一样，定义一个函数变量</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (c) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(c);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">printElement(x) &#123;\t<span class=\"comment\">//方法签名写成 void printElement(int x) 更直观</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">list.forEach(printElement);</span><br></pre></td></tr></table></figure>\n<p><code>forEach</code>的函数定义如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> forEach(<span class=\"keyword\">void</span> f(E element)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (E element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) f(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的例子直观展示将函数作为变量传递的思想</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder(<span class=\"built_in\">num</span> n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; n + i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//更明晰的写法</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder_(<span class=\"built_in\">num</span> n) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> add = (<span class=\"built_in\">num</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + n;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> adder2 = makeAdder(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adder2(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n<p>控制台将输出 5</p>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"赋值操作符\"><a href=\"#赋值操作符\" class=\"headerlink\" title=\"赋值操作符\"></a>赋值操作符</h3><p>除了<code>=</code>，还有<code>??=</code>，表示如果左边的变量为 null，则将右边的值赋予它，否则左边值不变。</p>\n<h3 id=\"相等\"><a href=\"#相等\" class=\"headerlink\" title=\"相等\"></a>相等</h3><p><code>==</code>将比较两个对象的属性是否相等，判断是否为同一对象使用的是预定义的<code>identical</code>方法</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"built_in\">bool</span> identical(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br></pre></td></tr></table></figure>\n<h3 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/</td>\n<td>除，比如 5/2 = 2.5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">~/</td>\n<td>整除， 5/2 = 2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">is</td>\n<td>对象属于指定类型则返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">is!</td>\n<td>对象不属于指定类型返回true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">as</td>\n<td>类型转换</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><p>分为两种</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition ? expr1 : expr2\t<span class=\"comment\">//通用表达式</span></span><br><span class=\"line\">expr1 ?? expr2\t<span class=\"comment\">//如果 expr1 非空，返回其值，否则返回 expr2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"级联调用与非空调用\"><a href=\"#级联调用与非空调用\" class=\"headerlink\" title=\"级联调用与非空调用\"></a>级联调用与非空调用</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常规写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>);</span><br><span class=\"line\">button.text = <span class=\"string\">'Confirm'</span>;</span><br><span class=\"line\">button.classes.add(<span class=\"string\">'important'</span>);</span><br><span class=\"line\">button.onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用级联表达式</span></span><br><span class=\"line\"><span class=\"built_in\">querySelector</span>(<span class=\"string\">'#button'</span>) <span class=\"comment\">// Get an object.</span></span><br><span class=\"line\">  ..text = <span class=\"string\">'Confirm'</span>   <span class=\"comment\">// Use its members.</span></span><br><span class=\"line\">  ..classes.add(<span class=\"string\">'important'</span>)</span><br><span class=\"line\">  ..onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非空调用</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(button?.text);</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>Dart 语言在比如 <code>if/else</code>、<code>[do、]while</code>、<code>for</code>、<code>switch/case</code>等语句上跟 Java 类似，不再赘述。</p>\n<p>异常处理的做法如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'x should be less than 10'</span>;\t</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获异常</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125; catch (e, s) &#123;\t</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Exception details:\\n <span class=\"subst\">$e<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">  print('</span></span>Stack trace:\\n <span class=\"subst\">$s<span class=\"string\">');</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/LeetCode：最长回文子串（Longest-Palindromic-Substring）的解法/i-center-right.png","slug":"i-center-right.png","post":"cjurzavar000hi0up4kd3nj10","modified":0,"renderable":0},{"_id":"source/_posts/Android-消息机制详解/消息流程图.jpg","slug":"消息流程图.jpg","post":"cjurzavc4001li0upzt7z1k8h","modified":0,"renderable":0},{"_id":"source/_posts/基本数据结构的简单Java实现/HashMap.png","slug":"HashMap.png","post":"cjurzavcd0022i0upu48f4bpx","modified":0,"renderable":0},{"_id":"source/_posts/基本数据结构的简单Java实现/二叉搜索树.png","slug":"二叉搜索树.png","post":"cjurzavcd0022i0upu48f4bpx","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/工厂方法.jpg","slug":"工厂方法.jpg","post":"cjurzavc6001oi0up9yqnk0nl","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/抽象工厂.jpg","slug":"抽象工厂.jpg","post":"cjurzavc6001oi0up9yqnk0nl","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/简单工厂.jpg","slug":"简单工厂.jpg","post":"cjurzavc6001oi0up9yqnk0nl","modified":0,"renderable":0},{"_id":"source/_posts/Java设计模式：创建型模式/设计模式之间的关系.jpg","slug":"设计模式之间的关系.jpg","post":"cjurzavc6001oi0up9yqnk0nl","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/GFW内部结构.jpg","slug":"GFW内部结构.jpg","post":"cjurzavcf0026i0uptkf9ruyy","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/GFW存在后的连接方式.png","slug":"GFW存在后的连接方式.png","post":"cjurzavcf0026i0uptkf9ruyy","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/SSH连接方式.png","slug":"SSH连接方式.png","post":"cjurzavcf0026i0uptkf9ruyy","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/SS连接方式.png","slug":"SS连接方式.png","post":"cjurzavcf0026i0uptkf9ruyy","modified":0,"renderable":0},{"_id":"source/_posts/翻越GFW记/原始连接方式.png","slug":"原始连接方式.png","post":"cjurzavcf0026i0uptkf9ruyy","modified":0,"renderable":0},{"_id":"source/_posts/《剑指offer》题目-Java-实现/rebt.png","slug":"rebt.png","post":"cjurzavdu0032i0up9wwvbhpr","modified":0,"renderable":0},{"_id":"source/_posts/《剑指offer》题目-Java-实现/翻转链表.png","slug":"翻转链表.png","post":"cjurzavdu0032i0up9wwvbhpr","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/线程池流程.png","slug":"线程池流程.png","post":"cjurzavea003di0upt32ghpxm","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/线程状态1.png","slug":"线程状态1.png","post":"cjurzavea003di0upt32ghpxm","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/线程状态2.png","slug":"线程状态2.png","post":"cjurzavea003di0upt32ghpxm","modified":0,"renderable":0},{"_id":"source/_posts/Java-线程和线程池详解/继承图.png","slug":"继承图.png","post":"cjurzavea003di0upt32ghpxm","modified":0,"renderable":0},{"_id":"source/_posts/Dart 笔记之基本语法和数据类型/idea_category.png","slug":"idea_category.png","post":"cjus7e4f80003cgupa2ho5tem","modified":1,"renderable":0},{"_id":"source/_posts/Dart 笔记之基本语法和数据类型/idea_create.png","slug":"idea_create.png","post":"cjus7e4f80003cgupa2ho5tem","modified":1,"renderable":0},{"_id":"source/_posts/Dart 笔记之基本语法和数据类型/dart_core.png","slug":"dart_core.png","post":"cjus7e4f80003cgupa2ho5tem","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cjurzava70003i0upupxbn0i2","category_id":"cjurzavac0005i0upi8a26yrh","_id":"cjurzavaq000fi0up2ij049v9"},{"post_id":"cjurzavab0004i0upkkct6gkx","category_id":"cjurzavac0005i0upi8a26yrh","_id":"cjurzavat000ki0upxows5prc"},{"post_id":"cjurzavag0008i0upuqnzyt6o","category_id":"cjurzavaq000ei0uptqgz8kkv","_id":"cjurzavav000oi0up3mk7nzka"},{"post_id":"cjurzavai0009i0upgeu538ee","category_id":"cjurzavau000mi0upadlalb6s","_id":"cjurzavaw000si0upvqizt9tr"},{"post_id":"cjurzavao000di0up9disnq5o","category_id":"cjurzavau000mi0upadlalb6s","_id":"cjurzavax000vi0upg7vaxx35"},{"post_id":"cjurzavar000hi0up4kd3nj10","category_id":"cjurzavaw000ri0upr54z8lg3","_id":"cjurzavaz0010i0upx7pmb85e"},{"post_id":"cjurzavas000ji0upfs7ry01u","category_id":"cjurzavax000xi0up6zthqbqs","_id":"cjurzavb00013i0upxfxy5piw"},{"post_id":"cjurzavc3001ki0upnx41nfmk","category_id":"cjurzavac0005i0upi8a26yrh","_id":"cjurzavc7001pi0upr5dht5k6"},{"post_id":"cjurzavc4001li0upzt7z1k8h","category_id":"cjurzavac0005i0upi8a26yrh","_id":"cjurzavc9001si0upc4do3zqm"},{"post_id":"cjurzavc5001ni0up4iytqr3y","category_id":"cjurzavaw000ri0upr54z8lg3","_id":"cjurzavca001wi0upp16vtk1c"},{"post_id":"cjurzavc6001oi0up9yqnk0nl","category_id":"cjurzavau000mi0upadlalb6s","_id":"cjurzavcc001zi0upq8dudxao"},{"post_id":"cjurzavc8001ri0upupip2w8x","category_id":"cjurzavau000mi0upadlalb6s","_id":"cjurzavce0023i0up3hc5j94u"},{"post_id":"cjurzavca001vi0up3alsoe2j","category_id":"cjurzavac0005i0upi8a26yrh","_id":"cjurzavcg0027i0up88vg9mrv"},{"post_id":"cjurzavcd0022i0upu48f4bpx","category_id":"cjurzavau000mi0upadlalb6s","_id":"cjurzavch002bi0uprtfi8dmf"},{"post_id":"cjurzavcf0026i0uptkf9ruyy","category_id":"cjurzavaq000ei0uptqgz8kkv","_id":"cjurzavci002ei0upifv6cwj3"},{"post_id":"cjurzavcb001yi0upvezyp71t","category_id":"cjurzavce0024i0up2rxtjlxv","_id":"cjurzavci002gi0uptkkfn107"},{"post_id":"cjurzavds002zi0upedbnelfe","category_id":"cjurzavac0005i0upi8a26yrh","_id":"cjurzavdx0033i0up6xyszac7"},{"post_id":"cjurzavdt0030i0upn559qva5","category_id":"cjurzavac0005i0upi8a26yrh","_id":"cjurzavdy0035i0upnwii144m"},{"post_id":"cjurzavdu0032i0up9wwvbhpr","category_id":"cjurzavaw000ri0upr54z8lg3","_id":"cjurzavdz0038i0upvthywcjg"},{"post_id":"cjurzavea003di0upt32ghpxm","category_id":"cjurzavau000mi0upadlalb6s","_id":"cjurzavec003fi0upk7a87dzw"},{"post_id":"cjus7e4f80003cgupa2ho5tem","category_id":"cjurze33s003ji0upr7wjlg7i","_id":"cjus7e4f90005cgupod76yh89"},{"post_id":"cjus7f5570006cgupzwias228","category_id":"cjurze33s003ji0upr7wjlg7i","_id":"cjus7f55a0008cgupxaaj4830"}],"PostTag":[{"post_id":"cjurzava70003i0upupxbn0i2","tag_id":"cjurzavae0006i0up75zso5j7","_id":"cjurzavas000ii0upnzrmcncu"},{"post_id":"cjurzava70003i0upupxbn0i2","tag_id":"cjurzavak000bi0up8urcsp2j","_id":"cjurzavat000li0uprsy03lxh"},{"post_id":"cjurzavab0004i0upkkct6gkx","tag_id":"cjurzavae0006i0up75zso5j7","_id":"cjurzavax000ui0up7jqq0ga9"},{"post_id":"cjurzavab0004i0upkkct6gkx","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavax000wi0upd0tdflxh"},{"post_id":"cjurzavab0004i0upkkct6gkx","tag_id":"cjurzavav000qi0uplpf5x787","_id":"cjurzavay000zi0upc0ykc2qc"},{"post_id":"cjurzavag0008i0upuqnzyt6o","tag_id":"cjurzavaw000ti0upkyh3o3qz","_id":"cjurzavaz0012i0up5ywtxovb"},{"post_id":"cjurzavag0008i0upuqnzyt6o","tag_id":"cjurzavay000yi0upo4pafdvp","_id":"cjurzavb00014i0uphi4531mf"},{"post_id":"cjurzavai0009i0upgeu538ee","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavb10017i0up4utxfl2e"},{"post_id":"cjurzavai0009i0upgeu538ee","tag_id":"cjurzavb00015i0up1ldubz1j","_id":"cjurzavb20018i0upjudvkwpt"},{"post_id":"cjurzavao000di0up9disnq5o","tag_id":"cjurzavb10016i0upt3l3p2b4","_id":"cjurzavb3001bi0up06w7nog1"},{"post_id":"cjurzavao000di0up9disnq5o","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavb3001ci0upbo3705ds"},{"post_id":"cjurzavar000hi0up4kd3nj10","tag_id":"cjurzavb3001ai0up6mc0k7ph","_id":"cjurzavb5001fi0uprb3exfd0"},{"post_id":"cjurzavar000hi0up4kd3nj10","tag_id":"cjurzavb4001di0up11e1cvss","_id":"cjurzavb5001gi0updgu26za6"},{"post_id":"cjurzavas000ji0upfs7ry01u","tag_id":"cjurzavb4001ei0up41jy6x27","_id":"cjurzavb6001ii0up3v7uxjax"},{"post_id":"cjurzavas000ji0upfs7ry01u","tag_id":"cjurzavb5001hi0upmy3p40qu","_id":"cjurzavb6001ji0upvz8r2ihl"},{"post_id":"cjurzavc5001ni0up4iytqr3y","tag_id":"cjurzavb3001ai0up6mc0k7ph","_id":"cjurzavc8001qi0upnhuzrj2g"},{"post_id":"cjurzavc5001ni0up4iytqr3y","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavc9001ui0up8zazzlof"},{"post_id":"cjurzavc6001oi0up9yqnk0nl","tag_id":"cjurzavb10016i0upt3l3p2b4","_id":"cjurzavcb001xi0upoavl5mt9"},{"post_id":"cjurzavc6001oi0up9yqnk0nl","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavcd0021i0uptl0rzklh"},{"post_id":"cjurzavc8001ri0upupip2w8x","tag_id":"cjurzavb10016i0upt3l3p2b4","_id":"cjurzavcf0025i0upue3hptls"},{"post_id":"cjurzavc8001ri0upupip2w8x","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavch0029i0upjgkju4im"},{"post_id":"cjurzavc3001ki0upnx41nfmk","tag_id":"cjurzavae0006i0up75zso5j7","_id":"cjurzavch002ai0upxusrr9w8"},{"post_id":"cjurzavc3001ki0upnx41nfmk","tag_id":"cjurzavc5001mi0upr40eiooq","_id":"cjurzavci002ci0upslr7j4yu"},{"post_id":"cjurzavc3001ki0upnx41nfmk","tag_id":"cjurzavc9001ti0upumib9dn7","_id":"cjurzavci002fi0upzo3zcr4j"},{"post_id":"cjurzavc4001li0upzt7z1k8h","tag_id":"cjurzavae0006i0up75zso5j7","_id":"cjurzavcj002hi0upcaodoe20"},{"post_id":"cjurzavc4001li0upzt7z1k8h","tag_id":"cjurzavcc0020i0upp5n2jqun","_id":"cjurzavcj002ji0upwevq01rf"},{"post_id":"cjurzavca001vi0up3alsoe2j","tag_id":"cjurzavcg0028i0up85zgj1bl","_id":"cjurzavcj002ki0upbjmqzin2"},{"post_id":"cjurzavca001vi0up3alsoe2j","tag_id":"cjurzavae0006i0up75zso5j7","_id":"cjurzavck002mi0up7qatq9bk"},{"post_id":"cjurzavca001vi0up3alsoe2j","tag_id":"cjurzavci002di0up8ff4nc9i","_id":"cjurzavck002ni0upcgonlvqp"},{"post_id":"cjurzavcb001yi0upvezyp71t","tag_id":"cjurzavcj002ii0uphea27t59","_id":"cjurzavcl002qi0up5bya8iwi"},{"post_id":"cjurzavcb001yi0upvezyp71t","tag_id":"cjurzavcj002li0up7c08mnc8","_id":"cjurzavcl002ri0up5l1bcjv7"},{"post_id":"cjurzavcb001yi0upvezyp71t","tag_id":"cjurzavck002oi0upy8f57xm9","_id":"cjurzavcm002ti0up7dp8wlbn"},{"post_id":"cjurzavcd0022i0upu48f4bpx","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavcm002ui0up0wa0iz7l"},{"post_id":"cjurzavcd0022i0upu48f4bpx","tag_id":"cjurzavck002pi0up1vaecf7y","_id":"cjurzavcm002wi0upsn0a94kk"},{"post_id":"cjurzavcf0026i0uptkf9ruyy","tag_id":"cjurzavcl002si0upkmkaxf0y","_id":"cjurzavcn002xi0uppse0uqlp"},{"post_id":"cjurzavcf0026i0uptkf9ruyy","tag_id":"cjurzavcm002vi0upb252jibb","_id":"cjurzavcn002yi0upz9g2ta1j"},{"post_id":"cjurzavdu0032i0up9wwvbhpr","tag_id":"cjurzavb3001ai0up6mc0k7ph","_id":"cjurzavdy0034i0upks6dgucz"},{"post_id":"cjurzavdu0032i0up9wwvbhpr","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzavdz0037i0up2dpv77pm"},{"post_id":"cjurzavds002zi0upedbnelfe","tag_id":"cjurzavae0006i0up75zso5j7","_id":"cjurzave00039i0upygs2s1hx"},{"post_id":"cjurzavds002zi0upedbnelfe","tag_id":"cjurzavdu0031i0upo1xdnfkc","_id":"cjurzave0003ai0up9r0h0r0e"},{"post_id":"cjurzavdt0030i0upn559qva5","tag_id":"cjurzavae0006i0up75zso5j7","_id":"cjurzave0003bi0up4wysukaz"},{"post_id":"cjurzavdt0030i0upn559qva5","tag_id":"cjurzavdy0036i0up9jnp4xid","_id":"cjurzave0003ci0up7p4ya1as"},{"post_id":"cjurzavea003di0upt32ghpxm","tag_id":"cjurzavau000ni0up1q0z5yi1","_id":"cjurzaved003gi0upmpo3yirt"},{"post_id":"cjurzavea003di0upt32ghpxm","tag_id":"cjurzavav000qi0uplpf5x787","_id":"cjurzaved003hi0upend7cjj6"},{"post_id":"cjurzavea003di0upt32ghpxm","tag_id":"cjurzavec003ei0upblt7vaos","_id":"cjurzaved003ii0upjsel3jxf"},{"post_id":"cjus7e4f80003cgupa2ho5tem","tag_id":"cjurze33t003ki0upblhl6607","_id":"cjus7e4f90004cgupm0ing6sf"},{"post_id":"cjus7f5570006cgupzwias228","tag_id":"cjurze33t003ki0upblhl6607","_id":"cjus7f5590007cgup0q8y3sbw"}],"Tag":[{"name":"Android","_id":"cjurzavae0006i0up75zso5j7"},{"name":"View","_id":"cjurzavak000bi0up8urcsp2j"},{"name":"Java","_id":"cjurzavau000ni0up1q0z5yi1"},{"name":"多线程","_id":"cjurzavav000qi0uplpf5x787"},{"name":"GitHub","_id":"cjurzavaw000ti0upkyh3o3qz"},{"name":"Hexo","_id":"cjurzavay000yi0upo4pafdvp"},{"name":"反射","_id":"cjurzavb00015i0up1ldubz1j"},{"name":"设计模式","_id":"cjurzavb10016i0upt3l3p2b4"},{"name":"算法","_id":"cjurzavb3001ai0up6mc0k7ph"},{"name":"LeetCode","_id":"cjurzavb4001di0up11e1cvss"},{"name":"随笔","_id":"cjurzavb4001ei0up41jy6x27"},{"name":"诗歌","_id":"cjurzavb5001hi0upmy3p40qu"},{"name":"LRU","_id":"cjurzavc5001mi0upr40eiooq"},{"name":"缓存","_id":"cjurzavc9001ti0upumib9dn7"},{"name":"Handler","_id":"cjurzavcc0020i0upp5n2jqun"},{"name":"内存泄漏","_id":"cjurzavcg0028i0up85zgj1bl"},{"name":"源码","_id":"cjurzavci002di0up8ff4nc9i"},{"name":"音乐","_id":"cjurzavcj002ii0uphea27t59"},{"name":"巴洛克","_id":"cjurzavcj002li0up7c08mnc8"},{"name":"巴赫","_id":"cjurzavck002oi0upy8f57xm9"},{"name":"数据结构","_id":"cjurzavck002pi0up1vaecf7y"},{"name":"翻墙","_id":"cjurzavcl002si0upkmkaxf0y"},{"name":"互联网","_id":"cjurzavcm002vi0upb252jibb"},{"name":"多进程通信","_id":"cjurzavdu0031i0upo1xdnfkc"},{"name":"动画开发","_id":"cjurzavdy0036i0up9jnp4xid"},{"name":"线程池","_id":"cjurzavec003ei0upblt7vaos"},{"name":"Dart","_id":"cjurze33t003ki0upblhl6607"}]}}